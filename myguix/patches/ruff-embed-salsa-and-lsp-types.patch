diff --git a/Cargo.toml b/Cargo.toml
index f2a934387..22acddc93 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -105,9 +105,7 @@ libc = { version = "0.2.153" }
 libcst = { version = "1.1.0", default-features = false }
 log = { version = "0.4.17" }
 lsp-server = { version = "0.7.6" }
-lsp-types = { git = "https://github.com/astral-sh/lsp-types.git", rev = "3512a9f", features = [
-    "proposed",
-] }
+lsp-types = { path = "crates/lsp-types", features = ["proposed"] }
 matchit = { version = "0.8.1" }
 memchr = { version = "2.7.1" }
 mimalloc = { version = "0.1.39" }
@@ -129,7 +127,7 @@ regex = { version = "1.10.2" }
 rustc-hash = { version = "2.0.0" }
 rustc-stable-hash = { version = "0.1.2" }
 # When updating salsa, make sure to also update the revision in `fuzz/Cargo.toml`
-salsa = { git = "https://github.com/salsa-rs/salsa.git", rev = "4818b15f3b7516555d39f5a41cb75970448bee4c" }
+salsa = { path = "crates/salsa" }
 schemars = { version = "0.8.16" }
 seahash = { version = "4.1.0" }
 serde = { version = "1.0.197", features = ["derive"] }
diff --git a/crates/lsp-types/.clog.toml b/crates/lsp-types/.clog.toml
new file mode 100644
index 000000000..b2116ec9d
--- /dev/null
+++ b/crates/lsp-types/.clog.toml
@@ -0,0 +1,6 @@
+[clog]
+repository = "https://github.com/gluon-lang/lsp-types"
+
+changelog = "CHANGELOG.md"
+
+from-latest-tag = true
diff --git a/crates/lsp-types/.github/workflows/rust.yml b/crates/lsp-types/.github/workflows/rust.yml
new file mode 100644
index 000000000..3b5207f7c
--- /dev/null
+++ b/crates/lsp-types/.github/workflows/rust.yml
@@ -0,0 +1,40 @@
+name: Rust
+
+on:
+  push:
+    branches: [ master ]
+  pull_request:
+    branches: [ master ]
+
+env:
+  CARGO_TERM_COLOR: always
+
+jobs:
+  build:
+    strategy:
+      matrix:
+        rust: [stable, nightly]
+        features: ["", proposed]
+
+    env:
+      CARGO_INCREMENTAL: 0 # Incremental compilation is slower and bloats the cache
+      RUST_BACKTRACE: 1
+
+    runs-on: ubuntu-latest
+
+    steps:
+    - uses: actions/checkout@v2
+
+    - uses: actions-rs/toolchain@v1
+      with:
+        profile: minimal
+        toolchain: ${{ matrix.rust }}
+        override: true
+
+    - name: Build
+      run: cargo build
+
+    - name: Run tests
+      run: >
+        FEATURES=${{ matrix.features }}
+        cargo test --features ${FEATURES:-""}
diff --git a/crates/lsp-types/.gitignore b/crates/lsp-types/.gitignore
new file mode 100644
index 000000000..997609a95
--- /dev/null
+++ b/crates/lsp-types/.gitignore
@@ -0,0 +1,5 @@
+target
+Cargo.lock
+/.settings/
+/.project
+/.vscode
diff --git a/crates/lsp-types/CHANGELOG.md b/crates/lsp-types/CHANGELOG.md
new file mode 100644
index 000000000..fb15e7a7a
--- /dev/null
+++ b/crates/lsp-types/CHANGELOG.md
@@ -0,0 +1,319 @@
+<a name="v0.95.1"></a>
+### v0.95.1 (2024-03-18)
+
+
+
+
+<a name="v0.95.0"></a>
+## v0.95.0 (2023-12-12)
+
+
+
+
+<a name="v0.94.2"></a>
+### v0.94.2 (2023-12-12)
+
+
+
+
+<a name="v0.94.1"></a>
+### v0.94.1 (2023-08-07)
+
+
+
+
+<a name="v0.94.0"></a>
+## v0.94.0 (2023-02-08)
+
+
+
+
+<a name="v0.93.2"></a>
+### v0.93.2 (2022-10-21)
+
+
+
+
+<a name="v0.93.1"></a>
+### v0.93.1 (2022-08-23)
+
+
+
+
+<a name="v0.93.0"></a>
+## v0.93.0 (2022-04-08)
+
+
+#### Features
+
+* **helperTypes:**  implement new JSON types ([bd9bb2e7](https://github.com/gluon-lang/lsp-types/commit/bd9bb2e74171b0194be51085c822c3ccbbb68b7b))
+
+
+
+<a name="v0.92.1"></a>
+### v0.92.1 (2022-03-21)
+
+
+#### Bug Fixes
+
+* **inlayHint:**  typo in prop name ([7f7ada31](https://github.com/gluon-lang/lsp-types/commit/7f7ada310fa045ef628dc36f97b8564408fcec6a))
+
+#### Features
+
+* **inlayHint:**
+  *  add request impls ([393aefa1](https://github.com/gluon-lang/lsp-types/commit/393aefa18b3c900c3f1ac8f6337b7098bdc4365a))
+  *  add inlayHint provider ([69f21e71](https://github.com/gluon-lang/lsp-types/commit/69f21e714df305643aa727cbf745b439bbd8c112))
+  *  implement inlayHint basic types ([29a50e71](https://github.com/gluon-lang/lsp-types/commit/29a50e71461f72d2fa2aea90fa03f61adf062074))
+
+
+
+<a name="v0.92.0"></a>
+## v0.92.0 (2022-02-07)
+
+
+
+
+<a name="v0.91.2"></a>
+### v0.91.2 (2022-02-07)
+
+
+#### Features
+
+*   Add a TryFrom<&str> implementation for enumerations ([19b85cf4](https://github.com/gluon-lang/lsp-types/commit/19b85cf4a7b5396a89d364e271c3867eb6c840e4), closes [#223](https://github.com/gluon-lang/lsp-types/issues/223))
+
+#### Bug Fixes
+
+*   Ensure that the pascal_case_name is evaluated at compile time ([7337535b](https://github.com/gluon-lang/lsp-types/commit/7337535b79000912f859319455cd371af77d1899))
+
+
+
+<a name="v0.91.1"></a>
+### v0.91.1 (2021-11-01)
+
+
+#### Features
+
+*   Print the name of know enumerations ([2877b6a1](https://github.com/gluon-lang/lsp-types/commit/2877b6a131ef5c28310b972126f6d1b23cd97788))
+
+
+
+<a name="v0.91.0"></a>
+## v0.91.0 (2021-10-18)
+
+
+
+
+<a name="v0.90.1"></a>
+### v0.90.1 (2021-10-11)
+
+
+#### Bug Fixes
+
+*   add missing rename_all serde attribute ([b403cba5](https://github.com/gluon-lang/lsp-types/commit/b403cba5fb568f7f1bda3ea2929822269797f7f3))
+
+
+
+<a name="v0.90.1"></a>
+### v0.90.1 (2021-10-11)
+
+
+#### Bug Fixes
+
+*   add missing rename_all serde attribute ([b403cba5](https://github.com/gluon-lang/lsp-types/commit/b403cba5fb568f7f1bda3ea2929822269797f7f3))
+
+
+
+<a name="v0.90.1"></a>
+### v0.90.1 (2021-10-11)
+
+
+#### Bug Fixes
+
+*   add missing rename_all serde attribute ([b403cba5](https://github.com/gluon-lang/lsp-types/commit/b403cba5fb568f7f1bda3ea2929822269797f7f3))
+
+
+
+<a name="v0.90.1"></a>
+### v0.90.1 (2021-10-11)
+
+
+#### Bug Fixes
+
+*   add missing rename_all serde attribute ([b403cba5](https://github.com/gluon-lang/lsp-types/commit/b403cba5fb568f7f1bda3ea2929822269797f7f3))
+
+
+
+<a name="v0.90.0"></a>
+## v0.90.0 (2021-09-25)
+
+
+
+
+<a name="v0.61.1"></a>
+### v0.61.1 (2021-06-10)
+
+
+#### Features
+
+*   Add DeserializeOwned + Serialize bounds on request/notifications ([fb945a93](https://github.com/gluon-lang/lsp-types/commit/fb945a9347b353dd9bc5aab99a86731bebd94c15), closes [#140](https://github.com/gluon-lang/lsp-types/issues/140))
+
+
+
+<a name="v0.89.1"></a>
+### v0.89.1 (2021-05-22)
+
+
+
+
+<a name="v0.89.0"></a>
+## v0.89.0 (2021-04-07)
+
+
+
+
+<a name="v0.88.0"></a>
+## v0.88.0 (2021-02-16)
+
+
+
+
+<a name="v0.87.0"></a>
+## v0.87.0 (2021-02-14)
+
+
+
+
+<a name="v0.86.0"></a>
+## v0.86.0 (2020-12-17)
+
+
+
+
+<a name="v0.85.0"></a>
+## v0.85.0 (2020-12-01)
+
+
+
+
+<a name="v0.84.0"></a>
+## v0.84.0 (2020-11-24)
+
+
+
+
+<a name="v0.83.1"></a>
+### v0.83.1 (2020-11-16)
+
+
+
+
+<a name="v0.82.0"></a>
+## v0.82.0 (2020-09-23)
+
+
+
+
+<a name="v0.80.0"></a>
+## v0.80.0 (2020-09-18)
+
+
+
+
+<a name="v0.80.0"></a>
+## v0.80.0 (2020-09-02)
+
+
+
+
+<a name="v0.79.0"></a>
+## v0.79.0 (2020-07-26)
+
+
+
+
+<a name="v0.77.0"></a>
+## v0.77.0 (2020-07-15)
+
+
+
+
+<a name="v0.76.1"></a>
+### v0.76.1 (2020-07-14)
+
+
+
+
+<a name="v0.74.2"></a>
+### v0.74.2 (2020-05-30)
+
+
+
+
+<a name="v0.74.1"></a>
+### v0.74.1 (2020-05-01)
+
+
+
+
+<a name="v0.74.0"></a>
+## v0.74.0 (2020-04-26)
+
+
+
+
+<a name="v0.74.0"></a>
+## v0.74.0 (2020-04-26)
+
+
+
+
+<a name="v0.72.0"></a>
+## v0.72.0 (2020-03-02)
+
+
+#### Features
+
+*   Add DeserializeOwned + Serialize bounds on request/notifications ([fb945a93](https://github.com/gluon-lang/lsp-types/commit/fb945a9347b353dd9bc5aab99a86731bebd94c15), closes [#140](https://github.com/gluon-lang/lsp-types/issues/140))
+
+
+
+<a name="v0.72.0"></a>
+## v0.72.0 (2020-03-02)
+
+
+#### Features
+
+*   Add DeserializeOwned + Serialize bounds on request/notifications ([fb945a93](https://github.com/gluon-lang/lsp-types/commit/fb945a9347b353dd9bc5aab99a86731bebd94c15), closes [#140](https://github.com/gluon-lang/lsp-types/issues/140))
+
+
+
+<a name="v0.72.0"></a>
+## v0.72.0 (2020-03-02)
+
+
+#### Features
+
+*   Add DeserializeOwned + Serialize bounds on request/notifications ([fb945a93](https://github.com/gluon-lang/lsp-types/commit/fb945a9347b353dd9bc5aab99a86731bebd94c15), closes [#140](https://github.com/gluon-lang/lsp-types/issues/140))
+
+
+
+<a name="v0.72.0"></a>
+## v0.72.0 (2020-03-02)
+
+
+#### Features
+
+*   Add DeserializeOwned + Serialize bounds on request/notifications ([fb945a93](https://github.com/gluon-lang/lsp-types/commit/fb945a9347b353dd9bc5aab99a86731bebd94c15), closes [#140](https://github.com/gluon-lang/lsp-types/issues/140))
+
+
+
+<a name="v0.72.0"></a>
+## v0.72.0 (2020-03-02)
+
+
+#### Features
+
+*   Add DeserializeOwned + Serialize bounds on request/notifications ([fb945a93](https://github.com/gluon-lang/lsp-types/commit/fb945a9347b353dd9bc5aab99a86731bebd94c15), closes [#140](https://github.com/gluon-lang/lsp-types/issues/140))
+
+
+
diff --git a/crates/lsp-types/Cargo.toml b/crates/lsp-types/Cargo.toml
new file mode 100644
index 000000000..ad7a3ca05
--- /dev/null
+++ b/crates/lsp-types/Cargo.toml
@@ -0,0 +1,28 @@
+[package]
+name = "lsp-types"
+version = "0.95.1"
+authors = ["Markus Westerlind <marwes91@gmail.com>", "Bruno Medeiros <bruno.do.medeiros@gmail.com>"]
+edition = "2018"
+description = "Types for interaction with a language server, using VSCode's Language Server Protocol"
+
+repository = "https://github.com/gluon-lang/lsp-types"
+documentation = "https://docs.rs/lsp-types"
+
+readme = "README.md"
+
+keywords = ["language", "server", "lsp", "vscode", "lsif"]
+
+license = "MIT"
+
+[dependencies]
+bitflags = "1.0.1"
+serde = { version = "1.0.34", features = ["derive"] }
+serde_json = "1.0.50"
+serde_repr = "0.1"
+url = {version = "2.0.0", features = ["serde"]}
+
+[features]
+default = []
+# Enables proposed LSP extensions.
+# NOTE: No semver compatibility is guaranteed for types enabled by this feature.
+proposed = []
diff --git a/crates/lsp-types/LICENSE b/crates/lsp-types/LICENSE
new file mode 100644
index 000000000..32781d976
--- /dev/null
+++ b/crates/lsp-types/LICENSE
@@ -0,0 +1,22 @@
+The MIT License (MIT)
+
+Copyright (c) 2016 Markus Westerlind
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
diff --git a/crates/lsp-types/README.md b/crates/lsp-types/README.md
new file mode 100644
index 000000000..b5641f54c
--- /dev/null
+++ b/crates/lsp-types/README.md
@@ -0,0 +1,18 @@
+# lsp-types [![Build Status](https://travis-ci.org/gluon-lang/lsp-types.svg?branch=master)](https://travis-ci.org/gluon-lang/lsp-types) [![Documentation](https://docs.rs/lsp-types/badge.svg)](https://docs.rs/crate/lsp-types)
+
+Types useful for interacting with a [language server](https://code.visualstudio.com/blogs/2016/06/27/common-language-protocol).
+
+Supports Language Server Protocol (LSP) version 3.16.0.
+
+Proposed 3.17 features can be activated using the `proposed` feature flag.
+- **NOTE** that these are unstable and may change between releases.
+
+## Contributing
+
+If you are making a change which adds, removes or modifies the LSP API it is highly appreciated if you link to the spec where this change is described. This gives context to whether the change should be an experimental addition and lets the reviewer double check the changes easily against the spec.
+
+## Links
+
+[Stable Protocol reference](https://github.com/microsoft/language-server-protocol/tree/gh-pages/_specifications/lsp/3.17/specification.md)
+
+[Proposed Protocol reference](https://github.com/microsoft/language-server-protocol/blob/gh-pages/_specifications/lsp/3.18/specification.md)
diff --git a/crates/lsp-types/release.sh b/crates/lsp-types/release.sh
new file mode 100755
index 000000000..68e484455
--- /dev/null
+++ b/crates/lsp-types/release.sh
@@ -0,0 +1,15 @@
+#!/bin/sh
+set -ex
+
+LEVEL=$1
+if [ -z "$LEVEL" ]; then
+    echo "Expected patch, minor or major"
+    exit 1
+fi
+
+clog --$LEVEL
+
+git add CHANGELOG.md
+git commit -m "Update changelog"
+
+cargo release $LEVEL --execute
diff --git a/crates/lsp-types/release.toml b/crates/lsp-types/release.toml
new file mode 100644
index 000000000..06f6dfa8b
--- /dev/null
+++ b/crates/lsp-types/release.toml
@@ -0,0 +1 @@
+tag-message = "Version {{version}}"
diff --git a/crates/lsp-types/src/call_hierarchy.rs b/crates/lsp-types/src/call_hierarchy.rs
new file mode 100644
index 000000000..dea78803f
--- /dev/null
+++ b/crates/lsp-types/src/call_hierarchy.rs
@@ -0,0 +1,127 @@
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+use url::Url;
+
+use crate::{
+    DynamicRegistrationClientCapabilities, PartialResultParams, Range, SymbolKind, SymbolTag,
+    TextDocumentPositionParams, WorkDoneProgressOptions, WorkDoneProgressParams,
+};
+
+pub type CallHierarchyClientCapabilities = DynamicRegistrationClientCapabilities;
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize, Copy)]
+#[serde(rename_all = "camelCase")]
+pub struct CallHierarchyOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize, Copy)]
+#[serde(untagged)]
+pub enum CallHierarchyServerCapability {
+    Simple(bool),
+    Options(CallHierarchyOptions),
+}
+
+impl From<CallHierarchyOptions> for CallHierarchyServerCapability {
+    fn from(from: CallHierarchyOptions) -> Self {
+        Self::Options(from)
+    }
+}
+
+impl From<bool> for CallHierarchyServerCapability {
+    fn from(from: bool) -> Self {
+        Self::Simple(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CallHierarchyPrepareParams {
+    #[serde(flatten)]
+    pub text_document_position_params: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct CallHierarchyItem {
+    /// The name of this item.
+    pub name: String,
+
+    /// The kind of this item.
+    pub kind: SymbolKind,
+
+    /// Tags for this item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tags: Option<Vec<SymbolTag>>,
+
+    /// More detail for this item, e.g. the signature of a function.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub detail: Option<String>,
+
+    /// The resource identifier of this item.
+    pub uri: Url,
+
+    /// The range enclosing this symbol not including leading/trailing whitespace but everything else, e.g. comments and code.
+    pub range: Range,
+
+    /// The range that should be selected and revealed when this symbol is being picked, e.g. the name of a function.
+    /// Must be contained by the [`range`](#CallHierarchyItem.range).
+    pub selection_range: Range,
+
+    /// A data entry field that is preserved between a call hierarchy prepare and incoming calls or outgoing calls requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data: Option<Value>,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CallHierarchyIncomingCallsParams {
+    pub item: CallHierarchyItem,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// Represents an incoming call, e.g. a caller of a method or constructor.
+#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct CallHierarchyIncomingCall {
+    /// The item that makes the call.
+    pub from: CallHierarchyItem,
+
+    /// The range at which at which the calls appears. This is relative to the caller
+    /// denoted by [`this.from`](#CallHierarchyIncomingCall.from).
+    pub from_ranges: Vec<Range>,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CallHierarchyOutgoingCallsParams {
+    pub item: CallHierarchyItem,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// Represents an outgoing call, e.g. calling a getter from a method or a method from a constructor etc.
+#[derive(Serialize, Deserialize, Debug, PartialEq, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct CallHierarchyOutgoingCall {
+    /// The item that is called.
+    pub to: CallHierarchyItem,
+
+    /// The range at which this item is called. This is the range relative to the caller, e.g the item
+    /// passed to [`provideCallHierarchyOutgoingCalls`](#CallHierarchyItemProvider.provideCallHierarchyOutgoingCalls)
+    /// and not [`this.to`](#CallHierarchyOutgoingCall.to).
+    pub from_ranges: Vec<Range>,
+}
diff --git a/crates/lsp-types/src/code_action.rs b/crates/lsp-types/src/code_action.rs
new file mode 100644
index 000000000..6cc39e0d0
--- /dev/null
+++ b/crates/lsp-types/src/code_action.rs
@@ -0,0 +1,395 @@
+use crate::{
+    Command, Diagnostic, PartialResultParams, Range, TextDocumentIdentifier,
+    WorkDoneProgressOptions, WorkDoneProgressParams, WorkspaceEdit,
+};
+use serde::{Deserialize, Serialize};
+
+use serde_json::Value;
+
+use std::borrow::Cow;
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum CodeActionProviderCapability {
+    Simple(bool),
+    Options(CodeActionOptions),
+}
+
+impl From<CodeActionOptions> for CodeActionProviderCapability {
+    fn from(from: CodeActionOptions) -> Self {
+        Self::Options(from)
+    }
+}
+
+impl From<bool> for CodeActionProviderCapability {
+    fn from(from: bool) -> Self {
+        Self::Simple(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeActionClientCapabilities {
+    ///
+    /// This capability supports dynamic registration.
+    ///
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// The client support code action literals as a valid
+    /// response of the `textDocument/codeAction` request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code_action_literal_support: Option<CodeActionLiteralSupport>,
+
+    /// Whether code action supports the `isPreferred` property.
+    ///
+    /// @since 3.15.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub is_preferred_support: Option<bool>,
+
+    /// Whether code action supports the `disabled` property.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub disabled_support: Option<bool>,
+
+    /// Whether code action supports the `data` property which is
+    /// preserved between a `textDocument/codeAction` and a
+    /// `codeAction/resolve` request.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data_support: Option<bool>,
+
+    /// Whether the client supports resolving additional code action
+    /// properties via a separate `codeAction/resolve` request.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_support: Option<CodeActionCapabilityResolveSupport>,
+
+    /// Whether the client honors the change annotations in
+    /// text edits and resource operations returned via the
+    /// `CodeAction#edit` property by for example presenting
+    /// the workspace edit in the user interface and asking
+    /// for confirmation.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub honors_change_annotations: Option<bool>,
+}
+
+/// Whether the client supports resolving additional code action
+/// properties via a separate `codeAction/resolve` request.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeActionCapabilityResolveSupport {
+    /// The properties that a client can resolve lazily.
+    pub properties: Vec<String>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeActionLiteralSupport {
+    /// The code action kind is support with the following value set.
+    pub code_action_kind: CodeActionKindLiteralSupport,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeActionKindLiteralSupport {
+    /// The code action kind values the client supports. When this
+    /// property exists the client also guarantees that it will
+    /// handle values outside its set gracefully and falls back
+    /// to a default value when unknown.
+    pub value_set: Vec<String>,
+}
+
+/// Params for the CodeActionRequest
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeActionParams {
+    /// The document in which the command was invoked.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The range for which the command was invoked.
+    pub range: Range,
+
+    /// Context carrying additional information.
+    pub context: CodeActionContext,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// response for CodeActionRequest
+pub type CodeActionResponse = Vec<CodeActionOrCommand>;
+
+#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum CodeActionOrCommand {
+    Command(Command),
+    CodeAction(CodeAction),
+}
+
+impl From<Command> for CodeActionOrCommand {
+    fn from(command: Command) -> Self {
+        CodeActionOrCommand::Command(command)
+    }
+}
+
+impl From<CodeAction> for CodeActionOrCommand {
+    fn from(action: CodeAction) -> Self {
+        CodeActionOrCommand::CodeAction(action)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Hash, PartialOrd, Clone, Deserialize, Serialize)]
+pub struct CodeActionKind(Cow<'static, str>);
+
+impl CodeActionKind {
+    /// Empty kind.
+    pub const EMPTY: CodeActionKind = CodeActionKind::new("");
+
+    /// Base kind for quickfix actions: 'quickfix'
+    pub const QUICKFIX: CodeActionKind = CodeActionKind::new("quickfix");
+
+    /// Base kind for refactoring actions: 'refactor'
+    pub const REFACTOR: CodeActionKind = CodeActionKind::new("refactor");
+
+    /// Base kind for refactoring extraction actions: 'refactor.extract'
+    ///
+    /// Example extract actions:
+    ///
+    /// - Extract method
+    /// - Extract function
+    /// - Extract variable
+    /// - Extract interface from class
+    /// - ...
+    pub const REFACTOR_EXTRACT: CodeActionKind = CodeActionKind::new("refactor.extract");
+
+    /// Base kind for refactoring inline actions: 'refactor.inline'
+    ///
+    /// Example inline actions:
+    ///
+    /// - Inline function
+    /// - Inline variable
+    /// - Inline constant
+    /// - ...
+    pub const REFACTOR_INLINE: CodeActionKind = CodeActionKind::new("refactor.inline");
+
+    /// Base kind for refactoring rewrite actions: 'refactor.rewrite'
+    ///
+    /// Example rewrite actions:
+    ///
+    /// - Convert JavaScript function to class
+    /// - Add or remove parameter
+    /// - Encapsulate field
+    /// - Make method static
+    /// - Move method to base class
+    /// - ...
+    pub const REFACTOR_REWRITE: CodeActionKind = CodeActionKind::new("refactor.rewrite");
+
+    /// Base kind for source actions: `source`
+    ///
+    /// Source code actions apply to the entire file.
+    pub const SOURCE: CodeActionKind = CodeActionKind::new("source");
+
+    /// Base kind for an organize imports source action: `source.organizeImports`
+    pub const SOURCE_ORGANIZE_IMPORTS: CodeActionKind =
+        CodeActionKind::new("source.organizeImports");
+
+    /// Base kind for a 'fix all' source action: `source.fixAll`.
+    ///
+    /// 'Fix all' actions automatically fix errors that have a clear fix that
+    /// do not require user input. They should not suppress errors or perform
+    /// unsafe fixes such as generating new types or classes.
+    ///
+    /// @since 3.17.0
+    pub const SOURCE_FIX_ALL: CodeActionKind = CodeActionKind::new("source.fixAll");
+
+    pub const fn new(tag: &'static str) -> Self {
+        CodeActionKind(Cow::Borrowed(tag))
+    }
+
+    pub fn as_str(&self) -> &str {
+        &self.0
+    }
+}
+
+impl From<String> for CodeActionKind {
+    fn from(from: String) -> Self {
+        CodeActionKind(Cow::from(from))
+    }
+}
+
+impl From<&'static str> for CodeActionKind {
+    fn from(from: &'static str) -> Self {
+        CodeActionKind::new(from)
+    }
+}
+
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeAction {
+    /// A short, human-readable, title for this code action.
+    pub title: String,
+
+    /// The kind of the code action.
+    /// Used to filter code actions.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub kind: Option<CodeActionKind>,
+
+    /// The diagnostics that this code action resolves.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub diagnostics: Option<Vec<Diagnostic>>,
+
+    /// The workspace edit this code action performs.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub edit: Option<WorkspaceEdit>,
+
+    /// A command this code action executes. If a code action
+    /// provides an edit and a command, first the edit is
+    /// executed and then the command.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub command: Option<Command>,
+
+    /// Marks this as a preferred action. Preferred actions are used by the `auto fix` command and can be targeted
+    /// by keybindings.
+    /// A quick fix should be marked preferred if it properly addresses the underlying error.
+    /// A refactoring should be marked preferred if it is the most reasonable choice of actions to take.
+    ///
+    /// @since 3.15.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub is_preferred: Option<bool>,
+
+    /// Marks that the code action cannot currently be applied.
+    ///
+    /// Clients should follow the following guidelines regarding disabled code actions:
+    ///
+    /// - Disabled code actions are not shown in automatic
+    ///   [lightbulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action)
+    ///   code action menu.
+    ///
+    /// - Disabled actions are shown as faded out in the code action menu when the user request
+    ///   a more specific type of code action, such as refactorings.
+    ///
+    /// - If the user has a keybinding that auto applies a code action and only a disabled code
+    ///   actions are returned, the client should show the user an error message with `reason`
+    ///   in the editor.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub disabled: Option<CodeActionDisabled>,
+
+    /// A data entry field that is preserved on a code action between
+    /// a `textDocument/codeAction` and a `codeAction/resolve` request.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data: Option<Value>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeActionDisabled {
+    /// Human readable description of why the code action is currently disabled.
+    ///
+    /// This is displayed in the code actions UI.
+    pub reason: String,
+}
+
+/// The reason why code actions were requested.
+///
+/// @since 3.17.0
+#[derive(Eq, PartialEq, Clone, Copy, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct CodeActionTriggerKind(i32);
+lsp_enum! {
+impl CodeActionTriggerKind {
+    /// Code actions were explicitly requested by the user or by an extension.
+    pub const INVOKED: CodeActionTriggerKind = CodeActionTriggerKind(1);
+
+    /// Code actions were requested automatically.
+    ///
+    /// This typically happens when current selection in a file changes, but can
+    /// also be triggered when file content changes.
+    pub const AUTOMATIC: CodeActionTriggerKind = CodeActionTriggerKind(2);
+}
+}
+
+/// Contains additional diagnostic information about the context in which
+/// a code action is run.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeActionContext {
+    /// An array of diagnostics.
+    pub diagnostics: Vec<Diagnostic>,
+
+    /// Requested kind of actions to return.
+    ///
+    /// Actions not of this kind are filtered out by the client before being shown. So servers
+    /// can omit computing them.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub only: Option<Vec<CodeActionKind>>,
+
+    /// The reason why code actions were requested.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub trigger_kind: Option<CodeActionTriggerKind>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize, Default)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeActionOptions {
+    /// CodeActionKinds that this server may return.
+    ///
+    /// The list of kinds may be generic, such as `CodeActionKind.Refactor`, or the server
+    /// may list out every specific kind they provide.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code_action_kinds: Option<Vec<CodeActionKind>>,
+
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+
+    /// The server provides support to resolve additional
+    /// information for a code action.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_provider: Option<bool>,
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::tests::test_serialization;
+
+    #[test]
+    fn test_code_action_response() {
+        test_serialization(
+            &vec![
+                CodeActionOrCommand::Command(Command {
+                    title: "title".to_string(),
+                    command: "command".to_string(),
+                    arguments: None,
+                }),
+                CodeActionOrCommand::CodeAction(CodeAction {
+                    title: "title".to_string(),
+                    kind: Some(CodeActionKind::QUICKFIX),
+                    command: None,
+                    diagnostics: None,
+                    edit: None,
+                    is_preferred: None,
+                    ..CodeAction::default()
+                }),
+            ],
+            r#"[{"title":"title","command":"command"},{"title":"title","kind":"quickfix"}]"#,
+        )
+    }
+}
diff --git a/crates/lsp-types/src/code_lens.rs b/crates/lsp-types/src/code_lens.rs
new file mode 100644
index 000000000..c4c9c904e
--- /dev/null
+++ b/crates/lsp-types/src/code_lens.rs
@@ -0,0 +1,66 @@
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+
+use crate::{
+    Command, DynamicRegistrationClientCapabilities, PartialResultParams, Range,
+    TextDocumentIdentifier, WorkDoneProgressParams,
+};
+
+pub type CodeLensClientCapabilities = DynamicRegistrationClientCapabilities;
+
+/// Code Lens options.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize, Copy)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeLensOptions {
+    /// Code lens has a resolve provider as well.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_provider: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeLensParams {
+    /// The document to request code lens for.
+    pub text_document: TextDocumentIdentifier,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// A code lens represents a command that should be shown along with
+/// source text, like the number of references, a way to run tests, etc.
+///
+/// A code lens is _unresolved_ when no command is associated to it. For performance
+/// reasons the creation of a code lens and resolving should be done in two stages.
+#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeLens {
+    /// The range in which this code lens is valid. Should only span a single line.
+    pub range: Range,
+
+    /// The command this code lens represents.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub command: Option<Command>,
+
+    /// A data entry field that is preserved on a code lens item between
+    /// a code lens and a code lens resolve request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data: Option<Value>,
+}
+
+#[derive(Debug, Clone, PartialEq, Eq, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeLensWorkspaceClientCapabilities {
+    /// Whether the client implementation supports a refresh request sent from the
+    /// server to the client.
+    ///
+    /// Note that this event is global and will force the client to refresh all
+    /// code lenses currently shown. It should be used with absolute care and is
+    /// useful for situation where a server for example detect a project wide
+    /// change that requires such a calculation.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub refresh_support: Option<bool>,
+}
diff --git a/crates/lsp-types/src/color.rs b/crates/lsp-types/src/color.rs
new file mode 100644
index 000000000..584f979ee
--- /dev/null
+++ b/crates/lsp-types/src/color.rs
@@ -0,0 +1,122 @@
+use crate::{
+    DocumentSelector, DynamicRegistrationClientCapabilities, PartialResultParams, Range,
+    TextDocumentIdentifier, TextEdit, WorkDoneProgressParams,
+};
+use serde::{Deserialize, Serialize};
+
+pub type DocumentColorClientCapabilities = DynamicRegistrationClientCapabilities;
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ColorProviderOptions {}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct StaticTextDocumentColorProviderOptions {
+    /// A document selector to identify the scope of the registration. If set to null
+    /// the document selector provided on the client side will be used.
+    pub document_selector: Option<DocumentSelector>,
+
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub id: Option<String>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum ColorProviderCapability {
+    Simple(bool),
+    ColorProvider(ColorProviderOptions),
+    Options(StaticTextDocumentColorProviderOptions),
+}
+
+impl From<ColorProviderOptions> for ColorProviderCapability {
+    fn from(from: ColorProviderOptions) -> Self {
+        Self::ColorProvider(from)
+    }
+}
+
+impl From<StaticTextDocumentColorProviderOptions> for ColorProviderCapability {
+    fn from(from: StaticTextDocumentColorProviderOptions) -> Self {
+        Self::Options(from)
+    }
+}
+
+impl From<bool> for ColorProviderCapability {
+    fn from(from: bool) -> Self {
+        Self::Simple(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentColorParams {
+    /// The text document
+    pub text_document: TextDocumentIdentifier,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ColorInformation {
+    /// The range in the document where this color appears.
+    pub range: Range,
+    /// The actual color value for this color range.
+    pub color: Color,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize, Copy)]
+#[serde(rename_all = "camelCase")]
+pub struct Color {
+    /// The red component of this color in the range [0-1].
+    pub red: f32,
+    /// The green component of this color in the range [0-1].
+    pub green: f32,
+    /// The blue component of this color in the range [0-1].
+    pub blue: f32,
+    /// The alpha component of this color in the range [0-1].
+    pub alpha: f32,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ColorPresentationParams {
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The color information to request presentations for.
+    pub color: Color,
+
+    /// The range where the color would be inserted. Serves as a context.
+    pub range: Range,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+#[derive(Debug, PartialEq, Eq, Deserialize, Serialize, Default, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct ColorPresentation {
+    /// The label of this color presentation. It will be shown on the color
+    /// picker header. By default this is also the text that is inserted when selecting
+    /// this color presentation.
+    pub label: String,
+
+    /// An [edit](#TextEdit) which is applied to a document when selecting
+    /// this presentation for the color.  When `falsy` the [label](#ColorPresentation.label)
+    /// is used.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub text_edit: Option<TextEdit>,
+
+    /// An optional array of additional [text edits](#TextEdit) that are applied when
+    /// selecting this color presentation. Edits must not overlap with the main [edit](#ColorPresentation.textEdit) nor with themselves.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub additional_text_edits: Option<Vec<TextEdit>>,
+}
diff --git a/crates/lsp-types/src/completion.rs b/crates/lsp-types/src/completion.rs
new file mode 100644
index 000000000..bdf60fb51
--- /dev/null
+++ b/crates/lsp-types/src/completion.rs
@@ -0,0 +1,616 @@
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    Command, Documentation, MarkupKind, PartialResultParams, TagSupport,
+    TextDocumentPositionParams, TextDocumentRegistrationOptions, TextEdit, WorkDoneProgressOptions,
+    WorkDoneProgressParams,
+};
+
+use crate::Range;
+use serde_json::Value;
+use std::fmt::Debug;
+
+/// Defines how to interpret the insert text in a completion item
+#[derive(Eq, PartialEq, Clone, Copy, Serialize, Deserialize)]
+#[serde(transparent)]
+pub struct InsertTextFormat(i32);
+lsp_enum! {
+impl InsertTextFormat {
+    pub const PLAIN_TEXT: InsertTextFormat = InsertTextFormat(1);
+    pub const SNIPPET: InsertTextFormat = InsertTextFormat(2);
+}
+}
+
+/// The kind of a completion entry.
+#[derive(Eq, PartialEq, Clone, Copy, Serialize, Deserialize)]
+#[serde(transparent)]
+pub struct CompletionItemKind(i32);
+lsp_enum! {
+impl CompletionItemKind {
+    pub const TEXT: CompletionItemKind = CompletionItemKind(1);
+    pub const METHOD: CompletionItemKind = CompletionItemKind(2);
+    pub const FUNCTION: CompletionItemKind = CompletionItemKind(3);
+    pub const CONSTRUCTOR: CompletionItemKind = CompletionItemKind(4);
+    pub const FIELD: CompletionItemKind = CompletionItemKind(5);
+    pub const VARIABLE: CompletionItemKind = CompletionItemKind(6);
+    pub const CLASS: CompletionItemKind = CompletionItemKind(7);
+    pub const INTERFACE: CompletionItemKind = CompletionItemKind(8);
+    pub const MODULE: CompletionItemKind = CompletionItemKind(9);
+    pub const PROPERTY: CompletionItemKind = CompletionItemKind(10);
+    pub const UNIT: CompletionItemKind = CompletionItemKind(11);
+    pub const VALUE: CompletionItemKind = CompletionItemKind(12);
+    pub const ENUM: CompletionItemKind = CompletionItemKind(13);
+    pub const KEYWORD: CompletionItemKind = CompletionItemKind(14);
+    pub const SNIPPET: CompletionItemKind = CompletionItemKind(15);
+    pub const COLOR: CompletionItemKind = CompletionItemKind(16);
+    pub const FILE: CompletionItemKind = CompletionItemKind(17);
+    pub const REFERENCE: CompletionItemKind = CompletionItemKind(18);
+    pub const FOLDER: CompletionItemKind = CompletionItemKind(19);
+    pub const ENUM_MEMBER: CompletionItemKind = CompletionItemKind(20);
+    pub const CONSTANT: CompletionItemKind = CompletionItemKind(21);
+    pub const STRUCT: CompletionItemKind = CompletionItemKind(22);
+    pub const EVENT: CompletionItemKind = CompletionItemKind(23);
+    pub const OPERATOR: CompletionItemKind = CompletionItemKind(24);
+    pub const TYPE_PARAMETER: CompletionItemKind = CompletionItemKind(25);
+}
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionItemCapability {
+    /// Client supports snippets as insert text.
+    ///
+    /// A snippet can define tab stops and placeholders with `$1`, `$2`
+    /// and `${3:foo}`. `$0` defines the final tab stop, it defaults to
+    /// the end of the snippet. Placeholders with equal identifiers are linked,
+    /// that is typing in one will update others too.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub snippet_support: Option<bool>,
+
+    /// Client supports commit characters on a completion item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub commit_characters_support: Option<bool>,
+
+    /// Client supports the follow content formats for the documentation
+    /// property. The order describes the preferred format of the client.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub documentation_format: Option<Vec<MarkupKind>>,
+
+    /// Client supports the deprecated property on a completion item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub deprecated_support: Option<bool>,
+
+    /// Client supports the preselect property on a completion item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub preselect_support: Option<bool>,
+
+    /// Client supports the tag property on a completion item. Clients supporting
+    /// tags have to handle unknown tags gracefully. Clients especially need to
+    /// preserve unknown tags when sending a completion item back to the server in
+    /// a resolve call.
+    #[serde(
+        default,
+        skip_serializing_if = "Option::is_none",
+        deserialize_with = "TagSupport::deserialize_compat"
+    )]
+    pub tag_support: Option<TagSupport<CompletionItemTag>>,
+
+    /// Client support insert replace edit to control different behavior if a
+    /// completion item is inserted in the text or should replace text.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub insert_replace_support: Option<bool>,
+
+    /// Indicates which properties a client can resolve lazily on a completion
+    /// item. Before version 3.16.0 only the predefined properties `documentation`
+    /// and `details` could be resolved lazily.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_support: Option<CompletionItemCapabilityResolveSupport>,
+
+    /// The client supports the `insertTextMode` property on
+    /// a completion item to override the whitespace handling mode
+    /// as defined by the client.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub insert_text_mode_support: Option<InsertTextModeSupport>,
+
+    /// The client has support for completion item label
+    /// details (see also `CompletionItemLabelDetails`).
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub label_details_support: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionItemCapabilityResolveSupport {
+    /// The properties that a client can resolve lazily.
+    pub properties: Vec<String>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InsertTextModeSupport {
+    pub value_set: Vec<InsertTextMode>,
+}
+
+/// How whitespace and indentation is handled during completion
+/// item insertion.
+///
+/// @since 3.16.0
+#[derive(Eq, PartialEq, Clone, Copy, Serialize, Deserialize)]
+#[serde(transparent)]
+pub struct InsertTextMode(i32);
+lsp_enum! {
+impl InsertTextMode {
+    /// The insertion or replace strings is taken as it is. If the
+    /// value is multi line the lines below the cursor will be
+    /// inserted using the indentation defined in the string value.
+    /// The client will not apply any kind of adjustments to the
+    /// string.
+    pub const AS_IS: InsertTextMode = InsertTextMode(1);
+
+    /// The editor adjusts leading whitespace of new lines so that
+    /// they match the indentation up to the cursor of the line for
+    /// which the item is accepted.
+    ///
+    /// Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
+    /// multi line completion item is indented using 2 tabs all
+    /// following lines inserted will be indented using 2 tabs as well.
+    pub const ADJUST_INDENTATION: InsertTextMode = InsertTextMode(2);
+}
+}
+
+#[derive(Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct CompletionItemTag(i32);
+lsp_enum! {
+impl CompletionItemTag {
+    pub const DEPRECATED: CompletionItemTag = CompletionItemTag(1);
+}
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionItemKindCapability {
+    /// The completion item kind values the client supports. When this
+    /// property exists the client also guarantees that it will
+    /// handle values outside its set gracefully and falls back
+    /// to a default value when unknown.
+    ///
+    /// If this property is not present the client only supports
+    /// the completion items kinds from `Text` to `Reference` as defined in
+    /// the initial version of the protocol.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub value_set: Option<Vec<CompletionItemKind>>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionListCapability {
+    /// The client supports the following itemDefaults on
+    /// a completion list.
+    ///
+    /// The value lists the supported property names of the
+    /// `CompletionList.itemDefaults` object. If omitted
+    /// no properties are supported.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub item_defaults: Option<Vec<String>>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionClientCapabilities {
+    /// Whether completion supports dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// The client supports the following `CompletionItem` specific
+    /// capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub completion_item: Option<CompletionItemCapability>,
+
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub completion_item_kind: Option<CompletionItemKindCapability>,
+
+    /// The client supports to send additional context information for a
+    /// `textDocument/completion` request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub context_support: Option<bool>,
+
+    /// The client's default when the completion item doesn't provide a
+    /// `insertTextMode` property.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub insert_text_mode: Option<InsertTextMode>,
+
+    /// The client supports the following `CompletionList` specific
+    /// capabilities.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub completion_list: Option<CompletionListCapability>,
+}
+
+/// A special text edit to provide an insert and a replace operation.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InsertReplaceEdit {
+    /// The string to be inserted.
+    pub new_text: String,
+
+    /// The range if the insert is requested
+    pub insert: Range,
+
+    /// The range if the replace is requested.
+    pub replace: Range,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum CompletionTextEdit {
+    Edit(TextEdit),
+    InsertAndReplace(InsertReplaceEdit),
+}
+
+impl From<TextEdit> for CompletionTextEdit {
+    fn from(edit: TextEdit) -> Self {
+        CompletionTextEdit::Edit(edit)
+    }
+}
+
+impl From<InsertReplaceEdit> for CompletionTextEdit {
+    fn from(edit: InsertReplaceEdit) -> Self {
+        CompletionTextEdit::InsertAndReplace(edit)
+    }
+}
+
+/// Completion options.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionOptions {
+    /// The server provides support to resolve additional information for a completion item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_provider: Option<bool>,
+
+    /// Most tools trigger completion request automatically without explicitly
+    /// requesting it using a keyboard shortcut (e.g. Ctrl+Space). Typically they
+    /// do so when the user starts to type an identifier. For example if the user
+    /// types `c` in a JavaScript file code complete will automatically pop up
+    /// present `console` besides others as a completion item. Characters that
+    /// make up identifiers don't need to be listed here.
+    ///
+    /// If code complete should automatically be trigger on characters not being
+    /// valid inside an identifier (for example `.` in JavaScript) list them in
+    /// `triggerCharacters`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub trigger_characters: Option<Vec<String>>,
+
+    /// The list of all possible characters that commit a completion. This field
+    /// can be used if clients don't support individual commit characters per
+    /// completion item. See client capability
+    /// `completion.completionItem.commitCharactersSupport`.
+    ///
+    /// If a server provides both `allCommitCharacters` and commit characters on
+    /// an individual completion item the ones on the completion item win.
+    ///
+    /// @since 3.2.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub all_commit_characters: Option<Vec<String>>,
+
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+
+    /// The server supports the following `CompletionItem` specific
+    /// capabilities.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub completion_item: Option<CompletionOptionsCompletionItem>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionOptionsCompletionItem {
+    /// The server has support for completion item label
+    /// details (see also `CompletionItemLabelDetails`) when receiving
+    /// a completion item in a resolve call.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub label_details_support: Option<bool>,
+}
+
+#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
+pub struct CompletionRegistrationOptions {
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub completion_options: CompletionOptions,
+}
+
+#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
+#[serde(untagged)]
+pub enum CompletionResponse {
+    Array(Vec<CompletionItem>),
+    List(CompletionList),
+}
+
+impl From<Vec<CompletionItem>> for CompletionResponse {
+    fn from(items: Vec<CompletionItem>) -> Self {
+        CompletionResponse::Array(items)
+    }
+}
+
+impl From<CompletionList> for CompletionResponse {
+    fn from(list: CompletionList) -> Self {
+        CompletionResponse::List(list)
+    }
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionParams {
+    // This field was "mixed-in" from TextDocumentPositionParams
+    #[serde(flatten)]
+    pub text_document_position: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+
+    // CompletionParams properties:
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub context: Option<CompletionContext>,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionContext {
+    /// How the completion was triggered.
+    pub trigger_kind: CompletionTriggerKind,
+
+    /// The trigger character (a single character) that has trigger code complete.
+    /// Is undefined if `triggerKind !== CompletionTriggerKind.TriggerCharacter`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub trigger_character: Option<String>,
+}
+
+/// How a completion was triggered.
+#[derive(Eq, PartialEq, Clone, Copy, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct CompletionTriggerKind(i32);
+lsp_enum! {
+impl CompletionTriggerKind {
+    pub const INVOKED: CompletionTriggerKind = CompletionTriggerKind(1);
+    pub const TRIGGER_CHARACTER: CompletionTriggerKind = CompletionTriggerKind(2);
+    pub const TRIGGER_FOR_INCOMPLETE_COMPLETIONS: CompletionTriggerKind = CompletionTriggerKind(3);
+}
+}
+
+/// Represents a collection of [completion items](#CompletionItem) to be presented
+/// in the editor.
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionList {
+    /// This list it not complete. Further typing should result in recomputing
+    /// this list.
+    pub is_incomplete: bool,
+
+    /// The completion items.
+    pub items: Vec<CompletionItem>,
+}
+
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionItem {
+    /// The label of this completion item. By default
+    /// also the text that is inserted when selecting
+    /// this completion.
+    pub label: String,
+
+    /// Additional details for the label
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub label_details: Option<CompletionItemLabelDetails>,
+
+    /// The kind of this completion item. Based of the kind
+    /// an icon is chosen by the editor.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub kind: Option<CompletionItemKind>,
+
+    /// A human-readable string with additional information
+    /// about this item, like type or symbol information.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub detail: Option<String>,
+
+    /// A human-readable string that represents a doc-comment.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub documentation: Option<Documentation>,
+
+    /// Indicates if this item is deprecated.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub deprecated: Option<bool>,
+
+    /// Select this item when showing.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub preselect: Option<bool>,
+
+    /// A string that should be used when comparing this item
+    /// with other items. When `falsy` the label is used
+    /// as the sort text for this item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub sort_text: Option<String>,
+
+    /// A string that should be used when filtering a set of
+    /// completion items. When `falsy` the label is used as the
+    /// filter text for this item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub filter_text: Option<String>,
+
+    /// A string that should be inserted into a document when selecting
+    /// this completion. When `falsy` the label is used as the insert text
+    /// for this item.
+    ///
+    /// The `insertText` is subject to interpretation by the client side.
+    /// Some tools might not take the string literally. For example
+    /// VS Code when code complete is requested in this example
+    /// `con<cursor position>` and a completion item with an `insertText` of
+    /// `console` is provided it will only insert `sole`. Therefore it is
+    /// recommended to use `textEdit` instead since it avoids additional client
+    /// side interpretation.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub insert_text: Option<String>,
+
+    /// The format of the insert text. The format applies to both the `insertText` property
+    /// and the `newText` property of a provided `textEdit`. If omitted defaults to `InsertTextFormat.PlainText`.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub insert_text_format: Option<InsertTextFormat>,
+
+    /// How whitespace and indentation is handled during completion
+    /// item insertion. If not provided the client's default value depends on
+    /// the `textDocument.completion.insertTextMode` client capability.
+    ///
+    /// @since 3.16.0
+    /// @since 3.17.0 - support for `textDocument.completion.insertTextMode`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub insert_text_mode: Option<InsertTextMode>,
+
+    /// An edit which is applied to a document when selecting
+    /// this completion. When an edit is provided the value of
+    /// insertText is ignored.
+    ///
+    /// Most editors support two different operation when accepting a completion item. One is to insert a
+
+    /// completion text and the other is to replace an existing text with a completion text. Since this can
+    /// usually not predetermined by a server it can report both ranges. Clients need to signal support for
+    /// `InsertReplaceEdits` via the `textDocument.completion.insertReplaceSupport` client capability
+    /// property.
+    ///
+    /// *Note 1:* The text edit's range as well as both ranges from a insert replace edit must be a
+    /// [single line] and they must contain the position at which completion has been requested.
+    /// *Note 2:* If an `InsertReplaceEdit` is returned the edit's insert range must be a prefix of
+    /// the edit's replace range, that means it must be contained and starting at the same position.
+    ///
+    /// @since 3.16.0 additional type `InsertReplaceEdit`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub text_edit: Option<CompletionTextEdit>,
+
+    /// An optional array of additional text edits that are applied when
+    /// selecting this completion. Edits must not overlap with the main edit
+    /// nor with themselves.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub additional_text_edits: Option<Vec<TextEdit>>,
+
+    /// An optional command that is executed *after* inserting this completion. *Note* that
+    /// additional modifications to the current document should be described with the
+    /// additionalTextEdits-property.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub command: Option<Command>,
+
+    /// An optional set of characters that when pressed while this completion is
+    /// active will accept it first and then type that character. *Note* that all
+    /// commit characters should have `length=1` and that superfluous characters
+    /// will be ignored.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub commit_characters: Option<Vec<String>>,
+
+    /// An data entry field that is preserved on a completion item between
+    /// a completion and a completion resolve request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data: Option<Value>,
+
+    /// Tags for this completion item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tags: Option<Vec<CompletionItemTag>>,
+}
+
+impl CompletionItem {
+    /// Create a CompletionItem with the minimum possible info (label and detail).
+    pub fn new_simple(label: String, detail: String) -> CompletionItem {
+        CompletionItem {
+            label,
+            detail: Some(detail),
+            ..Self::default()
+        }
+    }
+}
+
+/// Additional details for a completion item label.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct CompletionItemLabelDetails {
+    /// An optional string which is rendered less prominently directly after
+    /// {@link CompletionItemLabel.label label}, without any spacing. Should be
+    /// used for function signatures or type annotations.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub detail: Option<String>,
+
+    /// An optional string which is rendered less prominently after
+    /// {@link CompletionItemLabel.detail}. Should be used for fully qualified
+    /// names or file path.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub description: Option<String>,
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::tests::test_deserialization;
+
+    #[test]
+    fn test_tag_support_deserialization() {
+        let mut empty = CompletionItemCapability::default();
+        empty.tag_support = None;
+
+        test_deserialization(r#"{}"#, &empty);
+        test_deserialization(r#"{"tagSupport": false}"#, &empty);
+
+        let mut t = CompletionItemCapability::default();
+        t.tag_support = Some(TagSupport { value_set: vec![] });
+        test_deserialization(r#"{"tagSupport": true}"#, &t);
+
+        let mut t = CompletionItemCapability::default();
+        t.tag_support = Some(TagSupport {
+            value_set: vec![CompletionItemTag::DEPRECATED],
+        });
+        test_deserialization(r#"{"tagSupport": {"valueSet": [1]}}"#, &t);
+    }
+
+    #[test]
+    fn test_debug_enum() {
+        assert_eq!(format!("{:?}", CompletionItemKind::TEXT), "Text");
+        assert_eq!(
+            format!("{:?}", CompletionItemKind::TYPE_PARAMETER),
+            "TypeParameter"
+        );
+    }
+
+    #[test]
+    fn test_try_from_enum() {
+        use std::convert::TryInto;
+        assert_eq!("Text".try_into(), Ok(CompletionItemKind::TEXT));
+        assert_eq!(
+            "TypeParameter".try_into(),
+            Ok(CompletionItemKind::TYPE_PARAMETER)
+        );
+    }
+}
diff --git a/crates/lsp-types/src/document_diagnostic.rs b/crates/lsp-types/src/document_diagnostic.rs
new file mode 100644
index 000000000..a2b5c41fa
--- /dev/null
+++ b/crates/lsp-types/src/document_diagnostic.rs
@@ -0,0 +1,269 @@
+use std::collections::HashMap;
+
+use serde::{Deserialize, Serialize};
+use url::Url;
+
+use crate::{
+    Diagnostic, PartialResultParams, StaticRegistrationOptions, TextDocumentIdentifier,
+    TextDocumentRegistrationOptions, WorkDoneProgressOptions, WorkDoneProgressParams,
+};
+
+/// Client capabilities specific to diagnostic pull requests.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DiagnosticClientCapabilities {
+    /// Whether implementation supports dynamic registration.
+    ///
+    /// If this is set to `true` the client supports the new `(TextDocumentRegistrationOptions &
+    /// StaticRegistrationOptions)` return value for the corresponding server capability as well.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// Whether the clients supports related documents for document diagnostic pulls.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub related_document_support: Option<bool>,
+}
+
+/// Diagnostic options.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DiagnosticOptions {
+    /// An optional identifier under which the diagnostics are
+    /// managed by the client.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub identifier: Option<String>,
+
+    /// Whether the language has inter file dependencies, meaning that editing code in one file can
+    /// result in a different diagnostic set in another file. Inter file dependencies are common
+    /// for most programming languages and typically uncommon for linters.
+    pub inter_file_dependencies: bool,
+
+    /// The server provides support for workspace diagnostics as well.
+    pub workspace_diagnostics: bool,
+
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+/// Diagnostic registration options.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DiagnosticRegistrationOptions {
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub diagnostic_options: DiagnosticOptions,
+
+    #[serde(flatten)]
+    pub static_registration_options: StaticRegistrationOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum DiagnosticServerCapabilities {
+    Options(DiagnosticOptions),
+    RegistrationOptions(DiagnosticRegistrationOptions),
+}
+
+/// Parameters of the document diagnostic request.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentDiagnosticParams {
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The additional identifier provided during registration.
+    pub identifier: Option<String>,
+
+    /// The result ID of a previous response if provided.
+    pub previous_result_id: Option<String>,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// A diagnostic report with a full set of problems.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct FullDocumentDiagnosticReport {
+    /// An optional result ID. If provided it will be sent on the next diagnostic request for the
+    /// same document.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub result_id: Option<String>,
+
+    /// The actual items.
+    pub items: Vec<Diagnostic>,
+}
+
+/// A diagnostic report indicating that the last returned report is still accurate.
+///
+/// A server can only return `unchanged` if result ids are provided.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct UnchangedDocumentDiagnosticReport {
+    /// A result ID which will be sent on the next diagnostic request for the same document.
+    pub result_id: String,
+}
+
+/// The document diagnostic report kinds.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(tag = "kind", rename_all = "lowercase")]
+pub enum DocumentDiagnosticReportKind {
+    /// A diagnostic report with a full set of problems.
+    Full(FullDocumentDiagnosticReport),
+    /// A report indicating that the last returned report is still accurate.
+    Unchanged(UnchangedDocumentDiagnosticReport),
+}
+
+impl From<FullDocumentDiagnosticReport> for DocumentDiagnosticReportKind {
+    fn from(from: FullDocumentDiagnosticReport) -> Self {
+        DocumentDiagnosticReportKind::Full(from)
+    }
+}
+
+impl From<UnchangedDocumentDiagnosticReport> for DocumentDiagnosticReportKind {
+    fn from(from: UnchangedDocumentDiagnosticReport) -> Self {
+        DocumentDiagnosticReportKind::Unchanged(from)
+    }
+}
+
+/// A full diagnostic report with a set of related documents.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct RelatedFullDocumentDiagnosticReport {
+    /// Diagnostics of related documents.
+    ///
+    /// This information is useful in programming languages where code in a file A can generate
+    /// diagnostics in a file B which A depends on. An example of such a language is C/C++ where
+    /// macro definitions in a file `a.cpp` result in errors in a header file `b.hpp`.
+    ///
+    /// @since 3.17.0
+    #[serde(with = "crate::url_map")]
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[serde(default)]
+    pub related_documents: Option<HashMap<Url, DocumentDiagnosticReportKind>>,
+    // relatedDocuments?: { [uri: string]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport; };
+    #[serde(flatten)]
+    pub full_document_diagnostic_report: FullDocumentDiagnosticReport,
+}
+
+/// An unchanged diagnostic report with a set of related documents.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct RelatedUnchangedDocumentDiagnosticReport {
+    /// Diagnostics of related documents.
+    ///
+    /// This information is useful in programming languages where code in a file A can generate
+    /// diagnostics in a file B which A depends on. An example of such a language is C/C++ where
+    /// macro definitions in a file `a.cpp` result in errors in a header file `b.hpp`.
+    ///
+    /// @since 3.17.0
+    #[serde(with = "crate::url_map")]
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[serde(default)]
+    pub related_documents: Option<HashMap<Url, DocumentDiagnosticReportKind>>,
+    // relatedDocuments?: { [uri: string]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport; };
+    #[serde(flatten)]
+    pub unchanged_document_diagnostic_report: UnchangedDocumentDiagnosticReport,
+}
+
+/// The result of a document diagnostic pull request.
+///
+/// A report can either be a full report containing all diagnostics for the requested document or
+/// an unchanged report indicating that nothing has changed in terms of diagnostics in comparison
+/// to the last pull request.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(tag = "kind", rename_all = "lowercase")]
+pub enum DocumentDiagnosticReport {
+    /// A diagnostic report with a full set of problems.
+    Full(RelatedFullDocumentDiagnosticReport),
+    /// A report indicating that the last returned report is still accurate.
+    Unchanged(RelatedUnchangedDocumentDiagnosticReport),
+}
+
+impl From<RelatedFullDocumentDiagnosticReport> for DocumentDiagnosticReport {
+    fn from(from: RelatedFullDocumentDiagnosticReport) -> Self {
+        DocumentDiagnosticReport::Full(from)
+    }
+}
+
+impl From<RelatedUnchangedDocumentDiagnosticReport> for DocumentDiagnosticReport {
+    fn from(from: RelatedUnchangedDocumentDiagnosticReport) -> Self {
+        DocumentDiagnosticReport::Unchanged(from)
+    }
+}
+
+/// A partial result for a document diagnostic report.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentDiagnosticReportPartialResult {
+    #[serde(with = "crate::url_map")]
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[serde(default)]
+    pub related_documents: Option<HashMap<Url, DocumentDiagnosticReportKind>>,
+    // relatedDocuments?: { [uri: string]: FullDocumentDiagnosticReport | UnchangedDocumentDiagnosticReport; };
+}
+
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(untagged)]
+pub enum DocumentDiagnosticReportResult {
+    Report(DocumentDiagnosticReport),
+    Partial(DocumentDiagnosticReportPartialResult),
+}
+
+impl From<DocumentDiagnosticReport> for DocumentDiagnosticReportResult {
+    fn from(from: DocumentDiagnosticReport) -> Self {
+        DocumentDiagnosticReportResult::Report(from)
+    }
+}
+
+impl From<DocumentDiagnosticReportPartialResult> for DocumentDiagnosticReportResult {
+    fn from(from: DocumentDiagnosticReportPartialResult) -> Self {
+        DocumentDiagnosticReportResult::Partial(from)
+    }
+}
+
+/// Cancellation data returned from a diagnostic request.
+///
+/// If no data is provided, it defaults to `{ retrigger_request: true }`.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct DiagnosticServerCancellationData {
+    pub retrigger_request: bool,
+}
+
+impl Default for DiagnosticServerCancellationData {
+    fn default() -> Self {
+        DiagnosticServerCancellationData {
+            retrigger_request: true,
+        }
+    }
+}
diff --git a/crates/lsp-types/src/document_highlight.rs b/crates/lsp-types/src/document_highlight.rs
new file mode 100644
index 000000000..f2954e6d9
--- /dev/null
+++ b/crates/lsp-types/src/document_highlight.rs
@@ -0,0 +1,51 @@
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    DynamicRegistrationClientCapabilities, PartialResultParams, Range, TextDocumentPositionParams,
+    WorkDoneProgressParams,
+};
+
+pub type DocumentHighlightClientCapabilities = DynamicRegistrationClientCapabilities;
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentHighlightParams {
+    #[serde(flatten)]
+    pub text_document_position_params: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// A document highlight is a range inside a text document which deserves
+/// special attention. Usually a document highlight is visualized by changing
+/// the background color of its range.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct DocumentHighlight {
+    /// The range this highlight applies to.
+    pub range: Range,
+
+    /// The highlight kind, default is DocumentHighlightKind.Text.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub kind: Option<DocumentHighlightKind>,
+}
+
+/// A document highlight kind.
+#[derive(Eq, PartialEq, Copy, Clone, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct DocumentHighlightKind(i32);
+lsp_enum! {
+impl DocumentHighlightKind {
+    /// A textual occurrence.
+    pub const TEXT: DocumentHighlightKind = DocumentHighlightKind(1);
+
+    /// Read-access of a symbol, like reading a variable.
+    pub const READ: DocumentHighlightKind = DocumentHighlightKind(2);
+
+    /// Write-access of a symbol, like writing to a variable.
+    pub const WRITE: DocumentHighlightKind = DocumentHighlightKind(3);
+}
+}
diff --git a/crates/lsp-types/src/document_link.rs b/crates/lsp-types/src/document_link.rs
new file mode 100644
index 000000000..1400dd96b
--- /dev/null
+++ b/crates/lsp-types/src/document_link.rs
@@ -0,0 +1,67 @@
+use crate::{
+    PartialResultParams, Range, TextDocumentIdentifier, WorkDoneProgressOptions,
+    WorkDoneProgressParams,
+};
+use serde::{Deserialize, Serialize};
+use serde_json::Value;
+use url::Url;
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentLinkClientCapabilities {
+    /// Whether document link supports dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// Whether the client support the `tooltip` property on `DocumentLink`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tooltip_support: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentLinkOptions {
+    /// Document links have a resolve provider as well.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_provider: Option<bool>,
+
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentLinkParams {
+    /// The document to provide document links for.
+    pub text_document: TextDocumentIdentifier,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// A document link is a range in a text document that links to an internal or external resource, like another
+/// text document or a web site.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct DocumentLink {
+    /// The range this link applies to.
+    pub range: Range,
+    /// The uri this link points to.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub target: Option<Url>,
+
+    /// The tooltip text when you hover over this link.
+    ///
+    /// If a tooltip is provided, is will be displayed in a string that includes instructions on how to
+    /// trigger the link, such as `{0} (ctrl + click)`. The specific instructions vary depending on OS,
+    /// user settings, and localization.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tooltip: Option<String>,
+
+    /// A data entry field that is preserved on a document link between a DocumentLinkRequest
+    /// and a DocumentLinkResolveRequest.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data: Option<Value>,
+}
diff --git a/crates/lsp-types/src/document_symbols.rs b/crates/lsp-types/src/document_symbols.rs
new file mode 100644
index 000000000..3f482e166
--- /dev/null
+++ b/crates/lsp-types/src/document_symbols.rs
@@ -0,0 +1,134 @@
+use crate::{
+    Location, PartialResultParams, Range, SymbolKind, SymbolKindCapability, TextDocumentIdentifier,
+    WorkDoneProgressParams,
+};
+
+use crate::{SymbolTag, TagSupport};
+
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentSymbolClientCapabilities {
+    /// This capability supports dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// Specific capabilities for the `SymbolKind`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub symbol_kind: Option<SymbolKindCapability>,
+
+    /// The client support hierarchical document symbols.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub hierarchical_document_symbol_support: Option<bool>,
+
+    /// The client supports tags on `SymbolInformation`. Tags are supported on
+    /// `DocumentSymbol` if `hierarchicalDocumentSymbolSupport` is set to true.
+    /// Clients supporting tags have to handle unknown tags gracefully.
+    ///
+    /// @since 3.16.0
+    #[serde(
+        default,
+        skip_serializing_if = "Option::is_none",
+        deserialize_with = "TagSupport::deserialize_compat"
+    )]
+    pub tag_support: Option<TagSupport<SymbolTag>>,
+}
+
+#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
+#[serde(untagged)]
+pub enum DocumentSymbolResponse {
+    Flat(Vec<SymbolInformation>),
+    Nested(Vec<DocumentSymbol>),
+}
+
+impl From<Vec<SymbolInformation>> for DocumentSymbolResponse {
+    fn from(info: Vec<SymbolInformation>) -> Self {
+        DocumentSymbolResponse::Flat(info)
+    }
+}
+
+impl From<Vec<DocumentSymbol>> for DocumentSymbolResponse {
+    fn from(symbols: Vec<DocumentSymbol>) -> Self {
+        DocumentSymbolResponse::Nested(symbols)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentSymbolParams {
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// Represents programming constructs like variables, classes, interfaces etc.
+/// that appear in a document. Document symbols can be hierarchical and they have two ranges:
+/// one that encloses its definition and one that points to its most interesting range,
+/// e.g. the range of an identifier.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentSymbol {
+    /// The name of this symbol.
+    pub name: String,
+    /// More detail for this symbol, e.g the signature of a function. If not provided the
+    /// name is used.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub detail: Option<String>,
+    /// The kind of this symbol.
+    pub kind: SymbolKind,
+    /// Tags for this completion item.
+    ///
+    /// @since 3.15.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tags: Option<Vec<SymbolTag>>,
+    /// Indicates if this symbol is deprecated.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[deprecated(note = "Use tags instead")]
+    pub deprecated: Option<bool>,
+    /// The range enclosing this symbol not including leading/trailing whitespace but everything else
+    /// like comments. This information is typically used to determine if the the clients cursor is
+    /// inside the symbol to reveal in the symbol in the UI.
+    pub range: Range,
+    /// The range that should be selected and revealed when this symbol is being picked, e.g the name of a function.
+    /// Must be contained by the the `range`.
+    pub selection_range: Range,
+    /// Children of this symbol, e.g. properties of a class.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub children: Option<Vec<DocumentSymbol>>,
+}
+
+/// Represents information about programming constructs like variables, classes,
+/// interfaces etc.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SymbolInformation {
+    /// The name of this symbol.
+    pub name: String,
+
+    /// The kind of this symbol.
+    pub kind: SymbolKind,
+
+    /// Tags for this completion item.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tags: Option<Vec<SymbolTag>>,
+
+    /// Indicates if this symbol is deprecated.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[deprecated(note = "Use tags instead")]
+    pub deprecated: Option<bool>,
+
+    /// The location of this symbol.
+    pub location: Location,
+
+    /// The name of the symbol containing this symbol.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub container_name: Option<String>,
+}
diff --git a/crates/lsp-types/src/error_codes.rs b/crates/lsp-types/src/error_codes.rs
new file mode 100644
index 000000000..f09fae168
--- /dev/null
+++ b/crates/lsp-types/src/error_codes.rs
@@ -0,0 +1,54 @@
+//! In this module we only define constants for lsp specific error codes.
+//! There are other error codes that are defined in the
+//! [JSON RPC specification](https://www.jsonrpc.org/specification#error_object).
+
+/// Defined in the LSP specification but in the range reserved for JSON-RPC error codes,
+/// namely the -32099 to -32000 "Reserved for implementation-defined server-errors." range.
+/// The code has, nonetheless, been left in this range for backwards compatibility reasons.
+pub const SERVER_NOT_INITIALIZED: i64 = -32002;
+
+/// Defined in the LSP specification but in the range reserved for JSON-RPC error codes,
+/// namely the -32099 to -32000 "Reserved for implementation-defined server-errors." range.
+/// The code has, nonetheless, left in this range for backwards compatibility reasons.
+pub const UNKNOWN_ERROR_CODE: i64 = -32001;
+
+/// This is the start range of LSP reserved error codes.
+/// It doesn't denote a real error code.
+///
+/// @since 3.16.0
+pub const LSP_RESERVED_ERROR_RANGE_START: i64 = -32899;
+
+/// A request failed but it was syntactically correct, e.g the
+/// method name was known and the parameters were valid. The error
+/// message should contain human readable information about why
+/// the request failed.
+///
+/// @since 3.17.0
+pub const REQUEST_FAILED: i64 = -32803;
+
+/// The server cancelled the request. This error code should
+/// only be used for requests that explicitly support being
+/// server cancellable.
+///
+/// @since 3.17.0
+pub const SERVER_CANCELLED: i64 = -32802;
+
+/// The server detected that the content of a document got
+/// modified outside normal conditions. A server should
+/// NOT send this error code if it detects a content change
+/// in it unprocessed messages. The result even computed
+/// on an older state might still be useful for the client.
+///
+/// If a client decides that a result is not of any use anymore
+/// the client should cancel the request.
+pub const CONTENT_MODIFIED: i64 = -32801;
+
+/// The client has canceled a request and a server as detected
+/// the cancel.
+pub const REQUEST_CANCELLED: i64 = -32800;
+
+/// This is the end range of LSP reserved error codes.
+/// It doesn't denote a real error code.
+///
+/// @since 3.16.0
+pub const LSP_RESERVED_ERROR_RANGE_END: i64 = -32800;
diff --git a/crates/lsp-types/src/file_operations.rs b/crates/lsp-types/src/file_operations.rs
new file mode 100644
index 000000000..52572f931
--- /dev/null
+++ b/crates/lsp-types/src/file_operations.rs
@@ -0,0 +1,213 @@
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceFileOperationsClientCapabilities {
+    /// Whether the client supports dynamic registration for file
+    /// requests/notifications.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// The client has support for sending didCreateFiles notifications.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub did_create: Option<bool>,
+
+    /// The server is interested in receiving willCreateFiles requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_create: Option<bool>,
+
+    /// The server is interested in receiving didRenameFiles requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub did_rename: Option<bool>,
+
+    /// The server is interested in receiving willRenameFiles requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_rename: Option<bool>,
+
+    /// The server is interested in receiving didDeleteFiles requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub did_delete: Option<bool>,
+
+    /// The server is interested in receiving willDeleteFiles requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_delete: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceFileOperationsServerCapabilities {
+    /// The server is interested in receiving didCreateFiles
+    /// notifications.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub did_create: Option<FileOperationRegistrationOptions>,
+
+    /// The server is interested in receiving willCreateFiles requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_create: Option<FileOperationRegistrationOptions>,
+
+    /// The server is interested in receiving didRenameFiles
+    /// notifications.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub did_rename: Option<FileOperationRegistrationOptions>,
+
+    /// The server is interested in receiving willRenameFiles requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_rename: Option<FileOperationRegistrationOptions>,
+
+    /// The server is interested in receiving didDeleteFiles file
+    /// notifications.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub did_delete: Option<FileOperationRegistrationOptions>,
+
+    /// The server is interested in receiving willDeleteFiles file
+    /// requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_delete: Option<FileOperationRegistrationOptions>,
+}
+
+/// The options to register for file operations.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FileOperationRegistrationOptions {
+    /// The actual filters.
+    pub filters: Vec<FileOperationFilter>,
+}
+
+/// A filter to describe in which file operation requests or notifications
+/// the server is interested in.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FileOperationFilter {
+    /// A Uri like `file` or `untitled`.
+    pub scheme: Option<String>,
+
+    /// The actual file operation pattern.
+    pub pattern: FileOperationPattern,
+}
+
+/// A pattern kind describing if a glob pattern matches a file a folder or
+/// both.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "lowercase")]
+pub enum FileOperationPatternKind {
+    /// The pattern matches a file only.
+    File,
+
+    /// The pattern matches a folder only.
+    Folder,
+}
+
+/// Matching options for the file operation pattern.
+///
+/// @since 3.16.0
+///
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FileOperationPatternOptions {
+    /// The pattern should be matched ignoring casing.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub ignore_case: Option<bool>,
+}
+
+/// A pattern to describe in which file operation requests or notifications
+/// the server is interested in.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FileOperationPattern {
+    /// The glob pattern to match. Glob patterns can have the following syntax:
+    /// - `*` to match one or more characters in a path segment
+    /// - `?` to match on one character in a path segment
+    /// - `**` to match any number of path segments, including none
+    /// - `{}` to group conditions (e.g. `**/*.{ts,js}` matches all TypeScript
+    ///   and JavaScript files)
+    /// - `[]` to declare a range of characters to match in a path segment
+    ///   (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
+    /// - `[!...]` to negate a range of characters to match in a path segment
+    ///   (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but
+    ///   not `example.0`)
+    pub glob: String,
+
+    /// Whether to match files or folders with this pattern.
+    ///
+    /// Matches both if undefined.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub matches: Option<FileOperationPatternKind>,
+
+    /// Additional options used during matching.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub options: Option<FileOperationPatternOptions>,
+}
+
+/// The parameters sent in notifications/requests for user-initiated creation
+/// of files.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CreateFilesParams {
+    /// An array of all files/folders created in this operation.
+    pub files: Vec<FileCreate>,
+}
+/// Represents information on a file/folder create.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FileCreate {
+    /// A file:// URI for the location of the file/folder being created.
+    pub uri: String,
+}
+
+/// The parameters sent in notifications/requests for user-initiated renames
+/// of files.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RenameFilesParams {
+    /// An array of all files/folders renamed in this operation. When a folder
+    /// is renamed, only the folder will be included, and not its children.
+    pub files: Vec<FileRename>,
+}
+
+/// Represents information on a file/folder rename.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FileRename {
+    /// A file:// URI for the original location of the file/folder being renamed.
+    pub old_uri: String,
+
+    /// A file:// URI for the new location of the file/folder being renamed.
+    pub new_uri: String,
+}
+
+/// The parameters sent in notifications/requests for user-initiated deletes
+/// of files.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DeleteFilesParams {
+    /// An array of all files/folders deleted in this operation.
+    pub files: Vec<FileDelete>,
+}
+
+/// Represents information on a file/folder delete.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FileDelete {
+    /// A file:// URI for the location of the file/folder being deleted.
+    pub uri: String,
+}
diff --git a/crates/lsp-types/src/folding_range.rs b/crates/lsp-types/src/folding_range.rs
new file mode 100644
index 000000000..c9109ebf3
--- /dev/null
+++ b/crates/lsp-types/src/folding_range.rs
@@ -0,0 +1,145 @@
+use crate::{
+    PartialResultParams, StaticTextDocumentColorProviderOptions, TextDocumentIdentifier,
+    WorkDoneProgressParams,
+};
+use serde::{Deserialize, Serialize};
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FoldingRangeParams {
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum FoldingRangeProviderCapability {
+    Simple(bool),
+    FoldingProvider(FoldingProviderOptions),
+    Options(StaticTextDocumentColorProviderOptions),
+}
+
+impl From<StaticTextDocumentColorProviderOptions> for FoldingRangeProviderCapability {
+    fn from(from: StaticTextDocumentColorProviderOptions) -> Self {
+        Self::Options(from)
+    }
+}
+
+impl From<FoldingProviderOptions> for FoldingRangeProviderCapability {
+    fn from(from: FoldingProviderOptions) -> Self {
+        Self::FoldingProvider(from)
+    }
+}
+
+impl From<bool> for FoldingRangeProviderCapability {
+    fn from(from: bool) -> Self {
+        Self::Simple(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct FoldingProviderOptions {}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FoldingRangeKindCapability {
+    /// The folding range kind values the client supports. When this
+    /// property exists the client also guarantees that it will
+    /// handle values outside its set gracefully and falls back
+    /// to a default value when unknown.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub value_set: Option<Vec<FoldingRangeKind>>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FoldingRangeCapability {
+    /// If set, the client signals that it supports setting collapsedText on
+    /// folding ranges to display custom labels instead of the default text.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub collapsed_text: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FoldingRangeClientCapabilities {
+    /// Whether implementation supports dynamic registration for folding range providers. If this is set to `true`
+    /// the client supports the new `(FoldingRangeProviderOptions & TextDocumentRegistrationOptions & StaticRegistrationOptions)`
+    /// return value for the corresponding server capability as well.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// The maximum number of folding ranges that the client prefers to receive per document. The value serves as a
+    /// hint, servers are free to follow the limit.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub range_limit: Option<u32>,
+
+    /// If set, the client signals that it only supports folding complete lines. If set, client will
+    /// ignore specified `startCharacter` and `endCharacter` properties in a FoldingRange.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub line_folding_only: Option<bool>,
+
+    /// Specific options for the folding range kind.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub folding_range_kind: Option<FoldingRangeKindCapability>,
+
+    /// Specific options for the folding range.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub folding_range: Option<FoldingRangeCapability>,
+}
+
+/// Enum of known range kinds
+#[derive(Debug, Eq, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "lowercase")]
+pub enum FoldingRangeKind {
+    /// Folding range for a comment
+    Comment,
+    /// Folding range for a imports or includes
+    Imports,
+    /// Folding range for a region (e.g. `#region`)
+    Region,
+}
+
+/// Represents a folding range.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FoldingRange {
+    /// The zero-based line number from where the folded range starts.
+    pub start_line: u32,
+
+    /// The zero-based character offset from where the folded range starts. If not defined, defaults to the length of the start line.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub start_character: Option<u32>,
+
+    /// The zero-based line number where the folded range ends.
+    pub end_line: u32,
+
+    /// The zero-based character offset before the folded range ends. If not defined, defaults to the length of the end line.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub end_character: Option<u32>,
+
+    /// Describes the kind of the folding range such as `comment' or 'region'. The kind
+    /// is used to categorize folding ranges and used by commands like 'Fold all comments'. See
+    /// [FoldingRangeKind](#FoldingRangeKind) for an enumeration of standardized kinds.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub kind: Option<FoldingRangeKind>,
+
+    /// The text that the client should show when the specified range is
+    /// collapsed. If not defined or not supported by the client, a default
+    /// will be chosen by the client.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub collapsed_text: Option<String>,
+}
diff --git a/crates/lsp-types/src/formatting.rs b/crates/lsp-types/src/formatting.rs
new file mode 100644
index 000000000..4e5593c83
--- /dev/null
+++ b/crates/lsp-types/src/formatting.rs
@@ -0,0 +1,153 @@
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    DocumentSelector, DynamicRegistrationClientCapabilities, Range, TextDocumentIdentifier,
+    TextDocumentPositionParams, WorkDoneProgressParams,
+};
+
+use std::collections::HashMap;
+
+pub type DocumentFormattingClientCapabilities = DynamicRegistrationClientCapabilities;
+pub type DocumentRangeFormattingClientCapabilities = DynamicRegistrationClientCapabilities;
+pub type DocumentOnTypeFormattingClientCapabilities = DynamicRegistrationClientCapabilities;
+
+/// Format document on type options
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentOnTypeFormattingOptions {
+    /// A character on which formatting should be triggered, like `}`.
+    pub first_trigger_character: String,
+
+    /// More trigger characters.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub more_trigger_character: Option<Vec<String>>,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentFormattingParams {
+    /// The document to format.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The format options.
+    pub options: FormattingOptions,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+/// Value-object describing what options formatting should use.
+#[derive(Debug, PartialEq, Clone, Default, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FormattingOptions {
+    /// Size of a tab in spaces.
+    pub tab_size: u32,
+
+    /// Prefer spaces over tabs.
+    pub insert_spaces: bool,
+
+    /// Signature for further properties.
+    #[serde(flatten)]
+    pub properties: HashMap<String, FormattingProperty>,
+
+    /// Trim trailing whitespace on a line.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub trim_trailing_whitespace: Option<bool>,
+
+    /// Insert a newline character at the end of the file if one does not exist.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub insert_final_newline: Option<bool>,
+
+    /// Trim all newlines after the final newline at the end of the file.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub trim_final_newlines: Option<bool>,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum FormattingProperty {
+    Bool(bool),
+    Number(i32),
+    String(String),
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentRangeFormattingParams {
+    /// The document to format.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The range to format
+    pub range: Range,
+
+    /// The format options
+    pub options: FormattingOptions,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentOnTypeFormattingParams {
+    /// Text Document and Position fields.
+    #[serde(flatten)]
+    pub text_document_position: TextDocumentPositionParams,
+
+    /// The character that has been typed.
+    pub ch: String,
+
+    /// The format options.
+    pub options: FormattingOptions,
+}
+
+/// Extends TextDocumentRegistrationOptions
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentOnTypeFormattingRegistrationOptions {
+    /// A document selector to identify the scope of the registration. If set to null
+    /// the document selector provided on the client side will be used.
+    pub document_selector: Option<DocumentSelector>,
+
+    /// A character on which formatting should be triggered, like `}`.
+    pub first_trigger_character: String,
+
+    /// More trigger characters.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub more_trigger_character: Option<Vec<String>>,
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::tests::test_serialization;
+
+    #[test]
+    fn formatting_options() {
+        test_serialization(
+            &FormattingOptions {
+                tab_size: 123,
+                insert_spaces: true,
+                properties: HashMap::new(),
+                trim_trailing_whitespace: None,
+                insert_final_newline: None,
+                trim_final_newlines: None,
+            },
+            r#"{"tabSize":123,"insertSpaces":true}"#,
+        );
+
+        test_serialization(
+            &FormattingOptions {
+                tab_size: 123,
+                insert_spaces: true,
+                properties: vec![("prop".to_string(), FormattingProperty::Number(1))]
+                    .into_iter()
+                    .collect(),
+                trim_trailing_whitespace: None,
+                insert_final_newline: None,
+                trim_final_newlines: None,
+            },
+            r#"{"tabSize":123,"insertSpaces":true,"prop":1}"#,
+        );
+    }
+}
diff --git a/crates/lsp-types/src/hover.rs b/crates/lsp-types/src/hover.rs
new file mode 100644
index 000000000..01bd2f8d1
--- /dev/null
+++ b/crates/lsp-types/src/hover.rs
@@ -0,0 +1,86 @@
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    MarkedString, MarkupContent, MarkupKind, Range, TextDocumentPositionParams,
+    TextDocumentRegistrationOptions, WorkDoneProgressOptions, WorkDoneProgressParams,
+};
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct HoverClientCapabilities {
+    /// Whether completion supports dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// Client supports the follow content formats for the content
+    /// property. The order describes the preferred format of the client.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub content_format: Option<Vec<MarkupKind>>,
+}
+
+/// Hover options.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct HoverOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct HoverRegistrationOptions {
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub hover_options: HoverOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum HoverProviderCapability {
+    Simple(bool),
+    Options(HoverOptions),
+}
+
+impl From<HoverOptions> for HoverProviderCapability {
+    fn from(from: HoverOptions) -> Self {
+        Self::Options(from)
+    }
+}
+
+impl From<bool> for HoverProviderCapability {
+    fn from(from: bool) -> Self {
+        Self::Simple(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct HoverParams {
+    #[serde(flatten)]
+    pub text_document_position_params: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+/// The result of a hover request.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct Hover {
+    /// The hover's content
+    pub contents: HoverContents,
+    /// An optional range is a range inside a text document
+    /// that is used to visualize a hover, e.g. by changing the background color.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub range: Option<Range>,
+}
+
+/// Hover contents could be single entry or multiple entries.
+#[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+#[serde(untagged)]
+pub enum HoverContents {
+    Scalar(MarkedString),
+    Array(Vec<MarkedString>),
+    Markup(MarkupContent),
+}
diff --git a/crates/lsp-types/src/inlay_hint.rs b/crates/lsp-types/src/inlay_hint.rs
new file mode 100644
index 000000000..171f3c9d1
--- /dev/null
+++ b/crates/lsp-types/src/inlay_hint.rs
@@ -0,0 +1,281 @@
+use crate::{
+    Command, LSPAny, Location, MarkupContent, Position, Range, StaticRegistrationOptions,
+    TextDocumentIdentifier, TextDocumentRegistrationOptions, TextEdit, WorkDoneProgressOptions,
+    WorkDoneProgressParams,
+};
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(untagged)]
+pub enum InlayHintServerCapabilities {
+    Options(InlayHintOptions),
+    RegistrationOptions(InlayHintRegistrationOptions),
+}
+
+/// Inlay hint client capabilities.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlayHintClientCapabilities {
+    /// Whether inlay hints support dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// Indicates which properties a client can resolve lazily on a inlay
+    /// hint.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_support: Option<InlayHintResolveClientCapabilities>,
+}
+
+/// Inlay hint options used during static registration.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlayHintOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+
+    /// The server provides support to resolve additional
+    /// information for an inlay hint item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_provider: Option<bool>,
+}
+
+/// Inlay hint options used during static or dynamic registration.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlayHintRegistrationOptions {
+    #[serde(flatten)]
+    pub inlay_hint_options: InlayHintOptions,
+
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub static_registration_options: StaticRegistrationOptions,
+}
+
+/// A parameter literal used in inlay hint requests.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlayHintParams {
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The visible document range for which inlay hints should be computed.
+    pub range: Range,
+}
+
+/// Inlay hint information.
+///
+/// @since 3.17.0
+#[derive(Debug, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlayHint {
+    /// The position of this hint.
+    pub position: Position,
+
+    /// The label of this hint. A human readable string or an array of
+    /// InlayHintLabelPart label parts.
+    ///
+    /// *Note* that neither the string nor the label part can be empty.
+    pub label: InlayHintLabel,
+
+    /// The kind of this hint. Can be omitted in which case the client
+    /// should fall back to a reasonable default.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub kind: Option<InlayHintKind>,
+
+    /// Optional text edits that are performed when accepting this inlay hint.
+    ///
+    /// *Note* that edits are expected to change the document so that the inlay
+    /// hint (or its nearest variant) is now part of the document and the inlay
+    /// hint itself is now obsolete.
+    ///
+    /// Depending on the client capability `inlayHint.resolveSupport` clients
+    /// might resolve this property late using the resolve request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub text_edits: Option<Vec<TextEdit>>,
+
+    /// The tooltip text when you hover over this item.
+    ///
+    /// Depending on the client capability `inlayHint.resolveSupport` clients
+    /// might resolve this property late using the resolve request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tooltip: Option<InlayHintTooltip>,
+
+    /// Render padding before the hint.
+    ///
+    /// Note: Padding should use the editor's background color, not the
+    /// background color of the hint itself. That means padding can be used
+    /// to visually align/separate an inlay hint.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub padding_left: Option<bool>,
+
+    /// Render padding after the hint.
+    ///
+    /// Note: Padding should use the editor's background color, not the
+    /// background color of the hint itself. That means padding can be used
+    /// to visually align/separate an inlay hint.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub padding_right: Option<bool>,
+
+    /// A data entry field that is preserved on a inlay hint between
+    /// a `textDocument/inlayHint` and a `inlayHint/resolve` request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data: Option<LSPAny>,
+}
+
+#[derive(Debug, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum InlayHintLabel {
+    String(String),
+    LabelParts(Vec<InlayHintLabelPart>),
+}
+
+impl From<String> for InlayHintLabel {
+    #[inline]
+    fn from(from: String) -> Self {
+        Self::String(from)
+    }
+}
+
+impl From<Vec<InlayHintLabelPart>> for InlayHintLabel {
+    #[inline]
+    fn from(from: Vec<InlayHintLabelPart>) -> Self {
+        Self::LabelParts(from)
+    }
+}
+
+#[derive(Debug, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum InlayHintTooltip {
+    String(String),
+    MarkupContent(MarkupContent),
+}
+
+impl From<String> for InlayHintTooltip {
+    #[inline]
+    fn from(from: String) -> Self {
+        Self::String(from)
+    }
+}
+
+impl From<MarkupContent> for InlayHintTooltip {
+    #[inline]
+    fn from(from: MarkupContent) -> Self {
+        Self::MarkupContent(from)
+    }
+}
+
+/// An inlay hint label part allows for interactive and composite labels
+/// of inlay hints.
+#[derive(Debug, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlayHintLabelPart {
+    /// The value of this label part.
+    pub value: String,
+
+    /// The tooltip text when you hover over this label part. Depending on
+    /// the client capability `inlayHint.resolveSupport` clients might resolve
+    /// this property late using the resolve request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tooltip: Option<InlayHintLabelPartTooltip>,
+
+    /// An optional source code location that represents this
+    /// label part.
+    ///
+    /// The editor will use this location for the hover and for code navigation
+    /// features: This part will become a clickable link that resolves to the
+    /// definition of the symbol at the given location (not necessarily the
+    /// location itself), it shows the hover that shows at the given location,
+    /// and it shows a context menu with further code navigation commands.
+    ///
+    /// Depending on the client capability `inlayHint.resolveSupport` clients
+    /// might resolve this property late using the resolve request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub location: Option<Location>,
+
+    /// An optional command for this label part.
+    ///
+    /// Depending on the client capability `inlayHint.resolveSupport` clients
+    /// might resolve this property late using the resolve request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub command: Option<Command>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum InlayHintLabelPartTooltip {
+    String(String),
+    MarkupContent(MarkupContent),
+}
+
+impl From<String> for InlayHintLabelPartTooltip {
+    #[inline]
+    fn from(from: String) -> Self {
+        Self::String(from)
+    }
+}
+
+impl From<MarkupContent> for InlayHintLabelPartTooltip {
+    #[inline]
+    fn from(from: MarkupContent) -> Self {
+        Self::MarkupContent(from)
+    }
+}
+
+/// Inlay hint kinds.
+///
+/// @since 3.17.0
+#[derive(Eq, PartialEq, Copy, Clone, Serialize, Deserialize)]
+#[serde(transparent)]
+pub struct InlayHintKind(i32);
+lsp_enum! {
+impl InlayHintKind {
+    /// An inlay hint that for a type annotation.
+    pub const TYPE: InlayHintKind = InlayHintKind(1);
+
+    /// An inlay hint that is for a parameter.
+    pub const PARAMETER: InlayHintKind = InlayHintKind(2);
+}
+}
+
+/// Inlay hint client capabilities.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlayHintResolveClientCapabilities {
+    /// The properties that a client can resolve lazily.
+    pub properties: Vec<String>,
+}
+
+/// Client workspace capabilities specific to inlay hints.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlayHintWorkspaceClientCapabilities {
+    /// Whether the client implementation supports a refresh request sent from
+    /// the server to the client.
+    ///
+    /// Note that this event is global and will force the client to refresh all
+    /// inlay hints currently shown. It should be used with absolute care and
+    /// is useful for situation where a server for example detects a project wide
+    /// change that requires such a calculation.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub refresh_support: Option<bool>,
+}
+
+// TODO(sno2): add tests once stabilized
diff --git a/crates/lsp-types/src/inline_completion.rs b/crates/lsp-types/src/inline_completion.rs
new file mode 100644
index 000000000..8289858ad
--- /dev/null
+++ b/crates/lsp-types/src/inline_completion.rs
@@ -0,0 +1,162 @@
+use crate::{
+    Command, InsertTextFormat, Range, StaticRegistrationOptions, TextDocumentPositionParams,
+    TextDocumentRegistrationOptions, WorkDoneProgressOptions, WorkDoneProgressParams,
+};
+use serde::{Deserialize, Serialize};
+
+/// Client capabilities specific to inline completions.
+///
+/// @since 3.18.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlineCompletionClientCapabilities {
+    /// Whether implementation supports dynamic registration for inline completion providers.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+}
+
+/// Inline completion options used during static registration.
+///
+/// @since 3.18.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct InlineCompletionOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+/// Inline completion options used during static or dynamic registration.
+///
+// @since 3.18.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct InlineCompletionRegistrationOptions {
+    #[serde(flatten)]
+    pub inline_completion_options: InlineCompletionOptions,
+
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub static_registration_options: StaticRegistrationOptions,
+}
+
+/// A parameter literal used in inline completion requests.
+///
+/// @since 3.18.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlineCompletionParams {
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub text_document_position: TextDocumentPositionParams,
+
+    /// Additional information about the context in which inline completions were requested.
+    pub context: InlineCompletionContext,
+}
+
+/// Describes how an [`InlineCompletionItemProvider`] was triggered.
+///
+/// @since 3.18.0
+#[derive(Eq, PartialEq, Clone, Copy, Deserialize, Serialize)]
+pub struct InlineCompletionTriggerKind(i32);
+lsp_enum! {
+impl InlineCompletionTriggerKind {
+    /// Completion was triggered explicitly by a user gesture.
+    /// Return multiple completion items to enable cycling through them.
+    pub const Invoked: InlineCompletionTriggerKind = InlineCompletionTriggerKind(1);
+
+    /// Completion was triggered automatically while editing.
+    /// It is sufficient to return a single completion item in this case.
+    pub const Automatic: InlineCompletionTriggerKind = InlineCompletionTriggerKind(2);
+}
+}
+
+/// Describes the currently selected completion item.
+///
+/// @since 3.18.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct SelectedCompletionInfo {
+    /// The range that will be replaced if this completion item is accepted.
+    pub range: Range,
+    /// The text the range will be replaced with if this completion is
+    /// accepted.
+    pub text: String,
+}
+
+/// Provides information about the context in which an inline completion was
+/// requested.
+///
+/// @since 3.18.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlineCompletionContext {
+    /// Describes how the inline completion was triggered.
+    pub trigger_kind: InlineCompletionTriggerKind,
+    /// Provides information about the currently selected item in the
+    /// autocomplete widget if it is visible.
+    ///
+    /// If set, provided inline completions must extend the text of the
+    /// selected item and use the same range, otherwise they are not shown as
+    /// preview.
+    /// As an example, if the document text is `console.` and the selected item
+    /// is `.log` replacing the `.` in the document, the inline completion must
+    /// also replace `.` and start with `.log`, for example `.log()`.
+    ///
+    /// Inline completion providers are requested again whenever the selected
+    /// item changes.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub selected_completion_info: Option<SelectedCompletionInfo>,
+}
+
+/// InlineCompletion response can be multiple completion items, or a list of completion items
+#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
+#[serde(untagged)]
+pub enum InlineCompletionResponse {
+    Array(Vec<InlineCompletionItem>),
+    List(InlineCompletionList),
+}
+
+/// Represents a collection of [`InlineCompletionItem`] to be presented in the editor.
+///
+/// @since 3.18.0
+#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
+pub struct InlineCompletionList {
+    /// The inline completion items
+    pub items: Vec<InlineCompletionItem>,
+}
+
+/// An inline completion item represents a text snippet that is proposed inline
+/// to complete text that is being typed.
+///
+/// @since 3.18.0
+#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlineCompletionItem {
+    /// The text to replace the range with. Must be set.
+    /// Is used both for the preview and the accept operation.
+    pub insert_text: String,
+    /// A text that is used to decide if this inline completion should be
+    /// shown. When `falsy` the [`InlineCompletionItem::insertText`] is
+    /// used.
+    ///
+    /// An inline completion is shown if the text to replace is a prefix of the
+    /// filter text.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub filter_text: Option<String>,
+    /// The range to replace.
+    /// Must begin and end on the same line.
+    ///
+    /// Prefer replacements over insertions to provide a better experience when
+    /// the user deletes typed text.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub range: Option<Range>,
+    /// An optional command that is executed *after* inserting this
+    /// completion.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub command: Option<Command>,
+    /// The format of the insert text. The format applies to the `insertText`.
+    /// If omitted defaults to `InsertTextFormat.PlainText`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub insert_text_format: Option<InsertTextFormat>,
+}
diff --git a/crates/lsp-types/src/inline_value.rs b/crates/lsp-types/src/inline_value.rs
new file mode 100644
index 000000000..dd29fbbf9
--- /dev/null
+++ b/crates/lsp-types/src/inline_value.rs
@@ -0,0 +1,217 @@
+use crate::{
+    DynamicRegistrationClientCapabilities, Range, StaticRegistrationOptions,
+    TextDocumentIdentifier, TextDocumentRegistrationOptions, WorkDoneProgressOptions,
+    WorkDoneProgressParams,
+};
+use serde::{Deserialize, Serialize};
+
+pub type InlineValueClientCapabilities = DynamicRegistrationClientCapabilities;
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum InlineValueServerCapabilities {
+    Options(InlineValueOptions),
+    RegistrationOptions(InlineValueRegistrationOptions),
+}
+
+/// Inline value options used during static registration.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct InlineValueOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+/// Inline value options used during static or dynamic registration.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct InlineValueRegistrationOptions {
+    #[serde(flatten)]
+    pub inline_value_options: InlineValueOptions,
+
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub static_registration_options: StaticRegistrationOptions,
+}
+
+/// A parameter literal used in inline value requests.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlineValueParams {
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The document range for which inline values should be computed.
+    pub range: Range,
+
+    /// Additional information about the context in which inline values were
+    /// requested.
+    pub context: InlineValueContext,
+}
+
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlineValueContext {
+    /// The stack frame (as a DAP Id) where the execution has stopped.
+    pub frame_id: i32,
+
+    /// The document range where execution has stopped.
+    /// Typically the end position of the range denotes the line where the
+    /// inline values are shown.
+    pub stopped_location: Range,
+}
+
+/// Provide inline value as text.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct InlineValueText {
+    /// The document range for which the inline value applies.
+    pub range: Range,
+
+    /// The text of the inline value.
+    pub text: String,
+}
+
+/// Provide inline value through a variable lookup.
+///
+/// If only a range is specified, the variable name will be extracted from
+/// the underlying document.
+///
+/// An optional variable name can be used to override the extracted name.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlineValueVariableLookup {
+    /// The document range for which the inline value applies.
+    /// The range is used to extract the variable name from the underlying
+    /// document.
+    pub range: Range,
+
+    /// If specified the name of the variable to look up.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub variable_name: Option<String>,
+
+    /// How to perform the lookup.
+    pub case_sensitive_lookup: bool,
+}
+
+/// Provide an inline value through an expression evaluation.
+///
+/// If only a range is specified, the expression will be extracted from the
+/// underlying document.
+///
+/// An optional expression can be used to override the extracted expression.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InlineValueEvaluatableExpression {
+    /// The document range for which the inline value applies.
+    /// The range is used to extract the evaluatable expression from the
+    /// underlying document.
+    pub range: Range,
+
+    /// If specified the expression overrides the extracted expression.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub expression: Option<String>,
+}
+
+/// Inline value information can be provided by different means:
+/// - directly as a text value (class InlineValueText).
+/// - as a name to use for a variable lookup (class InlineValueVariableLookup)
+/// - as an evaluatable expression (class InlineValueEvaluatableExpression)
+/// The InlineValue types combines all inline value types into one type.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum InlineValue {
+    Text(InlineValueText),
+    VariableLookup(InlineValueVariableLookup),
+    EvaluatableExpression(InlineValueEvaluatableExpression),
+}
+
+impl From<InlineValueText> for InlineValue {
+    #[inline]
+    fn from(from: InlineValueText) -> Self {
+        Self::Text(from)
+    }
+}
+
+impl From<InlineValueVariableLookup> for InlineValue {
+    #[inline]
+    fn from(from: InlineValueVariableLookup) -> Self {
+        Self::VariableLookup(from)
+    }
+}
+
+impl From<InlineValueEvaluatableExpression> for InlineValue {
+    #[inline]
+    fn from(from: InlineValueEvaluatableExpression) -> Self {
+        Self::EvaluatableExpression(from)
+    }
+}
+
+/// Client workspace capabilities specific to inline values.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+///
+/// @since 3.17.0
+#[serde(rename_all = "camelCase")]
+pub struct InlineValueWorkspaceClientCapabilities {
+    /// Whether the client implementation supports a refresh request sent from
+    /// the server to the client.
+    ///
+    /// Note that this event is global and will force the client to refresh all
+    /// inline values currently shown. It should be used with absolute care and
+    /// is useful for situation where a server for example detect a project wide
+    /// change that requires such a calculation.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub refresh_support: Option<bool>,
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::tests::test_serialization;
+    use crate::Position;
+
+    #[test]
+    fn inline_values() {
+        test_serialization(
+            &InlineValueText {
+                range: Range::new(Position::new(0, 0), Position::new(0, 4)),
+                text: "one".to_owned(),
+            },
+            r#"{"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":4}},"text":"one"}"#,
+        );
+
+        test_serialization(
+            &InlineValue::VariableLookup(InlineValueVariableLookup {
+                range: Range::new(Position::new(1, 0), Position::new(1, 4)),
+                variable_name: None,
+                case_sensitive_lookup: false,
+            }),
+            r#"{"range":{"start":{"line":1,"character":0},"end":{"line":1,"character":4}},"caseSensitiveLookup":false}"#,
+        );
+
+        test_serialization(
+            &InlineValue::EvaluatableExpression(InlineValueEvaluatableExpression {
+                range: Range::new(Position::new(2, 0), Position::new(2, 4)),
+                expression: None,
+            }),
+            r#"{"range":{"start":{"line":2,"character":0},"end":{"line":2,"character":4}}}"#,
+        );
+    }
+}
diff --git a/crates/lsp-types/src/lib.rs b/crates/lsp-types/src/lib.rs
new file mode 100644
index 000000000..ed85a86be
--- /dev/null
+++ b/crates/lsp-types/src/lib.rs
@@ -0,0 +1,2896 @@
+/*!
+
+Language Server Protocol types for Rust.
+
+Based on: <https://microsoft.github.io/language-server-protocol/specification>
+
+This library uses the URL crate for parsing URIs.  Note that there is
+some confusion on the meaning of URLs vs URIs:
+<http://stackoverflow.com/a/28865728/393898>.  According to that
+information, on the classical sense of "URLs", "URLs" are a subset of
+URIs, But on the modern/new meaning of URLs, they are the same as
+URIs.  The important take-away aspect is that the URL crate should be
+able to parse any URI, such as `urn:isbn:0451450523`.
+
+
+*/
+#![allow(non_upper_case_globals)]
+#![forbid(unsafe_code)]
+#[macro_use]
+extern crate bitflags;
+
+use std::{collections::HashMap, fmt::Debug};
+
+use serde::{de, de::Error as Error_, Deserialize, Serialize};
+use serde_json::Value;
+pub use url::Url;
+
+// Large enough to contain any enumeration name defined in this crate
+type PascalCaseBuf = [u8; 32];
+const fn fmt_pascal_case_const(name: &str) -> (PascalCaseBuf, usize) {
+    let mut buf = [0; 32];
+    let mut buf_i = 0;
+    let mut name_i = 0;
+    let name = name.as_bytes();
+    while name_i < name.len() {
+        let first = name[name_i];
+        name_i += 1;
+
+        buf[buf_i] = first;
+        buf_i += 1;
+
+        while name_i < name.len() {
+            let rest = name[name_i];
+            name_i += 1;
+            if rest == b'_' {
+                break;
+            }
+
+            buf[buf_i] = rest.to_ascii_lowercase();
+            buf_i += 1;
+        }
+    }
+    (buf, buf_i)
+}
+
+fn fmt_pascal_case(f: &mut std::fmt::Formatter<'_>, name: &str) -> std::fmt::Result {
+    for word in name.split('_') {
+        let mut chars = word.chars();
+        let first = chars.next().unwrap();
+        write!(f, "{}", first)?;
+        for rest in chars {
+            write!(f, "{}", rest.to_lowercase())?;
+        }
+    }
+    Ok(())
+}
+
+macro_rules! lsp_enum {
+    (impl $typ: ident { $( $(#[$attr:meta])* pub const $name: ident : $enum_type: ty = $value: expr; )* }) => {
+        impl $typ {
+            $(
+            $(#[$attr])*
+            pub const $name: $enum_type = $value;
+            )*
+        }
+
+        impl std::fmt::Debug for $typ {
+            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+                match *self {
+                    $(
+                    Self::$name => crate::fmt_pascal_case(f, stringify!($name)),
+                    )*
+                    _ => write!(f, "{}({})", stringify!($typ), self.0),
+                }
+            }
+        }
+
+        impl std::convert::TryFrom<&str> for $typ {
+            type Error = &'static str;
+            fn try_from(value: &str) -> Result<Self, Self::Error> {
+                match () {
+                    $(
+                        _ if {
+                            const X: (crate::PascalCaseBuf, usize) = crate::fmt_pascal_case_const(stringify!($name));
+                            let (buf, len) = X;
+                            &buf[..len] == value.as_bytes()
+                        } => Ok(Self::$name),
+                    )*
+                    _ => Err("unknown enum variant"),
+                }
+            }
+        }
+
+    }
+}
+
+pub mod error_codes;
+pub mod notification;
+pub mod request;
+
+mod call_hierarchy;
+pub use call_hierarchy::*;
+
+mod code_action;
+pub use code_action::*;
+
+mod code_lens;
+pub use code_lens::*;
+
+mod color;
+pub use color::*;
+
+mod completion;
+pub use completion::*;
+
+mod document_diagnostic;
+pub use document_diagnostic::*;
+
+mod document_highlight;
+pub use document_highlight::*;
+
+mod document_link;
+pub use document_link::*;
+
+mod document_symbols;
+pub use document_symbols::*;
+
+mod notebook;
+pub use notebook::*;
+
+mod file_operations;
+pub use file_operations::*;
+
+mod folding_range;
+pub use folding_range::*;
+
+mod formatting;
+pub use formatting::*;
+
+mod hover;
+pub use hover::*;
+
+mod inlay_hint;
+pub use inlay_hint::*;
+
+mod inline_value;
+pub use inline_value::*;
+
+#[cfg(feature = "proposed")]
+mod inline_completion;
+#[cfg(feature = "proposed")]
+pub use inline_completion::*;
+
+mod moniker;
+pub use moniker::*;
+
+mod progress;
+pub use progress::*;
+
+mod references;
+pub use references::*;
+
+mod rename;
+pub use rename::*;
+
+pub mod selection_range;
+pub use selection_range::*;
+
+mod semantic_tokens;
+pub use semantic_tokens::*;
+
+mod signature_help;
+pub use signature_help::*;
+
+mod type_hierarchy;
+pub use type_hierarchy::*;
+
+mod linked_editing;
+pub use linked_editing::*;
+
+mod window;
+pub use window::*;
+
+mod workspace_diagnostic;
+pub use workspace_diagnostic::*;
+
+mod workspace_folders;
+pub use workspace_folders::*;
+
+mod workspace_symbols;
+pub use workspace_symbols::*;
+
+pub mod lsif;
+
+mod trace;
+pub use trace::*;
+
+/* ----------------- Auxiliary types ----------------- */
+
+#[derive(Debug, Eq, Hash, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum NumberOrString {
+    Number(i32),
+    String(String),
+}
+
+/* ----------------- Cancel support ----------------- */
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct CancelParams {
+    /// The request id to cancel.
+    pub id: NumberOrString,
+}
+
+/* ----------------- Basic JSON Structures ----------------- */
+
+/// The LSP any type
+///
+/// @since 3.17.0
+pub type LSPAny = serde_json::Value;
+
+/// LSP object definition.
+///
+/// @since 3.17.0
+pub type LSPObject = serde_json::Map<String, serde_json::Value>;
+
+/// LSP arrays.
+///
+/// @since 3.17.0
+pub type LSPArray = Vec<serde_json::Value>;
+
+/// Position in a text document expressed as zero-based line and character offset.
+/// A position is between two characters like an 'insert' cursor in a editor.
+#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Copy, Clone, Default, Deserialize, Serialize, Hash)]
+pub struct Position {
+    /// Line position in a document (zero-based).
+    pub line: u32,
+    /// Character offset on a line in a document (zero-based). The meaning of this
+    /// offset is determined by the negotiated `PositionEncodingKind`.
+    ///
+    /// If the character value is greater than the line length it defaults back
+    /// to the line length.
+    pub character: u32,
+}
+
+impl Position {
+    pub fn new(line: u32, character: u32) -> Position {
+        Position { line, character }
+    }
+}
+
+/// A range in a text document expressed as (zero-based) start and end positions.
+/// A range is comparable to a selection in an editor. Therefore the end position is exclusive.
+#[derive(Debug, Eq, PartialEq, Copy, Clone, Default, Deserialize, Serialize, Hash)]
+pub struct Range {
+    /// The range's start position.
+    pub start: Position,
+    /// The range's end position.
+    pub end: Position,
+}
+
+impl Range {
+    pub fn new(start: Position, end: Position) -> Range {
+        Range { start, end }
+    }
+}
+
+/// Represents a location inside a resource, such as a line inside a text file.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize, Hash)]
+pub struct Location {
+    pub uri: Url,
+    pub range: Range,
+}
+
+impl Location {
+    pub fn new(uri: Url, range: Range) -> Location {
+        Location { uri, range }
+    }
+}
+
+/// Represents a link between a source and a target location.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct LocationLink {
+    /// Span of the origin of this link.
+    ///
+    /// Used as the underlined span for mouse interaction. Defaults to the word range at
+    /// the mouse position.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub origin_selection_range: Option<Range>,
+
+    /// The target resource identifier of this link.
+    pub target_uri: Url,
+
+    /// The full target range of this link.
+    pub target_range: Range,
+
+    /// The span of this link.
+    pub target_selection_range: Range,
+}
+
+/// A type indicating how positions are encoded,
+/// specifically what column offsets mean.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Hash, PartialOrd, Clone, Deserialize, Serialize)]
+pub struct PositionEncodingKind(std::borrow::Cow<'static, str>);
+
+impl PositionEncodingKind {
+    /// Character offsets count UTF-8 code units.
+    pub const UTF8: PositionEncodingKind = PositionEncodingKind::new("utf-8");
+
+    /// Character offsets count UTF-16 code units.
+    ///
+    /// This is the default and must always be supported
+    /// by servers
+    pub const UTF16: PositionEncodingKind = PositionEncodingKind::new("utf-16");
+
+    /// Character offsets count UTF-32 code units.
+    ///
+    /// Implementation note: these are the same as Unicode code points,
+    /// so this `PositionEncodingKind` may also be used for an
+    /// encoding-agnostic representation of character offsets.
+    pub const UTF32: PositionEncodingKind = PositionEncodingKind::new("utf-32");
+
+    pub const fn new(tag: &'static str) -> Self {
+        PositionEncodingKind(std::borrow::Cow::Borrowed(tag))
+    }
+
+    pub fn as_str(&self) -> &str {
+        &self.0
+    }
+}
+
+impl From<String> for PositionEncodingKind {
+    fn from(from: String) -> Self {
+        PositionEncodingKind(std::borrow::Cow::from(from))
+    }
+}
+
+impl From<&'static str> for PositionEncodingKind {
+    fn from(from: &'static str) -> Self {
+        PositionEncodingKind::new(from)
+    }
+}
+
+/// Represents a diagnostic, such as a compiler error or warning.
+/// Diagnostic objects are only valid in the scope of a resource.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Diagnostic {
+    /// The range at which the message applies.
+    pub range: Range,
+
+    /// The diagnostic's severity. Can be omitted. If omitted it is up to the
+    /// client to interpret diagnostics as error, warning, info or hint.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub severity: Option<DiagnosticSeverity>,
+
+    /// The diagnostic's code. Can be omitted.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code: Option<NumberOrString>,
+
+    /// An optional property to describe the error code.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code_description: Option<CodeDescription>,
+
+    /// A human-readable string describing the source of this
+    /// diagnostic, e.g. 'typescript' or 'super lint'.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub source: Option<String>,
+
+    /// The diagnostic's message.
+    pub message: String,
+
+    /// An array of related diagnostic information, e.g. when symbol-names within
+    /// a scope collide all definitions can be marked via this property.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub related_information: Option<Vec<DiagnosticRelatedInformation>>,
+
+    /// Additional metadata about the diagnostic.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tags: Option<Vec<DiagnosticTag>>,
+
+    /// A data entry field that is preserved between a `textDocument/publishDiagnostics`
+    /// notification and `textDocument/codeAction` request.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data: Option<serde_json::Value>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CodeDescription {
+    pub href: Url,
+}
+
+impl Diagnostic {
+    pub fn new(
+        range: Range,
+        severity: Option<DiagnosticSeverity>,
+        code: Option<NumberOrString>,
+        source: Option<String>,
+        message: String,
+        related_information: Option<Vec<DiagnosticRelatedInformation>>,
+        tags: Option<Vec<DiagnosticTag>>,
+    ) -> Diagnostic {
+        Diagnostic {
+            range,
+            severity,
+            code,
+            source,
+            message,
+            related_information,
+            tags,
+            ..Diagnostic::default()
+        }
+    }
+
+    pub fn new_simple(range: Range, message: String) -> Diagnostic {
+        Self::new(range, None, None, None, message, None, None)
+    }
+
+    pub fn new_with_code_number(
+        range: Range,
+        severity: DiagnosticSeverity,
+        code_number: i32,
+        source: Option<String>,
+        message: String,
+    ) -> Diagnostic {
+        let code = Some(NumberOrString::Number(code_number));
+        Self::new(range, Some(severity), code, source, message, None, None)
+    }
+}
+
+/// The protocol currently supports the following diagnostic severities:
+#[derive(Eq, PartialEq, Ord, PartialOrd, Clone, Copy, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct DiagnosticSeverity(i32);
+lsp_enum! {
+impl DiagnosticSeverity {
+    /// Reports an error.
+    pub const ERROR: DiagnosticSeverity = DiagnosticSeverity(1);
+    /// Reports a warning.
+    pub const WARNING: DiagnosticSeverity = DiagnosticSeverity(2);
+    /// Reports an information.
+    pub const INFORMATION: DiagnosticSeverity = DiagnosticSeverity(3);
+    /// Reports a hint.
+    pub const HINT: DiagnosticSeverity = DiagnosticSeverity(4);
+}
+}
+
+/// Represents a related message and source code location for a diagnostic. This
+/// should be used to point to code locations that cause or related to a
+/// diagnostics, e.g when duplicating a symbol in a scope.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct DiagnosticRelatedInformation {
+    /// The location of this related diagnostic information.
+    pub location: Location,
+
+    /// The message of this related diagnostic information.
+    pub message: String,
+}
+
+/// The diagnostic tags.
+#[derive(Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct DiagnosticTag(i32);
+lsp_enum! {
+impl DiagnosticTag {
+    /// Unused or unnecessary code.
+    /// Clients are allowed to render diagnostics with this tag faded out instead of having
+    /// an error squiggle.
+    pub const UNNECESSARY: DiagnosticTag = DiagnosticTag(1);
+
+    /// Deprecated or obsolete code.
+    /// Clients are allowed to rendered diagnostics with this tag strike through.
+    pub const DEPRECATED: DiagnosticTag = DiagnosticTag(2);
+}
+}
+
+/// Represents a reference to a command. Provides a title which will be used to represent a command in the UI.
+/// Commands are identified by a string identifier. The recommended way to handle commands is to implement
+/// their execution on the server side if the client and server provides the corresponding capabilities.
+/// Alternatively the tool extension code could handle the command.
+/// The protocol currently doesnt specify a set of well-known commands.
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct Command {
+    /// Title of the command, like `save`.
+    pub title: String,
+    /// The identifier of the actual command handler.
+    pub command: String,
+    /// Arguments that the command handler should be
+    /// invoked with.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub arguments: Option<Vec<Value>>,
+}
+
+impl Command {
+    pub fn new(title: String, command: String, arguments: Option<Vec<Value>>) -> Command {
+        Command {
+            title,
+            command,
+            arguments,
+        }
+    }
+}
+
+/// A textual edit applicable to a text document.
+///
+/// If n `TextEdit`s are applied to a text document all text edits describe changes to the initial document version.
+/// Execution wise text edits should applied from the bottom to the top of the text document. Overlapping text edits
+/// are not supported.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextEdit {
+    /// The range of the text document to be manipulated. To insert
+    /// text into a document create a range where start === end.
+    pub range: Range,
+    /// The string to be inserted. For delete operations use an
+    /// empty string.
+    pub new_text: String,
+}
+
+impl TextEdit {
+    pub fn new(range: Range, new_text: String) -> TextEdit {
+        TextEdit { range, new_text }
+    }
+}
+
+/// An identifier referring to a change annotation managed by a workspace
+/// edit.
+///
+/// @since 3.16.0
+pub type ChangeAnnotationIdentifier = String;
+
+/// A special text edit with an additional change annotation.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct AnnotatedTextEdit {
+    #[serde(flatten)]
+    pub text_edit: TextEdit,
+
+    /// The actual annotation
+    pub annotation_id: ChangeAnnotationIdentifier,
+}
+
+/// Describes textual changes on a single text document. The text document is referred to as a
+/// `OptionalVersionedTextDocumentIdentifier` to allow clients to check the text document version before an
+/// edit is applied. A `TextDocumentEdit` describes all changes on a version Si and after they are
+/// applied move the document to version Si+1. So the creator of a `TextDocumentEdit` doesn't need to
+/// sort the array or do any kind of ordering. However the edits must be non overlapping.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentEdit {
+    /// The text document to change.
+    pub text_document: OptionalVersionedTextDocumentIdentifier,
+
+    /// The edits to be applied.
+    ///
+    /// @since 3.16.0 - support for AnnotatedTextEdit. This is guarded by the
+    /// client capability `workspace.workspaceEdit.changeAnnotationSupport`
+    pub edits: Vec<OneOf<TextEdit, AnnotatedTextEdit>>,
+}
+
+/// Additional information that describes document changes.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ChangeAnnotation {
+    /// A human-readable string describing the actual change. The string
+    /// is rendered prominent in the user interface.
+    pub label: String,
+
+    /// A flag which indicates that user confirmation is needed
+    /// before applying the change.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub needs_confirmation: Option<bool>,
+
+    /// A human-readable string which is rendered less prominent in
+    /// the user interface.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub description: Option<String>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ChangeAnnotationWorkspaceEditClientCapabilities {
+    /// Whether the client groups edits with equal labels into tree nodes,
+    /// for instance all edits labelled with "Changes in Strings" would
+    /// be a tree node.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub groups_on_label: Option<bool>,
+}
+
+/// Options to create a file.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CreateFileOptions {
+    /// Overwrite existing file. Overwrite wins over `ignoreIfExists`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub overwrite: Option<bool>,
+    /// Ignore if exists.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub ignore_if_exists: Option<bool>,
+}
+
+/// Create file operation
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct CreateFile {
+    /// The resource to create.
+    pub uri: Url,
+    /// Additional options
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub options: Option<CreateFileOptions>,
+
+    /// An optional annotation identifier describing the operation.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub annotation_id: Option<ChangeAnnotationIdentifier>,
+}
+
+/// Rename file options
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RenameFileOptions {
+    /// Overwrite target if existing. Overwrite wins over `ignoreIfExists`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub overwrite: Option<bool>,
+    /// Ignores if target exists.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub ignore_if_exists: Option<bool>,
+}
+
+/// Rename file operation
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RenameFile {
+    /// The old (existing) location.
+    pub old_uri: Url,
+    /// The new location.
+    pub new_uri: Url,
+    /// Rename options.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub options: Option<RenameFileOptions>,
+
+    /// An optional annotation identifier describing the operation.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub annotation_id: Option<ChangeAnnotationIdentifier>,
+}
+
+/// Delete file options
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DeleteFileOptions {
+    /// Delete the content recursively if a folder is denoted.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub recursive: Option<bool>,
+    /// Ignore the operation if the file doesn't exist.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub ignore_if_not_exists: Option<bool>,
+
+    /// An optional annotation identifier describing the operation.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub annotation_id: Option<ChangeAnnotationIdentifier>,
+}
+
+/// Delete file operation
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DeleteFile {
+    /// The file to delete.
+    pub uri: Url,
+    /// Delete options.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub options: Option<DeleteFileOptions>,
+}
+
+/// A workspace edit represents changes to many resources managed in the workspace.
+/// The edit should either provide `changes` or `documentChanges`.
+/// If the client can handle versioned document edits and if `documentChanges` are present,
+/// the latter are preferred over `changes`.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceEdit {
+    /// Holds changes to existing resources.
+    #[serde(with = "url_map")]
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[serde(default)]
+    pub changes: Option<HashMap<Url, Vec<TextEdit>>>, //    changes?: { [uri: string]: TextEdit[]; };
+
+    /// Depending on the client capability `workspace.workspaceEdit.resourceOperations` document changes
+    /// are either an array of `TextDocumentEdit`s to express changes to n different text documents
+    /// where each text document edit addresses a specific version of a text document. Or it can contain
+    /// above `TextDocumentEdit`s mixed with create, rename and delete file / folder operations.
+    ///
+    /// Whether a client supports versioned document edits is expressed via
+    /// `workspace.workspaceEdit.documentChanges` client capability.
+    ///
+    /// If a client neither supports `documentChanges` nor `workspace.workspaceEdit.resourceOperations` then
+    /// only plain `TextEdit`s using the `changes` property are supported.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_changes: Option<DocumentChanges>,
+
+    /// A map of change annotations that can be referenced in
+    /// `AnnotatedTextEdit`s or create, rename and delete file / folder
+    /// operations.
+    ///
+    /// Whether clients honor this property depends on the client capability
+    /// `workspace.changeAnnotationSupport`.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub change_annotations: Option<HashMap<ChangeAnnotationIdentifier, ChangeAnnotation>>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum DocumentChanges {
+    Edits(Vec<TextDocumentEdit>),
+    Operations(Vec<DocumentChangeOperation>),
+}
+
+// TODO: Once https://github.com/serde-rs/serde/issues/912 is solved
+// we can remove ResourceOp and switch to the following implementation
+// of DocumentChangeOperation:
+//
+// #[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+// #[serde(tag = "kind", rename_all="lowercase" )]
+// pub enum DocumentChangeOperation {
+//     Create(CreateFile),
+//     Rename(RenameFile),
+//     Delete(DeleteFile),
+//
+//     #[serde(other)]
+//     Edit(TextDocumentEdit),
+// }
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged, rename_all = "lowercase")]
+pub enum DocumentChangeOperation {
+    Op(ResourceOp),
+    Edit(TextDocumentEdit),
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(tag = "kind", rename_all = "lowercase")]
+pub enum ResourceOp {
+    Create(CreateFile),
+    Rename(RenameFile),
+    Delete(DeleteFile),
+}
+
+pub type DidChangeConfigurationClientCapabilities = DynamicRegistrationClientCapabilities;
+
+#[derive(Debug, Default, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ConfigurationParams {
+    pub items: Vec<ConfigurationItem>,
+}
+
+#[derive(Debug, Default, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ConfigurationItem {
+    /// The scope to get the configuration section for.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub scope_uri: Option<Url>,
+
+    ///The configuration section asked for.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub section: Option<String>,
+}
+
+mod url_map {
+    use std::fmt;
+    use std::marker::PhantomData;
+
+    use super::*;
+
+    pub fn deserialize<'de, D, V>(deserializer: D) -> Result<Option<HashMap<Url, V>>, D::Error>
+    where
+        D: serde::Deserializer<'de>,
+        V: de::DeserializeOwned,
+    {
+        struct UrlMapVisitor<V> {
+            _marker: PhantomData<V>,
+        }
+
+        impl<V: de::DeserializeOwned> Default for UrlMapVisitor<V> {
+            fn default() -> Self {
+                UrlMapVisitor {
+                    _marker: PhantomData,
+                }
+            }
+        }
+        impl<'de, V: de::DeserializeOwned> de::Visitor<'de> for UrlMapVisitor<V> {
+            type Value = HashMap<Url, V>;
+
+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+                formatter.write_str("map")
+            }
+
+            fn visit_map<M>(self, mut visitor: M) -> Result<Self::Value, M::Error>
+            where
+                M: de::MapAccess<'de>,
+            {
+                let mut values = HashMap::with_capacity(visitor.size_hint().unwrap_or(0));
+
+                // While there are entries remaining in the input, add them
+                // into our map.
+                while let Some((key, value)) = visitor.next_entry::<Url, _>()? {
+                    values.insert(key, value);
+                }
+
+                Ok(values)
+            }
+        }
+
+        struct OptionUrlMapVisitor<V> {
+            _marker: PhantomData<V>,
+        }
+        impl<V: de::DeserializeOwned> Default for OptionUrlMapVisitor<V> {
+            fn default() -> Self {
+                OptionUrlMapVisitor {
+                    _marker: PhantomData,
+                }
+            }
+        }
+        impl<'de, V: de::DeserializeOwned> de::Visitor<'de> for OptionUrlMapVisitor<V> {
+            type Value = Option<HashMap<Url, V>>;
+
+            fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
+                formatter.write_str("option")
+            }
+
+            #[inline]
+            fn visit_unit<E>(self) -> Result<Self::Value, E>
+            where
+                E: serde::de::Error,
+            {
+                Ok(None)
+            }
+
+            #[inline]
+            fn visit_none<E>(self) -> Result<Self::Value, E>
+            where
+                E: serde::de::Error,
+            {
+                Ok(None)
+            }
+
+            #[inline]
+            fn visit_some<D>(self, deserializer: D) -> Result<Self::Value, D::Error>
+            where
+                D: serde::Deserializer<'de>,
+            {
+                deserializer
+                    .deserialize_map(UrlMapVisitor::<V>::default())
+                    .map(Some)
+            }
+        }
+
+        // Instantiate our Visitor and ask the Deserializer to drive
+        // it over the input data, resulting in an instance of MyMap.
+        deserializer.deserialize_option(OptionUrlMapVisitor::default())
+    }
+
+    pub fn serialize<S, V>(
+        changes: &Option<HashMap<Url, V>>,
+        serializer: S,
+    ) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+        V: serde::Serialize,
+    {
+        use serde::ser::SerializeMap;
+
+        match *changes {
+            Some(ref changes) => {
+                let mut map = serializer.serialize_map(Some(changes.len()))?;
+                for (k, v) in changes {
+                    map.serialize_entry(k.as_str(), v)?;
+                }
+                map.end()
+            }
+            None => serializer.serialize_none(),
+        }
+    }
+}
+
+impl WorkspaceEdit {
+    pub fn new(changes: HashMap<Url, Vec<TextEdit>>) -> WorkspaceEdit {
+        WorkspaceEdit {
+            changes: Some(changes),
+            document_changes: None,
+            ..Default::default()
+        }
+    }
+}
+
+/// Text documents are identified using a URI. On the protocol level, URIs are passed as strings.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct TextDocumentIdentifier {
+    // !!!!!! Note:
+    // In the spec VersionedTextDocumentIdentifier extends TextDocumentIdentifier
+    // This modelled by "mixing-in" TextDocumentIdentifier in VersionedTextDocumentIdentifier,
+    // so any changes to this type must be effected in the sub-type as well.
+    /// The text document's URI.
+    pub uri: Url,
+}
+
+impl TextDocumentIdentifier {
+    pub fn new(uri: Url) -> TextDocumentIdentifier {
+        TextDocumentIdentifier { uri }
+    }
+}
+
+/// An item to transfer a text document from the client to the server.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentItem {
+    /// The text document's URI.
+    pub uri: Url,
+
+    /// The text document's language identifier.
+    pub language_id: String,
+
+    /// The version number of this document (it will strictly increase after each
+    /// change, including undo/redo).
+    pub version: i32,
+
+    /// The content of the opened text document.
+    pub text: String,
+}
+
+impl TextDocumentItem {
+    pub fn new(uri: Url, language_id: String, version: i32, text: String) -> TextDocumentItem {
+        TextDocumentItem {
+            uri,
+            language_id,
+            version,
+            text,
+        }
+    }
+}
+
+/// An identifier to denote a specific version of a text document. This information usually flows from the client to the server.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct VersionedTextDocumentIdentifier {
+    // This field was "mixed-in" from TextDocumentIdentifier
+    /// The text document's URI.
+    pub uri: Url,
+
+    /// The version number of this document.
+    ///
+    /// The version number of a document will increase after each change,
+    /// including undo/redo. The number doesn't need to be consecutive.
+    pub version: i32,
+}
+
+impl VersionedTextDocumentIdentifier {
+    pub fn new(uri: Url, version: i32) -> VersionedTextDocumentIdentifier {
+        VersionedTextDocumentIdentifier { uri, version }
+    }
+}
+
+/// An identifier which optionally denotes a specific version of a text document. This information usually flows from the server to the client
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct OptionalVersionedTextDocumentIdentifier {
+    // This field was "mixed-in" from TextDocumentIdentifier
+    /// The text document's URI.
+    pub uri: Url,
+
+    /// The version number of this document. If an optional versioned text document
+    /// identifier is sent from the server to the client and the file is not
+    /// open in the editor (the server has not received an open notification
+    /// before) the server can send `null` to indicate that the version is
+    /// known and the content on disk is the master (as specified with document
+    /// content ownership).
+    ///
+    /// The version number of a document will increase after each change,
+    /// including undo/redo. The number doesn't need to be consecutive.
+    pub version: Option<i32>,
+}
+
+impl OptionalVersionedTextDocumentIdentifier {
+    pub fn new(uri: Url, version: i32) -> OptionalVersionedTextDocumentIdentifier {
+        OptionalVersionedTextDocumentIdentifier {
+            uri,
+            version: Some(version),
+        }
+    }
+}
+
+/// A parameter literal used in requests to pass a text document and a position inside that document.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentPositionParams {
+    // !!!!!! Note:
+    // In the spec ReferenceParams extends TextDocumentPositionParams
+    // This modelled by "mixing-in" TextDocumentPositionParams in ReferenceParams,
+    // so any changes to this type must be effected in sub-type as well.
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The position inside the text document.
+    pub position: Position,
+}
+
+impl TextDocumentPositionParams {
+    pub fn new(
+        text_document: TextDocumentIdentifier,
+        position: Position,
+    ) -> TextDocumentPositionParams {
+        TextDocumentPositionParams {
+            text_document,
+            position,
+        }
+    }
+}
+
+/// A document filter denotes a document through properties like language, schema or pattern.
+/// Examples are a filter that applies to TypeScript files on disk or a filter the applies to JSON
+/// files with name package.json:
+///
+/// { language: 'typescript', scheme: 'file' }
+/// { language: 'json', pattern: '**/package.json' }
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct DocumentFilter {
+    /// A language id, like `typescript`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub language: Option<String>,
+
+    /// A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub scheme: Option<String>,
+
+    /// A glob pattern, like `*.{ts,js}`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub pattern: Option<String>,
+}
+
+/// A document selector is the combination of one or many document filters.
+pub type DocumentSelector = Vec<DocumentFilter>;
+
+// ========================= Actual Protocol =========================
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize, Default)]
+#[serde(rename_all = "camelCase")]
+pub struct InitializeParams {
+    /// The process Id of the parent process that started
+    /// the server. Is null if the process has not been started by another process.
+    /// If the parent process is not alive then the server should exit (see exit notification) its process.
+    pub process_id: Option<u32>,
+
+    /// The rootPath of the workspace. Is null
+    /// if no folder is open.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[deprecated(note = "Use `root_uri` instead when possible")]
+    pub root_path: Option<String>,
+
+    /// The rootUri of the workspace. Is null if no
+    /// folder is open. If both `rootPath` and `rootUri` are set
+    /// `rootUri` wins.
+    #[serde(default)]
+    #[deprecated(note = "Use `workspace_folders` instead when possible")]
+    pub root_uri: Option<Url>,
+
+    /// User provided initialization options.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub initialization_options: Option<Value>,
+
+    /// The capabilities provided by the client (editor or tool)
+    pub capabilities: ClientCapabilities,
+
+    /// The initial trace setting. If omitted trace is disabled ('off').
+    #[serde(default)]
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub trace: Option<TraceValue>,
+
+    /// The workspace folders configured in the client when the server starts.
+    /// This property is only available if the client supports workspace folders.
+    /// It can be `null` if the client supports workspace folders but none are
+    /// configured.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub workspace_folders: Option<Vec<WorkspaceFolder>>,
+
+    /// Information about the client.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub client_info: Option<ClientInfo>,
+
+    /// The locale the client is currently showing the user interface
+    /// in. This must not necessarily be the locale of the operating
+    /// system.
+    ///
+    /// Uses IETF language tags as the value's syntax
+    /// (See <https://en.wikipedia.org/wiki/IETF_language_tag>)
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub locale: Option<String>,
+
+    /// The LSP server may report about initialization progress to the client
+    /// by using the following work done token if it was passed by the client.
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+pub struct ClientInfo {
+    /// The name of the client as defined by the client.
+    pub name: String,
+    /// The client's version as defined by the client.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub version: Option<String>,
+}
+
+#[derive(Debug, PartialEq, Clone, Copy, Deserialize, Serialize)]
+pub struct InitializedParams {}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct GenericRegistrationOptions {
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub options: GenericOptions,
+
+    #[serde(flatten)]
+    pub static_registration_options: StaticRegistrationOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct GenericOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct GenericParams {
+    #[serde(flatten)]
+    pub text_document_position_params: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Copy, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DynamicRegistrationClientCapabilities {
+    /// This capability supports dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Copy, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct GotoCapability {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// The client supports additional metadata in the form of definition links.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub link_support: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceEditClientCapabilities {
+    /// The client supports versioned document changes in `WorkspaceEdit`s
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_changes: Option<bool>,
+
+    /// The resource operations the client supports. Clients should at least
+    /// support 'create', 'rename' and 'delete' files and folders.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resource_operations: Option<Vec<ResourceOperationKind>>,
+
+    /// The failure handling strategy of a client if applying the workspace edit fails.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub failure_handling: Option<FailureHandlingKind>,
+
+    /// Whether the client normalizes line endings to the client specific
+    /// setting.
+    /// If set to `true` the client will normalize line ending characters
+    /// in a workspace edit to the client specific new line character(s).
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub normalizes_line_endings: Option<bool>,
+
+    /// Whether the client in general supports change annotations on text edits,
+    /// create file, rename file and delete file changes.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub change_annotation_support: Option<ChangeAnnotationWorkspaceEditClientCapabilities>,
+}
+
+#[derive(Debug, Eq, PartialEq, Deserialize, Serialize, Copy, Clone)]
+#[serde(rename_all = "lowercase")]
+pub enum ResourceOperationKind {
+    Create,
+    Rename,
+    Delete,
+}
+
+#[derive(Debug, Eq, PartialEq, Deserialize, Serialize, Copy, Clone)]
+#[serde(rename_all = "camelCase")]
+pub enum FailureHandlingKind {
+    Abort,
+    Transactional,
+    TextOnlyTransactional,
+    Undo,
+}
+
+/// A symbol kind.
+#[derive(Eq, PartialEq, Copy, Clone, Serialize, Deserialize)]
+#[serde(transparent)]
+pub struct SymbolKind(i32);
+lsp_enum! {
+impl SymbolKind {
+    pub const FILE: SymbolKind = SymbolKind(1);
+    pub const MODULE: SymbolKind = SymbolKind(2);
+    pub const NAMESPACE: SymbolKind = SymbolKind(3);
+    pub const PACKAGE: SymbolKind = SymbolKind(4);
+    pub const CLASS: SymbolKind = SymbolKind(5);
+    pub const METHOD: SymbolKind = SymbolKind(6);
+    pub const PROPERTY: SymbolKind = SymbolKind(7);
+    pub const FIELD: SymbolKind = SymbolKind(8);
+    pub const CONSTRUCTOR: SymbolKind = SymbolKind(9);
+    pub const ENUM: SymbolKind = SymbolKind(10);
+    pub const INTERFACE: SymbolKind = SymbolKind(11);
+    pub const FUNCTION: SymbolKind = SymbolKind(12);
+    pub const VARIABLE: SymbolKind = SymbolKind(13);
+    pub const CONSTANT: SymbolKind = SymbolKind(14);
+    pub const STRING: SymbolKind = SymbolKind(15);
+    pub const NUMBER: SymbolKind = SymbolKind(16);
+    pub const BOOLEAN: SymbolKind = SymbolKind(17);
+    pub const ARRAY: SymbolKind = SymbolKind(18);
+    pub const OBJECT: SymbolKind = SymbolKind(19);
+    pub const KEY: SymbolKind = SymbolKind(20);
+    pub const NULL: SymbolKind = SymbolKind(21);
+    pub const ENUM_MEMBER: SymbolKind = SymbolKind(22);
+    pub const STRUCT: SymbolKind = SymbolKind(23);
+    pub const EVENT: SymbolKind = SymbolKind(24);
+    pub const OPERATOR: SymbolKind = SymbolKind(25);
+    pub const TYPE_PARAMETER: SymbolKind = SymbolKind(26);
+}
+}
+
+/// Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SymbolKindCapability {
+    /// The symbol kind values the client supports. When this
+    /// property exists the client also guarantees that it will
+    /// handle values outside its set gracefully and falls back
+    /// to a default value when unknown.
+    ///
+    /// If this property is not present the client only supports
+    /// the symbol kinds from `File` to `Array` as defined in
+    /// the initial version of the protocol.
+    pub value_set: Option<Vec<SymbolKind>>,
+}
+
+/// Workspace specific client capabilities.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceClientCapabilities {
+    /// The client supports applying batch edits to the workspace by supporting
+    /// the request 'workspace/applyEdit'
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub apply_edit: Option<bool>,
+
+    /// Capabilities specific to `WorkspaceEdit`s
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub workspace_edit: Option<WorkspaceEditClientCapabilities>,
+
+    /// Capabilities specific to the `workspace/didChangeConfiguration` notification.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub did_change_configuration: Option<DidChangeConfigurationClientCapabilities>,
+
+    /// Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub did_change_watched_files: Option<DidChangeWatchedFilesClientCapabilities>,
+
+    /// Capabilities specific to the `workspace/symbol` request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub symbol: Option<WorkspaceSymbolClientCapabilities>,
+
+    /// Capabilities specific to the `workspace/executeCommand` request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub execute_command: Option<ExecuteCommandClientCapabilities>,
+
+    /// The client has support for workspace folders.
+    ///
+    /// @since 3.6.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub workspace_folders: Option<bool>,
+
+    /// The client supports `workspace/configuration` requests.
+    ///
+    /// @since 3.6.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub configuration: Option<bool>,
+
+    /// Capabilities specific to the semantic token requests scoped to the workspace.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub semantic_tokens: Option<SemanticTokensWorkspaceClientCapabilities>,
+
+    /// Capabilities specific to the code lens requests scoped to the workspace.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code_lens: Option<CodeLensWorkspaceClientCapabilities>,
+
+    /// The client has support for file requests/notifications.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub file_operations: Option<WorkspaceFileOperationsClientCapabilities>,
+
+    /// Client workspace capabilities specific to inline values.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub inline_value: Option<InlineValueWorkspaceClientCapabilities>,
+
+    /// Client workspace capabilities specific to inlay hints.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub inlay_hint: Option<InlayHintWorkspaceClientCapabilities>,
+
+    /// Client workspace capabilities specific to diagnostics.
+    /// since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub diagnostics: Option<DiagnosticWorkspaceClientCapabilities>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentSyncClientCapabilities {
+    /// Whether text document synchronization supports dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// The client supports sending will save notifications.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_save: Option<bool>,
+
+    /// The client supports sending a will save request and
+    /// waits for a response providing text edits which will
+    /// be applied to the document before it is saved.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_save_wait_until: Option<bool>,
+
+    /// The client supports did save notifications.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub did_save: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PublishDiagnosticsClientCapabilities {
+    /// Whether the clients accepts diagnostics with related information.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub related_information: Option<bool>,
+
+    /// Client supports the tag property to provide meta data about a diagnostic.
+    /// Clients supporting tags have to handle unknown tags gracefully.
+    #[serde(
+        default,
+        skip_serializing_if = "Option::is_none",
+        deserialize_with = "TagSupport::deserialize_compat"
+    )]
+    pub tag_support: Option<TagSupport<DiagnosticTag>>,
+
+    /// Whether the client interprets the version property of the
+    /// `textDocument/publishDiagnostics` notification's parameter.
+    ///
+    /// @since 3.15.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub version_support: Option<bool>,
+
+    /// Client supports a codeDescription property
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code_description_support: Option<bool>,
+
+    /// Whether code action supports the `data` property which is
+    /// preserved between a `textDocument/publishDiagnostics` and
+    /// `textDocument/codeAction` request.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data_support: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TagSupport<T> {
+    /// The tags supported by the client.
+    pub value_set: Vec<T>,
+}
+
+impl<T> TagSupport<T> {
+    /// Support for deserializing a boolean tag Support, in case it's present.
+    ///
+    /// This is currently the case for vscode 1.41.1
+    fn deserialize_compat<'de, S>(serializer: S) -> Result<Option<TagSupport<T>>, S::Error>
+    where
+        S: serde::Deserializer<'de>,
+        T: serde::Deserialize<'de>,
+    {
+        Ok(
+            match Option::<Value>::deserialize(serializer).map_err(serde::de::Error::custom)? {
+                Some(Value::Bool(false)) => None,
+                Some(Value::Bool(true)) => Some(TagSupport { value_set: vec![] }),
+                Some(other) => {
+                    Some(TagSupport::<T>::deserialize(other).map_err(serde::de::Error::custom)?)
+                }
+                None => None,
+            },
+        )
+    }
+}
+
+/// Text document specific client capabilities.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentClientCapabilities {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub synchronization: Option<TextDocumentSyncClientCapabilities>,
+    /// Capabilities specific to the `textDocument/completion`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub completion: Option<CompletionClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/hover`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub hover: Option<HoverClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/signatureHelp`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub signature_help: Option<SignatureHelpClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/references`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub references: Option<ReferenceClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/documentHighlight`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_highlight: Option<DocumentHighlightClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/documentSymbol`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_symbol: Option<DocumentSymbolClientCapabilities>,
+    /// Capabilities specific to the `textDocument/formatting`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub formatting: Option<DocumentFormattingClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/rangeFormatting`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub range_formatting: Option<DocumentRangeFormattingClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/onTypeFormatting`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub on_type_formatting: Option<DocumentOnTypeFormattingClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/declaration`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub declaration: Option<GotoCapability>,
+
+    /// Capabilities specific to the `textDocument/definition`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub definition: Option<GotoCapability>,
+
+    /// Capabilities specific to the `textDocument/typeDefinition`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub type_definition: Option<GotoCapability>,
+
+    /// Capabilities specific to the `textDocument/implementation`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub implementation: Option<GotoCapability>,
+
+    /// Capabilities specific to the `textDocument/codeAction`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code_action: Option<CodeActionClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/codeLens`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code_lens: Option<CodeLensClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/documentLink`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_link: Option<DocumentLinkClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/documentColor` and the
+    /// `textDocument/colorPresentation` request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub color_provider: Option<DocumentColorClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/rename`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub rename: Option<RenameClientCapabilities>,
+
+    /// Capabilities specific to `textDocument/publishDiagnostics`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub publish_diagnostics: Option<PublishDiagnosticsClientCapabilities>,
+
+    /// Capabilities specific to `textDocument/foldingRange` requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub folding_range: Option<FoldingRangeClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/selectionRange` request.
+    ///
+    /// @since 3.15.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub selection_range: Option<SelectionRangeClientCapabilities>,
+
+    /// Capabilities specific to `textDocument/linkedEditingRange` requests.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub linked_editing_range: Option<LinkedEditingRangeClientCapabilities>,
+
+    /// Capabilities specific to the various call hierarchy requests.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub call_hierarchy: Option<CallHierarchyClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/semanticTokens/*` requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub semantic_tokens: Option<SemanticTokensClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/moniker` request.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub moniker: Option<MonikerClientCapabilities>,
+
+    /// Capabilities specific to the various type hierarchy requests.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub type_hierarchy: Option<TypeHierarchyClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/inlineValue` request.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub inline_value: Option<InlineValueClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/inlayHint` request.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub inlay_hint: Option<InlayHintClientCapabilities>,
+
+    /// Capabilities specific to the diagnostic pull model.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub diagnostic: Option<DiagnosticClientCapabilities>,
+
+    /// Capabilities specific to the `textDocument/inlineCompletion` request.
+    ///
+    /// @since 3.18.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[cfg(feature = "proposed")]
+    pub inline_completion: Option<InlineCompletionClientCapabilities>,
+}
+
+/// Where ClientCapabilities are currently empty:
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ClientCapabilities {
+    /// Workspace specific client capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub workspace: Option<WorkspaceClientCapabilities>,
+
+    /// Text document specific client capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub text_document: Option<TextDocumentClientCapabilities>,
+
+    /// Capabilities specific to the notebook document support.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub notebook_document: Option<NotebookDocumentClientCapabilities>,
+
+    /// Window specific client capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub window: Option<WindowClientCapabilities>,
+
+    /// General client capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub general: Option<GeneralClientCapabilities>,
+
+    /// Unofficial UT8-offsets extension.
+    ///
+    /// See https://clangd.llvm.org/extensions.html#utf-8-offsets.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[cfg(feature = "proposed")]
+    pub offset_encoding: Option<Vec<String>>,
+
+    /// Experimental client capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub experimental: Option<Value>,
+}
+
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct GeneralClientCapabilities {
+    /// Client capabilities specific to regular expressions.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub regular_expressions: Option<RegularExpressionsClientCapabilities>,
+
+    /// Client capabilities specific to the client's markdown parser.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub markdown: Option<MarkdownClientCapabilities>,
+
+    /// Client capability that signals how the client handles stale requests (e.g. a request for
+    /// which the client will not process the response anymore since the information is outdated).
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub stale_request_support: Option<StaleRequestSupportClientCapabilities>,
+
+    /// The position encodings supported by the client. Client and server
+    /// have to agree on the same position encoding to ensure that offsets
+    /// (e.g. character position in a line) are interpreted the same on both
+    /// side.
+    ///
+    /// To keep the protocol backwards compatible the following applies: if
+    /// the value 'utf-16' is missing from the array of position encodings
+    /// servers can assume that the client supports UTF-16. UTF-16 is
+    /// therefore a mandatory encoding.
+    ///
+    /// If omitted it defaults to ['utf-16'].
+    ///
+    /// Implementation considerations: since the conversion from one encoding
+    /// into another requires the content of the file / line the conversion
+    /// is best done where the file is read which is usually on the server
+    /// side.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub position_encodings: Option<Vec<PositionEncodingKind>>,
+}
+
+/// Client capability that signals how the client
+/// handles stale requests (e.g. a request
+/// for which the client will not process the response
+/// anymore since the information is outdated).
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct StaleRequestSupportClientCapabilities {
+    /// The client will actively cancel the request.
+    pub cancel: bool,
+
+    /// The list of requests for which the client
+    /// will retry the request if it receives a
+    /// response with error code `ContentModified``
+    pub retry_on_content_modified: Vec<String>,
+}
+
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RegularExpressionsClientCapabilities {
+    /// The engine's name.
+    pub engine: String,
+
+    /// The engine's version
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub version: Option<String>,
+}
+
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct MarkdownClientCapabilities {
+    /// The name of the parser.
+    pub parser: String,
+
+    /// The version of the parser.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub version: Option<String>,
+
+    /// A list of HTML tags that the client allows / supports in
+    /// Markdown.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub allowed_tags: Option<Vec<String>>,
+}
+
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct InitializeResult {
+    /// The capabilities the language server provides.
+    pub capabilities: ServerCapabilities,
+
+    /// Information about the server.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub server_info: Option<ServerInfo>,
+
+    /// Unofficial UT8-offsets extension.
+    ///
+    /// See https://clangd.llvm.org/extensions.html#utf-8-offsets.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[cfg(feature = "proposed")]
+    pub offset_encoding: Option<String>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct ServerInfo {
+    /// The name of the server as defined by the server.
+    pub name: String,
+    /// The servers's version as defined by the server.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub version: Option<String>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct InitializeError {
+    /// Indicates whether the client execute the following retry logic:
+    ///
+    /// - (1) show the message provided by the ResponseError to the user
+    /// - (2) user selects retry or cancel
+    /// - (3) if user selected retry the initialize method is sent again.
+    pub retry: bool,
+}
+
+// The server can signal the following capabilities:
+
+/// Defines how the host (editor) should sync document changes to the language server.
+#[derive(Eq, PartialEq, Clone, Copy, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct TextDocumentSyncKind(i32);
+lsp_enum! {
+impl TextDocumentSyncKind {
+    /// Documents should not be synced at all.
+    pub const NONE: TextDocumentSyncKind = TextDocumentSyncKind(0);
+
+    /// Documents are synced by always sending the full content of the document.
+    pub const FULL: TextDocumentSyncKind = TextDocumentSyncKind(1);
+
+    /// Documents are synced by sending the full content on open. After that only
+    /// incremental updates to the document are sent.
+    pub const INCREMENTAL: TextDocumentSyncKind = TextDocumentSyncKind(2);
+}
+}
+
+pub type ExecuteCommandClientCapabilities = DynamicRegistrationClientCapabilities;
+
+/// Execute command options.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct ExecuteCommandOptions {
+    /// The commands to be executed on the server
+    pub commands: Vec<String>,
+
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+/// Save options.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SaveOptions {
+    /// The client is supposed to include the content on save.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub include_text: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum TextDocumentSyncSaveOptions {
+    Supported(bool),
+    SaveOptions(SaveOptions),
+}
+
+impl From<SaveOptions> for TextDocumentSyncSaveOptions {
+    fn from(from: SaveOptions) -> Self {
+        Self::SaveOptions(from)
+    }
+}
+
+impl From<bool> for TextDocumentSyncSaveOptions {
+    fn from(from: bool) -> Self {
+        Self::Supported(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentSyncOptions {
+    /// Open and close notifications are sent to the server.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub open_close: Option<bool>,
+
+    /// Change notifications are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
+    /// and TextDocumentSyncKindIncremental.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub change: Option<TextDocumentSyncKind>,
+
+    /// Will save notifications are sent to the server.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_save: Option<bool>,
+
+    /// Will save wait until requests are sent to the server.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub will_save_wait_until: Option<bool>,
+
+    /// Save notifications are sent to the server.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub save: Option<TextDocumentSyncSaveOptions>,
+}
+
+#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum OneOf<A, B> {
+    Left(A),
+    Right(B),
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum TextDocumentSyncCapability {
+    Kind(TextDocumentSyncKind),
+    Options(TextDocumentSyncOptions),
+}
+
+impl From<TextDocumentSyncOptions> for TextDocumentSyncCapability {
+    fn from(from: TextDocumentSyncOptions) -> Self {
+        Self::Options(from)
+    }
+}
+
+impl From<TextDocumentSyncKind> for TextDocumentSyncCapability {
+    fn from(from: TextDocumentSyncKind) -> Self {
+        Self::Kind(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum ImplementationProviderCapability {
+    Simple(bool),
+    Options(StaticTextDocumentRegistrationOptions),
+}
+
+impl From<StaticTextDocumentRegistrationOptions> for ImplementationProviderCapability {
+    fn from(from: StaticTextDocumentRegistrationOptions) -> Self {
+        Self::Options(from)
+    }
+}
+
+impl From<bool> for ImplementationProviderCapability {
+    fn from(from: bool) -> Self {
+        Self::Simple(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum TypeDefinitionProviderCapability {
+    Simple(bool),
+    Options(StaticTextDocumentRegistrationOptions),
+}
+
+impl From<StaticTextDocumentRegistrationOptions> for TypeDefinitionProviderCapability {
+    fn from(from: StaticTextDocumentRegistrationOptions) -> Self {
+        Self::Options(from)
+    }
+}
+
+impl From<bool> for TypeDefinitionProviderCapability {
+    fn from(from: bool) -> Self {
+        Self::Simple(from)
+    }
+}
+
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ServerCapabilities {
+    /// The position encoding the server picked from the encodings offered
+    /// by the client via the client capability `general.positionEncodings`.
+    ///
+    /// If the client didn't provide any position encodings the only valid
+    /// value that a server can return is 'utf-16'.
+    ///
+    /// If omitted it defaults to 'utf-16'.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub position_encoding: Option<PositionEncodingKind>,
+
+    /// Defines how text documents are synced.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub text_document_sync: Option<TextDocumentSyncCapability>,
+
+    /// Defines how notebook documents are synced.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub notebook_document_sync:
+        Option<OneOf<NotebookDocumentSyncOptions, NotebookDocumentSyncRegistrationOptions>>,
+
+    /// Capabilities specific to `textDocument/selectionRange` requests.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub selection_range_provider: Option<SelectionRangeProviderCapability>,
+
+    /// The server provides hover support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub hover_provider: Option<HoverProviderCapability>,
+
+    /// The server provides completion support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub completion_provider: Option<CompletionOptions>,
+
+    /// The server provides signature help support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub signature_help_provider: Option<SignatureHelpOptions>,
+
+    /// The server provides goto definition support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub definition_provider: Option<OneOf<bool, DefinitionOptions>>,
+
+    /// The server provides goto type definition support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub type_definition_provider: Option<TypeDefinitionProviderCapability>,
+
+    /// The server provides goto implementation support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub implementation_provider: Option<ImplementationProviderCapability>,
+
+    /// The server provides find references support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub references_provider: Option<OneOf<bool, ReferencesOptions>>,
+
+    /// The server provides document highlight support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_highlight_provider: Option<OneOf<bool, DocumentHighlightOptions>>,
+
+    /// The server provides document symbol support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_symbol_provider: Option<OneOf<bool, DocumentSymbolOptions>>,
+
+    /// The server provides workspace symbol support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub workspace_symbol_provider: Option<OneOf<bool, WorkspaceSymbolOptions>>,
+
+    /// The server provides code actions.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code_action_provider: Option<CodeActionProviderCapability>,
+
+    /// The server provides code lens.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub code_lens_provider: Option<CodeLensOptions>,
+
+    /// The server provides document formatting.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_formatting_provider: Option<OneOf<bool, DocumentFormattingOptions>>,
+
+    /// The server provides document range formatting.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_range_formatting_provider: Option<OneOf<bool, DocumentRangeFormattingOptions>>,
+
+    /// The server provides document formatting on typing.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_on_type_formatting_provider: Option<DocumentOnTypeFormattingOptions>,
+
+    /// The server provides rename support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub rename_provider: Option<OneOf<bool, RenameOptions>>,
+
+    /// The server provides document link support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub document_link_provider: Option<DocumentLinkOptions>,
+
+    /// The server provides color provider support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub color_provider: Option<ColorProviderCapability>,
+
+    /// The server provides folding provider support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub folding_range_provider: Option<FoldingRangeProviderCapability>,
+
+    /// The server provides go to declaration support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub declaration_provider: Option<DeclarationCapability>,
+
+    /// The server provides execute command support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub execute_command_provider: Option<ExecuteCommandOptions>,
+
+    /// Workspace specific server capabilities
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub workspace: Option<WorkspaceServerCapabilities>,
+
+    /// Call hierarchy provider capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub call_hierarchy_provider: Option<CallHierarchyServerCapability>,
+
+    /// Semantic tokens server capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub semantic_tokens_provider: Option<SemanticTokensServerCapabilities>,
+
+    /// Whether server provides moniker support.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub moniker_provider: Option<OneOf<bool, MonikerServerCapabilities>>,
+
+    /// The server provides linked editing range support.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub linked_editing_range_provider: Option<LinkedEditingRangeServerCapabilities>,
+
+    /// The server provides inline values.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub inline_value_provider: Option<OneOf<bool, InlineValueServerCapabilities>>,
+
+    /// The server provides inlay hints.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub inlay_hint_provider: Option<OneOf<bool, InlayHintServerCapabilities>>,
+
+    /// The server has support for pull model diagnostics.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub diagnostic_provider: Option<DiagnosticServerCapabilities>,
+
+    /// The server provides inline completions.
+    ///
+    /// @since 3.18.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    #[cfg(feature = "proposed")]
+    pub inline_completion_provider: Option<OneOf<bool, InlineCompletionOptions>>,
+
+    /// Experimental server capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub experimental: Option<Value>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceServerCapabilities {
+    /// The server supports workspace folder.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub workspace_folders: Option<WorkspaceFoldersServerCapabilities>,
+
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub file_operations: Option<WorkspaceFileOperationsServerCapabilities>,
+}
+
+/// General parameters to to register for a capability.
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Registration {
+    /// The id used to register the request. The id can be used to deregister
+    /// the request again.
+    pub id: String,
+
+    /// The method / capability to register for.
+    pub method: String,
+
+    /// Options necessary for the registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub register_options: Option<Value>,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+pub struct RegistrationParams {
+    pub registrations: Vec<Registration>,
+}
+
+/// Since most of the registration options require to specify a document selector there is a base
+/// interface that can be used.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentRegistrationOptions {
+    /// A document selector to identify the scope of the registration. If set to null
+    /// the document selector provided on the client side will be used.
+    pub document_selector: Option<DocumentSelector>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum DeclarationCapability {
+    Simple(bool),
+    RegistrationOptions(DeclarationRegistrationOptions),
+    Options(DeclarationOptions),
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DeclarationRegistrationOptions {
+    #[serde(flatten)]
+    pub declaration_options: DeclarationOptions,
+
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub static_registration_options: StaticRegistrationOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DeclarationOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct StaticRegistrationOptions {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub id: Option<String>,
+}
+
+#[derive(Debug, Default, Eq, PartialEq, Clone, Deserialize, Serialize, Copy)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkDoneProgressOptions {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub work_done_progress: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentFormattingOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentRangeFormattingOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DefinitionOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentSymbolOptions {
+    /// A human-readable string that is shown when multiple outlines trees are
+    /// shown for the same document.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub label: Option<String>,
+
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ReferencesOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DocumentHighlightOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceSymbolOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+
+    /// The server provides support to resolve additional
+    /// information for a workspace symbol.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_provider: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct StaticTextDocumentRegistrationOptions {
+    /// A document selector to identify the scope of the registration. If set to null
+    /// the document selector provided on the client side will be used.
+    pub document_selector: Option<DocumentSelector>,
+
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub id: Option<String>,
+}
+
+/// General parameters to unregister a capability.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct Unregistration {
+    /// The id used to unregister the request or notification. Usually an id
+    /// provided during the register request.
+    pub id: String,
+
+    /// The method / capability to unregister for.
+    pub method: String,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct UnregistrationParams {
+    pub unregisterations: Vec<Unregistration>,
+}
+
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+pub struct DidChangeConfigurationParams {
+    /// The actual changed settings
+    pub settings: Value,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DidOpenTextDocumentParams {
+    /// The document that was opened.
+    pub text_document: TextDocumentItem,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DidChangeTextDocumentParams {
+    /// The document that did change. The version number points
+    /// to the version after all provided content changes have
+    /// been applied.
+    pub text_document: VersionedTextDocumentIdentifier,
+    /// The actual content changes.
+    pub content_changes: Vec<TextDocumentContentChangeEvent>,
+}
+
+/// An event describing a change to a text document. If range and rangeLength are omitted
+/// the new text is considered to be the full content of the document.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentContentChangeEvent {
+    /// The range of the document that changed.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub range: Option<Range>,
+
+    /// The length of the range that got replaced.
+    ///
+    /// Deprecated: Use range instead
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub range_length: Option<u32>,
+
+    /// The new text of the document.
+    pub text: String,
+}
+
+/// Describe options to be used when registering for text document change events.
+///
+/// Extends TextDocumentRegistrationOptions
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentChangeRegistrationOptions {
+    /// A document selector to identify the scope of the registration. If set to null
+    /// the document selector provided on the client side will be used.
+    pub document_selector: Option<DocumentSelector>,
+
+    /// How documents are synced to the server. See TextDocumentSyncKind.Full
+    /// and TextDocumentSyncKindIncremental.
+    pub sync_kind: i32,
+}
+
+/// The parameters send in a will save text document notification.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WillSaveTextDocumentParams {
+    /// The document that will be saved.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The 'TextDocumentSaveReason'.
+    pub reason: TextDocumentSaveReason,
+}
+
+/// Represents reasons why a text document is saved.
+#[derive(Copy, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct TextDocumentSaveReason(i32);
+lsp_enum! {
+impl TextDocumentSaveReason {
+    /// Manually triggered, e.g. by the user pressing save, by starting debugging,
+    /// or by an API call.
+    pub const MANUAL: TextDocumentSaveReason = TextDocumentSaveReason(1);
+
+    /// Automatic after a delay.
+    pub const AFTER_DELAY: TextDocumentSaveReason = TextDocumentSaveReason(2);
+
+    /// When the editor lost focus.
+    pub const FOCUS_OUT: TextDocumentSaveReason = TextDocumentSaveReason(3);
+}
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DidCloseTextDocumentParams {
+    /// The document that was closed.
+    pub text_document: TextDocumentIdentifier,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DidSaveTextDocumentParams {
+    /// The document that was saved.
+    pub text_document: TextDocumentIdentifier,
+
+    /// Optional the content when saved. Depends on the includeText value
+    /// when the save notification was requested.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub text: Option<String>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TextDocumentSaveRegistrationOptions {
+    /// The client is supposed to include the content on save.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub include_text: Option<bool>,
+
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Copy, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DidChangeWatchedFilesClientCapabilities {
+    /// Did change watched files notification supports dynamic registration.
+    /// Please note that the current protocol doesn't support static
+    /// configuration for file changes from the server side.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// Whether the client has support for relative patterns
+    /// or not.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub relative_pattern_support: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct DidChangeWatchedFilesParams {
+    /// The actual file events.
+    pub changes: Vec<FileEvent>,
+}
+
+/// The file event type.
+#[derive(Eq, PartialEq, Hash, Copy, Clone, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct FileChangeType(i32);
+lsp_enum! {
+impl FileChangeType {
+    /// The file got created.
+    pub const CREATED: FileChangeType = FileChangeType(1);
+
+    /// The file got changed.
+    pub const CHANGED: FileChangeType = FileChangeType(2);
+
+    /// The file got deleted.
+    pub const DELETED: FileChangeType = FileChangeType(3);
+}
+}
+
+/// An event describing a file change.
+#[derive(Debug, Eq, Hash, PartialEq, Clone, Deserialize, Serialize)]
+pub struct FileEvent {
+    /// The file's URI.
+    pub uri: Url,
+
+    /// The change type.
+    #[serde(rename = "type")]
+    pub typ: FileChangeType,
+}
+
+impl FileEvent {
+    pub fn new(uri: Url, typ: FileChangeType) -> FileEvent {
+        FileEvent { uri, typ }
+    }
+}
+
+/// Describe options to be used when registered for text document change events.
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Deserialize, Serialize)]
+pub struct DidChangeWatchedFilesRegistrationOptions {
+    /// The watchers to register.
+    pub watchers: Vec<FileSystemWatcher>,
+}
+
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct FileSystemWatcher {
+    /// The glob pattern to watch. See {@link GlobPattern glob pattern}
+    /// for more detail.
+    ///
+    /// @since 3.17.0 support for relative patterns.
+    pub glob_pattern: GlobPattern,
+
+    /// The kind of events of interest. If omitted it defaults to WatchKind.Create |
+    /// WatchKind.Change | WatchKind.Delete which is 7.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub kind: Option<WatchKind>,
+}
+
+/// The glob pattern. Either a string pattern or a relative pattern.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum GlobPattern {
+    String(Pattern),
+    Relative(RelativePattern),
+}
+
+impl From<Pattern> for GlobPattern {
+    #[inline]
+    fn from(from: Pattern) -> Self {
+        Self::String(from)
+    }
+}
+
+impl From<RelativePattern> for GlobPattern {
+    #[inline]
+    fn from(from: RelativePattern) -> Self {
+        Self::Relative(from)
+    }
+}
+
+/// A relative pattern is a helper to construct glob patterns that are matched
+/// relatively to a base URI. The common value for a `baseUri` is a workspace
+/// folder root, but it can be another absolute URI as well.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RelativePattern {
+    /// A workspace folder or a base URI to which this pattern will be matched
+    /// against relatively.
+    pub base_uri: OneOf<WorkspaceFolder, Url>,
+
+    /// The actual glob pattern.
+    pub pattern: Pattern,
+}
+
+/// The glob pattern to watch relative to the base path. Glob patterns can have
+/// the following syntax:
+/// - `*` to match one or more characters in a path segment
+/// - `?` to match on one character in a path segment
+/// - `**` to match any number of path segments, including none
+/// - `{}` to group conditions (e.g. `**/*.{ts,js}` matches all TypeScript
+///   and JavaScript files)
+/// - `[]` to declare a range of characters to match in a path segment
+///   (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )
+/// - `[!...]` to negate a range of characters to match in a path segment
+///   (e.g., `example.[!0-9]` to match on `example.a`, `example.b`,
+///   but not `example.0`)
+///
+/// @since 3.17.0
+pub type Pattern = String;
+
+bitflags! {
+pub struct WatchKind: u8 {
+    /// Interested in create events.
+    const Create = 1;
+    /// Interested in change events
+    const Change = 2;
+    /// Interested in delete events
+    const Delete = 4;
+}
+}
+
+impl<'de> serde::Deserialize<'de> for WatchKind {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: serde::Deserializer<'de>,
+    {
+        let i = u8::deserialize(deserializer)?;
+        WatchKind::from_bits(i).ok_or_else(|| {
+            D::Error::invalid_value(de::Unexpected::Unsigned(u64::from(i)), &"Unknown flag")
+        })
+    }
+}
+
+impl serde::Serialize for WatchKind {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        serializer.serialize_u8(self.bits())
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct PublishDiagnosticsParams {
+    /// The URI for which diagnostic information is reported.
+    pub uri: Url,
+
+    /// An array of diagnostic information items.
+    pub diagnostics: Vec<Diagnostic>,
+
+    /// Optional the version number of the document the diagnostics are published for.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub version: Option<i32>,
+}
+
+impl PublishDiagnosticsParams {
+    pub fn new(
+        uri: Url,
+        diagnostics: Vec<Diagnostic>,
+        version: Option<i32>,
+    ) -> PublishDiagnosticsParams {
+        PublishDiagnosticsParams {
+            uri,
+            diagnostics,
+            version,
+        }
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(untagged)]
+pub enum Documentation {
+    String(String),
+    MarkupContent(MarkupContent),
+}
+
+/// MarkedString can be used to render human readable text. It is either a
+/// markdown string or a code-block that provides a language and a code snippet.
+/// The language identifier is semantically equal to the optional language
+/// identifier in fenced code blocks in GitHub issues.
+///
+/// The pair of a language and a value is an equivalent to markdown:
+///
+/// ```${language}
+/// ${value}
+/// ```
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum MarkedString {
+    String(String),
+    LanguageString(LanguageString),
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct LanguageString {
+    pub language: String,
+    pub value: String,
+}
+
+impl MarkedString {
+    pub fn from_markdown(markdown: String) -> MarkedString {
+        MarkedString::String(markdown)
+    }
+
+    pub fn from_language_code(language: String, code_block: String) -> MarkedString {
+        MarkedString::LanguageString(LanguageString {
+            language,
+            value: code_block,
+        })
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct GotoDefinitionParams {
+    #[serde(flatten)]
+    pub text_document_position_params: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// GotoDefinition response can be single location, or multiple Locations or a link.
+#[derive(Debug, PartialEq, Serialize, Deserialize, Clone)]
+#[serde(untagged)]
+pub enum GotoDefinitionResponse {
+    Scalar(Location),
+    Array(Vec<Location>),
+    Link(Vec<LocationLink>),
+}
+
+impl From<Location> for GotoDefinitionResponse {
+    fn from(location: Location) -> Self {
+        GotoDefinitionResponse::Scalar(location)
+    }
+}
+
+impl From<Vec<Location>> for GotoDefinitionResponse {
+    fn from(locations: Vec<Location>) -> Self {
+        GotoDefinitionResponse::Array(locations)
+    }
+}
+
+impl From<Vec<LocationLink>> for GotoDefinitionResponse {
+    fn from(locations: Vec<LocationLink>) -> Self {
+        GotoDefinitionResponse::Link(locations)
+    }
+}
+
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct ExecuteCommandParams {
+    /// The identifier of the actual command handler.
+    pub command: String,
+    /// Arguments that the command should be invoked with.
+    #[serde(default)]
+    pub arguments: Vec<Value>,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+/// Execute command registration options.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct ExecuteCommandRegistrationOptions {
+    /// The commands to be executed on the server
+    pub commands: Vec<String>,
+
+    #[serde(flatten)]
+    pub execute_command_options: ExecuteCommandOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ApplyWorkspaceEditParams {
+    /// An optional label of the workspace edit. This label is
+    /// presented in the user interface for example on an undo
+    /// stack to undo the workspace edit.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub label: Option<String>,
+
+    /// The edits to apply.
+    pub edit: WorkspaceEdit,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ApplyWorkspaceEditResponse {
+    /// Indicates whether the edit was applied or not.
+    pub applied: bool,
+
+    /// An optional textual description for why the edit was not applied.
+    /// This may be used may be used by the server for diagnostic
+    /// logging or to provide a suitable error for a request that
+    /// triggered the edit
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub failure_reason: Option<String>,
+
+    /// Depending on the client's failure handling strategy `failedChange` might
+    /// contain the index of the change that failed. This property is only available
+    /// if the client signals a `failureHandlingStrategy` in its client capabilities.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub failed_change: Option<u32>,
+}
+
+/// Describes the content type that a client supports in various
+/// result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
+///
+/// Please note that `MarkupKinds` must not start with a `$`. This kinds
+/// are reserved for internal usage.
+#[derive(Debug, Eq, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "lowercase")]
+pub enum MarkupKind {
+    /// Plain text is supported as a content format
+    PlainText,
+    /// Markdown is supported as a content format
+    Markdown,
+}
+
+/// A `MarkupContent` literal represents a string value which content can be represented in different formats.
+/// Currently `plaintext` and `markdown` are supported formats. A `MarkupContent` is usually used in
+/// documentation properties of result literals like `CompletionItem` or `SignatureInformation`.
+/// If the format is `markdown` the content should follow the [GitHub Flavored Markdown Specification](https://github.github.com/gfm/).
+///
+/// Here is an example how such a string can be constructed using JavaScript / TypeScript:
+///
+/// ```ignore
+/// let markdown: MarkupContent = {
+///     kind: MarkupKind::Markdown,
+///     value: [
+///         "# Header",
+///         "Some text",
+///         "```typescript",
+///         "someCode();",
+///         "```"
+///     ]
+///     .join("\n"),
+/// };
+/// ```
+///
+/// Please *Note* that clients might sanitize the return markdown. A client could decide to
+/// remove HTML from the markdown to avoid script execution.
+#[derive(Debug, Eq, PartialEq, Deserialize, Serialize, Clone)]
+pub struct MarkupContent {
+    pub kind: MarkupKind,
+    pub value: String,
+}
+
+/// A parameter literal used to pass a partial result token.
+#[derive(Debug, Eq, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct PartialResultParams {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub partial_result_token: Option<ProgressToken>,
+}
+
+/// Symbol tags are extra annotations that tweak the rendering of a symbol.
+///
+/// @since 3.16.0
+#[derive(Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct SymbolTag(i32);
+lsp_enum! {
+impl SymbolTag {
+    /// Render a symbol as obsolete, usually using a strike-out.
+    pub const DEPRECATED: SymbolTag = SymbolTag(1);
+}
+}
+
+#[cfg(test)]
+mod tests {
+    use serde::{Deserialize, Serialize};
+
+    use super::*;
+
+    pub(crate) fn test_serialization<SER>(ms: &SER, expected: &str)
+    where
+        SER: Serialize + for<'de> Deserialize<'de> + PartialEq + std::fmt::Debug,
+    {
+        let json_str = serde_json::to_string(ms).unwrap();
+        assert_eq!(&json_str, expected);
+        let deserialized: SER = serde_json::from_str(&json_str).unwrap();
+        assert_eq!(&deserialized, ms);
+    }
+
+    pub(crate) fn test_deserialization<T>(json: &str, expected: &T)
+    where
+        T: for<'de> Deserialize<'de> + PartialEq + std::fmt::Debug,
+    {
+        let value = serde_json::from_str::<T>(json).unwrap();
+        assert_eq!(&value, expected);
+    }
+
+    #[test]
+    fn one_of() {
+        test_serialization(&OneOf::<bool, ()>::Left(true), r#"true"#);
+        test_serialization(&OneOf::<String, ()>::Left("abcd".into()), r#""abcd""#);
+        test_serialization(
+            &OneOf::<String, WorkDoneProgressOptions>::Right(WorkDoneProgressOptions {
+                work_done_progress: Some(false),
+            }),
+            r#"{"workDoneProgress":false}"#,
+        );
+    }
+
+    #[test]
+    fn number_or_string() {
+        test_serialization(&NumberOrString::Number(123), r#"123"#);
+
+        test_serialization(&NumberOrString::String("abcd".into()), r#""abcd""#);
+    }
+
+    #[test]
+    fn marked_string() {
+        test_serialization(&MarkedString::from_markdown("xxx".into()), r#""xxx""#);
+
+        test_serialization(
+            &MarkedString::from_language_code("lang".into(), "code".into()),
+            r#"{"language":"lang","value":"code"}"#,
+        );
+    }
+
+    #[test]
+    fn language_string() {
+        test_serialization(
+            &LanguageString {
+                language: "LL".into(),
+                value: "VV".into(),
+            },
+            r#"{"language":"LL","value":"VV"}"#,
+        );
+    }
+
+    #[test]
+    fn workspace_edit() {
+        test_serialization(
+            &WorkspaceEdit {
+                changes: Some(vec![].into_iter().collect()),
+                document_changes: None,
+                ..Default::default()
+            },
+            r#"{"changes":{}}"#,
+        );
+
+        test_serialization(
+            &WorkspaceEdit {
+                changes: None,
+                document_changes: None,
+                ..Default::default()
+            },
+            r#"{}"#,
+        );
+
+        test_serialization(
+            &WorkspaceEdit {
+                changes: Some(
+                    vec![(Url::parse("file://test").unwrap(), vec![])]
+                        .into_iter()
+                        .collect(),
+                ),
+                document_changes: None,
+                ..Default::default()
+            },
+            r#"{"changes":{"file://test/":[]}}"#,
+        );
+    }
+
+    #[test]
+    fn root_uri_can_be_missing() {
+        serde_json::from_str::<InitializeParams>(r#"{ "capabilities": {} }"#).unwrap();
+    }
+
+    #[test]
+    fn test_watch_kind() {
+        test_serialization(&WatchKind::Create, "1");
+        test_serialization(&(WatchKind::Create | WatchKind::Change), "3");
+        test_serialization(
+            &(WatchKind::Create | WatchKind::Change | WatchKind::Delete),
+            "7",
+        );
+    }
+
+    #[test]
+    fn test_resource_operation_kind() {
+        test_serialization(
+            &vec![
+                ResourceOperationKind::Create,
+                ResourceOperationKind::Rename,
+                ResourceOperationKind::Delete,
+            ],
+            r#"["create","rename","delete"]"#,
+        );
+    }
+}
diff --git a/crates/lsp-types/src/linked_editing.rs b/crates/lsp-types/src/linked_editing.rs
new file mode 100644
index 000000000..b23fb141f
--- /dev/null
+++ b/crates/lsp-types/src/linked_editing.rs
@@ -0,0 +1,61 @@
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    DynamicRegistrationClientCapabilities, Range, StaticRegistrationOptions,
+    TextDocumentPositionParams, TextDocumentRegistrationOptions, WorkDoneProgressOptions,
+    WorkDoneProgressParams,
+};
+
+pub type LinkedEditingRangeClientCapabilities = DynamicRegistrationClientCapabilities;
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct LinkedEditingRangeOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct LinkedEditingRangeRegistrationOptions {
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub linked_editing_range_options: LinkedEditingRangeOptions,
+
+    #[serde(flatten)]
+    pub static_registration_options: StaticRegistrationOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum LinkedEditingRangeServerCapabilities {
+    Simple(bool),
+    Options(LinkedEditingRangeOptions),
+    RegistrationOptions(LinkedEditingRangeRegistrationOptions),
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct LinkedEditingRangeParams {
+    #[serde(flatten)]
+    pub text_document_position_params: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct LinkedEditingRanges {
+    /// A list of ranges that can be renamed together. The ranges must have
+    /// identical length and contain identical text content. The ranges cannot overlap.
+    pub ranges: Vec<Range>,
+
+    /// An optional word pattern (regular expression) that describes valid contents for
+    /// the given ranges. If no pattern is provided, the client configuration's word
+    /// pattern will be used.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub word_pattern: Option<String>,
+}
diff --git a/crates/lsp-types/src/lsif.rs b/crates/lsp-types/src/lsif.rs
new file mode 100644
index 000000000..be6df6e58
--- /dev/null
+++ b/crates/lsp-types/src/lsif.rs
@@ -0,0 +1,336 @@
+//! Types of Language Server Index Format (LSIF). LSIF is a standard format
+//! for language servers or other programming tools to dump their knowledge
+//! about a workspace.
+//!
+//! Based on <https://microsoft.github.io/language-server-protocol/specifications/lsif/0.6.0/specification/>
+
+use crate::{Range, Url};
+use serde::{Deserialize, Serialize};
+
+pub type Id = crate::NumberOrString;
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(untagged)]
+pub enum LocationOrRangeId {
+    Location(crate::Location),
+    RangeId(Id),
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Entry {
+    pub id: Id,
+    #[serde(flatten)]
+    pub data: Element,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(tag = "type")]
+pub enum Element {
+    Vertex(Vertex),
+    Edge(Edge),
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+pub struct ToolInfo {
+    pub name: String,
+    #[serde(default = "Default::default")]
+    #[serde(skip_serializing_if = "Vec::is_empty")]
+    pub args: Vec<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub version: Option<String>,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize, Clone, Copy)]
+pub enum Encoding {
+    /// Currently only 'utf-16' is supported due to the limitations in LSP.
+    #[serde(rename = "utf-16")]
+    Utf16,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+pub struct RangeBasedDocumentSymbol {
+    pub id: Id,
+    #[serde(default = "Default::default")]
+    #[serde(skip_serializing_if = "Vec::is_empty")]
+    pub children: Vec<RangeBasedDocumentSymbol>,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(untagged)]
+pub enum DocumentSymbolOrRangeBasedVec {
+    DocumentSymbol(Vec<crate::DocumentSymbol>),
+    RangeBased(Vec<RangeBasedDocumentSymbol>),
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DefinitionTag {
+    /// The text covered by the range     
+    text: String,
+    /// The symbol kind.
+    kind: crate::SymbolKind,
+    /// Indicates if this symbol is deprecated.
+    #[serde(default)]
+    #[serde(skip_serializing_if = "std::ops::Not::not")]
+    deprecated: bool,
+    /// The full range of the definition not including leading/trailing whitespace but everything else, e.g comments and code.
+    /// The range must be included in fullRange.
+    full_range: Range,
+    /// Optional detail information for the definition.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    detail: Option<String>,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DeclarationTag {
+    /// The text covered by the range     
+    text: String,
+    /// The symbol kind.
+    kind: crate::SymbolKind,
+    /// Indicates if this symbol is deprecated.
+    #[serde(default)]
+    deprecated: bool,
+    /// The full range of the definition not including leading/trailing whitespace but everything else, e.g comments and code.
+    /// The range must be included in fullRange.
+    full_range: Range,
+    /// Optional detail information for the definition.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    detail: Option<String>,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ReferenceTag {
+    text: String,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct UnknownTag {
+    text: String,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(tag = "type")]
+pub enum RangeTag {
+    Definition(DefinitionTag),
+    Declaration(DeclarationTag),
+    Reference(ReferenceTag),
+    Unknown(UnknownTag),
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(tag = "label")]
+pub enum Vertex {
+    MetaData(MetaData),
+    /// <https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#the-project-vertex>
+    Project(Project),
+    Document(Document),
+    /// <https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#ranges>
+    Range {
+        #[serde(flatten)]
+        range: Range,
+        #[serde(skip_serializing_if = "Option::is_none")]
+        tag: Option<RangeTag>,
+    },
+    /// <https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#result-set>
+    ResultSet(ResultSet),
+    Moniker(crate::Moniker),
+    PackageInformation(PackageInformation),
+
+    #[serde(rename = "$event")]
+    Event(Event),
+
+    DefinitionResult,
+    DeclarationResult,
+    TypeDefinitionResult,
+    ReferenceResult,
+    ImplementationResult,
+    FoldingRangeResult {
+        result: Vec<crate::FoldingRange>,
+    },
+    HoverResult {
+        result: crate::Hover,
+    },
+    DocumentSymbolResult {
+        result: DocumentSymbolOrRangeBasedVec,
+    },
+    DocumentLinkResult {
+        result: Vec<crate::DocumentLink>,
+    },
+    DiagnosticResult {
+        result: Vec<crate::Diagnostic>,
+    },
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub enum EventKind {
+    Begin,
+    End,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub enum EventScope {
+    Document,
+    Project,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+pub struct Event {
+    pub kind: EventKind,
+    pub scope: EventScope,
+    pub data: Id,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(tag = "label")]
+pub enum Edge {
+    Contains(EdgeDataMultiIn),
+    Moniker(EdgeData),
+    NextMoniker(EdgeData),
+    Next(EdgeData),
+    PackageInformation(EdgeData),
+    Item(Item),
+
+    // Methods
+    #[serde(rename = "textDocument/definition")]
+    Definition(EdgeData),
+    #[serde(rename = "textDocument/declaration")]
+    Declaration(EdgeData),
+    #[serde(rename = "textDocument/hover")]
+    Hover(EdgeData),
+    #[serde(rename = "textDocument/references")]
+    References(EdgeData),
+    #[serde(rename = "textDocument/implementation")]
+    Implementation(EdgeData),
+    #[serde(rename = "textDocument/typeDefinition")]
+    TypeDefinition(EdgeData),
+    #[serde(rename = "textDocument/foldingRange")]
+    FoldingRange(EdgeData),
+    #[serde(rename = "textDocument/documentLink")]
+    DocumentLink(EdgeData),
+    #[serde(rename = "textDocument/documentSymbol")]
+    DocumentSymbol(EdgeData),
+    #[serde(rename = "textDocument/diagnostic")]
+    Diagnostic(EdgeData),
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct EdgeData {
+    pub in_v: Id,
+    pub out_v: Id,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct EdgeDataMultiIn {
+    pub in_vs: Vec<Id>,
+    pub out_v: Id,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(untagged)]
+pub enum DefinitionResultType {
+    Scalar(LocationOrRangeId),
+    Array(LocationOrRangeId),
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub enum ItemKind {
+    Declarations,
+    Definitions,
+    References,
+    ReferenceResults,
+    ImplementationResults,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Item {
+    pub document: Id,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub property: Option<ItemKind>,
+    #[serde(flatten)]
+    pub edge_data: EdgeDataMultiIn,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Document {
+    pub uri: Url,
+    pub language_id: String,
+}
+
+/// <https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#result-set>
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ResultSet {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub key: Option<String>,
+}
+
+/// <https://github.com/Microsoft/language-server-protocol/blob/master/indexFormat/specification.md#the-project-vertex>
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Project {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resource: Option<Url>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub content: Option<String>,
+    pub kind: String,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct MetaData {
+    /// The version of the LSIF format using semver notation. See <https://semver.org/>. Please note
+    /// the version numbers starting with 0 don't adhere to semver and adopters have to assume
+    /// that each new version is breaking.
+    pub version: String,
+
+    /// The project root (in form of an URI) used to compute this dump.
+    pub project_root: Url,
+
+    /// The string encoding used to compute line and character values in
+    /// positions and ranges.
+    pub position_encoding: Encoding,
+
+    /// Information about the tool that created the dump
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tool_info: Option<ToolInfo>,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Repository {
+    pub r#type: String,
+    pub url: String,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub commit_id: Option<String>,
+}
+
+#[derive(Debug, PartialEq, Serialize, Deserialize)]
+#[serde(rename_all = "camelCase")]
+pub struct PackageInformation {
+    pub name: String,
+    pub manager: String,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub uri: Option<Url>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub content: Option<String>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub repository: Option<Repository>,
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub version: Option<String>,
+}
diff --git a/crates/lsp-types/src/moniker.rs b/crates/lsp-types/src/moniker.rs
new file mode 100644
index 000000000..74bf89553
--- /dev/null
+++ b/crates/lsp-types/src/moniker.rs
@@ -0,0 +1,92 @@
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    DynamicRegistrationClientCapabilities, PartialResultParams, TextDocumentPositionParams,
+    TextDocumentRegistrationOptions, WorkDoneProgressOptions, WorkDoneProgressParams,
+};
+
+pub type MonikerClientCapabilities = DynamicRegistrationClientCapabilities;
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum MonikerServerCapabilities {
+    Options(MonikerOptions),
+    RegistrationOptions(MonikerRegistrationOptions),
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct MonikerOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct MonikerRegistrationOptions {
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub moniker_options: MonikerOptions,
+}
+
+/// Moniker uniqueness level to define scope of the moniker.
+#[derive(Debug, Eq, PartialEq, Deserialize, Serialize, Copy, Clone)]
+#[serde(rename_all = "camelCase")]
+pub enum UniquenessLevel {
+    /// The moniker is only unique inside a document
+    Document,
+    /// The moniker is unique inside a project for which a dump got created
+    Project,
+    /// The moniker is unique inside the group to which a project belongs
+    Group,
+    /// The moniker is unique inside the moniker scheme.
+    Scheme,
+    /// The moniker is globally unique
+    Global,
+}
+
+/// The moniker kind.
+#[derive(Debug, Eq, PartialEq, Deserialize, Serialize, Copy, Clone)]
+#[serde(rename_all = "camelCase")]
+pub enum MonikerKind {
+    /// The moniker represent a symbol that is imported into a project
+    Import,
+    /// The moniker represent a symbol that is exported into a project
+    Export,
+    /// The moniker represents a symbol that is local to a project (e.g. a local
+    /// variable of a function, a class not visible outside the project, ...)
+    Local,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct MonikerParams {
+    #[serde(flatten)]
+    pub text_document_position_params: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// Moniker definition to match LSIF 0.5 moniker definition.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct Moniker {
+    /// The scheme of the moniker. For example tsc or .Net
+    pub scheme: String,
+
+    /// The identifier of the moniker. The value is opaque in LSIF however
+    /// schema owners are allowed to define the structure if they want.
+    pub identifier: String,
+
+    /// The scope in which the moniker is unique
+    pub unique: UniquenessLevel,
+
+    /// The moniker kind if known.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub kind: Option<MonikerKind>,
+}
diff --git a/crates/lsp-types/src/notebook.rs b/crates/lsp-types/src/notebook.rs
new file mode 100644
index 000000000..57dfccbeb
--- /dev/null
+++ b/crates/lsp-types/src/notebook.rs
@@ -0,0 +1,404 @@
+use serde::{Deserialize, Serialize};
+use serde_repr::{Deserialize_repr, Serialize_repr};
+
+use crate::{LSPObject, Url as Uri};
+
+pub use notification_params::*;
+
+/// A notebook document.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct NotebookDocument {
+    /// The notebook document's URI.
+    pub uri: Uri,
+    /// The type of the notebook.
+    pub notebook_type: String,
+    /// The version number of this document (it will increase after each
+    /// change, including undo/redo).
+    pub version: i32,
+    /// Additional metadata stored with the notebook
+    /// document.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub metadata: Option<LSPObject>,
+    /// The cells of a notebook.
+    pub cells: Vec<NotebookCell>,
+}
+
+/// A notebook cell.
+///
+/// A cell's document URI must be unique across ALL notebook
+/// cells and can therefore be used to uniquely identify a
+/// notebook cell or the cell's text document.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct NotebookCell {
+    /// The cell's kind
+    pub kind: NotebookCellKind,
+    /// The URI of the cell's text document content.
+    pub document: Uri,
+    /// Additional metadata stored with the cell.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub metadata: Option<LSPObject>,
+    /// Additional execution summary information
+    /// if supported by the client.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub execution_summary: Option<ExecutionSummary>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ExecutionSummary {
+    /// A strict monotonically increasing value
+    /// indicating the execution order of a cell
+    /// inside a notebook.
+    pub execution_order: u32,
+    /// Whether the execution was successful or
+    /// not if known by the client.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub success: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Serialize_repr, Deserialize_repr)]
+#[repr(u8)]
+pub enum NotebookCellKind {
+    /// A markup-cell is formatted source that is used for display.
+    Markup = 1,
+    /// A code-cell is source code.
+    Code = 2,
+}
+
+/// Capabilities specific to the notebook document support.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct NotebookDocumentClientCapabilities {
+    /// Capabilities specific to notebook document synchronization
+    ///
+    /// @since 3.17.0
+    pub synchronization: NotebookDocumentSyncClientCapabilities,
+}
+
+/// Notebook specific client capabilities.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct NotebookDocumentSyncClientCapabilities {
+    /// Whether implementation supports dynamic registration. If this is
+    /// set to `true` the client supports the new
+    /// `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
+    /// return value for the corresponding server capability as well.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// The client supports sending execution summary data per cell.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub execution_summary_report: Option<bool>,
+}
+
+///  Options specific to a notebook plus its cells
+///  to be synced to the server.
+///
+///  If a selector provides a notebook document
+///  filter but no cell selector all cells of a
+///  matching notebook document will be synced.
+///
+///  If a selector provides no notebook document
+///  filter but only a cell selector all notebook
+///  documents that contain at least one matching
+///  cell will be synced.
+///
+///  @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct NotebookDocumentSyncOptions {
+    /// The notebooks to be synced
+    pub notebook_selector: Vec<NotebookSelector>,
+    /// Whether save notification should be forwarded to
+    /// the server. Will only be honored if mode === `notebook`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub save: Option<bool>,
+}
+
+/// Registration options specific to a notebook.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct NotebookDocumentSyncRegistrationOptions {
+    /// The notebooks to be synced
+    pub notebook_selector: Vec<NotebookSelector>,
+    /// Whether save notification should be forwarded to
+    /// the server. Will only be honored if mode === `notebook`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub save: Option<bool>,
+    /// The id used to register the request. The id can be used to deregister
+    /// the request again. See also Registration#id.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub id: Option<String>,
+}
+
+/// A notebook cell text document filter denotes a cell text
+/// document by different properties.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct NotebookCellTextDocumentFilter {
+    /// A filter that matches against the notebook
+    /// containing the notebook cell. If a string
+    /// value is provided it matches against the
+    /// notebook type. '*' matches every notebook.
+    pub notebook: Notebook,
+    /// A language id like `python`.
+    ///
+    /// Will be matched against the language id of the
+    /// notebook cell document. '*' matches every language.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub language: Option<String>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase", untagged)]
+pub enum NotebookSelector {
+    ByNotebook {
+        /// The notebook to be synced. If a string
+        /// value is provided it matches against the
+        /// notebook type. '*' matches every notebook.
+        notebook: Notebook,
+        /// The cells of the matching notebook to be synced.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        cells: Option<Vec<NotebookCellSelector>>,
+    },
+    ByCells {
+        /// The notebook to be synced. If a string
+        /// value is provided it matches against the
+        /// notebook type. '*' matches every notebook.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        notebook: Option<Notebook>,
+        /// The cells of the matching notebook to be synced.
+        cells: Vec<NotebookCellSelector>,
+    },
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct NotebookCellSelector {
+    pub language: String,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum Notebook {
+    String(String),
+    NotebookDocumentFilter(NotebookDocumentFilter),
+}
+
+/// A notebook document filter denotes a notebook document by
+/// different properties.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase", untagged)]
+pub enum NotebookDocumentFilter {
+    ByType {
+        /// The type of the enclosing notebook.
+        notebook_type: String,
+        /// A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        scheme: Option<String>,
+        /// A glob pattern.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pattern: Option<String>,
+    },
+    ByScheme {
+        /// The type of the enclosing notebook.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        notebook_type: Option<String>,
+        /// A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
+        scheme: String,
+        /// A glob pattern.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pattern: Option<String>,
+    },
+    ByPattern {
+        /// The type of the enclosing notebook.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        notebook_type: Option<String>,
+        /// A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        scheme: Option<String>,
+        /// A glob pattern.
+        pattern: String,
+    },
+}
+
+mod notification_params {
+    use serde::{Deserialize, Serialize};
+
+    use crate::{
+        TextDocumentContentChangeEvent, TextDocumentIdentifier, TextDocumentItem,
+        VersionedTextDocumentIdentifier,
+    };
+
+    use super::*;
+
+    /// The params sent in an open notebook document notification.
+    ///
+    /// @since 3.17.0
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct DidOpenNotebookDocumentParams {
+        /// The notebook document that got opened.
+        pub notebook_document: NotebookDocument,
+        /// The text documents that represent the content
+        /// of a notebook cell.
+        pub cell_text_documents: Vec<TextDocumentItem>,
+    }
+
+    /// The params sent in a change notebook document notification.
+    ///
+    /// @since 3.17.0
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct DidChangeNotebookDocumentParams {
+        /// The notebook document that did change. The version number points
+        /// to the version after all provided changes have been applied.
+        pub notebook_document: VersionedNotebookDocumentIdentifier,
+
+        /// The actual changes to the notebook document.
+        ///
+        /// The change describes single state change to the notebook document.
+        /// So it moves a notebook document, its cells and its cell text document
+        /// contents from state S to S'.
+        ///
+        /// To mirror the content of a notebook using change events use the
+        /// following approach:
+        /// - start with the same initial content
+        /// - apply the 'notebookDocument/didChange' notifications in the order
+        ///   you receive them.
+        pub change: NotebookDocumentChangeEvent,
+    }
+
+    /// A versioned notebook document identifier.
+    ///
+    /// @since 3.17.0
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct VersionedNotebookDocumentIdentifier {
+        /// The version number of this notebook document.
+        pub version: i32,
+        /// The notebook document's URI.
+        pub uri: Uri,
+    }
+
+    /// A change event for a notebook document.
+    ///
+    /// @since 3.17.0
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct NotebookDocumentChangeEvent {
+        /// The changed meta data if any.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub metadata: Option<LSPObject>,
+
+        /// Changes to cells
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub cells: Option<NotebookDocumentCellChange>,
+    }
+
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct NotebookDocumentCellChange {
+        /// Changes to the cell structure to add or
+        /// remove cells.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub structure: Option<NotebookDocumentCellChangeStructure>,
+
+        /// Changes to notebook cells properties like its
+        /// kind, execution summary or metadata.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub data: Option<Vec<NotebookCell>>,
+
+        /// Changes to the text content of notebook cells.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub text_content: Option<Vec<NotebookDocumentChangeTextContent>>,
+    }
+
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct NotebookDocumentChangeTextContent {
+        pub document: VersionedTextDocumentIdentifier,
+        pub changes: Vec<TextDocumentContentChangeEvent>,
+    }
+
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct NotebookDocumentCellChangeStructure {
+        /// The change to the cell array.
+        pub array: NotebookCellArrayChange,
+        /// Additional opened cell text documents.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub did_open: Option<Vec<TextDocumentItem>>,
+        /// Additional closed cell text documents.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub did_close: Option<Vec<TextDocumentIdentifier>>,
+    }
+
+    /// A change describing how to move a `NotebookCell`
+    /// array from state S to S'.
+    ///
+    /// @since 3.17.0
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct NotebookCellArrayChange {
+        /// The start offset of the cell that changed.
+        pub start: u32,
+
+        /// The deleted cells
+        pub delete_count: u32,
+
+        /// The new cells, if any
+        #[serde(skip_serializing_if = "Option::is_none")]
+        pub cells: Option<Vec<NotebookCell>>,
+    }
+
+    /// The params sent in a save notebook document notification.
+    ///
+    /// @since 3.17.0
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct DidSaveNotebookDocumentParams {
+        /// The notebook document that got saved.
+        pub notebook_document: NotebookDocumentIdentifier,
+    }
+
+    /// A literal to identify a notebook document in the client.
+    ///
+    /// @since 3.17.0
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct NotebookDocumentIdentifier {
+        /// The notebook document's URI.
+        pub uri: Uri,
+    }
+
+    /// The params sent in a close notebook document notification.
+    ///
+    /// @since 3.17.0
+    #[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+    #[serde(rename_all = "camelCase")]
+    pub struct DidCloseNotebookDocumentParams {
+        /// The notebook document that got closed.
+        pub notebook_document: NotebookDocumentIdentifier,
+
+        /// The text documents that represent the content
+        /// of a notebook cell that got closed.
+        pub cell_text_documents: Vec<TextDocumentIdentifier>,
+    }
+}
diff --git a/crates/lsp-types/src/notification.rs b/crates/lsp-types/src/notification.rs
new file mode 100644
index 000000000..ccf712d88
--- /dev/null
+++ b/crates/lsp-types/src/notification.rs
@@ -0,0 +1,402 @@
+use super::*;
+
+use serde::{de::DeserializeOwned, Serialize};
+
+pub trait Notification {
+    type Params: DeserializeOwned + Serialize + Send + Sync + 'static;
+    const METHOD: &'static str;
+}
+
+#[macro_export]
+macro_rules! lsp_notification {
+    ("$/cancelRequest") => {
+        $crate::notification::Cancel
+    };
+    ("$/setTrace") => {
+        $crate::notification::SetTrace
+    };
+    ("$/logTrace") => {
+        $crate::notification::LogTrace
+    };
+    ("initialized") => {
+        $crate::notification::Initialized
+    };
+    ("exit") => {
+        $crate::notification::Exit
+    };
+
+    ("window/showMessage") => {
+        $crate::notification::ShowMessage
+    };
+    ("window/logMessage") => {
+        $crate::notification::LogMessage
+    };
+    ("window/workDoneProgress/cancel") => {
+        $crate::notification::WorkDoneProgressCancel
+    };
+
+    ("telemetry/event") => {
+        $crate::notification::TelemetryEvent
+    };
+
+    ("textDocument/didOpen") => {
+        $crate::notification::DidOpenTextDocument
+    };
+    ("textDocument/didChange") => {
+        $crate::notification::DidChangeTextDocument
+    };
+    ("textDocument/willSave") => {
+        $crate::notification::WillSaveTextDocument
+    };
+    ("textDocument/didSave") => {
+        $crate::notification::DidSaveTextDocument
+    };
+    ("textDocument/didClose") => {
+        $crate::notification::DidCloseTextDocument
+    };
+    ("textDocument/publishDiagnostics") => {
+        $crate::notification::PublishDiagnostics
+    };
+
+    ("notebookDocument/didOpen") => {
+        $crate::notification::DidOpenNotebookDocument
+    };
+    ("notebookDocument/didChange") => {
+        $crate::notification::DidChangeNotebookDocument
+    };
+    ("notebookDocument/didSave") => {
+        $crate::notification::DidSaveNotebookDocument
+    };
+    ("notebookDocument/didClose") => {
+        $crate::notification::DidCloseNotebookDocument
+    };
+
+    ("workspace/didChangeConfiguration") => {
+        $crate::notification::DidChangeConfiguration
+    };
+    ("workspace/didChangeWatchedFiles") => {
+        $crate::notification::DidChangeWatchedFiles
+    };
+    ("workspace/didChangeWorkspaceFolders") => {
+        $crate::notification::DidChangeWorkspaceFolders
+    };
+    ("$/progress") => {
+        $crate::notification::Progress
+    };
+    ("workspace/didCreateFiles") => {
+        $crate::notification::DidCreateFiles
+    };
+    ("workspace/didRenameFiles") => {
+        $crate::notification::DidRenameFiles
+    };
+    ("workspace/didDeleteFiles") => {
+        $crate::notification::DidDeleteFiles
+    };
+}
+
+/// The base protocol now offers support for request cancellation. To cancel a request,
+/// a notification message with the following properties is sent:
+///
+/// A request that got canceled still needs to return from the server and send a response back.
+/// It can not be left open / hanging. This is in line with the JSON RPC protocol that requires
+/// that every request sends a response back. In addition it allows for returning partial results on cancel.
+#[derive(Debug)]
+pub enum Cancel {}
+
+impl Notification for Cancel {
+    type Params = CancelParams;
+    const METHOD: &'static str = "$/cancelRequest";
+}
+
+/// A notification that should be used by the client to modify the trace
+/// setting of the server.
+#[derive(Debug)]
+pub enum SetTrace {}
+
+impl Notification for SetTrace {
+    type Params = SetTraceParams;
+    const METHOD: &'static str = "$/setTrace";
+}
+
+/// A notification to log the trace of the servers execution.
+/// The amount and content of these notifications depends on the current trace configuration.
+///
+/// `LogTrace` should be used for systematic trace reporting. For single debugging messages,
+/// the server should send `LogMessage` notifications.
+#[derive(Debug)]
+pub enum LogTrace {}
+
+impl Notification for LogTrace {
+    type Params = LogTraceParams;
+    const METHOD: &'static str = "$/logTrace";
+}
+
+/// The initialized notification is sent from the client to the server after the client received
+/// the result of the initialize request but before the client is sending any other request or
+/// notification to the server. The server can use the initialized notification for example to
+/// dynamically register capabilities.
+#[derive(Debug)]
+pub enum Initialized {}
+
+impl Notification for Initialized {
+    type Params = InitializedParams;
+    const METHOD: &'static str = "initialized";
+}
+
+/// A notification to ask the server to exit its process.
+/// The server should exit with success code 0 if the shutdown request has been received before;
+/// otherwise with error code 1.
+#[derive(Debug)]
+pub enum Exit {}
+
+impl Notification for Exit {
+    type Params = ();
+    const METHOD: &'static str = "exit";
+}
+
+/// The show message notification is sent from a server to a client to ask the client to display a particular message
+/// in the user interface.
+#[derive(Debug)]
+pub enum ShowMessage {}
+
+impl Notification for ShowMessage {
+    type Params = ShowMessageParams;
+    const METHOD: &'static str = "window/showMessage";
+}
+
+/// The log message notification is sent from the server to the client to ask the client to log a particular message.
+#[derive(Debug)]
+pub enum LogMessage {}
+
+impl Notification for LogMessage {
+    type Params = LogMessageParams;
+    const METHOD: &'static str = "window/logMessage";
+}
+
+/// The telemetry notification is sent from the server to the client to ask the client to log a telemetry event.
+/// The protocol doesn't specify the payload since no interpretation of the data happens in the protocol. Most clients even don't handle
+/// the event directly but forward them to the extensions owning the corresponding server issuing the event.
+#[derive(Debug)]
+pub enum TelemetryEvent {}
+
+impl Notification for TelemetryEvent {
+    type Params = OneOf<LSPObject, LSPArray>;
+    const METHOD: &'static str = "telemetry/event";
+}
+
+/// A notification sent from the client to the server to signal the change of configuration settings.
+#[derive(Debug)]
+pub enum DidChangeConfiguration {}
+
+impl Notification for DidChangeConfiguration {
+    type Params = DidChangeConfigurationParams;
+    const METHOD: &'static str = "workspace/didChangeConfiguration";
+}
+
+/// The document open notification is sent from the client to the server to signal newly opened text documents.
+/// The document's truth is now managed by the client and the server must not try to read the document's truth
+/// using the document's uri.
+#[derive(Debug)]
+pub enum DidOpenTextDocument {}
+
+impl Notification for DidOpenTextDocument {
+    type Params = DidOpenTextDocumentParams;
+    const METHOD: &'static str = "textDocument/didOpen";
+}
+
+/// The document change notification is sent from the client to the server to signal changes to a text document.
+/// In 2.0 the shape of the params has changed to include proper version numbers and language ids.
+#[derive(Debug)]
+pub enum DidChangeTextDocument {}
+
+impl Notification for DidChangeTextDocument {
+    type Params = DidChangeTextDocumentParams;
+    const METHOD: &'static str = "textDocument/didChange";
+}
+
+/// The document will save notification is sent from the client to the server before the document
+/// is actually saved.
+#[derive(Debug)]
+pub enum WillSaveTextDocument {}
+
+impl Notification for WillSaveTextDocument {
+    type Params = WillSaveTextDocumentParams;
+    const METHOD: &'static str = "textDocument/willSave";
+}
+
+/// The document close notification is sent from the client to the server when the document got closed in the client.
+/// The document's truth now exists where the document's uri points to (e.g. if the document's uri is a file uri
+/// the truth now exists on disk).
+#[derive(Debug)]
+pub enum DidCloseTextDocument {}
+
+impl Notification for DidCloseTextDocument {
+    type Params = DidCloseTextDocumentParams;
+    const METHOD: &'static str = "textDocument/didClose";
+}
+
+/// The document save notification is sent from the client to the server when the document was saved in the client.
+#[derive(Debug)]
+pub enum DidSaveTextDocument {}
+
+impl Notification for DidSaveTextDocument {
+    type Params = DidSaveTextDocumentParams;
+    const METHOD: &'static str = "textDocument/didSave";
+}
+
+#[derive(Debug)]
+pub enum DidOpenNotebookDocument {}
+impl Notification for DidOpenNotebookDocument {
+    type Params = DidOpenNotebookDocumentParams;
+    const METHOD: &'static str = "notebookDocument/didOpen";
+}
+
+#[derive(Debug)]
+pub enum DidChangeNotebookDocument {}
+impl Notification for DidChangeNotebookDocument {
+    type Params = DidChangeNotebookDocumentParams;
+    const METHOD: &'static str = "notebookDocument/didChange";
+}
+
+#[derive(Debug)]
+pub enum DidSaveNotebookDocument {}
+impl Notification for DidSaveNotebookDocument {
+    type Params = DidSaveNotebookDocumentParams;
+    const METHOD: &'static str = "notebookDocument/didSave";
+}
+
+#[derive(Debug)]
+pub enum DidCloseNotebookDocument {}
+impl Notification for DidCloseNotebookDocument {
+    type Params = DidCloseNotebookDocumentParams;
+    const METHOD: &'static str = "notebookDocument/didClose";
+}
+
+/// The watched files notification is sent from the client to the server when the client detects changes to files and folders
+/// watched by the language client (note although the name suggest that only file events are sent it is about file system events which include folders as well).
+/// It is recommended that servers register for these file system events using the registration mechanism.
+/// In former implementations clients pushed file events without the server actively asking for it.
+#[derive(Debug)]
+pub enum DidChangeWatchedFiles {}
+
+impl Notification for DidChangeWatchedFiles {
+    type Params = DidChangeWatchedFilesParams;
+    const METHOD: &'static str = "workspace/didChangeWatchedFiles";
+}
+
+/// The workspace/didChangeWorkspaceFolders notification is sent from the client to the server to inform the server
+/// about workspace folder configuration changes
+#[derive(Debug)]
+pub enum DidChangeWorkspaceFolders {}
+
+impl Notification for DidChangeWorkspaceFolders {
+    type Params = DidChangeWorkspaceFoldersParams;
+    const METHOD: &'static str = "workspace/didChangeWorkspaceFolders";
+}
+
+/// Diagnostics notification are sent from the server to the client to signal results of validation runs.
+#[derive(Debug)]
+pub enum PublishDiagnostics {}
+
+impl Notification for PublishDiagnostics {
+    type Params = PublishDiagnosticsParams;
+    const METHOD: &'static str = "textDocument/publishDiagnostics";
+}
+
+/// The progress notification is sent from the server to the client to ask
+/// the client to indicate progress.
+#[derive(Debug)]
+pub enum Progress {}
+
+impl Notification for Progress {
+    type Params = ProgressParams;
+    const METHOD: &'static str = "$/progress";
+}
+
+/// The `window/workDoneProgress/cancel` notification is sent from the client
+/// to the server to cancel a progress initiated on the server side using the `window/workDoneProgress/create`.
+#[derive(Debug)]
+pub enum WorkDoneProgressCancel {}
+
+impl Notification for WorkDoneProgressCancel {
+    type Params = WorkDoneProgressCancelParams;
+    const METHOD: &'static str = "window/workDoneProgress/cancel";
+}
+
+/// The did create files notification is sent from the client to the server when files were created from within the client.
+#[derive(Debug)]
+pub enum DidCreateFiles {}
+
+impl Notification for DidCreateFiles {
+    type Params = CreateFilesParams;
+    const METHOD: &'static str = "workspace/didCreateFiles";
+}
+
+/// The did rename files notification is sent from the client to the server when files were renamed from within the client.
+#[derive(Debug)]
+pub enum DidRenameFiles {}
+
+impl Notification for DidRenameFiles {
+    type Params = RenameFilesParams;
+    const METHOD: &'static str = "workspace/didRenameFiles";
+}
+
+/// The did delete files notification is sent from the client to the server when files were deleted from within the client.
+#[derive(Debug)]
+pub enum DidDeleteFiles {}
+
+impl Notification for DidDeleteFiles {
+    type Params = DeleteFilesParams;
+    const METHOD: &'static str = "workspace/didDeleteFiles";
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    fn fake_call<N>()
+    where
+        N: Notification,
+        N::Params: serde::Serialize,
+    {
+    }
+
+    macro_rules! check_macro {
+        ($name:tt) => {
+            // check whether the macro name matches the method
+            assert_eq!(<lsp_notification!($name) as Notification>::METHOD, $name);
+            // test whether type checking passes for each component
+            fake_call::<lsp_notification!($name)>();
+        };
+    }
+
+    #[test]
+    fn check_macro_definitions() {
+        check_macro!("$/cancelRequest");
+        check_macro!("$/progress");
+        check_macro!("$/logTrace");
+        check_macro!("$/setTrace");
+        check_macro!("initialized");
+        check_macro!("exit");
+        check_macro!("window/showMessage");
+        check_macro!("window/logMessage");
+        check_macro!("window/workDoneProgress/cancel");
+        check_macro!("telemetry/event");
+        check_macro!("textDocument/didOpen");
+        check_macro!("textDocument/didChange");
+        check_macro!("textDocument/willSave");
+        check_macro!("textDocument/didSave");
+        check_macro!("textDocument/didClose");
+        check_macro!("textDocument/publishDiagnostics");
+        check_macro!("workspace/didChangeConfiguration");
+        check_macro!("workspace/didChangeWatchedFiles");
+        check_macro!("workspace/didChangeWorkspaceFolders");
+        check_macro!("workspace/didCreateFiles");
+        check_macro!("workspace/didRenameFiles");
+        check_macro!("workspace/didDeleteFiles");
+    }
+
+    #[test]
+    #[cfg(feature = "proposed")]
+    fn check_proposed_macro_definitions() {}
+}
diff --git a/crates/lsp-types/src/progress.rs b/crates/lsp-types/src/progress.rs
new file mode 100644
index 000000000..41fa74f9f
--- /dev/null
+++ b/crates/lsp-types/src/progress.rs
@@ -0,0 +1,134 @@
+use serde::{Deserialize, Serialize};
+
+use crate::NumberOrString;
+
+pub type ProgressToken = NumberOrString;
+
+/// The progress notification is sent from the server to the client to ask
+/// the client to indicate progress.
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct ProgressParams {
+    /// The progress token provided by the client.
+    pub token: ProgressToken,
+
+    /// The progress data.
+    pub value: ProgressParamsValue,
+}
+
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(untagged)]
+pub enum ProgressParamsValue {
+    WorkDone(WorkDoneProgress),
+}
+
+/// The `window/workDoneProgress/create` request is sent
+/// from the server to the client to ask the client to create a work done progress.
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkDoneProgressCreateParams {
+    /// The token to be used to report progress.
+    pub token: ProgressToken,
+}
+
+/// The `window/workDoneProgress/cancel` notification is sent from the client
+/// to the server to cancel a progress initiated on the server side using the `window/workDoneProgress/create`.
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkDoneProgressCancelParams {
+    /// The token to be used to report progress.
+    pub token: ProgressToken,
+}
+
+/// Options to signal work done progress support in server capabilities.
+#[derive(Debug, Eq, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkDoneProgressOptions {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub work_done_progress: Option<bool>,
+}
+
+/// An optional token that a server can use to report work done progress
+#[derive(Debug, Eq, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkDoneProgressParams {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub work_done_token: Option<ProgressToken>,
+}
+
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkDoneProgressBegin {
+    /// Mandatory title of the progress operation. Used to briefly inform
+    /// about the kind of operation being performed.
+    /// Examples: "Indexing" or "Linking dependencies".
+    pub title: String,
+
+    /// Controls if a cancel button should show to allow the user to cancel the
+    /// long running operation. Clients that don't support cancellation are allowed
+    /// to ignore the setting.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub cancellable: Option<bool>,
+
+    /// Optional, more detailed associated progress message. Contains
+    /// complementary information to the `title`.
+    ///
+    /// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
+    /// If unset, the previous progress message (if any) is still valid.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub message: Option<String>,
+
+    /// Optional progress percentage to display (value 100 is considered 100%).
+    /// If not provided infinite progress is assumed and clients are allowed
+    /// to ignore the `percentage` value in subsequent in report notifications.
+    ///
+    /// The value should be steadily rising. Clients are free to ignore values
+    /// that are not following this rule. The value range is [0, 100]
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub percentage: Option<u32>,
+}
+
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkDoneProgressReport {
+    /// Controls if a cancel button should show to allow the user to cancel the
+    /// long running operation. Clients that don't support cancellation are allowed
+    /// to ignore the setting.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub cancellable: Option<bool>,
+
+    /// Optional, more detailed associated progress message. Contains
+    /// complementary information to the `title`.
+    /// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
+    /// If unset, the previous progress message (if any) is still valid.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub message: Option<String>,
+
+    /// Optional progress percentage to display (value 100 is considered 100%).
+    /// If not provided infinite progress is assumed and clients are allowed
+    /// to ignore the `percentage` value in subsequent in report notifications.
+    ///
+    /// The value should be steadily rising. Clients are free to ignore values
+    /// that are not following this rule. The value range is [0, 100]
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub percentage: Option<u32>,
+}
+
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkDoneProgressEnd {
+    /// Optional, more detailed associated progress message. Contains
+    /// complementary information to the `title`.
+    /// Examples: "3/25 files", "project/src/module2", "node_modules/some_dep".
+    /// If unset, the previous progress message (if any) is still valid.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub message: Option<String>,
+}
+
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(tag = "kind", rename_all = "lowercase")]
+pub enum WorkDoneProgress {
+    Begin(WorkDoneProgressBegin),
+    Report(WorkDoneProgressReport),
+    End(WorkDoneProgressEnd),
+}
diff --git a/crates/lsp-types/src/references.rs b/crates/lsp-types/src/references.rs
new file mode 100644
index 000000000..cb590d58e
--- /dev/null
+++ b/crates/lsp-types/src/references.rs
@@ -0,0 +1,30 @@
+use crate::{
+    DynamicRegistrationClientCapabilities, PartialResultParams, TextDocumentPositionParams,
+    WorkDoneProgressParams,
+};
+use serde::{Deserialize, Serialize};
+
+pub type ReferenceClientCapabilities = DynamicRegistrationClientCapabilities;
+#[derive(Debug, Eq, PartialEq, Clone, Copy, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ReferenceContext {
+    /// Include the declaration of the current symbol.
+    pub include_declaration: bool,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ReferenceParams {
+    // Text Document and Position fields
+    #[serde(flatten)]
+    pub text_document_position: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+
+    // ReferenceParams properties:
+    pub context: ReferenceContext,
+}
diff --git a/crates/lsp-types/src/rename.rs b/crates/lsp-types/src/rename.rs
new file mode 100644
index 000000000..bb57e9afd
--- /dev/null
+++ b/crates/lsp-types/src/rename.rs
@@ -0,0 +1,88 @@
+use crate::{Range, TextDocumentPositionParams, WorkDoneProgressOptions, WorkDoneProgressParams};
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RenameParams {
+    /// Text Document and Position fields
+    #[serde(flatten)]
+    pub text_document_position: TextDocumentPositionParams,
+
+    /// The new name of the symbol. If the given name is not valid the
+    /// request must return a [ResponseError](#ResponseError) with an
+    /// appropriate message set.
+    pub new_name: String,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RenameOptions {
+    /// Renames should be checked and tested before being executed.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub prepare_provider: Option<bool>,
+
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct RenameClientCapabilities {
+    /// Whether rename supports dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// Client supports testing for validity of rename operations before execution.
+    ///
+    /// @since 3.12.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub prepare_support: Option<bool>,
+
+    /// Client supports the default behavior result.
+    ///
+    /// The value indicates the default behavior used by the
+    /// client.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub prepare_support_default_behavior: Option<PrepareSupportDefaultBehavior>,
+
+    /// Whether the client honors the change annotations in
+    /// text edits and resource operations returned via the
+    /// rename request's workspace edit by for example presenting
+    /// the workspace edit in the user interface and asking
+    /// for confirmation.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub honors_change_annotations: Option<bool>,
+}
+
+#[derive(Eq, PartialEq, Copy, Clone, Serialize, Deserialize)]
+#[serde(transparent)]
+pub struct PrepareSupportDefaultBehavior(i32);
+lsp_enum! {
+impl PrepareSupportDefaultBehavior {
+    /// The client's default behavior is to select the identifier
+    /// according the to language's syntax rule
+    pub const IDENTIFIER: PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior(1);
+}
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+#[serde(rename_all = "camelCase")]
+pub enum PrepareRenameResponse {
+    Range(Range),
+    RangeWithPlaceholder {
+        range: Range,
+        placeholder: String,
+    },
+    #[serde(rename_all = "camelCase")]
+    DefaultBehavior {
+        default_behavior: bool,
+    },
+}
diff --git a/crates/lsp-types/src/request.rs b/crates/lsp-types/src/request.rs
new file mode 100644
index 000000000..7502546be
--- /dev/null
+++ b/crates/lsp-types/src/request.rs
@@ -0,0 +1,1068 @@
+use super::*;
+
+use serde::{de::DeserializeOwned, Serialize};
+
+pub trait Request {
+    type Params: DeserializeOwned + Serialize + Send + Sync + 'static;
+    type Result: DeserializeOwned + Serialize + Send + Sync + 'static;
+    const METHOD: &'static str;
+}
+
+#[macro_export]
+macro_rules! lsp_request {
+    ("initialize") => {
+        $crate::request::Initialize
+    };
+    ("shutdown") => {
+        $crate::request::Shutdown
+    };
+
+    ("window/showMessageRequest") => {
+        $crate::request::ShowMessageRequest
+    };
+
+    ("client/registerCapability") => {
+        $crate::request::RegisterCapability
+    };
+    ("client/unregisterCapability") => {
+        $crate::request::UnregisterCapability
+    };
+
+    ("workspace/symbol") => {
+        $crate::request::WorkspaceSymbolRequest
+    };
+    ("workspaceSymbol/resolve") => {
+        $crate::request::WorkspaceSymbolResolve
+    };
+    ("workspace/executeCommand") => {
+        $crate::request::ExecuteCommand
+    };
+
+    ("textDocument/willSaveWaitUntil") => {
+        $crate::request::WillSaveWaitUntil
+    };
+
+    ("textDocument/completion") => {
+        $crate::request::Completion
+    };
+    ("completionItem/resolve") => {
+        $crate::request::ResolveCompletionItem
+    };
+    ("textDocument/hover") => {
+        $crate::request::HoverRequest
+    };
+    ("textDocument/signatureHelp") => {
+        $crate::request::SignatureHelpRequest
+    };
+    ("textDocument/declaration") => {
+        $crate::request::GotoDeclaration
+    };
+    ("textDocument/definition") => {
+        $crate::request::GotoDefinition
+    };
+    ("textDocument/references") => {
+        $crate::request::References
+    };
+    ("textDocument/documentHighlight") => {
+        $crate::request::DocumentHighlightRequest
+    };
+    ("textDocument/documentSymbol") => {
+        $crate::request::DocumentSymbolRequest
+    };
+    ("textDocument/codeAction") => {
+        $crate::request::CodeActionRequest
+    };
+    ("textDocument/codeLens") => {
+        $crate::request::CodeLensRequest
+    };
+    ("codeLens/resolve") => {
+        $crate::request::CodeLensResolve
+    };
+    ("textDocument/documentLink") => {
+        $crate::request::DocumentLinkRequest
+    };
+    ("documentLink/resolve") => {
+        $crate::request::DocumentLinkResolve
+    };
+    ("workspace/applyEdit") => {
+        $crate::request::ApplyWorkspaceEdit
+    };
+    ("textDocument/rangeFormatting") => {
+        $crate::request::RangeFormatting
+    };
+    ("textDocument/onTypeFormatting") => {
+        $crate::request::OnTypeFormatting
+    };
+    ("textDocument/formatting") => {
+        $crate::request::Formatting
+    };
+    ("textDocument/rename") => {
+        $crate::request::Rename
+    };
+    ("textDocument/documentColor") => {
+        $crate::request::DocumentColor
+    };
+    ("textDocument/colorPresentation") => {
+        $crate::request::ColorPresentationRequest
+    };
+    ("textDocument/foldingRange") => {
+        $crate::request::FoldingRangeRequest
+    };
+    ("textDocument/prepareRename") => {
+        $crate::request::PrepareRenameRequest
+    };
+    ("textDocument/implementation") => {
+        $crate::request::GotoImplementation
+    };
+    ("textDocument/typeDefinition") => {
+        $crate::request::GotoTypeDefinition
+    };
+    ("textDocument/selectionRange") => {
+        $crate::request::SelectionRangeRequest
+    };
+    ("workspace/workspaceFolders") => {
+        $crate::request::WorkspaceFoldersRequest
+    };
+    ("workspace/configuration") => {
+        $crate::request::WorkspaceConfiguration
+    };
+    ("window/workDoneProgress/create") => {
+        $crate::request::WorkDoneProgressCreate
+    };
+    ("callHierarchy/incomingCalls") => {
+        $crate::request::CallHierarchyIncomingCalls
+    };
+    ("callHierarchy/outgoingCalls") => {
+        $crate::request::CallHierarchyOutgoingCalls
+    };
+    ("textDocument/moniker") => {
+        $crate::request::MonikerRequest
+    };
+    ("textDocument/linkedEditingRange") => {
+        $crate::request::LinkedEditingRange
+    };
+    ("textDocument/prepareCallHierarchy") => {
+        $crate::request::CallHierarchyPrepare
+    };
+    ("textDocument/prepareTypeHierarchy") => {
+        $crate::request::TypeHierarchyPrepare
+    };
+    ("textDocument/semanticTokens/full") => {
+        $crate::request::SemanticTokensFullRequest
+    };
+    ("textDocument/semanticTokens/full/delta") => {
+        $crate::request::SemanticTokensFullDeltaRequest
+    };
+    ("textDocument/semanticTokens/range") => {
+        $crate::request::SemanticTokensRangeRequest
+    };
+    ("textDocument/inlayHint") => {
+        $crate::request::InlayHintRequest
+    };
+    ("textDocument/inlineValue") => {
+        $crate::request::InlineValueRequest
+    };
+    ("textDocument/diagnostic") => {
+        $crate::request::DocumentDiagnosticRequest
+    };
+    ("workspace/diagnostic") => {
+        $crate::request::WorkspaceDiagnosticRequest
+    };
+    ("workspace/diagnostic/refresh") => {
+        $crate::request::WorkspaceDiagnosticRefresh
+    };
+    ("typeHierarchy/supertypes") => {
+        $crate::request::TypeHierarchySupertypes
+    };
+    ("typeHierarchy/subtypes") => {
+        $crate::request::TypeHierarchySubtypes
+    };
+    ("workspace/willCreateFiles") => {
+        $crate::request::WillCreateFiles
+    };
+    ("workspace/willRenameFiles") => {
+        $crate::request::WillRenameFiles
+    };
+    ("workspace/willDeleteFiles") => {
+        $crate::request::WillDeleteFiles
+    };
+    ("workspace/semanticTokens/refresh") => {
+        $crate::request::SemanticTokensRefresh
+    };
+    ("workspace/codeLens/refresh") => {
+        $crate::request::CodeLensRefresh
+    };
+    ("workspace/inlayHint/refresh") => {
+        $crate::request::InlayHintRefreshRequest
+    };
+    ("workspace/inlineValue/refresh") => {
+        $crate::request::InlineValueRefreshRequest
+    };
+    ("codeAction/resolve") => {
+        $crate::request::CodeActionResolveRequest
+    };
+    ("inlayHint/resolve") => {
+        $crate::request::InlayHintResolveRequest
+    };
+    ("window/showDocument") => {
+        $crate::request::ShowDocument
+    };
+}
+
+/// The initialize request is sent as the first request from the client to the server.
+/// If the server receives request or notification before the `initialize` request it should act as follows:
+///
+/// * for a request the respond should be errored with `code: -32001`. The message can be picked by the server.
+/// * notifications should be dropped.
+#[derive(Debug)]
+pub enum Initialize {}
+
+impl Request for Initialize {
+    type Params = InitializeParams;
+    type Result = InitializeResult;
+    const METHOD: &'static str = "initialize";
+}
+
+/// The shutdown request is sent from the client to the server. It asks the server to shut down,
+/// but to not exit (otherwise the response might not be delivered correctly to the client).
+/// There is a separate exit notification that asks the server to exit.
+#[derive(Debug)]
+pub enum Shutdown {}
+
+impl Request for Shutdown {
+    type Params = ();
+    type Result = ();
+    const METHOD: &'static str = "shutdown";
+}
+
+/// The show message request is sent from a server to a client to ask the client to display a particular message
+/// in the user interface. In addition to the show message notification the request allows to pass actions and to
+/// wait for an answer from the client.
+#[derive(Debug)]
+pub enum ShowMessageRequest {}
+
+impl Request for ShowMessageRequest {
+    type Params = ShowMessageRequestParams;
+    type Result = Option<MessageActionItem>;
+    const METHOD: &'static str = "window/showMessageRequest";
+}
+
+/// The client/registerCapability request is sent from the server to the client to register for a new capability
+/// on the client side. Not all clients need to support dynamic capability registration. A client opts in via the
+/// ClientCapabilities.GenericCapability property.
+#[derive(Debug)]
+pub enum RegisterCapability {}
+
+impl Request for RegisterCapability {
+    type Params = RegistrationParams;
+    type Result = ();
+    const METHOD: &'static str = "client/registerCapability";
+}
+
+/// The client/unregisterCapability request is sent from the server to the client to unregister a
+/// previously register capability.
+#[derive(Debug)]
+pub enum UnregisterCapability {}
+
+impl Request for UnregisterCapability {
+    type Params = UnregistrationParams;
+    type Result = ();
+    const METHOD: &'static str = "client/unregisterCapability";
+}
+
+/// The Completion request is sent from the client to the server to compute completion items at a given cursor position.
+/// Completion items are presented in the IntelliSense user interface. If computing full completion items is expensive,
+/// servers can additionally provide a handler for the completion item resolve request ('completionItem/resolve').
+/// This request is sent when a completion item is selected in the user interface. A typical use case is for example:
+/// the 'textDocument/completion' request doesnt fill in the documentation property for returned completion items
+/// since it is expensive to compute. When the item is selected in the user interface then a completionItem/resolve
+/// request is sent with the selected completion item as a param. The returned completion item should have the
+/// documentation property filled in. The request can delay the computation of the detail and documentation properties.
+/// However, properties that are needed for the initial sorting and filtering, like sortText, filterText, insertText,
+/// and textEdit must be provided in the textDocument/completion request and must not be changed during resolve.
+#[derive(Debug)]
+pub enum Completion {}
+
+impl Request for Completion {
+    type Params = CompletionParams;
+    type Result = Option<CompletionResponse>;
+    const METHOD: &'static str = "textDocument/completion";
+}
+
+/// The request is sent from the client to the server to resolve additional information for a given completion item.
+#[derive(Debug)]
+pub enum ResolveCompletionItem {}
+
+impl Request for ResolveCompletionItem {
+    type Params = CompletionItem;
+    type Result = CompletionItem;
+    const METHOD: &'static str = "completionItem/resolve";
+}
+
+/// The hover request is sent from the client to the server to request hover information at a given text
+/// document position.
+#[derive(Debug)]
+pub enum HoverRequest {}
+
+impl Request for HoverRequest {
+    type Params = HoverParams;
+    type Result = Option<Hover>;
+    const METHOD: &'static str = "textDocument/hover";
+}
+
+/// The signature help request is sent from the client to the server to request signature information at
+/// a given cursor position.
+#[derive(Debug)]
+pub enum SignatureHelpRequest {}
+
+impl Request for SignatureHelpRequest {
+    type Params = SignatureHelpParams;
+    type Result = Option<SignatureHelp>;
+    const METHOD: &'static str = "textDocument/signatureHelp";
+}
+
+#[derive(Debug)]
+pub enum GotoDeclaration {}
+pub type GotoDeclarationParams = GotoDefinitionParams;
+pub type GotoDeclarationResponse = GotoDefinitionResponse;
+
+/// The goto declaration request is sent from the client to the server to resolve the declaration location of
+/// a symbol at a given text document position.
+impl Request for GotoDeclaration {
+    type Params = GotoDeclarationParams;
+    type Result = Option<GotoDeclarationResponse>;
+    const METHOD: &'static str = "textDocument/declaration";
+}
+
+/// The goto definition request is sent from the client to the server to resolve the definition location of
+/// a symbol at a given text document position.
+#[derive(Debug)]
+pub enum GotoDefinition {}
+
+impl Request for GotoDefinition {
+    type Params = GotoDefinitionParams;
+    type Result = Option<GotoDefinitionResponse>;
+    const METHOD: &'static str = "textDocument/definition";
+}
+
+/// The references request is sent from the client to the server to resolve project-wide references for the
+/// symbol denoted by the given text document position.
+#[derive(Debug)]
+pub enum References {}
+
+impl Request for References {
+    type Params = ReferenceParams;
+    type Result = Option<Vec<Location>>;
+    const METHOD: &'static str = "textDocument/references";
+}
+
+/// The goto type definition request is sent from the client to the
+/// server to resolve the type definition location of a symbol at a
+/// given text document position.
+#[derive(Debug)]
+pub enum GotoTypeDefinition {}
+
+pub type GotoTypeDefinitionParams = GotoDefinitionParams;
+pub type GotoTypeDefinitionResponse = GotoDefinitionResponse;
+
+impl Request for GotoTypeDefinition {
+    type Params = GotoTypeDefinitionParams;
+    type Result = Option<GotoTypeDefinitionResponse>;
+    const METHOD: &'static str = "textDocument/typeDefinition";
+}
+
+/// The goto implementation request is sent from the client to the
+/// server to resolve the implementation location of a symbol at a
+/// given text document position.
+#[derive(Debug)]
+pub enum GotoImplementation {}
+
+pub type GotoImplementationParams = GotoTypeDefinitionParams;
+pub type GotoImplementationResponse = GotoDefinitionResponse;
+
+impl Request for GotoImplementation {
+    type Params = GotoImplementationParams;
+    type Result = Option<GotoImplementationResponse>;
+    const METHOD: &'static str = "textDocument/implementation";
+}
+
+/// The document highlight request is sent from the client to the server to resolve a document highlights
+/// for a given text document position.
+/// For programming languages this usually highlights all references to the symbol scoped to this file.
+/// However we kept 'textDocument/documentHighlight' and 'textDocument/references' separate requests since
+/// the first one is allowed to be more fuzzy.
+/// Symbol matches usually have a DocumentHighlightKind of Read or Write whereas fuzzy or textual matches
+/// use Text as the kind.
+#[derive(Debug)]
+pub enum DocumentHighlightRequest {}
+
+impl Request for DocumentHighlightRequest {
+    type Params = DocumentHighlightParams;
+    type Result = Option<Vec<DocumentHighlight>>;
+    const METHOD: &'static str = "textDocument/documentHighlight";
+}
+
+/// The document symbol request is sent from the client to the server to list all symbols found in a given
+/// text document.
+#[derive(Debug)]
+pub enum DocumentSymbolRequest {}
+
+impl Request for DocumentSymbolRequest {
+    type Params = DocumentSymbolParams;
+    type Result = Option<DocumentSymbolResponse>;
+    const METHOD: &'static str = "textDocument/documentSymbol";
+}
+
+/// The workspace symbol request is sent from the client to the server to list project-wide symbols
+/// matching the query string.
+#[derive(Debug)]
+pub enum WorkspaceSymbolRequest {}
+
+impl Request for WorkspaceSymbolRequest {
+    type Params = WorkspaceSymbolParams;
+    type Result = Option<WorkspaceSymbolResponse>;
+    const METHOD: &'static str = "workspace/symbol";
+}
+
+/// The `workspaceSymbol/resolve` request is sent from the client to the server to resolve
+/// additional information for a given workspace symbol.
+#[derive(Debug)]
+pub enum WorkspaceSymbolResolve {}
+
+impl Request for WorkspaceSymbolResolve {
+    type Params = WorkspaceSymbol;
+    type Result = WorkspaceSymbol;
+    const METHOD: &'static str = "workspaceSymbol/resolve";
+}
+
+/// The workspace/executeCommand request is sent from the client to the server to trigger command execution on the server.
+/// In most cases the server creates a WorkspaceEdit structure and applies the changes to the workspace using the request
+/// workspace/applyEdit which is sent from the server to the client.
+#[derive(Debug)]
+pub enum ExecuteCommand {}
+
+impl Request for ExecuteCommand {
+    type Params = ExecuteCommandParams;
+    type Result = Option<Value>;
+    const METHOD: &'static str = "workspace/executeCommand";
+}
+
+/// The document will save request is sent from the client to the server before the document is
+/// actually saved. The request can return an array of TextEdits which will be applied to the text
+/// document before it is saved. Please note that clients might drop results if computing the text
+/// edits took too long or if a server constantly fails on this request. This is done to keep the
+/// save fast and reliable.
+#[derive(Debug)]
+pub enum WillSaveWaitUntil {}
+
+impl Request for WillSaveWaitUntil {
+    type Params = WillSaveTextDocumentParams;
+    type Result = Option<Vec<TextEdit>>;
+    const METHOD: &'static str = "textDocument/willSaveWaitUntil";
+}
+
+/// The workspace/applyEdit request is sent from the server to the client to modify resource on the
+/// client side.
+#[derive(Debug)]
+pub enum ApplyWorkspaceEdit {}
+
+impl Request for ApplyWorkspaceEdit {
+    type Params = ApplyWorkspaceEditParams;
+    type Result = ApplyWorkspaceEditResponse;
+    const METHOD: &'static str = "workspace/applyEdit";
+}
+
+/// The workspace/configuration request is sent from the server to the client to fetch configuration settings
+/// from the client. The request can fetch several configuration settings in one roundtrip.
+/// The order of the returned configuration settings correspond to the order of the passed ConfigurationItems
+/// (e.g. the first item in the response is the result for the first configuration item in the params).
+///
+/// A ConfigurationItem consists of the configuration section to ask for and an additional scope URI.
+/// The configuration section ask for is defined by the server and doesnt necessarily need to correspond to
+/// the configuration store used be the client. So a server might ask for a configuration cpp.formatterOptions
+/// but the client stores the configuration in a XML store layout differently.
+/// It is up to the client to do the necessary conversion. If a scope URI is provided the client should return
+/// the setting scoped to the provided resource. If the client for example uses EditorConfig to manage its
+/// settings the configuration should be returned for the passed resource URI. If the client cant provide a
+/// configuration setting for a given scope then null need to be present in the returned array.
+#[derive(Debug)]
+pub enum WorkspaceConfiguration {}
+
+impl Request for WorkspaceConfiguration {
+    type Params = ConfigurationParams;
+    type Result = Vec<Value>;
+    const METHOD: &'static str = "workspace/configuration";
+}
+
+/// The code action request is sent from the client to the server to compute commands for a given text document
+/// and range. The request is triggered when the user moves the cursor into a problem marker in the editor or
+/// presses the lightbulb associated with a marker.
+#[derive(Debug)]
+pub enum CodeActionRequest {}
+
+impl Request for CodeActionRequest {
+    type Params = CodeActionParams;
+    type Result = Option<CodeActionResponse>;
+    const METHOD: &'static str = "textDocument/codeAction";
+}
+
+/// The request is sent from the client to the server to resolve additional information for a given code action.
+/// This is usually used to compute the `edit` property of a code action to avoid its unnecessary computation
+/// during the `textDocument/codeAction` request.
+///
+/// @since 3.16.0
+#[derive(Debug)]
+pub enum CodeActionResolveRequest {}
+
+impl Request for CodeActionResolveRequest {
+    type Params = CodeAction;
+    type Result = CodeAction;
+    const METHOD: &'static str = "codeAction/resolve";
+}
+
+/// The code lens request is sent from the client to the server to compute code lenses for a given text document.
+#[derive(Debug)]
+pub enum CodeLensRequest {}
+
+impl Request for CodeLensRequest {
+    type Params = CodeLensParams;
+    type Result = Option<Vec<CodeLens>>;
+    const METHOD: &'static str = "textDocument/codeLens";
+}
+
+/// The code lens resolve request is sent from the client to the server to resolve the command for a
+/// given code lens item.
+#[derive(Debug)]
+pub enum CodeLensResolve {}
+
+impl Request for CodeLensResolve {
+    type Params = CodeLens;
+    type Result = CodeLens;
+    const METHOD: &'static str = "codeLens/resolve";
+}
+
+/// The document links request is sent from the client to the server to request the location of links in a document.
+#[derive(Debug)]
+pub enum DocumentLinkRequest {}
+
+impl Request for DocumentLinkRequest {
+    type Params = DocumentLinkParams;
+    type Result = Option<Vec<DocumentLink>>;
+    const METHOD: &'static str = "textDocument/documentLink";
+}
+
+/// The document link resolve request is sent from the client to the server to resolve the target of
+/// a given document link.
+#[derive(Debug)]
+pub enum DocumentLinkResolve {}
+
+impl Request for DocumentLinkResolve {
+    type Params = DocumentLink;
+    type Result = DocumentLink;
+    const METHOD: &'static str = "documentLink/resolve";
+}
+
+/// The document formatting request is sent from the server to the client to format a whole document.
+#[derive(Debug)]
+pub enum Formatting {}
+
+impl Request for Formatting {
+    type Params = DocumentFormattingParams;
+    type Result = Option<Vec<TextEdit>>;
+    const METHOD: &'static str = "textDocument/formatting";
+}
+
+/// The document range formatting request is sent from the client to the server to format a given range in a document.
+#[derive(Debug)]
+pub enum RangeFormatting {}
+
+impl Request for RangeFormatting {
+    type Params = DocumentRangeFormattingParams;
+    type Result = Option<Vec<TextEdit>>;
+    const METHOD: &'static str = "textDocument/rangeFormatting";
+}
+
+/// The document on type formatting request is sent from the client to the server to format parts of
+/// the document during typing.
+#[derive(Debug)]
+pub enum OnTypeFormatting {}
+
+impl Request for OnTypeFormatting {
+    type Params = DocumentOnTypeFormattingParams;
+    type Result = Option<Vec<TextEdit>>;
+    const METHOD: &'static str = "textDocument/onTypeFormatting";
+}
+
+/// The linked editing request is sent from the client to the server to return for a given position in a document
+/// the range of the symbol at the position and all ranges that have the same content.
+/// Optionally a word pattern can be returned to describe valid contents. A rename to one of the ranges can be applied
+/// to all other ranges if the new content is valid. If no result-specific word pattern is provided, the word pattern from
+/// the clients language configuration is used.
+#[derive(Debug)]
+pub enum LinkedEditingRange {}
+
+impl Request for LinkedEditingRange {
+    type Params = LinkedEditingRangeParams;
+    type Result = Option<LinkedEditingRanges>;
+    const METHOD: &'static str = "textDocument/linkedEditingRange";
+}
+
+/// The rename request is sent from the client to the server to perform a workspace-wide rename of a symbol.
+#[derive(Debug)]
+pub enum Rename {}
+
+impl Request for Rename {
+    type Params = RenameParams;
+    type Result = Option<WorkspaceEdit>;
+    const METHOD: &'static str = "textDocument/rename";
+}
+
+/// The document color request is sent from the client to the server to list all color references found in a given text document.
+/// Along with the range, a color value in RGB is returned.
+#[derive(Debug)]
+pub enum DocumentColor {}
+
+impl Request for DocumentColor {
+    type Params = DocumentColorParams;
+    type Result = Vec<ColorInformation>;
+    const METHOD: &'static str = "textDocument/documentColor";
+}
+
+/// The color presentation request is sent from the client to the server to obtain a list of presentations for a color value
+/// at a given location.
+#[derive(Debug)]
+pub enum ColorPresentationRequest {}
+
+impl Request for ColorPresentationRequest {
+    type Params = ColorPresentationParams;
+    type Result = Vec<ColorPresentation>;
+    const METHOD: &'static str = "textDocument/colorPresentation";
+}
+
+/// The folding range request is sent from the client to the server to return all folding ranges found in a given text document.
+#[derive(Debug)]
+pub enum FoldingRangeRequest {}
+
+impl Request for FoldingRangeRequest {
+    type Params = FoldingRangeParams;
+    type Result = Option<Vec<FoldingRange>>;
+    const METHOD: &'static str = "textDocument/foldingRange";
+}
+
+/// The prepare rename request is sent from the client to the server to setup and test the validity of a rename operation
+/// at a given location.
+#[derive(Debug)]
+pub enum PrepareRenameRequest {}
+
+impl Request for PrepareRenameRequest {
+    type Params = TextDocumentPositionParams;
+    type Result = Option<PrepareRenameResponse>;
+    const METHOD: &'static str = "textDocument/prepareRename";
+}
+
+#[derive(Debug)]
+#[cfg(feature = "proposed")]
+pub enum InlineCompletionRequest {}
+
+#[cfg(feature = "proposed")]
+impl Request for InlineCompletionRequest {
+    type Params = InlineCompletionParams;
+    type Result = Option<InlineCompletionResponse>;
+    const METHOD: &'static str = "textDocument/inlineCompletion";
+}
+
+/// The workspace/workspaceFolders request is sent from the server to the client to fetch the current open list of
+/// workspace folders. Returns null in the response if only a single file is open in the tool.
+/// Returns an empty array if a workspace is open but no folders are configured.
+#[derive(Debug)]
+pub enum WorkspaceFoldersRequest {}
+
+impl Request for WorkspaceFoldersRequest {
+    type Params = ();
+    type Result = Option<Vec<WorkspaceFolder>>;
+    const METHOD: &'static str = "workspace/workspaceFolders";
+}
+
+/// The `window/workDoneProgress/create` request is sent from the server
+/// to the client to ask the client to create a work done progress.
+#[derive(Debug)]
+pub enum WorkDoneProgressCreate {}
+
+impl Request for WorkDoneProgressCreate {
+    type Params = WorkDoneProgressCreateParams;
+    type Result = ();
+    const METHOD: &'static str = "window/workDoneProgress/create";
+}
+
+/// The selection range request is sent from the client to the server to return
+/// suggested selection ranges at given positions. A selection range is a range
+/// around the cursor position which the user might be interested in selecting.
+///
+/// A selection range in the return array is for the position in the provided parameters at the same index.
+/// Therefore `positions[i]` must be contained in `result[i].range`.
+///
+/// Typically, but not necessary, selection ranges correspond to the nodes of the
+/// syntax tree.
+pub enum SelectionRangeRequest {}
+
+impl Request for SelectionRangeRequest {
+    type Params = SelectionRangeParams;
+    type Result = Option<Vec<SelectionRange>>;
+    const METHOD: &'static str = "textDocument/selectionRange";
+}
+
+pub enum CallHierarchyPrepare {}
+
+impl Request for CallHierarchyPrepare {
+    type Params = CallHierarchyPrepareParams;
+    type Result = Option<Vec<CallHierarchyItem>>;
+    const METHOD: &'static str = "textDocument/prepareCallHierarchy";
+}
+
+pub enum CallHierarchyIncomingCalls {}
+
+impl Request for CallHierarchyIncomingCalls {
+    type Params = CallHierarchyIncomingCallsParams;
+    type Result = Option<Vec<CallHierarchyIncomingCall>>;
+    const METHOD: &'static str = "callHierarchy/incomingCalls";
+}
+
+pub enum CallHierarchyOutgoingCalls {}
+
+impl Request for CallHierarchyOutgoingCalls {
+    type Params = CallHierarchyOutgoingCallsParams;
+    type Result = Option<Vec<CallHierarchyOutgoingCall>>;
+    const METHOD: &'static str = "callHierarchy/outgoingCalls";
+}
+
+pub enum SemanticTokensFullRequest {}
+
+impl Request for SemanticTokensFullRequest {
+    type Params = SemanticTokensParams;
+    type Result = Option<SemanticTokensResult>;
+    const METHOD: &'static str = "textDocument/semanticTokens/full";
+}
+
+pub enum SemanticTokensFullDeltaRequest {}
+
+impl Request for SemanticTokensFullDeltaRequest {
+    type Params = SemanticTokensDeltaParams;
+    type Result = Option<SemanticTokensFullDeltaResult>;
+    const METHOD: &'static str = "textDocument/semanticTokens/full/delta";
+}
+
+pub enum SemanticTokensRangeRequest {}
+
+impl Request for SemanticTokensRangeRequest {
+    type Params = SemanticTokensRangeParams;
+    type Result = Option<SemanticTokensRangeResult>;
+    const METHOD: &'static str = "textDocument/semanticTokens/range";
+}
+
+/// The `workspace/semanticTokens/refresh` request is sent from the server to the client.
+/// Servers can use it to ask clients to refresh the editors for which this server provides semantic tokens.
+/// As a result the client should ask the server to recompute the semantic tokens for these editors.
+/// This is useful if a server detects a project wide configuration change which requires a re-calculation of all semantic tokens.
+/// Note that the client still has the freedom to delay the re-calculation of the semantic tokens if for example an editor is currently not visible.
+pub enum SemanticTokensRefresh {}
+
+impl Request for SemanticTokensRefresh {
+    type Params = ();
+    type Result = ();
+    const METHOD: &'static str = "workspace/semanticTokens/refresh";
+}
+
+/// The workspace/codeLens/refresh request is sent from the server to the client.
+/// Servers can use it to ask clients to refresh the code lenses currently shown in editors.
+/// As a result the client should ask the server to recompute the code lenses for these editors.
+/// This is useful if a server detects a configuration change which requires a re-calculation of all code lenses.
+/// Note that the client still has the freedom to delay the re-calculation of the code lenses if for example an editor is currently not visible.
+pub enum CodeLensRefresh {}
+
+impl Request for CodeLensRefresh {
+    type Params = ();
+    type Result = ();
+    const METHOD: &'static str = "workspace/codeLens/refresh";
+}
+
+/// The will create files request is sent from the client to the server before files are actually created as long as the creation is triggered from within the client. The request can return a WorkspaceEdit which will be applied to workspace before the files are created. Please note that clients might drop results if computing the edit took too long or if a server constantly fails on this request. This is done to keep creates fast and reliable.
+pub enum WillCreateFiles {}
+
+impl Request for WillCreateFiles {
+    type Params = CreateFilesParams;
+    type Result = Option<WorkspaceEdit>;
+    const METHOD: &'static str = "workspace/willCreateFiles";
+}
+
+/// The will rename files request is sent from the client to the server before files are actually renamed as long as the rename is triggered from within the client. The request can return a WorkspaceEdit which will be applied to workspace before the files are renamed. Please note that clients might drop results if computing the edit took too long or if a server constantly fails on this request. This is done to keep renames fast and reliable.
+pub enum WillRenameFiles {}
+
+impl Request for WillRenameFiles {
+    type Params = RenameFilesParams;
+    type Result = Option<WorkspaceEdit>;
+    const METHOD: &'static str = "workspace/willRenameFiles";
+}
+
+/// The will delete files request is sent from the client to the server before files are actually deleted as long as the deletion is triggered from within the client. The request can return a WorkspaceEdit which will be applied to workspace before the files are deleted. Please note that clients might drop results if computing the edit took too long or if a server constantly fails on this request. This is done to keep deletes fast and reliable.
+pub enum WillDeleteFiles {}
+
+impl Request for WillDeleteFiles {
+    type Params = DeleteFilesParams;
+    type Result = Option<WorkspaceEdit>;
+    const METHOD: &'static str = "workspace/willDeleteFiles";
+}
+
+/// The show document request is sent from a server to a client to ask the client to display a particular document in the user interface.
+pub enum ShowDocument {}
+
+impl Request for ShowDocument {
+    type Params = ShowDocumentParams;
+    type Result = ShowDocumentResult;
+    const METHOD: &'static str = "window/showDocument";
+}
+
+pub enum MonikerRequest {}
+
+impl Request for MonikerRequest {
+    type Params = MonikerParams;
+    type Result = Option<Vec<Moniker>>;
+    const METHOD: &'static str = "textDocument/moniker";
+}
+
+/// The inlay hints request is sent from the client to the server to compute inlay hints for a given
+/// [text document, range] tuple that may be rendered in the editor in place with other text.
+pub enum InlayHintRequest {}
+
+impl Request for InlayHintRequest {
+    type Params = InlayHintParams;
+    type Result = Option<Vec<InlayHint>>;
+    const METHOD: &'static str = "textDocument/inlayHint";
+}
+
+/// The `inlayHint/resolve` request is sent from the client to the server to resolve additional
+/// information for a given inlay hint. This is usually used to compute the tooltip, location or
+/// command properties of a inlay hints label part to avoid its unnecessary computation during the
+/// `textDocument/inlayHint` request.
+pub enum InlayHintResolveRequest {}
+
+impl Request for InlayHintResolveRequest {
+    type Params = InlayHint;
+    type Result = InlayHint;
+    const METHOD: &'static str = "inlayHint/resolve";
+}
+
+/// The `workspace/inlayHint/refresh` request is sent from the server to the client. Servers can use
+/// it to ask clients to refresh the inlay hints currently shown in editors. As a result the client
+/// should ask the server to recompute the inlay hints for these editors. This is useful if a server
+/// detects a configuration change which requires a re-calculation of all inlay hints. Note that the
+/// client still has the freedom to delay the re-calculation of the inlay hints if for example an
+/// editor is currently not visible.
+pub enum InlayHintRefreshRequest {}
+
+impl Request for InlayHintRefreshRequest {
+    type Params = ();
+    type Result = ();
+    const METHOD: &'static str = "workspace/inlayHint/refresh";
+}
+
+/// The inline value request is sent from the client to the server to compute inline values for a
+/// given text document that may be rendered in the editor at the end of lines.
+pub enum InlineValueRequest {}
+
+impl Request for InlineValueRequest {
+    type Params = InlineValueParams;
+    type Result = Option<InlineValue>;
+    const METHOD: &'static str = "textDocument/inlineValue";
+}
+
+/// The `workspace/inlineValue/refresh` request is sent from the server to the client. Servers can
+/// use it to ask clients to refresh the inline values currently shown in editors. As a result the
+/// client should ask the server to recompute the inline values for these editors. This is useful if
+/// a server detects a configuration change which requires a re-calculation of all inline values.
+/// Note that the client still has the freedom to delay the re-calculation of the inline values if
+/// for example an editor is currently not visible.
+pub enum InlineValueRefreshRequest {}
+
+impl Request for InlineValueRefreshRequest {
+    type Params = ();
+    type Result = ();
+    const METHOD: &'static str = "workspace/inlineValue/refresh";
+}
+
+/// The text document diagnostic request is sent from the client to the server to ask the server to
+/// compute the diagnostics for a given document. As with other pull requests the server is asked
+/// to compute the diagnostics for the currently synced version of the document.
+#[derive(Debug)]
+pub enum DocumentDiagnosticRequest {}
+
+impl Request for DocumentDiagnosticRequest {
+    type Params = DocumentDiagnosticParams;
+    type Result = DocumentDiagnosticReportResult;
+    const METHOD: &'static str = "textDocument/diagnostic";
+}
+
+/// The workspace diagnostic request is sent from the client to the server to ask the server to
+/// compute workspace wide diagnostics which previously where pushed from the server to the client.
+/// In contrast to the document diagnostic request the workspace request can be long running and is
+/// not bound to a specific workspace or document state. If the client supports streaming for the
+/// workspace diagnostic pull it is legal to provide a document diagnostic report multiple times
+/// for the same document URI. The last one reported will win over previous reports.
+#[derive(Debug)]
+pub enum WorkspaceDiagnosticRequest {}
+
+impl Request for WorkspaceDiagnosticRequest {
+    type Params = WorkspaceDiagnosticParams;
+    const METHOD: &'static str = "workspace/diagnostic";
+    type Result = WorkspaceDiagnosticReportResult;
+}
+
+/// The `workspace/diagnostic/refresh` request is sent from the server to the client. Servers can
+/// use it to ask clients to refresh all needed document and workspace diagnostics. This is useful
+/// if a server detects a project wide configuration change which requires a re-calculation of all
+/// diagnostics.
+#[derive(Debug)]
+pub enum WorkspaceDiagnosticRefresh {}
+
+impl Request for WorkspaceDiagnosticRefresh {
+    type Params = ();
+    type Result = ();
+    const METHOD: &'static str = "workspace/diagnostic/refresh";
+}
+
+/// The type hierarchy request is sent from the client to the server to return a type hierarchy for
+/// the language element of given text document positions. Will return null if the server couldnt
+/// infer a valid type from the position. The type hierarchy requests are executed in two steps:
+///
+/// 1. first a type hierarchy item is prepared for the given text document position.
+/// 2. for a type hierarchy item the supertype or subtype type hierarchy items are resolved.
+pub enum TypeHierarchyPrepare {}
+
+impl Request for TypeHierarchyPrepare {
+    type Params = TypeHierarchyPrepareParams;
+    type Result = Option<Vec<TypeHierarchyItem>>;
+    const METHOD: &'static str = "textDocument/prepareTypeHierarchy";
+}
+
+/// The `typeHierarchy/supertypes` request is sent from the client to the server to resolve the
+/// supertypes for a given type hierarchy item. Will return null if the server couldnt infer a
+/// valid type from item in the params. The request doesnt define its own client and server
+/// capabilities. It is only issued if a server registers for the
+/// `textDocument/prepareTypeHierarchy` request.
+pub enum TypeHierarchySupertypes {}
+
+impl Request for TypeHierarchySupertypes {
+    type Params = TypeHierarchySupertypesParams;
+    type Result = Option<Vec<TypeHierarchyItem>>;
+    const METHOD: &'static str = "typeHierarchy/supertypes";
+}
+
+/// The `typeHierarchy/subtypes` request is sent from the client to the server to resolve the
+/// subtypes for a given type hierarchy item. Will return null if the server couldnt infer a valid
+/// type from item in the params. The request doesnt define its own client and server capabilities.
+/// It is only issued if a server registers for the textDocument/prepareTypeHierarchy request.
+pub enum TypeHierarchySubtypes {}
+
+impl Request for TypeHierarchySubtypes {
+    type Params = TypeHierarchySubtypesParams;
+    type Result = Option<Vec<TypeHierarchyItem>>;
+    const METHOD: &'static str = "typeHierarchy/subtypes";
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    fn fake_call<R>()
+    where
+        R: Request,
+        R::Params: serde::Serialize,
+        R::Result: serde::de::DeserializeOwned,
+    {
+    }
+
+    macro_rules! check_macro {
+        ($name:tt) => {
+            // check whether the macro name matches the method
+            assert_eq!(<lsp_request!($name) as Request>::METHOD, $name);
+            // test whether type checking passes for each component
+            fake_call::<lsp_request!($name)>();
+        };
+    }
+
+    #[test]
+    fn check_macro_definitions() {
+        check_macro!("initialize");
+        check_macro!("shutdown");
+
+        check_macro!("window/showDocument");
+        check_macro!("window/showMessageRequest");
+        check_macro!("window/workDoneProgress/create");
+
+        check_macro!("client/registerCapability");
+        check_macro!("client/unregisterCapability");
+
+        check_macro!("textDocument/willSaveWaitUntil");
+        check_macro!("textDocument/completion");
+        check_macro!("textDocument/hover");
+        check_macro!("textDocument/signatureHelp");
+        check_macro!("textDocument/declaration");
+        check_macro!("textDocument/definition");
+        check_macro!("textDocument/references");
+        check_macro!("textDocument/documentHighlight");
+        check_macro!("textDocument/documentSymbol");
+        check_macro!("textDocument/codeAction");
+        check_macro!("textDocument/codeLens");
+        check_macro!("textDocument/documentLink");
+        check_macro!("textDocument/rangeFormatting");
+        check_macro!("textDocument/onTypeFormatting");
+        check_macro!("textDocument/formatting");
+        check_macro!("textDocument/rename");
+        check_macro!("textDocument/documentColor");
+        check_macro!("textDocument/colorPresentation");
+        check_macro!("textDocument/foldingRange");
+        check_macro!("textDocument/prepareRename");
+        check_macro!("textDocument/implementation");
+        check_macro!("textDocument/selectionRange");
+        check_macro!("textDocument/typeDefinition");
+        check_macro!("textDocument/moniker");
+        check_macro!("textDocument/linkedEditingRange");
+        check_macro!("textDocument/prepareCallHierarchy");
+        check_macro!("textDocument/prepareTypeHierarchy");
+        check_macro!("textDocument/semanticTokens/full");
+        check_macro!("textDocument/semanticTokens/full/delta");
+        check_macro!("textDocument/semanticTokens/range");
+        check_macro!("textDocument/inlayHint");
+        check_macro!("textDocument/inlineValue");
+        check_macro!("textDocument/diagnostic");
+
+        check_macro!("workspace/applyEdit");
+        check_macro!("workspace/symbol");
+        check_macro!("workspace/executeCommand");
+        check_macro!("workspace/configuration");
+        check_macro!("workspace/diagnostic");
+        check_macro!("workspace/diagnostic/refresh");
+        check_macro!("workspace/willCreateFiles");
+        check_macro!("workspace/willRenameFiles");
+        check_macro!("workspace/willDeleteFiles");
+        check_macro!("workspace/workspaceFolders");
+        check_macro!("workspace/semanticTokens/refresh");
+        check_macro!("workspace/codeLens/refresh");
+        check_macro!("workspace/inlayHint/refresh");
+        check_macro!("workspace/inlineValue/refresh");
+
+        check_macro!("callHierarchy/incomingCalls");
+        check_macro!("callHierarchy/outgoingCalls");
+        check_macro!("codeAction/resolve");
+        check_macro!("codeLens/resolve");
+        check_macro!("completionItem/resolve");
+        check_macro!("documentLink/resolve");
+        check_macro!("inlayHint/resolve");
+        check_macro!("typeHierarchy/subtypes");
+        check_macro!("typeHierarchy/supertypes");
+        check_macro!("workspaceSymbol/resolve");
+    }
+
+    #[test]
+    #[cfg(feature = "proposed")]
+    fn check_proposed_macro_definitions() {}
+}
diff --git a/crates/lsp-types/src/selection_range.rs b/crates/lsp-types/src/selection_range.rs
new file mode 100644
index 000000000..048df6f99
--- /dev/null
+++ b/crates/lsp-types/src/selection_range.rs
@@ -0,0 +1,86 @@
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    PartialResultParams, Position, Range, StaticTextDocumentRegistrationOptions,
+    TextDocumentIdentifier, WorkDoneProgressOptions, WorkDoneProgressParams,
+};
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SelectionRangeClientCapabilities {
+    /// Whether implementation supports dynamic registration for selection range
+    /// providers. If this is set to `true` the client supports the new
+    /// `SelectionRangeRegistrationOptions` return value for the corresponding
+    /// server capability as well.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct SelectionRangeOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct SelectionRangeRegistrationOptions {
+    #[serde(flatten)]
+    pub selection_range_options: SelectionRangeOptions,
+
+    #[serde(flatten)]
+    pub registration_options: StaticTextDocumentRegistrationOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum SelectionRangeProviderCapability {
+    Simple(bool),
+    Options(SelectionRangeOptions),
+    RegistrationOptions(SelectionRangeRegistrationOptions),
+}
+
+impl From<SelectionRangeRegistrationOptions> for SelectionRangeProviderCapability {
+    fn from(from: SelectionRangeRegistrationOptions) -> Self {
+        Self::RegistrationOptions(from)
+    }
+}
+
+impl From<SelectionRangeOptions> for SelectionRangeProviderCapability {
+    fn from(from: SelectionRangeOptions) -> Self {
+        Self::Options(from)
+    }
+}
+
+impl From<bool> for SelectionRangeProviderCapability {
+    fn from(from: bool) -> Self {
+        Self::Simple(from)
+    }
+}
+
+/// A parameter literal used in selection range requests.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SelectionRangeParams {
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The positions inside the text document.
+    pub positions: Vec<Position>,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// Represents a selection range.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SelectionRange {
+    /// Range of the selection.
+    pub range: Range,
+
+    /// The parent selection range containing this range.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub parent: Option<Box<SelectionRange>>,
+}
diff --git a/crates/lsp-types/src/semantic_tokens.rs b/crates/lsp-types/src/semantic_tokens.rs
new file mode 100644
index 000000000..842558bac
--- /dev/null
+++ b/crates/lsp-types/src/semantic_tokens.rs
@@ -0,0 +1,734 @@
+use std::borrow::Cow;
+
+use serde::ser::SerializeSeq;
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    PartialResultParams, Range, StaticRegistrationOptions, TextDocumentIdentifier,
+    TextDocumentRegistrationOptions, WorkDoneProgressOptions, WorkDoneProgressParams,
+};
+/// A set of predefined token types. This set is not fixed
+/// and clients can specify additional token types via the
+/// corresponding client capabilities.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Hash, PartialOrd, Clone, Deserialize, Serialize)]
+pub struct SemanticTokenType(Cow<'static, str>);
+
+impl SemanticTokenType {
+    pub const NAMESPACE: SemanticTokenType = SemanticTokenType::new("namespace");
+    pub const TYPE: SemanticTokenType = SemanticTokenType::new("type");
+    pub const CLASS: SemanticTokenType = SemanticTokenType::new("class");
+    pub const ENUM: SemanticTokenType = SemanticTokenType::new("enum");
+    pub const INTERFACE: SemanticTokenType = SemanticTokenType::new("interface");
+    pub const STRUCT: SemanticTokenType = SemanticTokenType::new("struct");
+    pub const TYPE_PARAMETER: SemanticTokenType = SemanticTokenType::new("typeParameter");
+    pub const PARAMETER: SemanticTokenType = SemanticTokenType::new("parameter");
+    pub const VARIABLE: SemanticTokenType = SemanticTokenType::new("variable");
+    pub const PROPERTY: SemanticTokenType = SemanticTokenType::new("property");
+    pub const ENUM_MEMBER: SemanticTokenType = SemanticTokenType::new("enumMember");
+    pub const EVENT: SemanticTokenType = SemanticTokenType::new("event");
+    pub const FUNCTION: SemanticTokenType = SemanticTokenType::new("function");
+    pub const METHOD: SemanticTokenType = SemanticTokenType::new("method");
+    pub const MACRO: SemanticTokenType = SemanticTokenType::new("macro");
+    pub const KEYWORD: SemanticTokenType = SemanticTokenType::new("keyword");
+    pub const MODIFIER: SemanticTokenType = SemanticTokenType::new("modifier");
+    pub const COMMENT: SemanticTokenType = SemanticTokenType::new("comment");
+    pub const STRING: SemanticTokenType = SemanticTokenType::new("string");
+    pub const NUMBER: SemanticTokenType = SemanticTokenType::new("number");
+    pub const REGEXP: SemanticTokenType = SemanticTokenType::new("regexp");
+    pub const OPERATOR: SemanticTokenType = SemanticTokenType::new("operator");
+
+    /// @since 3.17.0
+    pub const DECORATOR: SemanticTokenType = SemanticTokenType::new("decorator");
+
+    pub const fn new(tag: &'static str) -> Self {
+        SemanticTokenType(Cow::Borrowed(tag))
+    }
+
+    pub fn as_str(&self) -> &str {
+        &self.0
+    }
+}
+
+impl From<String> for SemanticTokenType {
+    fn from(from: String) -> Self {
+        SemanticTokenType(Cow::from(from))
+    }
+}
+
+impl From<&'static str> for SemanticTokenType {
+    fn from(from: &'static str) -> Self {
+        SemanticTokenType::new(from)
+    }
+}
+
+/// A set of predefined token modifiers. This set is not fixed
+/// and clients can specify additional token types via the
+/// corresponding client capabilities.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Hash, PartialOrd, Clone, Deserialize, Serialize)]
+pub struct SemanticTokenModifier(Cow<'static, str>);
+
+impl SemanticTokenModifier {
+    pub const DECLARATION: SemanticTokenModifier = SemanticTokenModifier::new("declaration");
+    pub const DEFINITION: SemanticTokenModifier = SemanticTokenModifier::new("definition");
+    pub const READONLY: SemanticTokenModifier = SemanticTokenModifier::new("readonly");
+    pub const STATIC: SemanticTokenModifier = SemanticTokenModifier::new("static");
+    pub const DEPRECATED: SemanticTokenModifier = SemanticTokenModifier::new("deprecated");
+    pub const ABSTRACT: SemanticTokenModifier = SemanticTokenModifier::new("abstract");
+    pub const ASYNC: SemanticTokenModifier = SemanticTokenModifier::new("async");
+    pub const MODIFICATION: SemanticTokenModifier = SemanticTokenModifier::new("modification");
+    pub const DOCUMENTATION: SemanticTokenModifier = SemanticTokenModifier::new("documentation");
+    pub const DEFAULT_LIBRARY: SemanticTokenModifier = SemanticTokenModifier::new("defaultLibrary");
+
+    pub const fn new(tag: &'static str) -> Self {
+        SemanticTokenModifier(Cow::Borrowed(tag))
+    }
+
+    pub fn as_str(&self) -> &str {
+        &self.0
+    }
+}
+
+impl From<String> for SemanticTokenModifier {
+    fn from(from: String) -> Self {
+        SemanticTokenModifier(Cow::from(from))
+    }
+}
+
+impl From<&'static str> for SemanticTokenModifier {
+    fn from(from: &'static str) -> Self {
+        SemanticTokenModifier::new(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Hash, PartialOrd, Clone, Deserialize, Serialize)]
+pub struct TokenFormat(Cow<'static, str>);
+
+impl TokenFormat {
+    pub const RELATIVE: TokenFormat = TokenFormat::new("relative");
+
+    pub const fn new(tag: &'static str) -> Self {
+        TokenFormat(Cow::Borrowed(tag))
+    }
+
+    pub fn as_str(&self) -> &str {
+        &self.0
+    }
+}
+
+impl From<String> for TokenFormat {
+    fn from(from: String) -> Self {
+        TokenFormat(Cow::from(from))
+    }
+}
+
+impl From<&'static str> for TokenFormat {
+    fn from(from: &'static str) -> Self {
+        TokenFormat::new(from)
+    }
+}
+
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensLegend {
+    /// The token types a server uses.
+    pub token_types: Vec<SemanticTokenType>,
+
+    /// The token modifiers a server uses.
+    pub token_modifiers: Vec<SemanticTokenModifier>,
+}
+
+/// The actual tokens.
+#[derive(Debug, Eq, PartialEq, Copy, Clone, Default)]
+pub struct SemanticToken {
+    pub delta_line: u32,
+    pub delta_start: u32,
+    pub length: u32,
+    pub token_type: u32,
+    pub token_modifiers_bitset: u32,
+}
+
+impl SemanticToken {
+    fn deserialize_tokens<'de, D>(deserializer: D) -> Result<Vec<SemanticToken>, D::Error>
+    where
+        D: serde::Deserializer<'de>,
+    {
+        let data = Vec::<u32>::deserialize(deserializer)?;
+        let chunks = data.chunks_exact(5);
+
+        if !chunks.remainder().is_empty() {
+            return Result::Err(serde::de::Error::custom("Length is not divisible by 5"));
+        }
+
+        Result::Ok(
+            chunks
+                .map(|chunk| SemanticToken {
+                    delta_line: chunk[0],
+                    delta_start: chunk[1],
+                    length: chunk[2],
+                    token_type: chunk[3],
+                    token_modifiers_bitset: chunk[4],
+                })
+                .collect(),
+        )
+    }
+
+    fn serialize_tokens<S>(tokens: &[SemanticToken], serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        let mut seq = serializer.serialize_seq(Some(tokens.len() * 5))?;
+        for token in tokens.iter() {
+            seq.serialize_element(&token.delta_line)?;
+            seq.serialize_element(&token.delta_start)?;
+            seq.serialize_element(&token.length)?;
+            seq.serialize_element(&token.token_type)?;
+            seq.serialize_element(&token.token_modifiers_bitset)?;
+        }
+        seq.end()
+    }
+
+    fn deserialize_tokens_opt<'de, D>(
+        deserializer: D,
+    ) -> Result<Option<Vec<SemanticToken>>, D::Error>
+    where
+        D: serde::Deserializer<'de>,
+    {
+        #[derive(Deserialize)]
+        #[serde(transparent)]
+        struct Wrapper {
+            #[serde(deserialize_with = "SemanticToken::deserialize_tokens")]
+            tokens: Vec<SemanticToken>,
+        }
+
+        Ok(Option::<Wrapper>::deserialize(deserializer)?.map(|wrapper| wrapper.tokens))
+    }
+
+    fn serialize_tokens_opt<S>(
+        data: &Option<Vec<SemanticToken>>,
+        serializer: S,
+    ) -> Result<S::Ok, S::Error>
+    where
+        S: serde::Serializer,
+    {
+        #[derive(Serialize)]
+        #[serde(transparent)]
+        struct Wrapper {
+            #[serde(serialize_with = "SemanticToken::serialize_tokens")]
+            tokens: Vec<SemanticToken>,
+        }
+
+        let opt = data.as_ref().map(|t| Wrapper { tokens: t.to_vec() });
+
+        opt.serialize(serializer)
+    }
+}
+
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokens {
+    /// An optional result id. If provided and clients support delta updating
+    /// the client will include the result id in the next semantic token request.
+    /// A server can then instead of computing all semantic tokens again simply
+    /// send a delta.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub result_id: Option<String>,
+
+    /// The actual tokens. For a detailed description about how the data is
+    /// structured please see
+    /// <https://github.com/microsoft/vscode-extension-samples/blob/5ae1f7787122812dcc84e37427ca90af5ee09f14/semantic-tokens-sample/vscode.proposed.d.ts#L71>
+    #[serde(
+        deserialize_with = "SemanticToken::deserialize_tokens",
+        serialize_with = "SemanticToken::serialize_tokens"
+    )]
+    pub data: Vec<SemanticToken>,
+}
+
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensPartialResult {
+    #[serde(
+        deserialize_with = "SemanticToken::deserialize_tokens",
+        serialize_with = "SemanticToken::serialize_tokens"
+    )]
+    pub data: Vec<SemanticToken>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(untagged)]
+pub enum SemanticTokensResult {
+    Tokens(SemanticTokens),
+    Partial(SemanticTokensPartialResult),
+}
+
+impl From<SemanticTokens> for SemanticTokensResult {
+    fn from(from: SemanticTokens) -> Self {
+        SemanticTokensResult::Tokens(from)
+    }
+}
+
+impl From<SemanticTokensPartialResult> for SemanticTokensResult {
+    fn from(from: SemanticTokensPartialResult) -> Self {
+        SemanticTokensResult::Partial(from)
+    }
+}
+
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensEdit {
+    pub start: u32,
+    pub delete_count: u32,
+
+    #[serde(
+        default,
+        skip_serializing_if = "Option::is_none",
+        deserialize_with = "SemanticToken::deserialize_tokens_opt",
+        serialize_with = "SemanticToken::serialize_tokens_opt"
+    )]
+    pub data: Option<Vec<SemanticToken>>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(untagged)]
+pub enum SemanticTokensFullDeltaResult {
+    Tokens(SemanticTokens),
+    TokensDelta(SemanticTokensDelta),
+    PartialTokensDelta { edits: Vec<SemanticTokensEdit> },
+}
+
+impl From<SemanticTokens> for SemanticTokensFullDeltaResult {
+    fn from(from: SemanticTokens) -> Self {
+        SemanticTokensFullDeltaResult::Tokens(from)
+    }
+}
+
+impl From<SemanticTokensDelta> for SemanticTokensFullDeltaResult {
+    fn from(from: SemanticTokensDelta) -> Self {
+        SemanticTokensFullDeltaResult::TokensDelta(from)
+    }
+}
+
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensDelta {
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub result_id: Option<String>,
+    /// For a detailed description how these edits are structured please see
+    /// <https://github.com/microsoft/vscode-extension-samples/blob/5ae1f7787122812dcc84e37427ca90af5ee09f14/semantic-tokens-sample/vscode.proposed.d.ts#L131>
+    pub edits: Vec<SemanticTokensEdit>,
+}
+
+/// Capabilities specific to the `textDocument/semanticTokens/*` requests.
+///
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensClientCapabilities {
+    /// Whether implementation supports dynamic registration. If this is set to `true`
+    /// the client supports the new `(TextDocumentRegistrationOptions & StaticRegistrationOptions)`
+    /// return value for the corresponding server capability as well.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// Which requests the client supports and might send to the server
+    /// depending on the server's capability. Please note that clients might not
+    /// show semantic tokens or degrade some of the user experience if a range
+    /// or full request is advertised by the client but not provided by the
+    /// server. If for example the client capability `requests.full` and
+    /// `request.range` are both set to true but the server only provides a
+    /// range provider the client might not render a minimap correctly or might
+    /// even decide to not show any semantic tokens at all.
+    pub requests: SemanticTokensClientCapabilitiesRequests,
+
+    /// The token types that the client supports.
+    pub token_types: Vec<SemanticTokenType>,
+
+    /// The token modifiers that the client supports.
+    pub token_modifiers: Vec<SemanticTokenModifier>,
+
+    /// The token formats the clients supports.
+    pub formats: Vec<TokenFormat>,
+
+    /// Whether the client supports tokens that can overlap each other.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub overlapping_token_support: Option<bool>,
+
+    /// Whether the client supports tokens that can span multiple lines.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub multiline_token_support: Option<bool>,
+
+    /// Whether the client allows the server to actively cancel a
+    /// semantic token request, e.g. supports returning
+    /// ErrorCodes.ServerCancelled. If a server does the client
+    /// needs to retrigger the request.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub server_cancel_support: Option<bool>,
+
+    /// Whether the client uses semantic tokens to augment existing
+    /// syntax tokens. If set to `true` client side created syntax
+    /// tokens and semantic tokens are both used for colorization. If
+    /// set to `false` the client only uses the returned semantic tokens
+    /// for colorization.
+    ///
+    /// If the value is `undefined` then the client behavior is not
+    /// specified.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub augments_syntax_tokens: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensClientCapabilitiesRequests {
+    /// The client will send the `textDocument/semanticTokens/range` request if the server provides a corresponding handler.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub range: Option<bool>,
+
+    /// The client will send the `textDocument/semanticTokens/full` request if the server provides a corresponding handler.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub full: Option<SemanticTokensFullOptions>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(untagged)]
+pub enum SemanticTokensFullOptions {
+    Bool(bool),
+    Delta {
+        /// The client will send the `textDocument/semanticTokens/full/delta` request if the server provides a corresponding handler.
+        /// The server supports deltas for full documents.
+        #[serde(skip_serializing_if = "Option::is_none")]
+        delta: Option<bool>,
+    },
+}
+
+/// @since 3.16.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+
+    /// The legend used by the server
+    pub legend: SemanticTokensLegend,
+
+    /// Server supports providing semantic tokens for a specific range
+    /// of a document.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub range: Option<bool>,
+
+    /// Server supports providing semantic tokens for a full document.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub full: Option<SemanticTokensFullOptions>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensRegistrationOptions {
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+
+    #[serde(flatten)]
+    pub semantic_tokens_options: SemanticTokensOptions,
+
+    #[serde(flatten)]
+    pub static_registration_options: StaticRegistrationOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(untagged)]
+pub enum SemanticTokensServerCapabilities {
+    SemanticTokensOptions(SemanticTokensOptions),
+    SemanticTokensRegistrationOptions(SemanticTokensRegistrationOptions),
+}
+
+impl From<SemanticTokensOptions> for SemanticTokensServerCapabilities {
+    fn from(from: SemanticTokensOptions) -> Self {
+        SemanticTokensServerCapabilities::SemanticTokensOptions(from)
+    }
+}
+
+impl From<SemanticTokensRegistrationOptions> for SemanticTokensServerCapabilities {
+    fn from(from: SemanticTokensRegistrationOptions) -> Self {
+        SemanticTokensServerCapabilities::SemanticTokensRegistrationOptions(from)
+    }
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensWorkspaceClientCapabilities {
+    /// Whether the client implementation supports a refresh request sent from
+    /// the server to the client.
+    ///
+    /// Note that this event is global and will force the client to refresh all
+    /// semantic tokens currently shown. It should be used with absolute care
+    /// and is useful for situation where a server for example detect a project
+    /// wide change that requires such a calculation.
+    pub refresh_support: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensParams {
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensDeltaParams {
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The result id of a previous response. The result Id can either point to a full response
+    /// or a delta response depending on what was received last.
+    pub previous_result_id: String,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SemanticTokensRangeParams {
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+
+    /// The text document.
+    pub text_document: TextDocumentIdentifier,
+
+    /// The range the semantic tokens are requested for.
+    pub range: Range,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+#[serde(untagged)]
+pub enum SemanticTokensRangeResult {
+    Tokens(SemanticTokens),
+    Partial(SemanticTokensPartialResult),
+}
+
+impl From<SemanticTokens> for SemanticTokensRangeResult {
+    fn from(tokens: SemanticTokens) -> Self {
+        SemanticTokensRangeResult::Tokens(tokens)
+    }
+}
+
+impl From<SemanticTokensPartialResult> for SemanticTokensRangeResult {
+    fn from(partial: SemanticTokensPartialResult) -> Self {
+        SemanticTokensRangeResult::Partial(partial)
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::tests::{test_deserialization, test_serialization};
+
+    #[test]
+    fn test_semantic_tokens_support_serialization() {
+        test_serialization(
+            &SemanticTokens {
+                result_id: None,
+                data: vec![],
+            },
+            r#"{"data":[]}"#,
+        );
+
+        test_serialization(
+            &SemanticTokens {
+                result_id: None,
+                data: vec![SemanticToken {
+                    delta_line: 2,
+                    delta_start: 5,
+                    length: 3,
+                    token_type: 0,
+                    token_modifiers_bitset: 3,
+                }],
+            },
+            r#"{"data":[2,5,3,0,3]}"#,
+        );
+
+        test_serialization(
+            &SemanticTokens {
+                result_id: None,
+                data: vec![
+                    SemanticToken {
+                        delta_line: 2,
+                        delta_start: 5,
+                        length: 3,
+                        token_type: 0,
+                        token_modifiers_bitset: 3,
+                    },
+                    SemanticToken {
+                        delta_line: 0,
+                        delta_start: 5,
+                        length: 4,
+                        token_type: 1,
+                        token_modifiers_bitset: 0,
+                    },
+                ],
+            },
+            r#"{"data":[2,5,3,0,3,0,5,4,1,0]}"#,
+        );
+    }
+
+    #[test]
+    fn test_semantic_tokens_support_deserialization() {
+        test_deserialization(
+            r#"{"data":[]}"#,
+            &SemanticTokens {
+                result_id: None,
+                data: vec![],
+            },
+        );
+
+        test_deserialization(
+            r#"{"data":[2,5,3,0,3]}"#,
+            &SemanticTokens {
+                result_id: None,
+                data: vec![SemanticToken {
+                    delta_line: 2,
+                    delta_start: 5,
+                    length: 3,
+                    token_type: 0,
+                    token_modifiers_bitset: 3,
+                }],
+            },
+        );
+
+        test_deserialization(
+            r#"{"data":[2,5,3,0,3,0,5,4,1,0]}"#,
+            &SemanticTokens {
+                result_id: None,
+                data: vec![
+                    SemanticToken {
+                        delta_line: 2,
+                        delta_start: 5,
+                        length: 3,
+                        token_type: 0,
+                        token_modifiers_bitset: 3,
+                    },
+                    SemanticToken {
+                        delta_line: 0,
+                        delta_start: 5,
+                        length: 4,
+                        token_type: 1,
+                        token_modifiers_bitset: 0,
+                    },
+                ],
+            },
+        );
+    }
+
+    #[test]
+    #[should_panic]
+    fn test_semantic_tokens_support_deserialization_err() {
+        test_deserialization(
+            r#"{"data":[1]}"#,
+            &SemanticTokens {
+                result_id: None,
+                data: vec![],
+            },
+        );
+    }
+
+    #[test]
+    fn test_semantic_tokens_edit_support_deserialization() {
+        test_deserialization(
+            r#"{"start":0,"deleteCount":1,"data":[2,5,3,0,3,0,5,4,1,0]}"#,
+            &SemanticTokensEdit {
+                start: 0,
+                delete_count: 1,
+                data: Some(vec![
+                    SemanticToken {
+                        delta_line: 2,
+                        delta_start: 5,
+                        length: 3,
+                        token_type: 0,
+                        token_modifiers_bitset: 3,
+                    },
+                    SemanticToken {
+                        delta_line: 0,
+                        delta_start: 5,
+                        length: 4,
+                        token_type: 1,
+                        token_modifiers_bitset: 0,
+                    },
+                ]),
+            },
+        );
+
+        test_deserialization(
+            r#"{"start":0,"deleteCount":1}"#,
+            &SemanticTokensEdit {
+                start: 0,
+                delete_count: 1,
+                data: None,
+            },
+        );
+    }
+
+    #[test]
+    fn test_semantic_tokens_edit_support_serialization() {
+        test_serialization(
+            &SemanticTokensEdit {
+                start: 0,
+                delete_count: 1,
+                data: Some(vec![
+                    SemanticToken {
+                        delta_line: 2,
+                        delta_start: 5,
+                        length: 3,
+                        token_type: 0,
+                        token_modifiers_bitset: 3,
+                    },
+                    SemanticToken {
+                        delta_line: 0,
+                        delta_start: 5,
+                        length: 4,
+                        token_type: 1,
+                        token_modifiers_bitset: 0,
+                    },
+                ]),
+            },
+            r#"{"start":0,"deleteCount":1,"data":[2,5,3,0,3,0,5,4,1,0]}"#,
+        );
+
+        test_serialization(
+            &SemanticTokensEdit {
+                start: 0,
+                delete_count: 1,
+                data: None,
+            },
+            r#"{"start":0,"deleteCount":1}"#,
+        );
+    }
+}
diff --git a/crates/lsp-types/src/signature_help.rs b/crates/lsp-types/src/signature_help.rs
new file mode 100644
index 000000000..2466d1088
--- /dev/null
+++ b/crates/lsp-types/src/signature_help.rs
@@ -0,0 +1,207 @@
+use serde::{Deserialize, Serialize};
+
+use crate::{
+    Documentation, MarkupKind, TextDocumentPositionParams, TextDocumentRegistrationOptions,
+    WorkDoneProgressOptions, WorkDoneProgressParams,
+};
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SignatureInformationSettings {
+    /// Client supports the follow content formats for the documentation
+    /// property. The order describes the preferred format of the client.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub documentation_format: Option<Vec<MarkupKind>>,
+
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub parameter_information: Option<ParameterInformationSettings>,
+
+    /// The client support the `activeParameter` property on `SignatureInformation`
+    /// literal.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub active_parameter_support: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ParameterInformationSettings {
+    /// The client supports processing label offsets instead of a
+    /// simple label string.
+    ///
+    /// @since 3.14.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub label_offset_support: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SignatureHelpClientCapabilities {
+    /// Whether completion supports dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// The client supports the following `SignatureInformation`
+    /// specific properties.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub signature_information: Option<SignatureInformationSettings>,
+
+    /// The client supports to send additional context information for a
+    /// `textDocument/signatureHelp` request. A client that opts into
+    /// contextSupport will also support the `retriggerCharacters` on
+    /// `SignatureHelpOptions`.
+    ///
+    /// @since 3.15.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub context_support: Option<bool>,
+}
+
+/// Signature help options.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SignatureHelpOptions {
+    /// The characters that trigger signature help automatically.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub trigger_characters: Option<Vec<String>>,
+
+    /// List of characters that re-trigger signature help.
+    /// These trigger characters are only active when signature help is already showing. All trigger characters
+    /// are also counted as re-trigger characters.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub retrigger_characters: Option<Vec<String>>,
+
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+/// Signature help options.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct SignatureHelpRegistrationOptions {
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+}
+
+/// Signature help options.
+#[derive(Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct SignatureHelpTriggerKind(i32);
+lsp_enum! {
+impl SignatureHelpTriggerKind {
+    /// Signature help was invoked manually by the user or by a command.
+    pub const INVOKED: SignatureHelpTriggerKind = SignatureHelpTriggerKind(1);
+    /// Signature help was triggered by a trigger character.
+    pub const TRIGGER_CHARACTER: SignatureHelpTriggerKind = SignatureHelpTriggerKind(2);
+    /// Signature help was triggered by the cursor moving or by the document content changing.
+    pub const CONTENT_CHANGE: SignatureHelpTriggerKind = SignatureHelpTriggerKind(3);
+}
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SignatureHelpParams {
+    /// The signature help context. This is only available if the client specifies
+    /// to send this using the client capability  `textDocument.signatureHelp.contextSupport === true`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub context: Option<SignatureHelpContext>,
+
+    #[serde(flatten)]
+    pub text_document_position_params: TextDocumentPositionParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SignatureHelpContext {
+    /// Action that caused signature help to be triggered.
+    pub trigger_kind: SignatureHelpTriggerKind,
+
+    /// Character that caused signature help to be triggered.
+    /// This is undefined when `triggerKind !== SignatureHelpTriggerKind.TriggerCharacter`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub trigger_character: Option<String>,
+
+    /// `true` if signature help was already showing when it was triggered.
+    /// Retriggers occur when the signature help is already active and can be caused by actions such as
+    /// typing a trigger character, a cursor move, or document content changes.
+    pub is_retrigger: bool,
+
+    /// The currently active `SignatureHelp`.
+    /// The `activeSignatureHelp` has its `SignatureHelp.activeSignature` field updated based on
+    /// the user navigating through available signatures.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub active_signature_help: Option<SignatureHelp>,
+}
+
+/// Signature help represents the signature of something
+/// callable. There can be multiple signature but only one
+/// active and only one active parameter.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SignatureHelp {
+    /// One or more signatures.
+    pub signatures: Vec<SignatureInformation>,
+
+    /// The active signature.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub active_signature: Option<u32>,
+
+    /// The active parameter of the active signature.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub active_parameter: Option<u32>,
+}
+
+/// Represents the signature of something callable. A signature
+/// can have a label, like a function-name, a doc-comment, and
+/// a set of parameters.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct SignatureInformation {
+    /// The label of this signature. Will be shown in
+    /// the UI.
+    pub label: String,
+
+    /// The human-readable doc-comment of this signature. Will be shown
+    /// in the UI but can be omitted.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub documentation: Option<Documentation>,
+
+    /// The parameters of this signature.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub parameters: Option<Vec<ParameterInformation>>,
+
+    /// The index of the active parameter.
+    ///
+    /// If provided, this is used in place of `SignatureHelp.activeParameter`.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub active_parameter: Option<u32>,
+}
+
+/// Represents a parameter of a callable-signature. A parameter can
+/// have a label and a doc-comment.
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ParameterInformation {
+    /// The label of this parameter information.
+    ///
+    /// Either a string or an inclusive start and exclusive end offsets within its containing
+    /// signature label. (see SignatureInformation.label). *Note*: A label of type string must be
+    /// a substring of its containing signature label.
+    pub label: ParameterLabel,
+
+    /// The human-readable doc-comment of this parameter. Will be shown
+    /// in the UI but can be omitted.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub documentation: Option<Documentation>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum ParameterLabel {
+    Simple(String),
+    LabelOffsets([u32; 2]),
+}
diff --git a/crates/lsp-types/src/trace.rs b/crates/lsp-types/src/trace.rs
new file mode 100644
index 000000000..7abcc5673
--- /dev/null
+++ b/crates/lsp-types/src/trace.rs
@@ -0,0 +1,77 @@
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct SetTraceParams {
+    /// The new value that should be assigned to the trace setting.
+    pub value: TraceValue,
+}
+
+/// A TraceValue represents the level of verbosity with which the server systematically
+/// reports its execution trace using `LogTrace` notifications.
+///
+/// The initial trace value is set by the client at initialization and can be modified
+/// later using the `SetTrace` notification.
+#[derive(Debug, Eq, PartialEq, Clone, Copy, Deserialize, Serialize, Default)]
+#[serde(rename_all = "camelCase")]
+pub enum TraceValue {
+    /// The server should not send any `$/logTrace` notification
+    #[default]
+    Off,
+    /// The server should not add the 'verbose' field in the `LogTraceParams`
+    Messages,
+    Verbose,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct LogTraceParams {
+    /// The message to be logged.
+    pub message: String,
+    /// Additional information that can be computed if the `trace` configuration
+    /// is set to `'verbose'`
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub verbose: Option<String>,
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::tests::test_serialization;
+
+    #[test]
+    fn test_set_trace_params() {
+        test_serialization(
+            &SetTraceParams {
+                value: TraceValue::Off,
+            },
+            r#"{"value":"off"}"#,
+        );
+    }
+
+    #[test]
+    fn test_log_trace_params() {
+        test_serialization(
+            &LogTraceParams {
+                message: "message".into(),
+                verbose: None,
+            },
+            r#"{"message":"message"}"#,
+        );
+
+        test_serialization(
+            &LogTraceParams {
+                message: "message".into(),
+                verbose: Some("verbose".into()),
+            },
+            r#"{"message":"message","verbose":"verbose"}"#,
+        );
+    }
+
+    #[test]
+    fn test_trace_value() {
+        test_serialization(
+            &vec![TraceValue::Off, TraceValue::Messages, TraceValue::Verbose],
+            r#"["off","messages","verbose"]"#,
+        );
+    }
+}
diff --git a/crates/lsp-types/src/type_hierarchy.rs b/crates/lsp-types/src/type_hierarchy.rs
new file mode 100644
index 000000000..568a03e25
--- /dev/null
+++ b/crates/lsp-types/src/type_hierarchy.rs
@@ -0,0 +1,90 @@
+use crate::{
+    DynamicRegistrationClientCapabilities, LSPAny, PartialResultParams, Range,
+    StaticRegistrationOptions, SymbolKind, SymbolTag, TextDocumentPositionParams,
+    TextDocumentRegistrationOptions, Url, WorkDoneProgressOptions, WorkDoneProgressParams,
+};
+
+use serde::{Deserialize, Serialize};
+
+pub type TypeHierarchyClientCapabilities = DynamicRegistrationClientCapabilities;
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct TypeHierarchyOptions {
+    #[serde(flatten)]
+    pub work_done_progress_options: WorkDoneProgressOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct TypeHierarchyRegistrationOptions {
+    #[serde(flatten)]
+    pub text_document_registration_options: TextDocumentRegistrationOptions,
+    #[serde(flatten)]
+    pub type_hierarchy_options: TypeHierarchyOptions,
+    #[serde(flatten)]
+    pub static_registration_options: StaticRegistrationOptions,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct TypeHierarchyPrepareParams {
+    #[serde(flatten)]
+    pub text_document_position_params: TextDocumentPositionParams,
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct TypeHierarchySupertypesParams {
+    pub item: TypeHierarchyItem,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct TypeHierarchySubtypesParams {
+    pub item: TypeHierarchyItem,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct TypeHierarchyItem {
+    /// The name of this item.
+    pub name: String,
+
+    /// The kind of this item.
+    pub kind: SymbolKind,
+
+    /// Tags for this item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tags: Option<SymbolTag>,
+
+    /// More detail for this item, e.g. the signature of a function.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub detail: Option<String>,
+
+    /// The resource identifier of this item.
+    pub uri: Url,
+
+    /// The range enclosing this symbol not including leading/trailing whitespace
+    /// but everything else, e.g. comments and code.
+    pub range: Range,
+
+    /// The range that should be selected and revealed when this symbol is being
+    /// picked, e.g. the name of a function. Must be contained by the
+    /// [`range`](#TypeHierarchyItem.range).
+    pub selection_range: Range,
+
+    /// A data entry field that is preserved between a type hierarchy prepare and
+    /// supertypes or subtypes requests. It could also be used to identify the
+    /// type hierarchy in the server, helping improve the performance on
+    /// resolving supertypes and subtypes.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data: Option<LSPAny>,
+}
diff --git a/crates/lsp-types/src/window.rs b/crates/lsp-types/src/window.rs
new file mode 100644
index 000000000..ac45e6083
--- /dev/null
+++ b/crates/lsp-types/src/window.rs
@@ -0,0 +1,173 @@
+use std::collections::HashMap;
+
+use serde::{Deserialize, Serialize};
+
+use serde_json::Value;
+
+use url::Url;
+
+use crate::Range;
+
+#[derive(Eq, PartialEq, Clone, Copy, Deserialize, Serialize)]
+#[serde(transparent)]
+pub struct MessageType(i32);
+lsp_enum! {
+impl MessageType {
+    /// An error message.
+    pub const ERROR: MessageType = MessageType(1);
+    /// A warning message.
+    pub const WARNING: MessageType = MessageType(2);
+    /// An information message;
+    pub const INFO: MessageType = MessageType(3);
+    /// A log message.
+    pub const LOG: MessageType = MessageType(4);
+}
+}
+
+/// Window specific client capabilities.
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WindowClientCapabilities {
+    /// Whether client supports handling progress notifications. If set
+    /// servers are allowed to report in `workDoneProgress` property in the
+    /// request specific server capabilities.
+    ///
+    /// @since 3.15.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub work_done_progress: Option<bool>,
+
+    /// Capabilities specific to the showMessage request.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub show_message: Option<ShowMessageRequestClientCapabilities>,
+
+    /// Client capabilities for the show document request.
+    ///
+    /// @since 3.16.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub show_document: Option<ShowDocumentClientCapabilities>,
+}
+
+/// Show message request client capabilities
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ShowMessageRequestClientCapabilities {
+    /// Capabilities specific to the `MessageActionItem` type.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub message_action_item: Option<MessageActionItemCapabilities>,
+}
+
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct MessageActionItemCapabilities {
+    /// Whether the client supports additional attributes which
+    /// are preserved and send back to the server in the
+    /// request's response.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub additional_properties_support: Option<bool>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct MessageActionItem {
+    /// A short title like 'Retry', 'Open Log' etc.
+    pub title: String,
+
+    /// Additional attributes that the client preserves and
+    /// sends back to the server. This depends on the client
+    /// capability window.messageActionItem.additionalPropertiesSupport
+    #[serde(flatten)]
+    pub properties: HashMap<String, MessageActionItemProperty>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(untagged)]
+pub enum MessageActionItemProperty {
+    String(String),
+    Boolean(bool),
+    Integer(i32),
+    Object(Value),
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct LogMessageParams {
+    /// The message type. See {@link MessageType}
+    #[serde(rename = "type")]
+    pub typ: MessageType,
+
+    /// The actual message
+    pub message: String,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct ShowMessageParams {
+    /// The message type. See {@link MessageType}.
+    #[serde(rename = "type")]
+    pub typ: MessageType,
+
+    /// The actual message.
+    pub message: String,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct ShowMessageRequestParams {
+    /// The message type. See {@link MessageType}
+    #[serde(rename = "type")]
+    pub typ: MessageType,
+
+    /// The actual message
+    pub message: String,
+
+    /// The message action items to present.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub actions: Option<Vec<MessageActionItem>>,
+}
+
+/// Client capabilities for the show document request.
+#[derive(Debug, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ShowDocumentClientCapabilities {
+    /// The client has support for the show document request.
+    pub support: bool,
+}
+
+/// Params to show a document.
+///
+/// @since 3.16.0
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ShowDocumentParams {
+    /// The document uri to show.
+    pub uri: Url,
+
+    /// Indicates to show the resource in an external program.
+    /// To show for example `https://code.visualstudio.com/`
+    /// in the default WEB browser set `external` to `true`.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub external: Option<bool>,
+
+    /// An optional property to indicate whether the editor
+    /// showing the document should take focus or not.
+    /// Clients might ignore this property if an external
+    /// program in started.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub take_focus: Option<bool>,
+
+    /// An optional selection range if the document is a text
+    /// document. Clients might ignore the property if an
+    /// external program is started or the file is not a text
+    /// file.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub selection: Option<Range>,
+}
+
+/// The result of an show document request.
+///
+/// @since 3.16.0
+#[derive(Debug, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct ShowDocumentResult {
+    /// A boolean indicating if the show was successful.
+    pub success: bool,
+}
diff --git a/crates/lsp-types/src/workspace_diagnostic.rs b/crates/lsp-types/src/workspace_diagnostic.rs
new file mode 100644
index 000000000..e8a7646b0
--- /dev/null
+++ b/crates/lsp-types/src/workspace_diagnostic.rs
@@ -0,0 +1,149 @@
+use serde::{Deserialize, Serialize};
+use url::Url;
+
+use crate::{
+    FullDocumentDiagnosticReport, PartialResultParams, UnchangedDocumentDiagnosticReport,
+    WorkDoneProgressParams,
+};
+
+/// Workspace client capabilities specific to diagnostic pull requests.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DiagnosticWorkspaceClientCapabilities {
+    /// Whether the client implementation supports a refresh request sent from
+    /// the server to the client.
+    ///
+    /// Note that this event is global and will force the client to refresh all
+    /// pulled diagnostics currently shown. It should be used with absolute care
+    /// and is useful for situation where a server for example detects a project
+    /// wide change that requires such a calculation.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub refresh_support: Option<bool>,
+}
+
+/// A previous result ID in a workspace pull request.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct PreviousResultId {
+    /// The URI for which the client knows a result ID.
+    pub uri: Url,
+
+    /// The value of the previous result ID.
+    pub value: String,
+}
+
+/// Parameters of the workspace diagnostic request.
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceDiagnosticParams {
+    /// The additional identifier provided during registration.
+    pub identifier: Option<String>,
+
+    /// The currently known diagnostic reports with their
+    /// previous result ids.
+    pub previous_result_ids: Vec<PreviousResultId>,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+}
+
+/// A full document diagnostic report for a workspace diagnostic result.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceFullDocumentDiagnosticReport {
+    /// The URI for which diagnostic information is reported.
+    pub uri: Url,
+
+    /// The version number for which the diagnostics are reported.
+    ///
+    /// If the document is not marked as open, `None` can be provided.
+    pub version: Option<i64>,
+
+    #[serde(flatten)]
+    pub full_document_diagnostic_report: FullDocumentDiagnosticReport,
+}
+
+/// An unchanged document diagnostic report for a workspace diagnostic result.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceUnchangedDocumentDiagnosticReport {
+    /// The URI for which diagnostic information is reported.
+    pub uri: Url,
+
+    /// The version number for which the diagnostics are reported.
+    ///
+    /// If the document is not marked as open, `None` can be provided.
+    pub version: Option<i64>,
+
+    #[serde(flatten)]
+    pub unchanged_document_diagnostic_report: UnchangedDocumentDiagnosticReport,
+}
+
+/// A workspace diagnostic document report.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(tag = "kind", rename_all = "lowercase")]
+pub enum WorkspaceDocumentDiagnosticReport {
+    Full(WorkspaceFullDocumentDiagnosticReport),
+    Unchanged(WorkspaceUnchangedDocumentDiagnosticReport),
+}
+
+impl From<WorkspaceFullDocumentDiagnosticReport> for WorkspaceDocumentDiagnosticReport {
+    fn from(from: WorkspaceFullDocumentDiagnosticReport) -> Self {
+        WorkspaceDocumentDiagnosticReport::Full(from)
+    }
+}
+
+impl From<WorkspaceUnchangedDocumentDiagnosticReport> for WorkspaceDocumentDiagnosticReport {
+    fn from(from: WorkspaceUnchangedDocumentDiagnosticReport) -> Self {
+        WorkspaceDocumentDiagnosticReport::Unchanged(from)
+    }
+}
+
+/// A workspace diagnostic report.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+pub struct WorkspaceDiagnosticReport {
+    pub items: Vec<WorkspaceDocumentDiagnosticReport>,
+}
+
+/// A partial result for a workspace diagnostic report.
+///
+/// @since 3.17.0
+#[derive(Debug, PartialEq, Default, Deserialize, Serialize, Clone)]
+pub struct WorkspaceDiagnosticReportPartialResult {
+    pub items: Vec<WorkspaceDocumentDiagnosticReport>,
+}
+
+#[derive(Debug, PartialEq, Deserialize, Serialize, Clone)]
+#[serde(untagged)]
+pub enum WorkspaceDiagnosticReportResult {
+    Report(WorkspaceDiagnosticReport),
+    Partial(WorkspaceDiagnosticReportPartialResult),
+}
+
+impl From<WorkspaceDiagnosticReport> for WorkspaceDiagnosticReportResult {
+    fn from(from: WorkspaceDiagnosticReport) -> Self {
+        WorkspaceDiagnosticReportResult::Report(from)
+    }
+}
+
+impl From<WorkspaceDiagnosticReportPartialResult> for WorkspaceDiagnosticReportResult {
+    fn from(from: WorkspaceDiagnosticReportPartialResult) -> Self {
+        WorkspaceDiagnosticReportResult::Partial(from)
+    }
+}
diff --git a/crates/lsp-types/src/workspace_folders.rs b/crates/lsp-types/src/workspace_folders.rs
new file mode 100644
index 000000000..aeca89ffe
--- /dev/null
+++ b/crates/lsp-types/src/workspace_folders.rs
@@ -0,0 +1,49 @@
+use serde::{Deserialize, Serialize};
+use url::Url;
+
+use crate::OneOf;
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceFoldersServerCapabilities {
+    /// The server has support for workspace folders
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub supported: Option<bool>,
+
+    /// Whether the server wants to receive workspace folder
+    /// change notifications.
+    ///
+    /// If a string is provided, the string is treated as an ID
+    /// under which the notification is registered on the client
+    /// side. The ID can be used to unregister for these events
+    /// using the `client/unregisterCapability` request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub change_notifications: Option<OneOf<bool, String>>,
+}
+
+#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceFolder {
+    /// The associated URI for this workspace folder.
+    pub uri: Url,
+    /// The name of the workspace folder. Defaults to the uri's basename.
+    pub name: String,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct DidChangeWorkspaceFoldersParams {
+    /// The actual workspace folder change event.
+    pub event: WorkspaceFoldersChangeEvent,
+}
+
+/// The workspace folder change event.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceFoldersChangeEvent {
+    /// The array of added workspace folders
+    pub added: Vec<WorkspaceFolder>,
+
+    /// The array of the removed workspace folders
+    pub removed: Vec<WorkspaceFolder>,
+}
diff --git a/crates/lsp-types/src/workspace_symbols.rs b/crates/lsp-types/src/workspace_symbols.rs
new file mode 100644
index 000000000..9ba80895b
--- /dev/null
+++ b/crates/lsp-types/src/workspace_symbols.rs
@@ -0,0 +1,105 @@
+use crate::{
+    LSPAny, Location, OneOf, PartialResultParams, SymbolInformation, SymbolKind,
+    SymbolKindCapability, SymbolTag, TagSupport, Url, WorkDoneProgressParams,
+};
+
+use serde::{Deserialize, Serialize};
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceSymbolClientCapabilities {
+    /// This capability supports dynamic registration.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub dynamic_registration: Option<bool>,
+
+    /// Specific capabilities for the `SymbolKind` in the `workspace/symbol` request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub symbol_kind: Option<SymbolKindCapability>,
+
+    /// The client supports tags on `SymbolInformation`.
+    /// Clients supporting tags have to handle unknown tags gracefully.
+    ///
+    /// @since 3.16.0
+    #[serde(
+        default,
+        skip_serializing_if = "Option::is_none",
+        deserialize_with = "TagSupport::deserialize_compat"
+    )]
+    pub tag_support: Option<TagSupport<SymbolTag>>,
+
+    /// The client support partial workspace symbols. The client will send the
+    /// request `workspaceSymbol/resolve` to the server to resolve additional
+    /// properties.
+    ///
+    /// @since 3.17.0
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub resolve_support: Option<WorkspaceSymbolResolveSupportCapability>,
+}
+
+/// The parameters of a Workspace Symbol Request.
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct WorkspaceSymbolParams {
+    #[serde(flatten)]
+    pub partial_result_params: PartialResultParams,
+
+    #[serde(flatten)]
+    pub work_done_progress_params: WorkDoneProgressParams,
+
+    /// A non-empty query string
+    pub query: String,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Default, Deserialize, Serialize)]
+pub struct WorkspaceSymbolResolveSupportCapability {
+    /// The properties that a client can resolve lazily. Usually
+    /// `location.range`
+    pub properties: Vec<String>,
+}
+
+/// A special workspace symbol that supports locations without a range
+///
+/// @since 3.17.0
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+#[serde(rename_all = "camelCase")]
+pub struct WorkspaceSymbol {
+    /// The name of this symbol.
+    pub name: String,
+
+    /// The kind of this symbol.
+    pub kind: SymbolKind,
+
+    /// Tags for this completion item.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub tags: Option<Vec<SymbolTag>>,
+
+    /// The name of the symbol containing this symbol. This information is for
+    /// user interface purposes (e.g. to render a qualifier in the user interface
+    /// if necessary). It can't be used to re-infer a hierarchy for the document
+    /// symbols.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub container_name: Option<String>,
+
+    /// The location of this symbol. Whether a server is allowed to
+    /// return a location without a range depends on the client
+    /// capability `workspace.symbol.resolveSupport`.
+    ///
+    /// See also `SymbolInformation.location`.
+    pub location: OneOf<Location, WorkspaceLocation>,
+
+    /// A data entry field that is preserved on a workspace symbol between a
+    /// workspace symbol request and a workspace symbol resolve request.
+    #[serde(skip_serializing_if = "Option::is_none")]
+    pub data: Option<LSPAny>,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Deserialize, Serialize)]
+pub struct WorkspaceLocation {
+    pub uri: Url,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone, Serialize, Deserialize)]
+#[serde(untagged)]
+pub enum WorkspaceSymbolResponse {
+    Flat(Vec<SymbolInformation>),
+    Nested(Vec<WorkspaceSymbol>),
+}
diff --git a/crates/lsp-types/tests/lsif.rs b/crates/lsp-types/tests/lsif.rs
new file mode 100644
index 000000000..3b90c8bc6
--- /dev/null
+++ b/crates/lsp-types/tests/lsif.rs
@@ -0,0 +1,18 @@
+#[test]
+#[cfg(unix)]
+fn run() {
+    use lsp_types::lsif::Entry;
+
+    let jsonl = include_str!("tsc-unix.lsif");
+    for json in jsonl.lines() {
+        let r = serde_json::from_str::<Entry>(&json).expect(&format!("can not parse {}", json));
+        let x = serde_json::to_string(&r).expect(&format!("can not serialize {}", json));
+        assert_eq!(
+            serde_json::from_str::<serde_json::Value>(&x).unwrap(),
+            serde_json::from_str::<serde_json::Value>(json).unwrap(),
+            "and strings:\ntheir: {}\n  our: {}",
+            json,
+            x,
+        );
+    }
+}
diff --git a/crates/lsp-types/tests/tsc-unix.lsif b/crates/lsp-types/tests/tsc-unix.lsif
new file mode 100644
index 000000000..24c4dc046
--- /dev/null
+++ b/crates/lsp-types/tests/tsc-unix.lsif
@@ -0,0 +1,135 @@
+{"id":1,"type":"vertex","label":"metaData","version":"0.4.3","projectRoot":"file:///media/hamid/nv1/garbage","positionEncoding":"utf-16","toolInfo":{"name":"lsif-tsc","args":["-p","."],"version":"0.7.2"}}
+{"id":2,"type":"vertex","label":"project","kind":"typescript"}
+{"id":3,"type":"vertex","label":"$event","kind":"begin","scope":"project","data":2}
+{"id":4,"type":"vertex","label":"document","uri":"file:///media/hamid/nv1/garbage/a.ts","languageId":"typescript"}
+{"id":5,"type":"vertex","label":"$event","kind":"begin","scope":"document","data":4}
+{"id":6,"type":"vertex","label":"resultSet"}
+{"id":7,"type":"vertex","label":"moniker","kind":"export","unique":"document","scheme":"tsc","identifier":"a:"}
+{"id":8,"type":"edge","label":"moniker","outV":6,"inV":7}
+{"id":9,"type":"vertex","label":"packageInformation","name":"garbage","manager":"npm","version":"1.0.0"}
+{"id":10,"type":"vertex","label":"moniker","kind":"export","unique":"global","scheme":"npm","identifier":"garbage:a:"}
+{"id":11,"type":"edge","label":"packageInformation","outV":10,"inV":9}
+{"id":12,"type":"edge","label":"nextMoniker","outV":7,"inV":10}
+{"id":13,"type":"vertex","label":"range","start":{"line":0,"character":0},"end":{"line":0,"character":0},"tag":{"type":"definition","text":"","kind":7,"fullRange":{"start":{"line":0,"character":0},"end":{"line":3,"character":0}}}}
+{"id":14,"type":"edge","label":"next","outV":13,"inV":6}
+{"id":15,"type":"vertex","label":"resultSet"}
+{"id":16,"type":"vertex","label":"moniker","kind":"export","unique":"document","scheme":"tsc","identifier":"a:a"}
+{"id":17,"type":"edge","label":"moniker","outV":15,"inV":16}
+{"id":18,"type":"vertex","label":"moniker","kind":"export","unique":"global","scheme":"npm","identifier":"garbage:a:a"}
+{"id":19,"type":"edge","label":"packageInformation","outV":18,"inV":9}
+{"id":20,"type":"edge","label":"nextMoniker","outV":16,"inV":18}
+{"id":21,"type":"vertex","label":"range","start":{"line":0,"character":13},"end":{"line":0,"character":14},"tag":{"type":"definition","text":"a","kind":7,"fullRange":{"start":{"line":0,"character":13},"end":{"line":2,"character":1}}}}
+{"id":22,"type":"edge","label":"next","outV":21,"inV":15}
+{"id":23,"type":"vertex","label":"hoverResult","result":{"contents":[{"language":"typescript","value":"const a: (x: number, y: string) => string"}]}}
+{"id":24,"type":"edge","label":"textDocument/hover","outV":15,"inV":23}
+{"id":25,"type":"vertex","label":"resultSet"}
+{"id":26,"type":"vertex","label":"moniker","kind":"local","unique":"document","scheme":"tsc","identifier":"dW50H+qRDGdPj+RYWpwLSg=="}
+{"id":27,"type":"edge","label":"moniker","outV":25,"inV":26}
+{"id":28,"type":"vertex","label":"range","start":{"line":0,"character":18},"end":{"line":0,"character":19},"tag":{"type":"definition","text":"x","kind":7,"fullRange":{"start":{"line":0,"character":18},"end":{"line":0,"character":27}}}}
+{"id":29,"type":"edge","label":"next","outV":28,"inV":25}
+{"id":30,"type":"vertex","label":"hoverResult","result":{"contents":[{"language":"typescript","value":"(parameter) x: number"}]}}
+{"id":31,"type":"edge","label":"textDocument/hover","outV":25,"inV":30}
+{"id":32,"type":"vertex","label":"resultSet"}
+{"id":33,"type":"vertex","label":"moniker","kind":"local","unique":"document","scheme":"tsc","identifier":"W2CLXh2PW8+ib7xga5YF4A=="}
+{"id":34,"type":"edge","label":"moniker","outV":32,"inV":33}
+{"id":35,"type":"vertex","label":"range","start":{"line":0,"character":29},"end":{"line":0,"character":30},"tag":{"type":"definition","text":"y","kind":7,"fullRange":{"start":{"line":0,"character":29},"end":{"line":0,"character":38}}}}
+{"id":36,"type":"edge","label":"next","outV":35,"inV":32}
+{"id":37,"type":"vertex","label":"hoverResult","result":{"contents":[{"language":"typescript","value":"(parameter) y: string"}]}}
+{"id":38,"type":"edge","label":"textDocument/hover","outV":32,"inV":37}
+{"id":39,"type":"vertex","label":"resultSet"}
+{"id":40,"type":"vertex","label":"moniker","kind":"local","unique":"document","scheme":"tsc","identifier":"WLUBvuhxsSADYrjTwQnBoA=="}
+{"id":41,"type":"edge","label":"moniker","outV":39,"inV":40}
+{"id":42,"type":"vertex","label":"range","start":{"line":0,"character":40},"end":{"line":0,"character":42},"tag":{"type":"reference","text":"=>"}}
+{"id":43,"type":"edge","label":"next","outV":42,"inV":39}
+{"id":44,"type":"vertex","label":"range","start":{"line":1,"character":18},"end":{"line":1,"character":19},"tag":{"type":"reference","text":"y"}}
+{"id":45,"type":"edge","label":"next","outV":44,"inV":32}
+{"id":46,"type":"vertex","label":"document","uri":"file:///media/hamid/nv1/garbage/node_modules/typescript-lsif/lib/lib.es2015.core.d.ts","languageId":"typescript"}
+{"id":47,"type":"vertex","label":"$event","kind":"begin","scope":"document","data":46}
+{"id":48,"type":"vertex","label":"resultSet"}
+{"id":49,"type":"vertex","label":"moniker","kind":"export","unique":"document","scheme":"tsc","identifier":"node_modules/typescript-lsif/lib/lib.es2015.core:String.repeat"}
+{"id":50,"type":"edge","label":"moniker","outV":48,"inV":49}
+{"id":51,"type":"vertex","label":"moniker","kind":"export","unique":"global","scheme":"npm","identifier":"garbage:node_modules/typescript-lsif/lib/lib.es2015.core:String.repeat"}
+{"id":52,"type":"edge","label":"packageInformation","outV":51,"inV":9}
+{"id":53,"type":"edge","label":"nextMoniker","outV":49,"inV":51}
+{"id":54,"type":"vertex","label":"range","start":{"line":446,"character":4},"end":{"line":446,"character":10},"tag":{"type":"definition","text":"repeat","kind":7,"fullRange":{"start":{"line":446,"character":4},"end":{"line":446,"character":34}}}}
+{"id":55,"type":"edge","label":"next","outV":54,"inV":48}
+{"id":56,"type":"vertex","label":"hoverResult","result":{"contents":[{"language":"typescript","value":"(method) String.repeat(count: number): string"},"Returns a String value that is made from count copies appended together. If count is 0,\nthe empty string is returned."]}}
+{"id":57,"type":"edge","label":"textDocument/hover","outV":48,"inV":56}
+{"id":58,"type":"vertex","label":"range","start":{"line":1,"character":20},"end":{"line":1,"character":26},"tag":{"type":"reference","text":"repeat"}}
+{"id":59,"type":"edge","label":"next","outV":58,"inV":48}
+{"id":60,"type":"vertex","label":"range","start":{"line":1,"character":27},"end":{"line":1,"character":28},"tag":{"type":"reference","text":"x"}}
+{"id":61,"type":"edge","label":"next","outV":60,"inV":25}
+{"id":62,"type":"vertex","label":"definitionResult"}
+{"id":63,"type":"edge","label":"textDocument/definition","outV":6,"inV":62}
+{"id":64,"type":"edge","label":"item","outV":62,"inVs":[13],"document":4}
+{"id":65,"type":"vertex","label":"referenceResult"}
+{"id":66,"type":"edge","label":"textDocument/references","outV":6,"inV":65}
+{"id":67,"type":"edge","label":"item","outV":65,"inVs":[13],"document":4,"property":"definitions"}
+{"id":68,"type":"vertex","label":"definitionResult"}
+{"id":69,"type":"edge","label":"textDocument/definition","outV":15,"inV":68}
+{"id":70,"type":"edge","label":"item","outV":68,"inVs":[21],"document":4}
+{"id":71,"type":"vertex","label":"referenceResult"}
+{"id":72,"type":"edge","label":"textDocument/references","outV":15,"inV":71}
+{"id":73,"type":"edge","label":"item","outV":71,"inVs":[21],"document":4,"property":"definitions"}
+{"id":74,"type":"vertex","label":"definitionResult"}
+{"id":75,"type":"edge","label":"textDocument/definition","outV":25,"inV":74}
+{"id":76,"type":"edge","label":"item","outV":74,"inVs":[28],"document":4}
+{"id":77,"type":"vertex","label":"referenceResult"}
+{"id":78,"type":"edge","label":"textDocument/references","outV":25,"inV":77}
+{"id":79,"type":"edge","label":"item","outV":77,"inVs":[28],"document":4,"property":"definitions"}
+{"id":80,"type":"edge","label":"item","outV":77,"inVs":[60],"document":4,"property":"references"}
+{"id":81,"type":"vertex","label":"definitionResult"}
+{"id":82,"type":"edge","label":"textDocument/definition","outV":32,"inV":81}
+{"id":83,"type":"edge","label":"item","outV":81,"inVs":[35],"document":4}
+{"id":84,"type":"vertex","label":"referenceResult"}
+{"id":85,"type":"edge","label":"textDocument/references","outV":32,"inV":84}
+{"id":86,"type":"edge","label":"item","outV":84,"inVs":[35],"document":4,"property":"definitions"}
+{"id":87,"type":"edge","label":"item","outV":84,"inVs":[44],"document":4,"property":"references"}
+{"id":88,"type":"vertex","label":"referenceResult"}
+{"id":89,"type":"edge","label":"textDocument/references","outV":39,"inV":88}
+{"id":90,"type":"edge","label":"item","outV":88,"inVs":[42],"document":4,"property":"references"}
+{"id":91,"type":"vertex","label":"referenceResult"}
+{"id":92,"type":"edge","label":"textDocument/references","outV":48,"inV":91}
+{"id":93,"type":"edge","label":"item","outV":91,"inVs":[58],"document":4,"property":"references"}
+{"id":94,"type":"vertex","label":"document","uri":"file:///media/hamid/nv1/garbage/b.ts","languageId":"typescript"}
+{"id":95,"type":"vertex","label":"$event","kind":"begin","scope":"document","data":94}
+{"id":96,"type":"vertex","label":"resultSet"}
+{"id":97,"type":"vertex","label":"moniker","kind":"export","unique":"document","scheme":"tsc","identifier":"b:"}
+{"id":98,"type":"edge","label":"moniker","outV":96,"inV":97}
+{"id":99,"type":"vertex","label":"moniker","kind":"export","unique":"global","scheme":"npm","identifier":"garbage:b:"}
+{"id":100,"type":"edge","label":"packageInformation","outV":99,"inV":9}
+{"id":101,"type":"edge","label":"nextMoniker","outV":97,"inV":99}
+{"id":102,"type":"vertex","label":"range","start":{"line":0,"character":0},"end":{"line":0,"character":0},"tag":{"type":"definition","text":"","kind":7,"fullRange":{"start":{"line":0,"character":0},"end":{"line":3,"character":0}}}}
+{"id":103,"type":"edge","label":"next","outV":102,"inV":96}
+{"id":104,"type":"vertex","label":"resultSet"}
+{"id":105,"type":"edge","label":"next","outV":104,"inV":15}
+{"id":106,"type":"vertex","label":"moniker","kind":"local","unique":"document","scheme":"tsc","identifier":"sNwThRvTZlfLwz6po1s2Zg=="}
+{"id":107,"type":"edge","label":"moniker","outV":104,"inV":106}
+{"id":108,"type":"vertex","label":"range","start":{"line":0,"character":9},"end":{"line":0,"character":10},"tag":{"type":"definition","text":"a","kind":7,"fullRange":{"start":{"line":0,"character":9},"end":{"line":0,"character":10}}}}
+{"id":109,"type":"edge","label":"next","outV":108,"inV":104}
+{"id":110,"type":"vertex","label":"hoverResult","result":{"contents":[{"language":"typescript","value":"(alias) const a: (x: number, y: string) => string\nimport a"}]}}
+{"id":111,"type":"edge","label":"textDocument/hover","outV":104,"inV":110}
+{"id":112,"type":"vertex","label":"range","start":{"line":0,"character":18},"end":{"line":0,"character":23},"tag":{"type":"reference","text":"\"./a\""}}
+{"id":113,"type":"edge","label":"next","outV":112,"inV":6}
+{"id":114,"type":"vertex","label":"range","start":{"line":2,"character":0},"end":{"line":2,"character":1},"tag":{"type":"reference","text":"a"}}
+{"id":115,"type":"edge","label":"next","outV":114,"inV":104}
+{"id":116,"type":"vertex","label":"definitionResult"}
+{"id":117,"type":"edge","label":"textDocument/definition","outV":96,"inV":116}
+{"id":118,"type":"edge","label":"item","outV":116,"inVs":[102],"document":94}
+{"id":119,"type":"vertex","label":"referenceResult"}
+{"id":120,"type":"edge","label":"textDocument/references","outV":96,"inV":119}
+{"id":121,"type":"edge","label":"item","outV":119,"inVs":[102],"document":94,"property":"definitions"}
+{"id":122,"type":"edge","label":"item","outV":71,"inVs":[108,114],"document":94,"property":"references"}
+{"id":123,"type":"edge","label":"item","outV":65,"inVs":[112],"document":94,"property":"references"}
+{"id":124,"type":"vertex","label":"definitionResult"}
+{"id":125,"type":"edge","label":"textDocument/definition","outV":48,"inV":124}
+{"id":126,"type":"edge","label":"item","outV":124,"inVs":[54],"document":46}
+{"id":127,"type":"edge","label":"item","outV":91,"inVs":[54],"document":46,"property":"definitions"}
+{"id":128,"type":"edge","label":"contains","outV":4,"inVs":[13,21,28,35,42,44,58,60]}
+{"id":129,"type":"vertex","label":"$event","kind":"end","scope":"document","data":4}
+{"id":130,"type":"edge","label":"contains","outV":46,"inVs":[54]}
+{"id":131,"type":"vertex","label":"$event","kind":"end","scope":"document","data":46}
+{"id":132,"type":"edge","label":"contains","outV":94,"inVs":[102,108,112,114]}
+{"id":133,"type":"vertex","label":"$event","kind":"end","scope":"document","data":94}
+{"id":134,"type":"edge","label":"contains","outV":2,"inVs":[4,46,94]}
+{"id":135,"type":"vertex","label":"$event","kind":"end","scope":"project","data":2}
diff --git a/crates/salsa/.devcontainer/devcontainer.json b/crates/salsa/.devcontainer/devcontainer.json
new file mode 100644
index 000000000..c6469ecbd
--- /dev/null
+++ b/crates/salsa/.devcontainer/devcontainer.json
@@ -0,0 +1,34 @@
+// For format details, see https://aka.ms/devcontainer.json. For config options, see the
+// README at: https://github.com/devcontainers/templates/tree/main/src/rust
+{
+	"name": "Rust",
+	// Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile
+	"image": "mcr.microsoft.com/devcontainers/rust:1-1-bullseye",
+	"features": {
+		"ghcr.io/devcontainers-contrib/features/ripgrep:1": {}
+	}
+
+	// Use 'mounts' to make the cargo cache persistent in a Docker Volume.
+	// "mounts": [
+	// 	{
+	// 		"source": "devcontainer-cargo-cache-${devcontainerId}",
+	// 		"target": "/usr/local/cargo",
+	// 		"type": "volume"
+	// 	}
+	// ]
+
+	// Features to add to the dev container. More info: https://containers.dev/features.
+	// "features": {},
+
+	// Use 'forwardPorts' to make a list of ports inside the container available locally.
+	// "forwardPorts": [],
+
+	// Use 'postCreateCommand' to run commands after the container is created.
+	// "postCreateCommand": "rustc --version",
+
+	// Configure tool-specific properties.
+	// "customizations": {},
+
+	// Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.
+	// "remoteUser": "root"
+}
diff --git a/crates/salsa/.dir-locals.el b/crates/salsa/.dir-locals.el
new file mode 100644
index 000000000..125e009be
--- /dev/null
+++ b/crates/salsa/.dir-locals.el
@@ -0,0 +1 @@
+((rust-mode (rust-format-on-save . t)))
diff --git a/crates/salsa/.github/dependabot.yml b/crates/salsa/.github/dependabot.yml
new file mode 100644
index 000000000..f33a02cd1
--- /dev/null
+++ b/crates/salsa/.github/dependabot.yml
@@ -0,0 +1,12 @@
+# To get started with Dependabot version updates, you'll need to specify which
+# package ecosystems to update and where the package manifests are located.
+# Please see the documentation for more information:
+# https://docs.github.com/github/administering-a-repository/configuration-options-for-dependency-updates
+# https://containers.dev/guide/dependabot
+
+version: 2
+updates:
+ - package-ecosystem: "devcontainers"
+   directory: "/"
+   schedule:
+     interval: weekly
diff --git a/crates/salsa/.github/workflows/book.yml b/crates/salsa/.github/workflows/book.yml
new file mode 100644
index 000000000..396981c95
--- /dev/null
+++ b/crates/salsa/.github/workflows/book.yml
@@ -0,0 +1,58 @@
+name: Book
+
+on:
+  push:
+    branches:
+      - master
+  pull_request:
+    paths:
+      - "book/**"
+      - ".github/workflows/book.yml"
+
+jobs:
+  book:
+    name: Book
+    runs-on: ubuntu-latest
+    env:
+      MDBOOK_VERSION: "0.4.40"
+      MDBOOK_LINKCHECK_VERSION: "0.7.7"
+      MDBOOK_MERMAID_VERSION: "0.13.0"
+    steps:
+      - uses: actions/checkout@v4
+      - name: Install mdbook
+        run: |
+          curl -L https://github.com/rust-lang/mdBook/releases/download/v$MDBOOK_VERSION/mdbook-v$MDBOOK_VERSION-x86_64-unknown-linux-gnu.tar.gz | tar xz -C ~/.cargo/bin
+          curl -L https://github.com/badboy/mdbook-mermaid/releases/download/v$MDBOOK_MERMAID_VERSION/mdbook-mermaid-v$MDBOOK_MERMAID_VERSION-x86_64-unknown-linux-gnu.tar.gz | tar xz -C ~/.cargo/bin
+          curl -L https://github.com/Michael-F-Bryan/mdbook-linkcheck/releases/download/v$MDBOOK_LINKCHECK_VERSION/mdbook-linkcheck.x86_64-unknown-linux-gnu.zip -O
+          unzip mdbook-linkcheck.x86_64-unknown-linux-gnu.zip -d ~/.cargo/bin
+          chmod +x ~/.cargo/bin/mdbook-linkcheck
+      - name: Setup Pages
+        id: pages
+        uses: actions/configure-pages@v5
+      - name: Build
+        run: mdbook build
+        working-directory: book
+      - name: Upload static files as artifact
+        id: deployment
+        uses: actions/upload-pages-artifact@v3
+        with:
+          path: ./book/book/html
+  deploy:
+    name: Deploy
+    runs-on: ubuntu-latest
+    needs: book
+    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
+    concurrency:
+      group: github-pages
+      cancel-in-progress: true
+    permissions:
+      contents: read
+      pages: write
+      id-token: write
+    environment:
+      name: github-pages
+      url: ${{ steps.deployment.outputs.page_url }}
+    steps:
+      - name: Deploy to GitHub Pages
+        id: deployment
+        uses: actions/deploy-pages@v4
diff --git a/crates/salsa/.github/workflows/release.yml b/crates/salsa/.github/workflows/release.yml
new file mode 100644
index 000000000..ad2dd41e9
--- /dev/null
+++ b/crates/salsa/.github/workflows/release.yml
@@ -0,0 +1,57 @@
+name: Release-plz
+
+permissions:
+  pull-requests: write
+  contents: write
+
+on:
+  push:
+    branches:
+      - master
+
+jobs:
+  # Release unpublished packages.
+  release-plz-release:
+    name: Release-plz release
+    runs-on: ubuntu-latest
+    permissions:
+      contents: write
+    steps:
+      - name: Checkout repository
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+      - name: Install Rust toolchain
+        uses: dtolnay/rust-toolchain@stable
+      - name: Run release-plz
+        uses: release-plz/action@v0.5
+        with:
+          command: release
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
+
+  # Create a PR with the new versions and changelog, preparing the next release.
+  release-plz-pr:
+    name: Release-plz PR
+    runs-on: ubuntu-latest
+    permissions:
+      contents: write
+      pull-requests: write
+    concurrency:
+      group: release-plz-${{ github.ref }}
+      cancel-in-progress: false
+    steps:
+      - name: Checkout repository
+        uses: actions/checkout@v4
+        with:
+          fetch-depth: 0
+      - name: Install Rust toolchain
+        uses: dtolnay/rust-toolchain@stable
+      - name: Run release-plz
+        uses: release-plz/action@v0.5
+        with:
+          command: release-pr
+        env:
+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
+          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
diff --git a/crates/salsa/.github/workflows/test.yml b/crates/salsa/.github/workflows/test.yml
new file mode 100644
index 000000000..8484b0633
--- /dev/null
+++ b/crates/salsa/.github/workflows/test.yml
@@ -0,0 +1,137 @@
+name: Test
+
+on:
+  pull_request:
+  merge_group:
+  push:
+    branches:
+      - master
+
+concurrency:
+  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
+  cancel-in-progress: true
+
+jobs:
+  test:
+    name: Test
+    strategy:
+      matrix:
+        rust:
+          - 1.80.0
+          - stable
+          - beta
+        experimental:
+          - false
+        include:
+          - rust: nightly
+            experimental: true
+    continue-on-error: ${{ matrix.experimental }}
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+      - name: Setup Rust toolchain
+        uses: dtolnay/rust-toolchain@master
+        id: rust-toolchain
+        with:
+          toolchain: ${{ matrix.rust }}
+          components: rustfmt, clippy
+      - uses: taiki-e/install-action@nextest
+      - uses: actions/cache@v4
+        with:
+          path: |
+            ~/.cargo/bin/
+            ~/.cargo/registry/index/
+            ~/.cargo/registry/cache/
+            ~/.cargo/git/db/
+            target/
+          key: ${{ runner.os }}-cargo-${{ steps.rust-toolchain.outputs.cachekey }}-${{ hashFiles('**/Cargo.toml') }}
+          restore-keys: |
+            ${{ runner.os }}-cargo-${{ steps.rust-toolchain.outputs.cachekey }}-
+            ${{ runner.os }}-cargo-
+      - name: Format
+        run: cargo fmt -- --check
+      - name: Clippy
+        run: cargo clippy --workspace --all-features --all-targets -- -D warnings
+      - name: Test
+        run: cargo nextest run --workspace --all-features --all-targets --no-fail-fast
+      - name: Test docs
+        run: cargo test --workspace --all-features --doc
+      - name: Check (without default features)
+        run: cargo check --workspace --no-default-features
+      - name: Check (loom)
+        run: RUSTFLAGS="--cfg loom" cargo check --workspace --features loom
+
+  miri:
+    name: Miri
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+      - name: Install Miri
+        uses: dtolnay/rust-toolchain@miri
+        id: rust-toolchain
+      - uses: taiki-e/install-action@nextest
+      - uses: actions/cache@v4
+        with:
+          path: |
+            ~/.cargo/bin/
+            ~/.cargo/registry/index/
+            ~/.cargo/registry/cache/
+            ~/.cargo/git/db/
+            target/
+          key: ${{ runner.os }}-cargo-${{ steps.rust-toolchain.outputs.cachekey }}-miri-${{ hashFiles('**/Cargo.toml') }}
+          restore-keys: |
+            ${{ runner.os }}-cargo-${{ steps.rust-toolchain.outputs.cachekey }}-miri-
+            ${{ runner.os }}-cargo-${{ steps.rust-toolchain.outputs.cachekey }}-
+            ${{ runner.os }}-cargo-
+      - name: Setup Miri
+        run: cargo miri setup
+      - name: Test with Miri
+        run: cargo miri nextest run --all-features --no-fail-fast --tests
+        env:
+          MIRIFLAGS: -Zmiri-disable-isolation -Zmiri-retag-fields
+      - name: Run examples with Miri
+        run: cargo miri run --example calc
+
+  benchmarks:
+    # https://github.com/CodSpeedHQ/action/issues/126
+    if: github.event_name != 'merge_group'
+    name: Benchmarks
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Setup Rust toolchain
+        uses: dtolnay/rust-toolchain@master
+        id: rust-toolchain
+        with:
+          toolchain: stable
+
+      - name: "Setup codspeed"
+        uses: taiki-e/install-action@v2
+        with:
+          tool: cargo-codspeed
+
+      - uses: actions/cache@v4
+        with:
+          path: |
+            ~/.cargo/bin/
+            ~/.cargo/registry/index/
+            ~/.cargo/registry/cache/
+            ~/.cargo/git/db/
+            target/
+          key: ${{ runner.os }}-cargo-${{ steps.rust-toolchain.outputs.cachekey }}-${{ hashFiles('**/Cargo.toml') }}
+          restore-keys: |
+            ${{ runner.os }}-cargo-${{ steps.rust-toolchain.outputs.cachekey }}-
+            ${{ runner.os }}-cargo-
+
+      - name: "Build benchmarks"
+        run: cargo codspeed build
+
+      - name: "Run benchmarks"
+        uses: CodSpeedHQ/action@v3
+        with:
+          run: cargo codspeed run
+          token: ${{ secrets.CODSPEED_TOKEN }}
diff --git a/crates/salsa/.gitignore b/crates/salsa/.gitignore
new file mode 100644
index 000000000..30bb648d4
--- /dev/null
+++ b/crates/salsa/.gitignore
@@ -0,0 +1,6 @@
+/target
+**/*.rs.bk
+Cargo.lock
+TAGS
+nikom
+.idea
diff --git a/crates/salsa/CHANGELOG.md b/crates/salsa/CHANGELOG.md
new file mode 100644
index 000000000..5ef4ca981
--- /dev/null
+++ b/crates/salsa/CHANGELOG.md
@@ -0,0 +1,152 @@
+# Changelog
+
+All notable changes to this project will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+## [Unreleased]
+
+## [0.21.1](https://github.com/salsa-rs/salsa/compare/salsa-v0.21.0...salsa-v0.21.1) - 2025-04-30
+
+### Added
+
+- Make `attach` pub ([#832](https://github.com/salsa-rs/salsa/pull/832))
+
+### Other
+
+- better debug name for interned query arguments ([#837](https://github.com/salsa-rs/salsa/pull/837))
+- Avoid panic in `Backtrace::capture` if `query_stack` is already borrowed ([#835](https://github.com/salsa-rs/salsa/pull/835))
+- Clean up `function::execute` ([#833](https://github.com/salsa-rs/salsa/pull/833))
+- Change an `assert!` to `assert_eq!` ([#828](https://github.com/salsa-rs/salsa/pull/828))
+
+## [0.21.0](https://github.com/salsa-rs/salsa/compare/salsa-v0.20.0...salsa-v0.21.0) - 2025-04-29
+
+### Fixed
+
+- Access to tracked-struct that was freed during fixpoint ([#817](https://github.com/salsa-rs/salsa/pull/817))
+- correct debug output for tracked fields ([#826](https://github.com/salsa-rs/salsa/pull/826))
+- Fix incorrect `values_equal` signature ([#825](https://github.com/salsa-rs/salsa/pull/825))
+- allow unused lifetimes in tracked_struct expansion ([#824](https://github.com/salsa-rs/salsa/pull/824))
+
+### Other
+
+- Implement a query stack `Backtrace` analog ([#827](https://github.com/salsa-rs/salsa/pull/827))
+- Simplify ID conversions ([#822](https://github.com/salsa-rs/salsa/pull/822))
+- Attempt to fix codspeed ([#823](https://github.com/salsa-rs/salsa/pull/823))
+- Remove unnecessary `Array` abstraction ([#821](https://github.com/salsa-rs/salsa/pull/821))
+- Add a compile-fail test for a `'static` `!Update` struct ([#820](https://github.com/salsa-rs/salsa/pull/820))
+- squelch most clippy warnings in generated code ([#809](https://github.com/salsa-rs/salsa/pull/809))
+- Include struct name in formatted input-field index ([#819](https://github.com/salsa-rs/salsa/pull/819))
+- Force inline `fetch_hot` ([#818](https://github.com/salsa-rs/salsa/pull/818))
+- Per ingredient sync table ([#650](https://github.com/salsa-rs/salsa/pull/650))
+- Use `DatabaseKey` for interned events ([#813](https://github.com/salsa-rs/salsa/pull/813))
+- [refactor] More `fetch_hot` simplification ([#793](https://github.com/salsa-rs/salsa/pull/793))
+- Don't store the fields in the interned map ([#812](https://github.com/salsa-rs/salsa/pull/812))
+- Fix ci not always running ([#810](https://github.com/salsa-rs/salsa/pull/810))
+
+## [0.20.0](https://github.com/salsa-rs/salsa/compare/salsa-v0.19.0...salsa-v0.20.0) - 2025-04-22
+
+### Added
+
+- Drop `Debug` requirements and flip implementation defaults ([#756](https://github.com/salsa-rs/salsa/pull/756))
+
+### Fixed
+
+- Dereferencing freed memos when verifying provisional memos ([#788](https://github.com/salsa-rs/salsa/pull/788))
+- `#[doc(hidden)]` `plumbing` module ([#781](https://github.com/salsa-rs/salsa/pull/781))
+- Use `changed_at` revision when updating fields ([#778](https://github.com/salsa-rs/salsa/pull/778))
+
+### Other
+
+- Reduce memory usage by deduplicating type information ([#803](https://github.com/salsa-rs/salsa/pull/803))
+- Make interned's `last_interned_at` equal `Revision::MAX` if they are interned outside a query ([#804](https://github.com/salsa-rs/salsa/pull/804))
+- Add a third cycle mode, equivalent to old Salsa cycle behavior ([#801](https://github.com/salsa-rs/salsa/pull/801))
+- Update compact_str from 0.8 to 0.9 ([#794](https://github.com/salsa-rs/salsa/pull/794))
+- Implement `Update` for `ThinVec` ([#807](https://github.com/salsa-rs/salsa/pull/807))
+- Don't push an unnecessary active query for `deep_verify_memo` ([#806](https://github.com/salsa-rs/salsa/pull/806))
+- Inline/Outline more cold and slow paths ([#805](https://github.com/salsa-rs/salsa/pull/805))
+- `#[inline]` some things ([#799](https://github.com/salsa-rs/salsa/pull/799))
+- Discard unnecessary atomic load ([#780](https://github.com/salsa-rs/salsa/pull/780))
+- Print query stack when encountering unexpected cycle ([#796](https://github.com/salsa-rs/salsa/pull/796))
+- Remove incorrect `parallel_scope` API ([#797](https://github.com/salsa-rs/salsa/pull/797))
+- [refactor] Simplify `fetch_hot` ([#792](https://github.com/salsa-rs/salsa/pull/792))
+- [refactor] Reuse the same stack for all cycles heads in `validate_same_iteration` ([#791](https://github.com/salsa-rs/salsa/pull/791))
+- add WillIterateCycle event ([#790](https://github.com/salsa-rs/salsa/pull/790))
+- [fix] Use `validate_maybe_provisional` instead of `validate_provisional` ([#789](https://github.com/salsa-rs/salsa/pull/789))
+- Use `ThinVec` for `CycleHeads` ([#787](https://github.com/salsa-rs/salsa/pull/787))
+- Keep edge condvar on stack instead of allocating it in an `Arc` ([#773](https://github.com/salsa-rs/salsa/pull/773))
+- allow reuse of cached provisional memos within the same cycle iteration ([#786](https://github.com/salsa-rs/salsa/pull/786))
+- Implement `Lookup`/`HashEqLike` for `Arc` ([#784](https://github.com/salsa-rs/salsa/pull/784))
+- Normalize imports style ([#779](https://github.com/salsa-rs/salsa/pull/779))
+- Clean up `par_map` a bit ([#742](https://github.com/salsa-rs/salsa/pull/742))
+- Fix typo in comment ([#777](https://github.com/salsa-rs/salsa/pull/777))
+- Document most safety blocks ([#776](https://github.com/salsa-rs/salsa/pull/776))
+- Use html directory for mdbook artifact ([#774](https://github.com/salsa-rs/salsa/pull/774))
+- Move `verified_final` from `Memo` into `QueryRevisions` ([#769](https://github.com/salsa-rs/salsa/pull/769))
+- Use `ThinVec` for `MemoTable`, halving its size ([#770](https://github.com/salsa-rs/salsa/pull/770))
+- Remove unnecessary query stack acess in `block_on` ([#771](https://github.com/salsa-rs/salsa/pull/771))
+- Replace memo queue with append-only vector ([#767](https://github.com/salsa-rs/salsa/pull/767))
+- update boxcar ([#696](https://github.com/salsa-rs/salsa/pull/696))
+- Remove extra page indirection in `Table` ([#710](https://github.com/salsa-rs/salsa/pull/710))
+- update release steps ([#705](https://github.com/salsa-rs/salsa/pull/705))
+- Remove some unnecessary panicking paths in cycle execution ([#765](https://github.com/salsa-rs/salsa/pull/765))
+- *(perf)* Pool `ActiveQuerys` in the query stack ([#629](https://github.com/salsa-rs/salsa/pull/629))
+- Resolve unwind safety fixme ([#761](https://github.com/salsa-rs/salsa/pull/761))
+- Enable Garbage Collection for Interned Values ([#602](https://github.com/salsa-rs/salsa/pull/602))
+- bug [salsa-macros]: Improve debug name of tracked methods ([#755](https://github.com/salsa-rs/salsa/pull/755))
+- Remove dead code ([#764](https://github.com/salsa-rs/salsa/pull/764))
+- Reduce unnecessary conditional work in `deep_verify_memo` ([#759](https://github.com/salsa-rs/salsa/pull/759))
+- Use a `Vec` for `CycleHeads` ([#760](https://github.com/salsa-rs/salsa/pull/760))
+- Use nextest for miri test runs ([#758](https://github.com/salsa-rs/salsa/pull/758))
+- Pin `half` version to prevent CI failure ([#757](https://github.com/salsa-rs/salsa/pull/757))
+- rewrite cycle handling to support fixed-point iteration ([#603](https://github.com/salsa-rs/salsa/pull/603))
+
+## [0.19.0](https://github.com/salsa-rs/salsa/compare/salsa-v0.18.0...salsa-v0.19.0) - 2025-03-10
+
+### Fixed
+
+- fix typo
+- fix enums bug
+
+### Other
+
+- Have salsa not depend on salsa-macros ([#750](https://github.com/salsa-rs/salsa/pull/750))
+- Group versions of packages together for releases ([#751](https://github.com/salsa-rs/salsa/pull/751))
+- use `portable-atomic` in `IngredientCache` to compile on `powerpc-unknown-linux-gnu` ([#749](https://github.com/salsa-rs/salsa/pull/749))
+- Store view downcaster in function ingredients directly ([#720](https://github.com/salsa-rs/salsa/pull/720))
+- Some small perf things ([#744](https://github.com/salsa-rs/salsa/pull/744))
+- :replace instead of std::mem::replace ([#746](https://github.com/salsa-rs/salsa/pull/746))
+- Cleanup `Cargo.toml`s ([#745](https://github.com/salsa-rs/salsa/pull/745))
+- Drop clone requirement for accumulated values
+- implement `Update` trait for `IndexMap`, and `IndexSet`
+- more correct bounds on `Send` and `Sync` implementation `DeletedEntries`
+- replace `arc-swap` with manual `AtomicPtr`
+- Remove unnecessary `current_revision` call from `setup_interned_struct`
+- Merge pull request #731 from Veykril/veykril/push-nzkwqzxxkxou
+- Remove some dynamically dispatched `Database::event` calls
+- Lazy fetching
+- Add small supertype input benchmark
+- Replace a `DashMap` with `RwLock` as writing is rare for it
+- address review comments
+- Skip memo ingredient index mapping for non enum tracked functions
+- Trade off a bit of memory for more speed in `MemoIngredientIndices`
+- Introduce Salsa enums
+- Cancel duplicate test workflow runs
+- implement `Update` trait for `hashbrown::HashMap`
+- Move `unwind_if_revision_cancelled` from `ZalsaLocal` to `Zalsa`
+- Don't clone strings in benchmarks
+- Merge pull request #714 from Veykril/veykril/push-synxntlkqqsq
+- Merge pull request #711 from Veykril/veykril/push-stmmwmtprovt
+- Merge pull request #715 from Veykril/veykril/push-plwpsqknwulq
+- Enforce `unsafe_op_in_unsafe_fn`
+- Remove some `ZalsaDatabase::zalsa` calls
+- Remove outdated FIXME
+- Replace `IngredientCache` lock with atomic primitive
+- Reduce method delegation duplication
+- Automatically clear the cancellation flag when cancellation completes
+- Allow trigger LRU eviction without increasing the current revision
+- Simplify `Ingredient::reset_for_new_revision` setup
+- Require mut Zalsa access for setting the lru limit
+- Split off revision bumping from `zalsa_mut` access
+- Update `hashbrown` (0.15) and `hashlink` (0.10)
diff --git a/crates/salsa/Cargo.toml b/crates/salsa/Cargo.toml
new file mode 100644
index 000000000..d30865613
--- /dev/null
+++ b/crates/salsa/Cargo.toml
@@ -0,0 +1,97 @@
+[package]
+name = "salsa"
+version = "0.21.1"
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+rust-version.workspace = true
+description = "A generic framework for on-demand, incrementalized computation (experimental)"
+
+[dependencies]
+salsa-macro-rules = { version = "0.21.1", path = "components/salsa-macro-rules" }
+salsa-macros = { version = "0.21.1", path = "components/salsa-macros", optional = true }
+
+boxcar = { version = "0.2.12" }
+crossbeam-queue = "0.3.11"
+dashmap = { version = "6", features = ["raw-api"] }
+hashbrown = "0.15"
+hashlink = "0.10"
+indexmap = "2"
+parking_lot = "0.12"
+portable-atomic = "1"
+rustc-hash = "2"
+smallvec = "1"
+tracing = { version = "0.1", default-features = false, features = ["std"] }
+
+# parallel map
+rayon = { version = "1.10.0", optional = true }
+
+# Stuff we want Update impls for by default
+compact_str = { version = "0.9", optional = true }
+thin-vec = "0.2.13"
+loom = { version = "0.7.2", optional = true }
+
+[features]
+default = ["salsa_unstable", "rayon", "macros"]
+# FIXME: remove `salsa_unstable` before 1.0.
+salsa_unstable = []
+loom = ["dep:loom", "boxcar/loom"]
+macros = ["dep:salsa-macros"]
+
+# This interlocks the `salsa-macros` and `salsa` versions together
+# preventing scenarios where they could diverge in a given project
+# which may ultimately result in odd issues due to the proc-macro
+# output mismatching with the declarative macro inputs
+[target.'cfg(any())'.dependencies]
+salsa-macros = { version = "=0.21.1", path = "components/salsa-macros" }
+
+[dev-dependencies]
+# examples
+crossbeam-channel = "0.5.14"
+eyre = "0.6.8"
+notify-debouncer-mini = "0.4.1"
+ordered-float = "4.2.1"
+
+# tests/benches
+annotate-snippets = "0.11.5"
+codspeed-criterion-compat = { version = "2.6.0", default-features = false }
+expect-test = "1.5.0"
+rustversion = "1.0"
+test-log = { version = "0.2.11", features = ["trace"] }
+trybuild = "1.0"
+
+# not directly used, but 2.5.0 bumped the MSRV beyond 1.80 so pin it temporarily
+half = "=2.4.1"
+
+[target.'cfg(all(not(target_os = "windows"), not(target_os = "openbsd"), any(target_arch = "x86_64", target_arch = "aarch64", target_arch = "powerpc64")))'.dev-dependencies]
+tikv-jemallocator = "0.6.0"
+
+[lints.rust]
+unexpected_cfgs = { level = "warn", check-cfg = ['cfg(loom)'] }
+
+[[bench]]
+name = "compare"
+harness = false
+
+[[bench]]
+name = "incremental"
+harness = false
+
+[[bench]]
+name = "accumulator"
+harness = false
+
+[[bench]]
+name = "dataflow"
+harness = false
+
+[workspace]
+members = ["components/salsa-macro-rules", "components/salsa-macros"]
+
+[workspace.package]
+authors = ["Salsa developers"]
+edition = "2021"
+license = "Apache-2.0 OR MIT"
+repository = "https://github.com/salsa-rs/salsa"
+rust-version = "1.80"
diff --git a/crates/salsa/FAQ.md b/crates/salsa/FAQ.md
new file mode 100644
index 000000000..9c9f6f92d
--- /dev/null
+++ b/crates/salsa/FAQ.md
@@ -0,0 +1,34 @@
+# Frequently asked questions
+
+## Why is it called salsa?
+
+I like salsa! Don't you?! Well, ok, there's a bit more to it. The
+underlying algorithm for figuring out which bits of code need to be
+re-executed after any given change is based on the algorithm used in
+rustc. Michael Woerister and I first described the rustc algorithm in
+terms of two colors, red and green, and hence we called it the
+"red-green algorithm". This made me think of the New Mexico State
+Question --- ["Red or green?"][nm] --- which refers to chile
+(salsa). Although this version no longer uses colors (we borrowed
+revision counters from Glimmer, instead), I still like the name.
+
+[nm]: https://www.sos.state.nm.us/about-new-mexico/state-question/
+
+## What is the relationship between salsa and an Entity-Component System (ECS)?
+
+You may have noticed that Salsa "feels" a lot like an ECS in some
+ways. That's true -- Salsa's queries are a bit like *components* (and
+the keys to the queries are a bit like *entities*). But there is one
+big difference: **ECS is -- at its heart -- a mutable system**. You
+can get or set a component of some entity whenever you like. In
+contrast, salsa's queries **define "derived values" via pure
+computations**.
+
+Partly as a consequence, ECS doesn't handle incremental updates for
+you. When you update some component of some entity, you have to ensure
+that other entities' components are updated appropriately.
+
+Finally, ECS offers interesting metadata and "aspect-like" facilities,
+such as iterating over all entities that share certain components.
+Salsa has no analogue to that.
+
diff --git a/crates/salsa/LICENSE-APACHE b/crates/salsa/LICENSE-APACHE
new file mode 100644
index 000000000..16fe87b06
--- /dev/null
+++ b/crates/salsa/LICENSE-APACHE
@@ -0,0 +1,201 @@
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright [yyyy] [name of copyright owner]
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/crates/salsa/LICENSE-MIT b/crates/salsa/LICENSE-MIT
new file mode 100644
index 000000000..31aa79387
--- /dev/null
+++ b/crates/salsa/LICENSE-MIT
@@ -0,0 +1,23 @@
+Permission is hereby granted, free of charge, to any
+person obtaining a copy of this software and associated
+documentation files (the "Software"), to deal in the
+Software without restriction, including without
+limitation the rights to use, copy, modify, merge,
+publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software
+is furnished to do so, subject to the following
+conditions:
+
+The above copyright notice and this permission notice
+shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+DEALINGS IN THE SOFTWARE.
diff --git a/crates/salsa/README.md b/crates/salsa/README.md
new file mode 100644
index 000000000..c25bc4a0f
--- /dev/null
+++ b/crates/salsa/README.md
@@ -0,0 +1,55 @@
+# salsa
+
+[![Test](https://github.com/salsa-rs/salsa/workflows/Test/badge.svg)](https://github.com/salsa-rs/salsa/actions?query=workflow%3ATest)
+[![Book](https://github.com/salsa-rs/salsa/workflows/Book/badge.svg)](https://github.com/salsa-rs/salsa/actions?query=workflow%3ABook)
+[![Released API docs](https://docs.rs/salsa/badge.svg)](https://docs.rs/salsa)
+[![Crates.io](https://img.shields.io/crates/v/salsa.svg)](https://crates.io/crates/salsa)
+
+*A generic framework for on-demand, incrementalized computation.*
+
+<img alt="Salsa Logo" src="https://raw.githubusercontent.com/salsa-rs/logo/main/FerrisSalsa4-01.svg" width="200" />
+
+## Obligatory warning
+
+Very much a WORK IN PROGRESS at this point.
+
+## Credits
+
+This system is heavily inspired by [adapton](http://adapton.org/), [glimmer](https://github.com/glimmerjs/glimmer-vm), and rustc's query
+system. So credit goes to Eduard-Mihai Burtescu, Matthew Hammer,
+Yehuda Katz, and Michael Woerister.
+
+## Key idea
+
+The key idea of `salsa` is that you define your program as a set of
+**queries**. Every query is used like function `K -> V` that maps from
+some key of type `K` to a value of type `V`. Queries come in two basic
+varieties:
+
+- **Inputs**: the base inputs to your system. You can change these
+  whenever you like.
+- **Functions**: pure functions (no side effects) that transform your
+  inputs into other values. The results of queries are memoized to
+  avoid recomputing them a lot. When you make changes to the inputs,
+  we'll figure out (fairly intelligently) when we can re-use these
+  memoized values and when we have to recompute them.
+
+## Want to learn more?
+
+To learn more about Salsa, try one of the following:
+
+- read the [heavily commented examples](https://github.com/salsa-rs/salsa/tree/master/examples);
+- check out the [Salsa book](https://salsa-rs.github.io/salsa);
+    - [](https://rust-chinese-translation.github.io/salsa-book)
+- watch one of our [videos](https://salsa-rs.github.io/salsa/videos.html).
+
+## Getting in touch
+
+The bulk of the discussion happens in the [issues](https://github.com/salsa-rs/salsa/issues)
+and [pull requests](https://github.com/salsa-rs/salsa/pulls),
+but we have a [zulip chat](https://salsa.zulipchat.com/) as well.
+
+## Contributing
+
+To create a release and publish to crates.io, update the `version` field in Cargo.toml.
+After pushed, GitHub Actions will publish the crates to crates.io automatically.
diff --git a/crates/salsa/RELEASES.md b/crates/salsa/RELEASES.md
new file mode 100644
index 000000000..732c400e8
--- /dev/null
+++ b/crates/salsa/RELEASES.md
@@ -0,0 +1,14 @@
+# 0.13.0
+
+- **Breaking change:** adopt the new `Durability` API proposed in [RFC #6]
+    - this replaces and generalizes the existing concepts of constants
+- **Breaking change:** remove "volatile" queries
+    - instead, create a normal query which invokes the
+      `report_untracked_read` method on the salsa runtime
+- introduce "slots", an optimization to salsa's internal workings
+- document `#[salsa::requires]` attribute, which permits private dependencies
+- Adopt `AtomicU64` for `runtimeId` (#182)
+- use `ptr::eq` and `ptr::hash` for readability
+- upgrade parking lot, rand dependencies
+
+[RFC #6]: https://github.com/salsa-rs/salsa-rfcs/pull/6
diff --git a/crates/salsa/benches/accumulator.rs b/crates/salsa/benches/accumulator.rs
new file mode 100644
index 000000000..3a91ec19f
--- /dev/null
+++ b/crates/salsa/benches/accumulator.rs
@@ -0,0 +1,74 @@
+use std::hint::black_box;
+
+use codspeed_criterion_compat::{criterion_group, criterion_main, BatchSize, Criterion};
+use salsa::Accumulator;
+
+include!("shims/global_alloc_overwrite.rs");
+
+#[salsa::input]
+struct Input {
+    expressions: usize,
+}
+
+#[allow(dead_code)]
+#[salsa::accumulator]
+struct Diagnostic(String);
+
+#[salsa::interned]
+struct Expression<'db> {
+    number: usize,
+}
+
+#[salsa::tracked]
+#[inline(never)]
+fn root<'db>(db: &'db dyn salsa::Database, input: Input) -> Vec<usize> {
+    (0..input.expressions(db))
+        .map(|i| infer_expression(db, Expression::new(db, i)))
+        .collect()
+}
+
+#[salsa::tracked]
+#[inline(never)]
+fn infer_expression<'db>(db: &'db dyn salsa::Database, expression: Expression<'db>) -> usize {
+    let number = expression.number(db);
+
+    if number % 10 == 0 {
+        Diagnostic(format!("Number is {number}")).accumulate(db);
+    }
+
+    if number != 0 && number % 2 == 0 {
+        let sub_expression = Expression::new(db, number / 2);
+        let _ = infer_expression(db, sub_expression);
+    }
+
+    number
+}
+
+fn accumulator(criterion: &mut Criterion) {
+    criterion.bench_function("accumulator", |b| {
+        b.iter_batched_ref(
+            || {
+                let db = salsa::DatabaseImpl::new();
+
+                let input = Input::new(black_box(&db), black_box(10_000));
+
+                // Pre-warm
+                let result = root(black_box(&db), black_box(input));
+                assert!(!black_box(result).is_empty());
+
+                (db, input)
+            },
+            |(db, input)| {
+                // Measure the cost of collecting accumulators ignoring the cost of running the
+                // query itself.
+                let diagnostics = root::accumulated::<Diagnostic>(black_box(db), *black_box(input));
+
+                assert_eq!(black_box(diagnostics).len(), 1000);
+            },
+            BatchSize::SmallInput,
+        );
+    });
+}
+
+criterion_group!(benches, accumulator);
+criterion_main!(benches);
diff --git a/crates/salsa/benches/compare.rs b/crates/salsa/benches/compare.rs
new file mode 100644
index 000000000..c4e6b36f8
--- /dev/null
+++ b/crates/salsa/benches/compare.rs
@@ -0,0 +1,245 @@
+use std::hint::black_box;
+use std::mem::transmute;
+
+use codspeed_criterion_compat::{
+    criterion_group, criterion_main, BatchSize, BenchmarkId, Criterion,
+};
+use salsa::Setter;
+
+include!("shims/global_alloc_overwrite.rs");
+
+#[salsa::input]
+pub struct Input {
+    #[returns(ref)]
+    pub text: String,
+}
+
+#[salsa::tracked]
+#[inline(never)]
+pub fn length(db: &dyn salsa::Database, input: Input) -> usize {
+    input.text(db).len()
+}
+
+#[salsa::interned]
+pub struct InternedInput<'db> {
+    #[returns(ref)]
+    pub text: String,
+}
+
+#[derive(Clone, Copy, PartialEq, Eq, Hash, salsa::Supertype)]
+enum SupertypeInput<'db> {
+    InternedInput(InternedInput<'db>),
+    Input(Input),
+}
+
+#[salsa::tracked]
+#[inline(never)]
+pub fn interned_length<'db>(db: &'db dyn salsa::Database, input: InternedInput<'db>) -> usize {
+    input.text(db).len()
+}
+
+#[salsa::tracked]
+#[inline(never)]
+pub fn either_length<'db>(db: &'db dyn salsa::Database, input: SupertypeInput<'db>) -> usize {
+    match input {
+        SupertypeInput::InternedInput(input) => interned_length(db, input),
+        SupertypeInput::Input(input) => length(db, input),
+    }
+}
+
+fn mutating_inputs(c: &mut Criterion) {
+    let mut group: codspeed_criterion_compat::BenchmarkGroup<
+        codspeed_criterion_compat::measurement::WallTime,
+    > = c.benchmark_group("Mutating Inputs");
+
+    for n in &[10, 20, 30] {
+        group.bench_function(BenchmarkId::new("mutating", n), |b| {
+            b.iter_batched_ref(
+                || {
+                    let db = salsa::DatabaseImpl::default();
+                    let base_string = "hello, world!".to_owned();
+                    let base_len = base_string.len();
+
+                    let string = base_string.clone().repeat(*n);
+                    let new_len = string.len();
+
+                    let input = Input::new(black_box(&db), black_box(base_string.clone()));
+                    let actual_len = length(&db, input);
+                    assert_eq!(black_box(actual_len), base_len);
+
+                    (db, input, string, new_len)
+                },
+                |&mut (ref mut db, input, ref string, new_len)| {
+                    input.set_text(black_box(db)).to(black_box(string).clone());
+                    let actual_len = length(db, input);
+                    assert_eq!(black_box(actual_len), new_len);
+                },
+                BatchSize::SmallInput,
+            )
+        });
+    }
+
+    group.finish();
+}
+
+fn inputs(c: &mut Criterion) {
+    let mut group: codspeed_criterion_compat::BenchmarkGroup<
+        codspeed_criterion_compat::measurement::WallTime,
+    > = c.benchmark_group("Mutating Inputs");
+
+    group.bench_function(BenchmarkId::new("new", "InternedInput"), |b| {
+        b.iter_batched_ref(
+            || {
+                let db = salsa::DatabaseImpl::default();
+                // Prepopulate ingredients.
+                let input =
+                    InternedInput::new(black_box(&db), black_box("hello, world!".to_owned()));
+                let interned_len = interned_length(black_box(&db), black_box(input));
+                assert_eq!(black_box(interned_len), 13);
+                db
+            },
+            |db| {
+                let input =
+                    InternedInput::new(black_box(db), black_box("hello, world!".to_owned()));
+                let interned_len = interned_length(black_box(db), black_box(input));
+                assert_eq!(black_box(interned_len), 13);
+            },
+            BatchSize::SmallInput,
+        )
+    });
+
+    group.bench_function(BenchmarkId::new("amortized", "InternedInput"), |b| {
+        b.iter_batched_ref(
+            || {
+                let db = salsa::DatabaseImpl::default();
+                // we can't pass this along otherwise, and the lifetime is generally informational
+                let input: InternedInput<'static> =
+                    unsafe { transmute(InternedInput::new(&db, "hello, world!".to_owned())) };
+                let interned_len = interned_length(black_box(&db), black_box(input));
+                assert_eq!(black_box(interned_len), 13);
+                (db, input)
+            },
+            |&mut (ref db, input)| {
+                let interned_len = interned_length(black_box(db), black_box(input));
+                assert_eq!(black_box(interned_len), 13);
+            },
+            BatchSize::SmallInput,
+        )
+    });
+
+    group.bench_function(BenchmarkId::new("new", "Input"), |b| {
+        b.iter_batched_ref(
+            || {
+                let db = salsa::DatabaseImpl::default();
+
+                // Prepopulate ingredients.
+                let input = Input::new(black_box(&db), black_box("hello, world!".to_owned()));
+                let len = length(black_box(&db), black_box(input));
+                assert_eq!(black_box(len), 13);
+
+                db
+            },
+            |db| {
+                let input = Input::new(black_box(db), black_box("hello, world!".to_owned()));
+                let len = length(black_box(db), black_box(input));
+                assert_eq!(black_box(len), 13);
+            },
+            BatchSize::SmallInput,
+        )
+    });
+
+    group.bench_function(BenchmarkId::new("amortized", "Input"), |b| {
+        b.iter_batched_ref(
+            || {
+                let db = salsa::DatabaseImpl::default();
+
+                let input = Input::new(black_box(&db), black_box("hello, world!".to_owned()));
+                let len = length(black_box(&db), black_box(input));
+                assert_eq!(black_box(len), 13);
+
+                (db, input)
+            },
+            |&mut (ref db, input)| {
+                let len = length(black_box(db), black_box(input));
+                assert_eq!(black_box(len), 13);
+            },
+            BatchSize::SmallInput,
+        )
+    });
+
+    group.bench_function(BenchmarkId::new("new", "SupertypeInput"), |b| {
+        b.iter_batched_ref(
+            || {
+                let db = salsa::DatabaseImpl::default();
+
+                // Prepopulate ingredients.
+                let input = SupertypeInput::Input(Input::new(
+                    black_box(&db),
+                    black_box("hello, world!".to_owned()),
+                ));
+                let interned_input = SupertypeInput::InternedInput(InternedInput::new(
+                    black_box(&db),
+                    black_box("hello, world!".to_owned()),
+                ));
+                let len = either_length(black_box(&db), black_box(input));
+                assert_eq!(black_box(len), 13);
+                let len = either_length(black_box(&db), black_box(interned_input));
+                assert_eq!(black_box(len), 13);
+
+                db
+            },
+            |db| {
+                let input = SupertypeInput::Input(Input::new(
+                    black_box(db),
+                    black_box("hello, world!".to_owned()),
+                ));
+                let interned_input = SupertypeInput::InternedInput(InternedInput::new(
+                    black_box(db),
+                    black_box("hello, world!".to_owned()),
+                ));
+                let len = either_length(black_box(db), black_box(input));
+                assert_eq!(black_box(len), 13);
+                let len = either_length(black_box(db), black_box(interned_input));
+                assert_eq!(black_box(len), 13);
+            },
+            BatchSize::SmallInput,
+        )
+    });
+
+    group.bench_function(BenchmarkId::new("amortized", "SupertypeInput"), |b| {
+        b.iter_batched_ref(
+            || {
+                let db = salsa::DatabaseImpl::default();
+
+                let input = SupertypeInput::Input(Input::new(
+                    black_box(&db),
+                    black_box("hello, world!".to_owned()),
+                ));
+                let interned_input = SupertypeInput::InternedInput(InternedInput::new(
+                    black_box(&db),
+                    black_box("hello, world!".to_owned()),
+                ));
+                // we can't pass this along otherwise, and the lifetime is generally informational
+                let interned_input: SupertypeInput<'static> = unsafe { transmute(interned_input) };
+                let len = either_length(black_box(&db), black_box(input));
+                assert_eq!(black_box(len), 13);
+                let len = either_length(black_box(&db), black_box(interned_input));
+                assert_eq!(black_box(len), 13);
+
+                (db, input, interned_input)
+            },
+            |&mut (ref db, input, interned_input)| {
+                let len = either_length(black_box(db), black_box(input));
+                assert_eq!(black_box(len), 13);
+                let len = either_length(black_box(db), black_box(interned_input));
+                assert_eq!(black_box(len), 13);
+            },
+            BatchSize::SmallInput,
+        )
+    });
+
+    group.finish();
+}
+
+criterion_group!(benches, mutating_inputs, inputs);
+criterion_main!(benches);
diff --git a/crates/salsa/benches/dataflow.rs b/crates/salsa/benches/dataflow.rs
new file mode 100644
index 000000000..f4f1aeaf1
--- /dev/null
+++ b/crates/salsa/benches/dataflow.rs
@@ -0,0 +1,173 @@
+//! Benchmark for fixpoint iteration cycle resolution.
+//!
+//! This benchmark simulates a (very simplified) version of a real dataflow analysis using fixpoint
+//! iteration.
+use std::collections::BTreeSet;
+use std::iter::IntoIterator;
+
+use codspeed_criterion_compat::{criterion_group, criterion_main, BatchSize, Criterion};
+use salsa::{CycleRecoveryAction, Database as Db, Setter};
+
+include!("shims/global_alloc_overwrite.rs");
+
+/// A Use of a symbol.
+#[salsa::input]
+struct Use {
+    reaching_definitions: Vec<Definition>,
+}
+
+/// A Definition of a symbol, either of the form `base + increment` or `0 + increment`.
+#[salsa::input]
+struct Definition {
+    base: Option<Use>,
+    increment: usize,
+}
+
+#[derive(Eq, PartialEq, Clone, Debug, salsa::Update)]
+enum Type {
+    Bottom,
+    Values(Box<[usize]>),
+    Top,
+}
+
+impl Type {
+    fn join(tys: impl IntoIterator<Item = Type>) -> Type {
+        let mut result = Type::Bottom;
+        for ty in tys.into_iter() {
+            result = match (result, ty) {
+                (result, Type::Bottom) => result,
+                (_, Type::Top) => Type::Top,
+                (Type::Top, _) => Type::Top,
+                (Type::Bottom, ty) => ty,
+                (Type::Values(a_ints), Type::Values(b_ints)) => {
+                    let mut set = BTreeSet::new();
+                    set.extend(a_ints);
+                    set.extend(b_ints);
+                    Type::Values(set.into_iter().collect())
+                }
+            }
+        }
+        result
+    }
+}
+
+#[salsa::tracked(cycle_fn=use_cycle_recover, cycle_initial=use_cycle_initial)]
+fn infer_use<'db>(db: &'db dyn Db, u: Use) -> Type {
+    let defs = u.reaching_definitions(db);
+    match defs[..] {
+        [] => Type::Bottom,
+        [def] => infer_definition(db, def),
+        _ => Type::join(defs.iter().map(|&def| infer_definition(db, def))),
+    }
+}
+
+#[salsa::tracked(cycle_fn=def_cycle_recover, cycle_initial=def_cycle_initial)]
+fn infer_definition<'db>(db: &'db dyn Db, def: Definition) -> Type {
+    let increment_ty = Type::Values(Box::from([def.increment(db)]));
+    if let Some(base) = def.base(db) {
+        let base_ty = infer_use(db, base);
+        add(&base_ty, &increment_ty)
+    } else {
+        increment_ty
+    }
+}
+
+fn def_cycle_initial(_db: &dyn Db, _def: Definition) -> Type {
+    Type::Bottom
+}
+
+fn def_cycle_recover(
+    _db: &dyn Db,
+    value: &Type,
+    count: u32,
+    _def: Definition,
+) -> CycleRecoveryAction<Type> {
+    cycle_recover(value, count)
+}
+
+fn use_cycle_initial(_db: &dyn Db, _use: Use) -> Type {
+    Type::Bottom
+}
+
+fn use_cycle_recover(
+    _db: &dyn Db,
+    value: &Type,
+    count: u32,
+    _use: Use,
+) -> CycleRecoveryAction<Type> {
+    cycle_recover(value, count)
+}
+
+fn cycle_recover(value: &Type, count: u32) -> CycleRecoveryAction<Type> {
+    match value {
+        Type::Bottom => CycleRecoveryAction::Iterate,
+        Type::Values(_) => {
+            if count > 4 {
+                CycleRecoveryAction::Fallback(Type::Top)
+            } else {
+                CycleRecoveryAction::Iterate
+            }
+        }
+        Type::Top => CycleRecoveryAction::Iterate,
+    }
+}
+
+fn add(a: &Type, b: &Type) -> Type {
+    match (a, b) {
+        (Type::Bottom, _) | (_, Type::Bottom) => Type::Bottom,
+        (Type::Top, _) | (_, Type::Top) => Type::Top,
+        (Type::Values(a_ints), Type::Values(b_ints)) => {
+            let mut set = BTreeSet::new();
+            set.extend(
+                a_ints
+                    .into_iter()
+                    .flat_map(|a| b_ints.into_iter().map(move |b| a + b)),
+            );
+            Type::Values(set.into_iter().collect())
+        }
+    }
+}
+
+fn dataflow(criterion: &mut Criterion) {
+    criterion.bench_function("converge_diverge", |b| {
+        b.iter_batched_ref(
+            || {
+                let mut db = salsa::DatabaseImpl::new();
+
+                let defx0 = Definition::new(&db, None, 0);
+                let defy0 = Definition::new(&db, None, 0);
+                let defx1 = Definition::new(&db, None, 0);
+                let defy1 = Definition::new(&db, None, 0);
+                let use_x = Use::new(&db, vec![defx0, defx1]);
+                let use_y = Use::new(&db, vec![defy0, defy1]);
+                defx1.set_base(&mut db).to(Some(use_y));
+                defy1.set_base(&mut db).to(Some(use_x));
+
+                // prewarm cache
+                let _ = infer_use(&db, use_x);
+                let _ = infer_use(&db, use_y);
+
+                (db, defx1, use_x, use_y)
+            },
+            |(db, defx1, use_x, use_y)| {
+                // Set the increment on x to 0.
+                defx1.set_increment(db).to(0);
+
+                // Both symbols converge on 0.
+                assert_eq!(infer_use(db, *use_x), Type::Values(Box::from([0])));
+                assert_eq!(infer_use(db, *use_y), Type::Values(Box::from([0])));
+
+                // Set the increment on x to 1.
+                defx1.set_increment(db).to(1);
+
+                // Now the loop diverges and we fall back to Top.
+                assert_eq!(infer_use(db, *use_x), Type::Top);
+                assert_eq!(infer_use(db, *use_y), Type::Top);
+            },
+            BatchSize::LargeInput,
+        );
+    });
+}
+
+criterion_group!(benches, dataflow);
+criterion_main!(benches);
diff --git a/crates/salsa/benches/incremental.rs b/crates/salsa/benches/incremental.rs
new file mode 100644
index 000000000..872d9fa1a
--- /dev/null
+++ b/crates/salsa/benches/incremental.rs
@@ -0,0 +1,62 @@
+use std::hint::black_box;
+
+use codspeed_criterion_compat::{criterion_group, criterion_main, BatchSize, Criterion};
+use salsa::Setter;
+
+include!("shims/global_alloc_overwrite.rs");
+
+#[salsa::input]
+struct Input {
+    field: usize,
+}
+
+#[salsa::tracked]
+struct Tracked<'db> {
+    number: usize,
+}
+
+#[salsa::tracked(returns(ref))]
+#[inline(never)]
+fn index<'db>(db: &'db dyn salsa::Database, input: Input) -> Vec<Tracked<'db>> {
+    (0..input.field(db)).map(|i| Tracked::new(db, i)).collect()
+}
+
+#[salsa::tracked]
+#[inline(never)]
+fn root(db: &dyn salsa::Database, input: Input) -> usize {
+    let index = index(db, input);
+    index.len()
+}
+
+fn many_tracked_structs(criterion: &mut Criterion) {
+    criterion.bench_function("many_tracked_structs", |b| {
+        b.iter_batched_ref(
+            || {
+                let db = salsa::DatabaseImpl::new();
+
+                let input = Input::new(black_box(&db), black_box(1_000));
+                let input2 = Input::new(black_box(&db), black_box(1));
+
+                // prewarm cache
+                let root1 = root(black_box(&db), black_box(input));
+                assert_eq!(black_box(root1), 1_000);
+                let root2 = root(black_box(&db), black_box(input2));
+                assert_eq!(black_box(root2), 1);
+
+                (db, input, input2)
+            },
+            |(db, input, input2)| {
+                // Make a change, but fetch the result for the other input
+                input2.set_field(black_box(db)).to(black_box(2));
+
+                let result = root(black_box(db), *black_box(input));
+
+                assert_eq!(black_box(result), 1_000);
+            },
+            BatchSize::LargeInput,
+        );
+    });
+}
+
+criterion_group!(benches, many_tracked_structs);
+criterion_main!(benches);
diff --git a/crates/salsa/benches/shims/global_alloc_overwrite.rs b/crates/salsa/benches/shims/global_alloc_overwrite.rs
new file mode 100644
index 000000000..e3b5ea74f
--- /dev/null
+++ b/crates/salsa/benches/shims/global_alloc_overwrite.rs
@@ -0,0 +1,29 @@
+#[cfg(all(
+    not(target_os = "windows"),
+    not(target_os = "openbsd"),
+    any(
+        target_arch = "x86_64",
+        target_arch = "aarch64",
+        target_arch = "powerpc64"
+    )
+))]
+#[global_allocator]
+static GLOBAL: tikv_jemallocator::Jemalloc = tikv_jemallocator::Jemalloc;
+
+// Disable decay after 10s because it can show up as *random* slow allocations
+// in benchmarks. We don't need purging in benchmarks because it isn't important
+// to give unallocated pages back to the OS.
+// https://jemalloc.net/jemalloc.3.html#opt.dirty_decay_ms
+#[cfg(all(
+    not(target_os = "windows"),
+    not(target_os = "openbsd"),
+    any(
+        target_arch = "x86_64",
+        target_arch = "aarch64",
+        target_arch = "powerpc64"
+    )
+))]
+#[allow(non_upper_case_globals)]
+#[export_name = "_rjem_malloc_conf"]
+#[allow(unsafe_code)]
+pub static _rjem_malloc_conf: &[u8] = b"dirty_decay_ms:-1,muzzy_decay_ms:-1\0";
diff --git a/crates/salsa/book/.gitignore b/crates/salsa/book/.gitignore
new file mode 100644
index 000000000..7585238ef
--- /dev/null
+++ b/crates/salsa/book/.gitignore
@@ -0,0 +1 @@
+book
diff --git a/crates/salsa/book/book.toml b/crates/salsa/book/book.toml
new file mode 100644
index 000000000..f904156c7
--- /dev/null
+++ b/crates/salsa/book/book.toml
@@ -0,0 +1,22 @@
+[book]
+authors = ["Salsa Contributors"]
+multilingual = false
+src = "src"
+title = "Salsa"
+
+[build]
+create-missing = false
+
+[preprocess.links]
+
+[output.html]
+additional-css =["mermaid.css"]
+additional-js =["mermaid.min.js", "mermaid-init.js"]
+
+[output.linkcheck]
+# follow-web-links = true --- this is commented out b/c of false errors
+traverse-parent-directories = false
+exclude = ['bilibili\.com']
+[preprocessor]
+[preprocessor.mermaid]
+command = "mdbook-mermaid"
diff --git a/crates/salsa/book/mermaid-init.js b/crates/salsa/book/mermaid-init.js
new file mode 100644
index 000000000..313a6e8bc
--- /dev/null
+++ b/crates/salsa/book/mermaid-init.js
@@ -0,0 +1 @@
+mermaid.initialize({startOnLoad:true});
diff --git a/crates/salsa/book/mermaid.css b/crates/salsa/book/mermaid.css
new file mode 100644
index 000000000..74de2c111
--- /dev/null
+++ b/crates/salsa/book/mermaid.css
@@ -0,0 +1,351 @@
+/* Flowchart variables */
+/* Sequence Diagram variables */
+/* Gantt chart variables */
+.mermaid .mermaid .label {
+  color: #333;
+}
+.mermaid .node rect,
+.mermaid .node circle,
+.mermaid .node ellipse,
+.mermaid .node polygon {
+  fill: #ECECFF;
+  stroke: #CCCCFF;
+  stroke-width: 1px;
+}
+.mermaid .arrowheadPath {
+  fill: #333333;
+}
+.mermaid .edgePath .path {
+  stroke: #333333;
+}
+.mermaid .edgeLabel {
+  background-color: #e8e8e8;
+}
+.mermaid .cluster rect {
+  fill: #ffffde !important;
+  rx: 4 !important;
+  stroke: #aaaa33 !important;
+  stroke-width: 1px !important;
+}
+.mermaid .cluster text {
+  fill: #333;
+}
+.mermaid .actor {
+  stroke: #CCCCFF;
+  fill: #ECECFF;
+}
+.mermaid text.actor {
+  fill: black;
+  stroke: none;
+}
+.mermaid .actor-line {
+  stroke: grey;
+}
+.mermaid .messageLine0 {
+  stroke-width: 1.5;
+  stroke-dasharray: "2 2";
+  marker-end: "url(#arrowhead)";
+  stroke: #333;
+}
+.mermaid .messageLine1 {
+  stroke-width: 1.5;
+  stroke-dasharray: "2 2";
+  stroke: #333;
+}
+.mermaid #arrowhead {
+  fill: #333;
+}
+.mermaid #crosshead path {
+  fill: #333 !important;
+  stroke: #333 !important;
+}
+.mermaid .messageText {
+  fill: #333;
+  stroke: none;
+}
+.mermaid .labelBox {
+  stroke: #CCCCFF;
+  fill: #ECECFF;
+}
+.mermaid .labelText {
+  fill: black;
+  stroke: none;
+}
+.mermaid .loopText {
+  fill: black;
+  stroke: none;
+}
+.mermaid .loopLine {
+  stroke-width: 2;
+  stroke-dasharray: "2 2";
+  marker-end: "url(#arrowhead)";
+  stroke: #CCCCFF;
+}
+.mermaid .note {
+  stroke: #aaaa33;
+  fill: #fff5ad;
+}
+.mermaid .noteText {
+  fill: black;
+  stroke: none;
+  font-family: 'trebuchet ms', verdana, arial;
+  font-size: 14px;
+}
+/** Section styling */
+.mermaid .section {
+  stroke: none;
+  opacity: 0.2;
+}
+.mermaid .section0 {
+  fill: rgba(102, 102, 255, 0.49);
+}
+.mermaid .section2 {
+  fill: #fff400;
+}
+.mermaid .section1,
+.mermaid .section3 {
+  fill: white;
+  opacity: 0.2;
+}
+.mermaid .sectionTitle0 {
+  fill: #333;
+}
+.mermaid .sectionTitle1 {
+  fill: #333;
+}
+.mermaid .sectionTitle2 {
+  fill: #333;
+}
+.mermaid .sectionTitle3 {
+  fill: #333;
+}
+.mermaid .sectionTitle {
+  text-anchor: start;
+  font-size: 11px;
+  text-height: 14px;
+}
+/* Grid and axis */
+.mermaid .grid .tick {
+  stroke: lightgrey;
+  opacity: 0.3;
+  shape-rendering: crispEdges;
+}
+.mermaid .grid path {
+  stroke-width: 0;
+}
+/* Today line */
+.mermaid .today {
+  fill: none;
+  stroke: red;
+  stroke-width: 2px;
+}
+/* Task styling */
+/* Default task */
+.mermaid .task {
+  stroke-width: 2;
+}
+.mermaid .taskText {
+  text-anchor: middle;
+  font-size: 11px;
+}
+.mermaid .taskTextOutsideRight {
+  fill: black;
+  text-anchor: start;
+  font-size: 11px;
+}
+.mermaid .taskTextOutsideLeft {
+  fill: black;
+  text-anchor: end;
+  font-size: 11px;
+}
+/* Specific task settings for the sections*/
+.mermaid .taskText0,
+.mermaid .taskText1,
+.mermaid .taskText2,
+.mermaid .taskText3 {
+  fill: white;
+}
+.mermaid .task0,
+.mermaid .task1,
+.mermaid .task2,
+.mermaid .task3 {
+  fill: #8a90dd;
+  stroke: #534fbc;
+}
+.mermaid .taskTextOutside0,
+.mermaid .taskTextOutside2 {
+  fill: black;
+}
+.mermaid .taskTextOutside1,
+.mermaid .taskTextOutside3 {
+  fill: black;
+}
+/* Active task */
+.mermaid .active0,
+.mermaid .active1,
+.mermaid .active2,
+.mermaid .active3 {
+  fill: #bfc7ff;
+  stroke: #534fbc;
+}
+.mermaid .activeText0,
+.mermaid .activeText1,
+.mermaid .activeText2,
+.mermaid .activeText3 {
+  fill: black !important;
+}
+/* Completed task */
+.mermaid .done0,
+.mermaid .done1,
+.mermaid .done2,
+.mermaid .done3 {
+  stroke: grey;
+  fill: lightgrey;
+  stroke-width: 2;
+}
+.mermaid .doneText0,
+.mermaid .doneText1,
+.mermaid .doneText2,
+.mermaid .doneText3 {
+  fill: black !important;
+}
+/* Tasks on the critical line */
+.mermaid .crit0,
+.mermaid .crit1,
+.mermaid .crit2,
+.mermaid .crit3 {
+  stroke: #ff8888;
+  fill: red;
+  stroke-width: 2;
+}
+.mermaid .activeCrit0,
+.mermaid .activeCrit1,
+.mermaid .activeCrit2,
+.mermaid .activeCrit3 {
+  stroke: #ff8888;
+  fill: #bfc7ff;
+  stroke-width: 2;
+}
+.mermaid .doneCrit0,
+.mermaid .doneCrit1,
+.mermaid .doneCrit2,
+.mermaid .doneCrit3 {
+  stroke: #ff8888;
+  fill: lightgrey;
+  stroke-width: 2;
+  cursor: pointer;
+  shape-rendering: crispEdges;
+}
+.mermaid .doneCritText0,
+.mermaid .doneCritText1,
+.mermaid .doneCritText2,
+.mermaid .doneCritText3 {
+  fill: black !important;
+}
+.mermaid .activeCritText0,
+.mermaid .activeCritText1,
+.mermaid .activeCritText2,
+.mermaid .activeCritText3 {
+  fill: black !important;
+}
+.mermaid .titleText {
+  text-anchor: middle;
+  font-size: 18px;
+  fill: black;
+}
+.mermaid g.classGroup text {
+  fill: #9370DB;
+  stroke: none;
+  font-family: 'trebuchet ms', verdana, arial;
+  font-size: 10px;
+}
+.mermaid g.classGroup rect {
+  fill: #ECECFF;
+  stroke: #9370DB;
+}
+.mermaid g.classGroup line {
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid svg .classLabel .box {
+  stroke: none;
+  stroke-width: 0;
+  fill: #ECECFF;
+  opacity: 0.5;
+}
+.mermaid svg .classLabel .label {
+  fill: #9370DB;
+  font-size: 10px;
+}
+.mermaid .relation {
+  stroke: #9370DB;
+  stroke-width: 1;
+  fill: none;
+}
+.mermaid .composition {
+  fill: #9370DB;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid #compositionStart {
+  fill: #9370DB;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid #compositionEnd {
+  fill: #9370DB;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid .aggregation {
+  fill: #ECECFF;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid #aggregationStart {
+  fill: #ECECFF;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid #aggregationEnd {
+  fill: #ECECFF;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid #dependencyStart {
+  fill: #9370DB;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid #dependencyEnd {
+  fill: #9370DB;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid #extensionStart {
+  fill: #9370DB;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid #extensionEnd {
+  fill: #9370DB;
+  stroke: #9370DB;
+  stroke-width: 1;
+}
+.mermaid .node text {
+  font-family: 'trebuchet ms', verdana, arial;
+  font-size: 14px;
+}
+.mermaid div.mermaidTooltip {
+  position: absolute;
+  text-align: center;
+  max-width: 200px;
+  padding: 2px;
+  font-family: 'trebuchet ms', verdana, arial;
+  font-size: 12px;
+  background: #ffffde;
+  border: 1px solid #aaaa33;
+  border-radius: 2px;
+  pointer-events: none;
+  z-index: 100;
+}
diff --git a/crates/salsa/book/mermaid.min.js b/crates/salsa/book/mermaid.min.js
new file mode 100644
index 000000000..0a72f3373
--- /dev/null
+++ b/crates/salsa/book/mermaid.min.js
@@ -0,0 +1,49 @@
+!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.mermaid=e():t.mermaid=e()}(window,(function(){return function(t){var e={};function n(r){if(e[r])return e[r].exports;var i=e[r]={i:r,l:!1,exports:{}};return t[r].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)n.d(r,i,function(e){return t[e]}.bind(null,i));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=509)}([function(t,e,n){"use strict";n.r(e);var r=function(t,e){return t<e?-1:t>e?1:t>=e?0:NaN},i=function(t){var e;return 1===t.length&&(e=t,t=function(t,n){return r(e(t),n)}),{left:function(e,n,r,i){for(null==r&&(r=0),null==i&&(i=e.length);r<i;){var o=r+i>>>1;t(e[o],n)<0?r=o+1:i=o}return r},right:function(e,n,r,i){for(null==r&&(r=0),null==i&&(i=e.length);r<i;){var o=r+i>>>1;t(e[o],n)>0?i=o:r=o+1}return r}}};var o=i(r),a=o.right,s=o.left,u=a,c=function(t,e){null==e&&(e=f);for(var n=0,r=t.length-1,i=t[0],o=new Array(r<0?0:r);n<r;)o[n]=e(i,i=t[++n]);return o};function f(t,e){return[t,e]}var l=function(t,e,n){var r,i,o,a,s=t.length,u=e.length,c=new Array(s*u);for(null==n&&(n=f),r=o=0;r<s;++r)for(a=t[r],i=0;i<u;++i,++o)c[o]=n(a,e[i]);return c},h=function(t,e){return e<t?-1:e>t?1:e>=t?0:NaN},d=function(t){return null===t?NaN:+t},p=function(t,e){var n,r,i=t.length,o=0,a=-1,s=0,u=0;if(null==e)for(;++a<i;)isNaN(n=d(t[a]))||(u+=(r=n-s)*(n-(s+=r/++o)));else for(;++a<i;)isNaN(n=d(e(t[a],a,t)))||(u+=(r=n-s)*(n-(s+=r/++o)));if(o>1)return u/(o-1)},g=function(t,e){var n=p(t,e);return n?Math.sqrt(n):n},y=function(t,e){var n,r,i,o=t.length,a=-1;if(null==e){for(;++a<o;)if(null!=(n=t[a])&&n>=n)for(r=i=n;++a<o;)null!=(n=t[a])&&(r>n&&(r=n),i<n&&(i=n))}else for(;++a<o;)if(null!=(n=e(t[a],a,t))&&n>=n)for(r=i=n;++a<o;)null!=(n=e(t[a],a,t))&&(r>n&&(r=n),i<n&&(i=n));return[r,i]},b=Array.prototype,m=b.slice,v=b.map,_=function(t){return function(){return t}},w=function(t){return t},x=function(t,e,n){t=+t,e=+e,n=(i=arguments.length)<2?(e=t,t=0,1):i<3?1:+n;for(var r=-1,i=0|Math.max(0,Math.ceil((e-t)/n)),o=new Array(i);++r<i;)o[r]=t+r*n;return o},k=Math.sqrt(50),E=Math.sqrt(10),A=Math.sqrt(2),S=function(t,e,n){var r,i,o,a,s=-1;if(n=+n,(t=+t)===(e=+e)&&n>0)return[t];if((r=e<t)&&(i=t,t=e,e=i),0===(a=T(t,e,n))||!isFinite(a))return[];if(a>0)for(t=Math.ceil(t/a),e=Math.floor(e/a),o=new Array(i=Math.ceil(e-t+1));++s<i;)o[s]=(t+s)*a;else for(t=Math.floor(t*a),e=Math.ceil(e*a),o=new Array(i=Math.ceil(t-e+1));++s<i;)o[s]=(t-s)/a;return r&&o.reverse(),o};function T(t,e,n){var r=(e-t)/Math.max(0,n),i=Math.floor(Math.log(r)/Math.LN10),o=r/Math.pow(10,i);return i>=0?(o>=k?10:o>=E?5:o>=A?2:1)*Math.pow(10,i):-Math.pow(10,-i)/(o>=k?10:o>=E?5:o>=A?2:1)}function M(t,e,n){var r=Math.abs(e-t)/Math.max(0,n),i=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),o=r/i;return o>=k?i*=10:o>=E?i*=5:o>=A&&(i*=2),e<t?-i:i}var D=function(t){return Math.ceil(Math.log(t.length)/Math.LN2)+1},C=function(){var t=w,e=y,n=D;function r(r){var i,o,a=r.length,s=new Array(a);for(i=0;i<a;++i)s[i]=t(r[i],i,r);var c=e(s),f=c[0],l=c[1],h=n(s,f,l);Array.isArray(h)||(h=M(f,l,h),h=x(Math.ceil(f/h)*h,l,h));for(var d=h.length;h[0]<=f;)h.shift(),--d;for(;h[d-1]>l;)h.pop(),--d;var p,g=new Array(d+1);for(i=0;i<=d;++i)(p=g[i]=[]).x0=i>0?h[i-1]:f,p.x1=i<d?h[i]:l;for(i=0;i<a;++i)f<=(o=s[i])&&o<=l&&g[u(h,o,0,d)].push(r[i]);return g}return r.value=function(e){return arguments.length?(t="function"==typeof e?e:_(e),r):t},r.domain=function(t){return arguments.length?(e="function"==typeof t?t:_([t[0],t[1]]),r):e},r.thresholds=function(t){return arguments.length?(n="function"==typeof t?t:Array.isArray(t)?_(m.call(t)):_(t),r):n},r},O=function(t,e,n){if(null==n&&(n=d),r=t.length){if((e=+e)<=0||r<2)return+n(t[0],0,t);if(e>=1)return+n(t[r-1],r-1,t);var r,i=(r-1)*e,o=Math.floor(i),a=+n(t[o],o,t);return a+(+n(t[o+1],o+1,t)-a)*(i-o)}},R=function(t,e,n){return t=v.call(t,d).sort(r),Math.ceil((n-e)/(2*(O(t,.75)-O(t,.25))*Math.pow(t.length,-1/3)))},I=function(t,e,n){return Math.ceil((n-e)/(3.5*g(t)*Math.pow(t.length,-1/3)))},N=function(t,e){var n,r,i=t.length,o=-1;if(null==e){for(;++o<i;)if(null!=(n=t[o])&&n>=n)for(r=n;++o<i;)null!=(n=t[o])&&n>r&&(r=n)}else for(;++o<i;)if(null!=(n=e(t[o],o,t))&&n>=n)for(r=n;++o<i;)null!=(n=e(t[o],o,t))&&n>r&&(r=n);return r},B=function(t,e){var n,r=t.length,i=r,o=-1,a=0;if(null==e)for(;++o<r;)isNaN(n=d(t[o]))?--i:a+=n;else for(;++o<r;)isNaN(n=d(e(t[o],o,t)))?--i:a+=n;if(i)return a/i},L=function(t,e){var n,i=t.length,o=-1,a=[];if(null==e)for(;++o<i;)isNaN(n=d(t[o]))||a.push(n);else for(;++o<i;)isNaN(n=d(e(t[o],o,t)))||a.push(n);return O(a.sort(r),.5)},P=function(t){for(var e,n,r,i=t.length,o=-1,a=0;++o<i;)a+=t[o].length;for(n=new Array(a);--i>=0;)for(e=(r=t[i]).length;--e>=0;)n[--a]=r[e];return n},F=function(t,e){var n,r,i=t.length,o=-1;if(null==e){for(;++o<i;)if(null!=(n=t[o])&&n>=n)for(r=n;++o<i;)null!=(n=t[o])&&r>n&&(r=n)}else for(;++o<i;)if(null!=(n=e(t[o],o,t))&&n>=n)for(r=n;++o<i;)null!=(n=e(t[o],o,t))&&r>n&&(r=n);return r},q=function(t,e){for(var n=e.length,r=new Array(n);n--;)r[n]=t[e[n]];return r},j=function(t,e){if(n=t.length){var n,i,o=0,a=0,s=t[a];for(null==e&&(e=r);++o<n;)(e(i=t[o],s)<0||0!==e(s,s))&&(s=i,a=o);return 0===e(s,s)?a:void 0}},U=function(t,e,n){for(var r,i,o=(null==n?t.length:n)-(e=null==e?0:+e);o;)i=Math.random()*o--|0,r=t[o+e],t[o+e]=t[i+e],t[i+e]=r;return t},z=function(t,e){var n,r=t.length,i=-1,o=0;if(null==e)for(;++i<r;)(n=+t[i])&&(o+=n);else for(;++i<r;)(n=+e(t[i],i,t))&&(o+=n);return o},Y=function(t){if(!(i=t.length))return[];for(var e=-1,n=F(t,V),r=new Array(n);++e<n;)for(var i,o=-1,a=r[e]=new Array(i);++o<i;)a[o]=t[o][e];return r};function V(t){return t.length}var H=function(){return Y(arguments)},$=Array.prototype.slice,G=function(t){return t},W=1,K=2,X=3,Z=4,J=1e-6;function Q(t){return"translate("+(t+.5)+",0)"}function tt(t){return"translate(0,"+(t+.5)+")"}function et(t){return function(e){return+t(e)}}function nt(t){var e=Math.max(0,t.bandwidth()-1)/2;return t.round()&&(e=Math.round(e)),function(n){return+t(n)+e}}function rt(){return!this.__axis}function it(t,e){var n=[],r=null,i=null,o=6,a=6,s=3,u=t===W||t===Z?-1:1,c=t===Z||t===K?"x":"y",f=t===W||t===X?Q:tt;function l(l){var h=null==r?e.ticks?e.ticks.apply(e,n):e.domain():r,d=null==i?e.tickFormat?e.tickFormat.apply(e,n):G:i,p=Math.max(o,0)+s,g=e.range(),y=+g[0]+.5,b=+g[g.length-1]+.5,m=(e.bandwidth?nt:et)(e.copy()),v=l.selection?l.selection():l,_=v.selectAll(".domain").data([null]),w=v.selectAll(".tick").data(h,e).order(),x=w.exit(),k=w.enter().append("g").attr("class","tick"),E=w.select("line"),A=w.select("text");_=_.merge(_.enter().insert("path",".tick").attr("class","domain").attr("stroke","currentColor")),w=w.merge(k),E=E.merge(k.append("line").attr("stroke","currentColor").attr(c+"2",u*o)),A=A.merge(k.append("text").attr("fill","currentColor").attr(c,u*p).attr("dy",t===W?"0em":t===X?"0.71em":"0.32em")),l!==v&&(_=_.transition(l),w=w.transition(l),E=E.transition(l),A=A.transition(l),x=x.transition(l).attr("opacity",J).attr("transform",(function(t){return isFinite(t=m(t))?f(t):this.getAttribute("transform")})),k.attr("opacity",J).attr("transform",(function(t){var e=this.parentNode.__axis;return f(e&&isFinite(e=e(t))?e:m(t))}))),x.remove(),_.attr("d",t===Z||t==K?a?"M"+u*a+","+y+"H0.5V"+b+"H"+u*a:"M0.5,"+y+"V"+b:a?"M"+y+","+u*a+"V0.5H"+b+"V"+u*a:"M"+y+",0.5H"+b),w.attr("opacity",1).attr("transform",(function(t){return f(m(t))})),E.attr(c+"2",u*o),A.attr(c,u*p).text(d),v.filter(rt).attr("fill","none").attr("font-size",10).attr("font-family","sans-serif").attr("text-anchor",t===K?"start":t===Z?"end":"middle"),v.each((function(){this.__axis=m}))}return l.scale=function(t){return arguments.length?(e=t,l):e},l.ticks=function(){return n=$.call(arguments),l},l.tickArguments=function(t){return arguments.length?(n=null==t?[]:$.call(t),l):n.slice()},l.tickValues=function(t){return arguments.length?(r=null==t?null:$.call(t),l):r&&r.slice()},l.tickFormat=function(t){return arguments.length?(i=t,l):i},l.tickSize=function(t){return arguments.length?(o=a=+t,l):o},l.tickSizeInner=function(t){return arguments.length?(o=+t,l):o},l.tickSizeOuter=function(t){return arguments.length?(a=+t,l):a},l.tickPadding=function(t){return arguments.length?(s=+t,l):s},l}function ot(t){return it(W,t)}function at(t){return it(K,t)}function st(t){return it(X,t)}function ut(t){return it(Z,t)}var ct={value:function(){}};function ft(){for(var t,e=0,n=arguments.length,r={};e<n;++e){if(!(t=arguments[e]+"")||t in r)throw new Error("illegal type: "+t);r[t]=[]}return new lt(r)}function lt(t){this._=t}function ht(t,e){return t.trim().split(/^|\s+/).map((function(t){var n="",r=t.indexOf(".");if(r>=0&&(n=t.slice(r+1),t=t.slice(0,r)),t&&!e.hasOwnProperty(t))throw new Error("unknown type: "+t);return{type:t,name:n}}))}function dt(t,e){for(var n,r=0,i=t.length;r<i;++r)if((n=t[r]).name===e)return n.value}function pt(t,e,n){for(var r=0,i=t.length;r<i;++r)if(t[r].name===e){t[r]=ct,t=t.slice(0,r).concat(t.slice(r+1));break}return null!=n&&t.push({name:e,value:n}),t}lt.prototype=ft.prototype={constructor:lt,on:function(t,e){var n,r=this._,i=ht(t+"",r),o=-1,a=i.length;if(!(arguments.length<2)){if(null!=e&&"function"!=typeof e)throw new Error("invalid callback: "+e);for(;++o<a;)if(n=(t=i[o]).type)r[n]=pt(r[n],t.name,e);else if(null==e)for(n in r)r[n]=pt(r[n],t.name,null);return this}for(;++o<a;)if((n=(t=i[o]).type)&&(n=dt(r[n],t.name)))return n},copy:function(){var t={},e=this._;for(var n in e)t[n]=e[n].slice();return new lt(t)},call:function(t,e){if((n=arguments.length-2)>0)for(var n,r,i=new Array(n),o=0;o<n;++o)i[o]=arguments[o+2];if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(o=0,n=(r=this._[t]).length;o<n;++o)r[o].value.apply(e,i)},apply:function(t,e,n){if(!this._.hasOwnProperty(t))throw new Error("unknown type: "+t);for(var r=this._[t],i=0,o=r.length;i<o;++i)r[i].value.apply(e,n)}};var gt=ft,yt="http://www.w3.org/1999/xhtml",bt={svg:"http://www.w3.org/2000/svg",xhtml:yt,xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"},mt=function(t){var e=t+="",n=e.indexOf(":");return n>=0&&"xmlns"!==(e=t.slice(0,n))&&(t=t.slice(n+1)),bt.hasOwnProperty(e)?{space:bt[e],local:t}:t};function vt(t){return function(){var e=this.ownerDocument,n=this.namespaceURI;return n===yt&&e.documentElement.namespaceURI===yt?e.createElement(t):e.createElementNS(n,t)}}function _t(t){return function(){return this.ownerDocument.createElementNS(t.space,t.local)}}var wt=function(t){var e=mt(t);return(e.local?_t:vt)(e)};function xt(){}var kt=function(t){return null==t?xt:function(){return this.querySelector(t)}};function Et(){return[]}var At=function(t){return null==t?Et:function(){return this.querySelectorAll(t)}},St=function(t){return function(){return this.matches(t)}},Tt=function(t){return new Array(t.length)};function Mt(t,e){this.ownerDocument=t.ownerDocument,this.namespaceURI=t.namespaceURI,this._next=null,this._parent=t,this.__data__=e}Mt.prototype={constructor:Mt,appendChild:function(t){return this._parent.insertBefore(t,this._next)},insertBefore:function(t,e){return this._parent.insertBefore(t,e)},querySelector:function(t){return this._parent.querySelector(t)},querySelectorAll:function(t){return this._parent.querySelectorAll(t)}};var Dt="$";function Ct(t,e,n,r,i,o){for(var a,s=0,u=e.length,c=o.length;s<c;++s)(a=e[s])?(a.__data__=o[s],r[s]=a):n[s]=new Mt(t,o[s]);for(;s<u;++s)(a=e[s])&&(i[s]=a)}function Ot(t,e,n,r,i,o,a){var s,u,c,f={},l=e.length,h=o.length,d=new Array(l);for(s=0;s<l;++s)(u=e[s])&&(d[s]=c=Dt+a.call(u,u.__data__,s,e),c in f?i[s]=u:f[c]=u);for(s=0;s<h;++s)(u=f[c=Dt+a.call(t,o[s],s,o)])?(r[s]=u,u.__data__=o[s],f[c]=null):n[s]=new Mt(t,o[s]);for(s=0;s<l;++s)(u=e[s])&&f[d[s]]===u&&(i[s]=u)}function Rt(t,e){return t<e?-1:t>e?1:t>=e?0:NaN}function It(t){return function(){this.removeAttribute(t)}}function Nt(t){return function(){this.removeAttributeNS(t.space,t.local)}}function Bt(t,e){return function(){this.setAttribute(t,e)}}function Lt(t,e){return function(){this.setAttributeNS(t.space,t.local,e)}}function Pt(t,e){return function(){var n=e.apply(this,arguments);null==n?this.removeAttribute(t):this.setAttribute(t,n)}}function Ft(t,e){return function(){var n=e.apply(this,arguments);null==n?this.removeAttributeNS(t.space,t.local):this.setAttributeNS(t.space,t.local,n)}}var qt=function(t){return t.ownerDocument&&t.ownerDocument.defaultView||t.document&&t||t.defaultView};function jt(t){return function(){this.style.removeProperty(t)}}function Ut(t,e,n){return function(){this.style.setProperty(t,e,n)}}function zt(t,e,n){return function(){var r=e.apply(this,arguments);null==r?this.style.removeProperty(t):this.style.setProperty(t,r,n)}}function Yt(t,e){return t.style.getPropertyValue(e)||qt(t).getComputedStyle(t,null).getPropertyValue(e)}function Vt(t){return function(){delete this[t]}}function Ht(t,e){return function(){this[t]=e}}function $t(t,e){return function(){var n=e.apply(this,arguments);null==n?delete this[t]:this[t]=n}}function Gt(t){return t.trim().split(/^|\s+/)}function Wt(t){return t.classList||new Kt(t)}function Kt(t){this._node=t,this._names=Gt(t.getAttribute("class")||"")}function Xt(t,e){for(var n=Wt(t),r=-1,i=e.length;++r<i;)n.add(e[r])}function Zt(t,e){for(var n=Wt(t),r=-1,i=e.length;++r<i;)n.remove(e[r])}function Jt(t){return function(){Xt(this,t)}}function Qt(t){return function(){Zt(this,t)}}function te(t,e){return function(){(e.apply(this,arguments)?Xt:Zt)(this,t)}}Kt.prototype={add:function(t){this._names.indexOf(t)<0&&(this._names.push(t),this._node.setAttribute("class",this._names.join(" ")))},remove:function(t){var e=this._names.indexOf(t);e>=0&&(this._names.splice(e,1),this._node.setAttribute("class",this._names.join(" ")))},contains:function(t){return this._names.indexOf(t)>=0}};function ee(){this.textContent=""}function ne(t){return function(){this.textContent=t}}function re(t){return function(){var e=t.apply(this,arguments);this.textContent=null==e?"":e}}function ie(){this.innerHTML=""}function oe(t){return function(){this.innerHTML=t}}function ae(t){return function(){var e=t.apply(this,arguments);this.innerHTML=null==e?"":e}}function se(){this.nextSibling&&this.parentNode.appendChild(this)}function ue(){this.previousSibling&&this.parentNode.insertBefore(this,this.parentNode.firstChild)}function ce(){return null}function fe(){var t=this.parentNode;t&&t.removeChild(this)}function le(){return this.parentNode.insertBefore(this.cloneNode(!1),this.nextSibling)}function he(){return this.parentNode.insertBefore(this.cloneNode(!0),this.nextSibling)}var de={},pe=null;"undefined"!=typeof document&&("onmouseenter"in document.documentElement||(de={mouseenter:"mouseover",mouseleave:"mouseout"}));function ge(t,e,n){return t=ye(t,e,n),function(e){var n=e.relatedTarget;n&&(n===this||8&n.compareDocumentPosition(this))||t.call(this,e)}}function ye(t,e,n){return function(r){var i=pe;pe=r;try{t.call(this,this.__data__,e,n)}finally{pe=i}}}function be(t){return t.trim().split(/^|\s+/).map((function(t){var e="",n=t.indexOf(".");return n>=0&&(e=t.slice(n+1),t=t.slice(0,n)),{type:t,name:e}}))}function me(t){return function(){var e=this.__on;if(e){for(var n,r=0,i=-1,o=e.length;r<o;++r)n=e[r],t.type&&n.type!==t.type||n.name!==t.name?e[++i]=n:this.removeEventListener(n.type,n.listener,n.capture);++i?e.length=i:delete this.__on}}}function ve(t,e,n){var r=de.hasOwnProperty(t.type)?ge:ye;return function(i,o,a){var s,u=this.__on,c=r(e,o,a);if(u)for(var f=0,l=u.length;f<l;++f)if((s=u[f]).type===t.type&&s.name===t.name)return this.removeEventListener(s.type,s.listener,s.capture),this.addEventListener(s.type,s.listener=c,s.capture=n),void(s.value=e);this.addEventListener(t.type,c,n),s={type:t.type,name:t.name,value:e,listener:c,capture:n},u?u.push(s):this.__on=[s]}}function _e(t,e,n,r){var i=pe;t.sourceEvent=pe,pe=t;try{return e.apply(n,r)}finally{pe=i}}function we(t,e,n){var r=qt(t),i=r.CustomEvent;"function"==typeof i?i=new i(e,n):(i=r.document.createEvent("Event"),n?(i.initEvent(e,n.bubbles,n.cancelable),i.detail=n.detail):i.initEvent(e,!1,!1)),t.dispatchEvent(i)}function xe(t,e){return function(){return we(this,t,e)}}function ke(t,e){return function(){return we(this,t,e.apply(this,arguments))}}var Ee=[null];function Ae(t,e){this._groups=t,this._parents=e}function Se(){return new Ae([[document.documentElement]],Ee)}Ae.prototype=Se.prototype={constructor:Ae,select:function(t){"function"!=typeof t&&(t=kt(t));for(var e=this._groups,n=e.length,r=new Array(n),i=0;i<n;++i)for(var o,a,s=e[i],u=s.length,c=r[i]=new Array(u),f=0;f<u;++f)(o=s[f])&&(a=t.call(o,o.__data__,f,s))&&("__data__"in o&&(a.__data__=o.__data__),c[f]=a);return new Ae(r,this._parents)},selectAll:function(t){"function"!=typeof t&&(t=At(t));for(var e=this._groups,n=e.length,r=[],i=[],o=0;o<n;++o)for(var a,s=e[o],u=s.length,c=0;c<u;++c)(a=s[c])&&(r.push(t.call(a,a.__data__,c,s)),i.push(a));return new Ae(r,i)},filter:function(t){"function"!=typeof t&&(t=St(t));for(var e=this._groups,n=e.length,r=new Array(n),i=0;i<n;++i)for(var o,a=e[i],s=a.length,u=r[i]=[],c=0;c<s;++c)(o=a[c])&&t.call(o,o.__data__,c,a)&&u.push(o);return new Ae(r,this._parents)},data:function(t,e){if(!t)return p=new Array(this.size()),f=-1,this.each((function(t){p[++f]=t})),p;var n,r=e?Ot:Ct,i=this._parents,o=this._groups;"function"!=typeof t&&(n=t,t=function(){return n});for(var a=o.length,s=new Array(a),u=new Array(a),c=new Array(a),f=0;f<a;++f){var l=i[f],h=o[f],d=h.length,p=t.call(l,l&&l.__data__,f,i),g=p.length,y=u[f]=new Array(g),b=s[f]=new Array(g);r(l,h,y,b,c[f]=new Array(d),p,e);for(var m,v,_=0,w=0;_<g;++_)if(m=y[_]){for(_>=w&&(w=_+1);!(v=b[w])&&++w<g;);m._next=v||null}}return(s=new Ae(s,i))._enter=u,s._exit=c,s},enter:function(){return new Ae(this._enter||this._groups.map(Tt),this._parents)},exit:function(){return new Ae(this._exit||this._groups.map(Tt),this._parents)},join:function(t,e,n){var r=this.enter(),i=this,o=this.exit();return r="function"==typeof t?t(r):r.append(t+""),null!=e&&(i=e(i)),null==n?o.remove():n(o),r&&i?r.merge(i).order():i},merge:function(t){for(var e=this._groups,n=t._groups,r=e.length,i=n.length,o=Math.min(r,i),a=new Array(r),s=0;s<o;++s)for(var u,c=e[s],f=n[s],l=c.length,h=a[s]=new Array(l),d=0;d<l;++d)(u=c[d]||f[d])&&(h[d]=u);for(;s<r;++s)a[s]=e[s];return new Ae(a,this._parents)},order:function(){for(var t=this._groups,e=-1,n=t.length;++e<n;)for(var r,i=t[e],o=i.length-1,a=i[o];--o>=0;)(r=i[o])&&(a&&4^r.compareDocumentPosition(a)&&a.parentNode.insertBefore(r,a),a=r);return this},sort:function(t){function e(e,n){return e&&n?t(e.__data__,n.__data__):!e-!n}t||(t=Rt);for(var n=this._groups,r=n.length,i=new Array(r),o=0;o<r;++o){for(var a,s=n[o],u=s.length,c=i[o]=new Array(u),f=0;f<u;++f)(a=s[f])&&(c[f]=a);c.sort(e)}return new Ae(i,this._parents).order()},call:function(){var t=arguments[0];return arguments[0]=this,t.apply(null,arguments),this},nodes:function(){var t=new Array(this.size()),e=-1;return this.each((function(){t[++e]=this})),t},node:function(){for(var t=this._groups,e=0,n=t.length;e<n;++e)for(var r=t[e],i=0,o=r.length;i<o;++i){var a=r[i];if(a)return a}return null},size:function(){var t=0;return this.each((function(){++t})),t},empty:function(){return!this.node()},each:function(t){for(var e=this._groups,n=0,r=e.length;n<r;++n)for(var i,o=e[n],a=0,s=o.length;a<s;++a)(i=o[a])&&t.call(i,i.__data__,a,o);return this},attr:function(t,e){var n=mt(t);if(arguments.length<2){var r=this.node();return n.local?r.getAttributeNS(n.space,n.local):r.getAttribute(n)}return this.each((null==e?n.local?Nt:It:"function"==typeof e?n.local?Ft:Pt:n.local?Lt:Bt)(n,e))},style:function(t,e,n){return arguments.length>1?this.each((null==e?jt:"function"==typeof e?zt:Ut)(t,e,null==n?"":n)):Yt(this.node(),t)},property:function(t,e){return arguments.length>1?this.each((null==e?Vt:"function"==typeof e?$t:Ht)(t,e)):this.node()[t]},classed:function(t,e){var n=Gt(t+"");if(arguments.length<2){for(var r=Wt(this.node()),i=-1,o=n.length;++i<o;)if(!r.contains(n[i]))return!1;return!0}return this.each(("function"==typeof e?te:e?Jt:Qt)(n,e))},text:function(t){return arguments.length?this.each(null==t?ee:("function"==typeof t?re:ne)(t)):this.node().textContent},html:function(t){return arguments.length?this.each(null==t?ie:("function"==typeof t?ae:oe)(t)):this.node().innerHTML},raise:function(){return this.each(se)},lower:function(){return this.each(ue)},append:function(t){var e="function"==typeof t?t:wt(t);return this.select((function(){return this.appendChild(e.apply(this,arguments))}))},insert:function(t,e){var n="function"==typeof t?t:wt(t),r=null==e?ce:"function"==typeof e?e:kt(e);return this.select((function(){return this.insertBefore(n.apply(this,arguments),r.apply(this,arguments)||null)}))},remove:function(){return this.each(fe)},clone:function(t){return this.select(t?he:le)},datum:function(t){return arguments.length?this.property("__data__",t):this.node().__data__},on:function(t,e,n){var r,i,o=be(t+""),a=o.length;if(!(arguments.length<2)){for(s=e?ve:me,null==n&&(n=!1),r=0;r<a;++r)this.each(s(o[r],e,n));return this}var s=this.node().__on;if(s)for(var u,c=0,f=s.length;c<f;++c)for(r=0,u=s[c];r<a;++r)if((i=o[r]).type===u.type&&i.name===u.name)return u.value},dispatch:function(t,e){return this.each(("function"==typeof e?ke:xe)(t,e))}};var Te=Se,Me=function(t){return"string"==typeof t?new Ae([[document.querySelector(t)]],[document.documentElement]):new Ae([[t]],Ee)},De=function(t){return Me(wt(t).call(document.documentElement))},Ce=0;function Oe(){return new Re}function Re(){this._="@"+(++Ce).toString(36)}Re.prototype=Oe.prototype={constructor:Re,get:function(t){for(var e=this._;!(e in t);)if(!(t=t.parentNode))return;return t[e]},set:function(t,e){return t[this._]=e},remove:function(t){return this._ in t&&delete t[this._]},toString:function(){return this._}};var Ie=function(){for(var t,e=pe;t=e.sourceEvent;)e=t;return e},Ne=function(t,e){var n=t.ownerSVGElement||t;if(n.createSVGPoint){var r=n.createSVGPoint();return r.x=e.clientX,r.y=e.clientY,[(r=r.matrixTransform(t.getScreenCTM().inverse())).x,r.y]}var i=t.getBoundingClientRect();return[e.clientX-i.left-t.clientLeft,e.clientY-i.top-t.clientTop]},Be=function(t){var e=Ie();return e.changedTouches&&(e=e.changedTouches[0]),Ne(t,e)},Le=function(t){return"string"==typeof t?new Ae([document.querySelectorAll(t)],[document.documentElement]):new Ae([null==t?[]:t],Ee)},Pe=function(t,e,n){arguments.length<3&&(n=e,e=Ie().changedTouches);for(var r,i=0,o=e?e.length:0;i<o;++i)if((r=e[i]).identifier===n)return Ne(t,r);return null},Fe=function(t,e){null==e&&(e=Ie().touches);for(var n=0,r=e?e.length:0,i=new Array(r);n<r;++n)i[n]=Ne(t,e[n]);return i};function qe(){pe.stopImmediatePropagation()}var je=function(){pe.preventDefault(),pe.stopImmediatePropagation()},Ue=function(t){var e=t.document.documentElement,n=Me(t).on("dragstart.drag",je,!0);"onselectstart"in e?n.on("selectstart.drag",je,!0):(e.__noselect=e.style.MozUserSelect,e.style.MozUserSelect="none")};function ze(t,e){var n=t.document.documentElement,r=Me(t).on("dragstart.drag",null);e&&(r.on("click.drag",je,!0),setTimeout((function(){r.on("click.drag",null)}),0)),"onselectstart"in n?r.on("selectstart.drag",null):(n.style.MozUserSelect=n.__noselect,delete n.__noselect)}var Ye=function(t){return function(){return t}};function Ve(t,e,n,r,i,o,a,s,u,c){this.target=t,this.type=e,this.subject=n,this.identifier=r,this.active=i,this.x=o,this.y=a,this.dx=s,this.dy=u,this._=c}function He(){return!pe.ctrlKey&&!pe.button}function $e(){return this.parentNode}function Ge(t){return null==t?{x:pe.x,y:pe.y}:t}function We(){return navigator.maxTouchPoints||"ontouchstart"in this}Ve.prototype.on=function(){var t=this._.on.apply(this._,arguments);return t===this._?this:t};var Ke=function(){var t,e,n,r,i=He,o=$e,a=Ge,s=We,u={},c=gt("start","drag","end"),f=0,l=0;function h(t){t.on("mousedown.drag",d).filter(s).on("touchstart.drag",y).on("touchmove.drag",b).on("touchend.drag touchcancel.drag",m).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function d(){if(!r&&i.apply(this,arguments)){var a=v("mouse",o.apply(this,arguments),Be,this,arguments);a&&(Me(pe.view).on("mousemove.drag",p,!0).on("mouseup.drag",g,!0),Ue(pe.view),qe(),n=!1,t=pe.clientX,e=pe.clientY,a("start"))}}function p(){if(je(),!n){var r=pe.clientX-t,i=pe.clientY-e;n=r*r+i*i>l}u.mouse("drag")}function g(){Me(pe.view).on("mousemove.drag mouseup.drag",null),ze(pe.view,n),je(),u.mouse("end")}function y(){if(i.apply(this,arguments)){var t,e,n=pe.changedTouches,r=o.apply(this,arguments),a=n.length;for(t=0;t<a;++t)(e=v(n[t].identifier,r,Pe,this,arguments))&&(qe(),e("start"))}}function b(){var t,e,n=pe.changedTouches,r=n.length;for(t=0;t<r;++t)(e=u[n[t].identifier])&&(je(),e("drag"))}function m(){var t,e,n=pe.changedTouches,i=n.length;for(r&&clearTimeout(r),r=setTimeout((function(){r=null}),500),t=0;t<i;++t)(e=u[n[t].identifier])&&(qe(),e("end"))}function v(t,e,n,r,i){var o,s,l,d=n(e,t),p=c.copy();if(_e(new Ve(h,"beforestart",o,t,f,d[0],d[1],0,0,p),(function(){return null!=(pe.subject=o=a.apply(r,i))&&(s=o.x-d[0]||0,l=o.y-d[1]||0,!0)})))return function a(c){var g,y=d;switch(c){case"start":u[t]=a,g=f++;break;case"end":delete u[t],--f;case"drag":d=n(e,t),g=f}_e(new Ve(h,c,o,t,g,d[0]+s,d[1]+l,d[0]-y[0],d[1]-y[1],p),p.apply,p,[c,r,i])}}return h.filter=function(t){return arguments.length?(i="function"==typeof t?t:Ye(!!t),h):i},h.container=function(t){return arguments.length?(o="function"==typeof t?t:Ye(t),h):o},h.subject=function(t){return arguments.length?(a="function"==typeof t?t:Ye(t),h):a},h.touchable=function(t){return arguments.length?(s="function"==typeof t?t:Ye(!!t),h):s},h.on=function(){var t=c.on.apply(c,arguments);return t===c?h:t},h.clickDistance=function(t){return arguments.length?(l=(t=+t)*t,h):Math.sqrt(l)},h},Xe=function(t,e,n){t.prototype=e.prototype=n,n.constructor=t};function Ze(t,e){var n=Object.create(t.prototype);for(var r in e)n[r]=e[r];return n}function Je(){}var Qe="\\s*([+-]?\\d+)\\s*",tn="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",en="\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",nn=/^#([0-9a-f]{3,8})$/,rn=new RegExp("^rgb\\("+[Qe,Qe,Qe]+"\\)$"),on=new RegExp("^rgb\\("+[en,en,en]+"\\)$"),an=new RegExp("^rgba\\("+[Qe,Qe,Qe,tn]+"\\)$"),sn=new RegExp("^rgba\\("+[en,en,en,tn]+"\\)$"),un=new RegExp("^hsl\\("+[tn,en,en]+"\\)$"),cn=new RegExp("^hsla\\("+[tn,en,en,tn]+"\\)$"),fn={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function ln(){return this.rgb().formatHex()}function hn(){return this.rgb().formatRgb()}function dn(t){var e,n;return t=(t+"").trim().toLowerCase(),(e=nn.exec(t))?(n=e[1].length,e=parseInt(e[1],16),6===n?pn(e):3===n?new mn(e>>8&15|e>>4&240,e>>4&15|240&e,(15&e)<<4|15&e,1):8===n?new mn(e>>24&255,e>>16&255,e>>8&255,(255&e)/255):4===n?new mn(e>>12&15|e>>8&240,e>>8&15|e>>4&240,e>>4&15|240&e,((15&e)<<4|15&e)/255):null):(e=rn.exec(t))?new mn(e[1],e[2],e[3],1):(e=on.exec(t))?new mn(255*e[1]/100,255*e[2]/100,255*e[3]/100,1):(e=an.exec(t))?gn(e[1],e[2],e[3],e[4]):(e=sn.exec(t))?gn(255*e[1]/100,255*e[2]/100,255*e[3]/100,e[4]):(e=un.exec(t))?xn(e[1],e[2]/100,e[3]/100,1):(e=cn.exec(t))?xn(e[1],e[2]/100,e[3]/100,e[4]):fn.hasOwnProperty(t)?pn(fn[t]):"transparent"===t?new mn(NaN,NaN,NaN,0):null}function pn(t){return new mn(t>>16&255,t>>8&255,255&t,1)}function gn(t,e,n,r){return r<=0&&(t=e=n=NaN),new mn(t,e,n,r)}function yn(t){return t instanceof Je||(t=dn(t)),t?new mn((t=t.rgb()).r,t.g,t.b,t.opacity):new mn}function bn(t,e,n,r){return 1===arguments.length?yn(t):new mn(t,e,n,null==r?1:r)}function mn(t,e,n,r){this.r=+t,this.g=+e,this.b=+n,this.opacity=+r}function vn(){return"#"+wn(this.r)+wn(this.g)+wn(this.b)}function _n(){var t=this.opacity;return(1===(t=isNaN(t)?1:Math.max(0,Math.min(1,t)))?"rgb(":"rgba(")+Math.max(0,Math.min(255,Math.round(this.r)||0))+", "+Math.max(0,Math.min(255,Math.round(this.g)||0))+", "+Math.max(0,Math.min(255,Math.round(this.b)||0))+(1===t?")":", "+t+")")}function wn(t){return((t=Math.max(0,Math.min(255,Math.round(t)||0)))<16?"0":"")+t.toString(16)}function xn(t,e,n,r){return r<=0?t=e=n=NaN:n<=0||n>=1?t=e=NaN:e<=0&&(t=NaN),new An(t,e,n,r)}function kn(t){if(t instanceof An)return new An(t.h,t.s,t.l,t.opacity);if(t instanceof Je||(t=dn(t)),!t)return new An;if(t instanceof An)return t;var e=(t=t.rgb()).r/255,n=t.g/255,r=t.b/255,i=Math.min(e,n,r),o=Math.max(e,n,r),a=NaN,s=o-i,u=(o+i)/2;return s?(a=e===o?(n-r)/s+6*(n<r):n===o?(r-e)/s+2:(e-n)/s+4,s/=u<.5?o+i:2-o-i,a*=60):s=u>0&&u<1?0:a,new An(a,s,u,t.opacity)}function En(t,e,n,r){return 1===arguments.length?kn(t):new An(t,e,n,null==r?1:r)}function An(t,e,n,r){this.h=+t,this.s=+e,this.l=+n,this.opacity=+r}function Sn(t,e,n){return 255*(t<60?e+(n-e)*t/60:t<180?n:t<240?e+(n-e)*(240-t)/60:e)}function Tn(t,e,n,r,i){var o=t*t,a=o*t;return((1-3*t+3*o-a)*e+(4-6*o+3*a)*n+(1+3*t+3*o-3*a)*r+a*i)/6}Xe(Je,dn,{copy:function(t){return Object.assign(new this.constructor,this,t)},displayable:function(){return this.rgb().displayable()},hex:ln,formatHex:ln,formatHsl:function(){return kn(this).formatHsl()},formatRgb:hn,toString:hn}),Xe(mn,bn,Ze(Je,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new mn(this.r*t,this.g*t,this.b*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new mn(this.r*t,this.g*t,this.b*t,this.opacity)},rgb:function(){return this},displayable:function(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:vn,formatHex:vn,formatRgb:_n,toString:_n})),Xe(An,En,Ze(Je,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new An(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new An(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=this.h%360+360*(this.h<0),e=isNaN(t)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*e,i=2*n-r;return new mn(Sn(t>=240?t-240:t+120,i,r),Sn(t,i,r),Sn(t<120?t+240:t-120,i,r),this.opacity)},displayable:function(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl:function(){var t=this.opacity;return(1===(t=isNaN(t)?1:Math.max(0,Math.min(1,t)))?"hsl(":"hsla(")+(this.h||0)+", "+100*(this.s||0)+"%, "+100*(this.l||0)+"%"+(1===t?")":", "+t+")")}}));var Mn=function(t){var e=t.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,e-1):Math.floor(n*e),i=t[r],o=t[r+1],a=r>0?t[r-1]:2*i-o,s=r<e-1?t[r+2]:2*o-i;return Tn((n-r/e)*e,a,i,o,s)}},Dn=function(t){var e=t.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*e),i=t[(r+e-1)%e],o=t[r%e],a=t[(r+1)%e],s=t[(r+2)%e];return Tn((n-r/e)*e,i,o,a,s)}},Cn=function(t){return function(){return t}};function On(t,e){return function(n){return t+n*e}}function Rn(t,e){var n=e-t;return n?On(t,n>180||n<-180?n-360*Math.round(n/360):n):Cn(isNaN(t)?e:t)}function In(t){return 1==(t=+t)?Nn:function(e,n){return n-e?function(t,e,n){return t=Math.pow(t,n),e=Math.pow(e,n)-t,n=1/n,function(r){return Math.pow(t+r*e,n)}}(e,n,t):Cn(isNaN(e)?n:e)}}function Nn(t,e){var n=e-t;return n?On(t,n):Cn(isNaN(t)?e:t)}var Bn=function t(e){var n=In(e);function r(t,e){var r=n((t=bn(t)).r,(e=bn(e)).r),i=n(t.g,e.g),o=n(t.b,e.b),a=Nn(t.opacity,e.opacity);return function(e){return t.r=r(e),t.g=i(e),t.b=o(e),t.opacity=a(e),t+""}}return r.gamma=t,r}(1);function Ln(t){return function(e){var n,r,i=e.length,o=new Array(i),a=new Array(i),s=new Array(i);for(n=0;n<i;++n)r=bn(e[n]),o[n]=r.r||0,a[n]=r.g||0,s[n]=r.b||0;return o=t(o),a=t(a),s=t(s),r.opacity=1,function(t){return r.r=o(t),r.g=a(t),r.b=s(t),r+""}}}var Pn=Ln(Mn),Fn=Ln(Dn),qn=function(t,e){var n,r=e?e.length:0,i=t?Math.min(r,t.length):0,o=new Array(i),a=new Array(r);for(n=0;n<i;++n)o[n]=Xn(t[n],e[n]);for(;n<r;++n)a[n]=e[n];return function(t){for(n=0;n<i;++n)a[n]=o[n](t);return a}},jn=function(t,e){var n=new Date;return e-=t=+t,function(r){return n.setTime(t+e*r),n}},Un=function(t,e){return e-=t=+t,function(n){return t+e*n}},zn=function(t,e){var n,r={},i={};for(n in null!==t&&"object"==typeof t||(t={}),null!==e&&"object"==typeof e||(e={}),e)n in t?r[n]=Xn(t[n],e[n]):i[n]=e[n];return function(t){for(n in r)i[n]=r[n](t);return i}},Yn=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Vn=new RegExp(Yn.source,"g");var Hn,$n,Gn,Wn,Kn=function(t,e){var n,r,i,o=Yn.lastIndex=Vn.lastIndex=0,a=-1,s=[],u=[];for(t+="",e+="";(n=Yn.exec(t))&&(r=Vn.exec(e));)(i=r.index)>o&&(i=e.slice(o,i),s[a]?s[a]+=i:s[++a]=i),(n=n[0])===(r=r[0])?s[a]?s[a]+=r:s[++a]=r:(s[++a]=null,u.push({i:a,x:Un(n,r)})),o=Vn.lastIndex;return o<e.length&&(i=e.slice(o),s[a]?s[a]+=i:s[++a]=i),s.length<2?u[0]?function(t){return function(e){return t(e)+""}}(u[0].x):function(t){return function(){return t}}(e):(e=u.length,function(t){for(var n,r=0;r<e;++r)s[(n=u[r]).i]=n.x(t);return s.join("")})},Xn=function(t,e){var n,r=typeof e;return null==e||"boolean"===r?Cn(e):("number"===r?Un:"string"===r?(n=dn(e))?(e=n,Bn):Kn:e instanceof dn?Bn:e instanceof Date?jn:Array.isArray(e)?qn:"function"!=typeof e.valueOf&&"function"!=typeof e.toString||isNaN(e)?zn:Un)(t,e)},Zn=function(t){var e=t.length;return function(n){return t[Math.max(0,Math.min(e-1,Math.floor(n*e)))]}},Jn=function(t,e){var n=Rn(+t,+e);return function(t){var e=n(t);return e-360*Math.floor(e/360)}},Qn=function(t,e){return e-=t=+t,function(n){return Math.round(t+e*n)}},tr=180/Math.PI,er={translateX:0,translateY:0,rotate:0,skewX:0,scaleX:1,scaleY:1},nr=function(t,e,n,r,i,o){var a,s,u;return(a=Math.sqrt(t*t+e*e))&&(t/=a,e/=a),(u=t*n+e*r)&&(n-=t*u,r-=e*u),(s=Math.sqrt(n*n+r*r))&&(n/=s,r/=s,u/=s),t*r<e*n&&(t=-t,e=-e,u=-u,a=-a),{translateX:i,translateY:o,rotate:Math.atan2(e,t)*tr,skewX:Math.atan(u)*tr,scaleX:a,scaleY:s}};function rr(t,e,n,r){function i(t){return t.length?t.pop()+" ":""}return function(o,a){var s=[],u=[];return o=t(o),a=t(a),function(t,r,i,o,a,s){if(t!==i||r!==o){var u=a.push("translate(",null,e,null,n);s.push({i:u-4,x:Un(t,i)},{i:u-2,x:Un(r,o)})}else(i||o)&&a.push("translate("+i+e+o+n)}(o.translateX,o.translateY,a.translateX,a.translateY,s,u),function(t,e,n,o){t!==e?(t-e>180?e+=360:e-t>180&&(t+=360),o.push({i:n.push(i(n)+"rotate(",null,r)-2,x:Un(t,e)})):e&&n.push(i(n)+"rotate("+e+r)}(o.rotate,a.rotate,s,u),function(t,e,n,o){t!==e?o.push({i:n.push(i(n)+"skewX(",null,r)-2,x:Un(t,e)}):e&&n.push(i(n)+"skewX("+e+r)}(o.skewX,a.skewX,s,u),function(t,e,n,r,o,a){if(t!==n||e!==r){var s=o.push(i(o)+"scale(",null,",",null,")");a.push({i:s-4,x:Un(t,n)},{i:s-2,x:Un(e,r)})}else 1===n&&1===r||o.push(i(o)+"scale("+n+","+r+")")}(o.scaleX,o.scaleY,a.scaleX,a.scaleY,s,u),o=a=null,function(t){for(var e,n=-1,r=u.length;++n<r;)s[(e=u[n]).i]=e.x(t);return s.join("")}}}var ir=rr((function(t){return"none"===t?er:(Hn||(Hn=document.createElement("DIV"),$n=document.documentElement,Gn=document.defaultView),Hn.style.transform=t,t=Gn.getComputedStyle($n.appendChild(Hn),null).getPropertyValue("transform"),$n.removeChild(Hn),t=t.slice(7,-1).split(","),nr(+t[0],+t[1],+t[2],+t[3],+t[4],+t[5]))}),"px, ","px)","deg)"),or=rr((function(t){return null==t?er:(Wn||(Wn=document.createElementNS("http://www.w3.org/2000/svg","g")),Wn.setAttribute("transform",t),(t=Wn.transform.baseVal.consolidate())?(t=t.matrix,nr(t.a,t.b,t.c,t.d,t.e,t.f)):er)}),", ",")",")"),ar=Math.SQRT2;function sr(t){return((t=Math.exp(t))+1/t)/2}var ur=function(t,e){var n,r,i=t[0],o=t[1],a=t[2],s=e[0],u=e[1],c=e[2],f=s-i,l=u-o,h=f*f+l*l;if(h<1e-12)r=Math.log(c/a)/ar,n=function(t){return[i+t*f,o+t*l,a*Math.exp(ar*t*r)]};else{var d=Math.sqrt(h),p=(c*c-a*a+4*h)/(2*a*2*d),g=(c*c-a*a-4*h)/(2*c*2*d),y=Math.log(Math.sqrt(p*p+1)-p),b=Math.log(Math.sqrt(g*g+1)-g);r=(b-y)/ar,n=function(t){var e,n=t*r,s=sr(y),u=a/(2*d)*(s*(e=ar*n+y,((e=Math.exp(2*e))-1)/(e+1))-function(t){return((t=Math.exp(t))-1/t)/2}(y));return[i+u*f,o+u*l,a*s/sr(ar*n+y)]}}return n.duration=1e3*r,n};function cr(t){return function(e,n){var r=t((e=En(e)).h,(n=En(n)).h),i=Nn(e.s,n.s),o=Nn(e.l,n.l),a=Nn(e.opacity,n.opacity);return function(t){return e.h=r(t),e.s=i(t),e.l=o(t),e.opacity=a(t),e+""}}}var fr=cr(Rn),lr=cr(Nn),hr=Math.PI/180,dr=180/Math.PI,pr=.96422,gr=1,yr=.82521,br=4/29,mr=6/29,vr=3*mr*mr,_r=mr*mr*mr;function wr(t){if(t instanceof Er)return new Er(t.l,t.a,t.b,t.opacity);if(t instanceof Rr)return Ir(t);t instanceof mn||(t=yn(t));var e,n,r=Mr(t.r),i=Mr(t.g),o=Mr(t.b),a=Ar((.2225045*r+.7168786*i+.0606169*o)/gr);return r===i&&i===o?e=n=a:(e=Ar((.4360747*r+.3850649*i+.1430804*o)/pr),n=Ar((.0139322*r+.0971045*i+.7141733*o)/yr)),new Er(116*a-16,500*(e-a),200*(a-n),t.opacity)}function xr(t,e){return new Er(t,0,0,null==e?1:e)}function kr(t,e,n,r){return 1===arguments.length?wr(t):new Er(t,e,n,null==r?1:r)}function Er(t,e,n,r){this.l=+t,this.a=+e,this.b=+n,this.opacity=+r}function Ar(t){return t>_r?Math.pow(t,1/3):t/vr+br}function Sr(t){return t>mr?t*t*t:vr*(t-br)}function Tr(t){return 255*(t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055)}function Mr(t){return(t/=255)<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4)}function Dr(t){if(t instanceof Rr)return new Rr(t.h,t.c,t.l,t.opacity);if(t instanceof Er||(t=wr(t)),0===t.a&&0===t.b)return new Rr(NaN,0<t.l&&t.l<100?0:NaN,t.l,t.opacity);var e=Math.atan2(t.b,t.a)*dr;return new Rr(e<0?e+360:e,Math.sqrt(t.a*t.a+t.b*t.b),t.l,t.opacity)}function Cr(t,e,n,r){return 1===arguments.length?Dr(t):new Rr(n,e,t,null==r?1:r)}function Or(t,e,n,r){return 1===arguments.length?Dr(t):new Rr(t,e,n,null==r?1:r)}function Rr(t,e,n,r){this.h=+t,this.c=+e,this.l=+n,this.opacity=+r}function Ir(t){if(isNaN(t.h))return new Er(t.l,0,0,t.opacity);var e=t.h*hr;return new Er(t.l,Math.cos(e)*t.c,Math.sin(e)*t.c,t.opacity)}function Nr(t,e){var n=Nn((t=kr(t)).l,(e=kr(e)).l),r=Nn(t.a,e.a),i=Nn(t.b,e.b),o=Nn(t.opacity,e.opacity);return function(e){return t.l=n(e),t.a=r(e),t.b=i(e),t.opacity=o(e),t+""}}function Br(t){return function(e,n){var r=t((e=Or(e)).h,(n=Or(n)).h),i=Nn(e.c,n.c),o=Nn(e.l,n.l),a=Nn(e.opacity,n.opacity);return function(t){return e.h=r(t),e.c=i(t),e.l=o(t),e.opacity=a(t),e+""}}}Xe(Er,kr,Ze(Je,{brighter:function(t){return new Er(this.l+18*(null==t?1:t),this.a,this.b,this.opacity)},darker:function(t){return new Er(this.l-18*(null==t?1:t),this.a,this.b,this.opacity)},rgb:function(){var t=(this.l+16)/116,e=isNaN(this.a)?t:t+this.a/500,n=isNaN(this.b)?t:t-this.b/200;return new mn(Tr(3.1338561*(e=pr*Sr(e))-1.6168667*(t=gr*Sr(t))-.4906146*(n=yr*Sr(n))),Tr(-.9787684*e+1.9161415*t+.033454*n),Tr(.0719453*e-.2289914*t+1.4052427*n),this.opacity)}})),Xe(Rr,Or,Ze(Je,{brighter:function(t){return new Rr(this.h,this.c,this.l+18*(null==t?1:t),this.opacity)},darker:function(t){return new Rr(this.h,this.c,this.l-18*(null==t?1:t),this.opacity)},rgb:function(){return Ir(this).rgb()}}));var Lr=Br(Rn),Pr=Br(Nn),Fr=-.29227,qr=-.90649,jr=1.97294,Ur=jr*qr,zr=1.78277*jr,Yr=1.78277*Fr- -.14861*qr;function Vr(t,e,n,r){return 1===arguments.length?function(t){if(t instanceof Hr)return new Hr(t.h,t.s,t.l,t.opacity);t instanceof mn||(t=yn(t));var e=t.r/255,n=t.g/255,r=t.b/255,i=(Yr*r+Ur*e-zr*n)/(Yr+Ur-zr),o=r-i,a=(jr*(n-i)-Fr*o)/qr,s=Math.sqrt(a*a+o*o)/(jr*i*(1-i)),u=s?Math.atan2(a,o)*dr-120:NaN;return new Hr(u<0?u+360:u,s,i,t.opacity)}(t):new Hr(t,e,n,null==r?1:r)}function Hr(t,e,n,r){this.h=+t,this.s=+e,this.l=+n,this.opacity=+r}function $r(t){return function e(n){function r(e,r){var i=t((e=Vr(e)).h,(r=Vr(r)).h),o=Nn(e.s,r.s),a=Nn(e.l,r.l),s=Nn(e.opacity,r.opacity);return function(t){return e.h=i(t),e.s=o(t),e.l=a(Math.pow(t,n)),e.opacity=s(t),e+""}}return n=+n,r.gamma=e,r}(1)}Xe(Hr,Vr,Ze(Je,{brighter:function(t){return t=null==t?1/.7:Math.pow(1/.7,t),new Hr(this.h,this.s,this.l*t,this.opacity)},darker:function(t){return t=null==t?.7:Math.pow(.7,t),new Hr(this.h,this.s,this.l*t,this.opacity)},rgb:function(){var t=isNaN(this.h)?0:(this.h+120)*hr,e=+this.l,n=isNaN(this.s)?0:this.s*e*(1-e),r=Math.cos(t),i=Math.sin(t);return new mn(255*(e+n*(-.14861*r+1.78277*i)),255*(e+n*(Fr*r+qr*i)),255*(e+n*(jr*r)),this.opacity)}}));var Gr=$r(Rn),Wr=$r(Nn);function Kr(t,e){for(var n=0,r=e.length-1,i=e[0],o=new Array(r<0?0:r);n<r;)o[n]=t(i,i=e[++n]);return function(t){var e=Math.max(0,Math.min(r-1,Math.floor(t*=r)));return o[e](t-e)}}var Xr,Zr,Jr=function(t,e){for(var n=new Array(e),r=0;r<e;++r)n[r]=t(r/(e-1));return n},Qr=0,ti=0,ei=0,ni=1e3,ri=0,ii=0,oi=0,ai="object"==typeof performance&&performance.now?performance:Date,si="object"==typeof window&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):function(t){setTimeout(t,17)};function ui(){return ii||(si(ci),ii=ai.now()+oi)}function ci(){ii=0}function fi(){this._call=this._time=this._next=null}function li(t,e,n){var r=new fi;return r.restart(t,e,n),r}function hi(){ui(),++Qr;for(var t,e=Xr;e;)(t=ii-e._time)>=0&&e._call.call(null,t),e=e._next;--Qr}function di(){ii=(ri=ai.now())+oi,Qr=ti=0;try{hi()}finally{Qr=0,function(){var t,e,n=Xr,r=1/0;for(;n;)n._call?(r>n._time&&(r=n._time),t=n,n=n._next):(e=n._next,n._next=null,n=t?t._next=e:Xr=e);Zr=t,gi(r)}(),ii=0}}function pi(){var t=ai.now(),e=t-ri;e>ni&&(oi-=e,ri=t)}function gi(t){Qr||(ti&&(ti=clearTimeout(ti)),t-ii>24?(t<1/0&&(ti=setTimeout(di,t-ai.now()-oi)),ei&&(ei=clearInterval(ei))):(ei||(ri=ai.now(),ei=setInterval(pi,ni)),Qr=1,si(di)))}fi.prototype=li.prototype={constructor:fi,restart:function(t,e,n){if("function"!=typeof t)throw new TypeError("callback is not a function");n=(null==n?ui():+n)+(null==e?0:+e),this._next||Zr===this||(Zr?Zr._next=this:Xr=this,Zr=this),this._call=t,this._time=n,gi()},stop:function(){this._call&&(this._call=null,this._time=1/0,gi())}};var yi=function(t,e,n){var r=new fi;return e=null==e?0:+e,r.restart((function(n){r.stop(),t(n+e)}),e,n),r},bi=function(t,e,n){var r=new fi,i=e;return null==e?(r.restart(t,e,n),r):(e=+e,n=null==n?ui():+n,r.restart((function o(a){a+=i,r.restart(o,i+=e,n),t(a)}),e,n),r)},mi=gt("start","end","cancel","interrupt"),vi=[],_i=0,wi=1,xi=2,ki=3,Ei=4,Ai=5,Si=6,Ti=function(t,e,n,r,i,o){var a=t.__transition;if(a){if(n in a)return}else t.__transition={};!function(t,e,n){var r,i=t.__transition;function o(u){var c,f,l,h;if(n.state!==wi)return s();for(c in i)if((h=i[c]).name===n.name){if(h.state===ki)return yi(o);h.state===Ei?(h.state=Si,h.timer.stop(),h.on.call("interrupt",t,t.__data__,h.index,h.group),delete i[c]):+c<e&&(h.state=Si,h.timer.stop(),h.on.call("cancel",t,t.__data__,h.index,h.group),delete i[c])}if(yi((function(){n.state===ki&&(n.state=Ei,n.timer.restart(a,n.delay,n.time),a(u))})),n.state=xi,n.on.call("start",t,t.__data__,n.index,n.group),n.state===xi){for(n.state=ki,r=new Array(l=n.tween.length),c=0,f=-1;c<l;++c)(h=n.tween[c].value.call(t,t.__data__,n.index,n.group))&&(r[++f]=h);r.length=f+1}}function a(e){for(var i=e<n.duration?n.ease.call(null,e/n.duration):(n.timer.restart(s),n.state=Ai,1),o=-1,a=r.length;++o<a;)r[o].call(t,i);n.state===Ai&&(n.on.call("end",t,t.__data__,n.index,n.group),s())}function s(){for(var r in n.state=Si,n.timer.stop(),delete i[e],i)return;delete t.__transition}i[e]=n,n.timer=li((function(t){n.state=wi,n.timer.restart(o,n.delay,n.time),n.delay<=t&&o(t-n.delay)}),0,n.time)}(t,n,{name:e,index:r,group:i,on:mi,tween:vi,time:o.time,delay:o.delay,duration:o.duration,ease:o.ease,timer:null,state:_i})};function Mi(t,e){var n=Ci(t,e);if(n.state>_i)throw new Error("too late; already scheduled");return n}function Di(t,e){var n=Ci(t,e);if(n.state>ki)throw new Error("too late; already running");return n}function Ci(t,e){var n=t.__transition;if(!n||!(n=n[e]))throw new Error("transition not found");return n}var Oi=function(t,e){var n,r,i,o=t.__transition,a=!0;if(o){for(i in e=null==e?null:e+"",o)(n=o[i]).name===e?(r=n.state>xi&&n.state<Ai,n.state=Si,n.timer.stop(),n.on.call(r?"interrupt":"cancel",t,t.__data__,n.index,n.group),delete o[i]):a=!1;a&&delete t.__transition}};function Ri(t,e){var n,r;return function(){var i=Di(this,t),o=i.tween;if(o!==n)for(var a=0,s=(r=n=o).length;a<s;++a)if(r[a].name===e){(r=r.slice()).splice(a,1);break}i.tween=r}}function Ii(t,e,n){var r,i;if("function"!=typeof n)throw new Error;return function(){var o=Di(this,t),a=o.tween;if(a!==r){i=(r=a).slice();for(var s={name:e,value:n},u=0,c=i.length;u<c;++u)if(i[u].name===e){i[u]=s;break}u===c&&i.push(s)}o.tween=i}}function Ni(t,e,n){var r=t._id;return t.each((function(){var t=Di(this,r);(t.value||(t.value={}))[e]=n.apply(this,arguments)})),function(t){return Ci(t,r).value[e]}}var Bi=function(t,e){var n;return("number"==typeof e?Un:e instanceof dn?Bn:(n=dn(e))?(e=n,Bn):Kn)(t,e)};function Li(t){return function(){this.removeAttribute(t)}}function Pi(t){return function(){this.removeAttributeNS(t.space,t.local)}}function Fi(t,e,n){var r,i,o=n+"";return function(){var a=this.getAttribute(t);return a===o?null:a===r?i:i=e(r=a,n)}}function qi(t,e,n){var r,i,o=n+"";return function(){var a=this.getAttributeNS(t.space,t.local);return a===o?null:a===r?i:i=e(r=a,n)}}function ji(t,e,n){var r,i,o;return function(){var a,s,u=n(this);if(null!=u)return(a=this.getAttribute(t))===(s=u+"")?null:a===r&&s===i?o:(i=s,o=e(r=a,u));this.removeAttribute(t)}}function Ui(t,e,n){var r,i,o;return function(){var a,s,u=n(this);if(null!=u)return(a=this.getAttributeNS(t.space,t.local))===(s=u+"")?null:a===r&&s===i?o:(i=s,o=e(r=a,u));this.removeAttributeNS(t.space,t.local)}}function zi(t,e){var n,r;function i(){var i=e.apply(this,arguments);return i!==r&&(n=(r=i)&&function(t,e){return function(n){this.setAttributeNS(t.space,t.local,e(n))}}(t,i)),n}return i._value=e,i}function Yi(t,e){var n,r;function i(){var i=e.apply(this,arguments);return i!==r&&(n=(r=i)&&function(t,e){return function(n){this.setAttribute(t,e(n))}}(t,i)),n}return i._value=e,i}function Vi(t,e){return function(){Mi(this,t).delay=+e.apply(this,arguments)}}function Hi(t,e){return e=+e,function(){Mi(this,t).delay=e}}function $i(t,e){return function(){Di(this,t).duration=+e.apply(this,arguments)}}function Gi(t,e){return e=+e,function(){Di(this,t).duration=e}}function Wi(t,e){if("function"!=typeof e)throw new Error;return function(){Di(this,t).ease=e}}function Ki(t,e,n){var r,i,o=function(t){return(t+"").trim().split(/^|\s+/).every((function(t){var e=t.indexOf(".");return e>=0&&(t=t.slice(0,e)),!t||"start"===t}))}(e)?Mi:Di;return function(){var a=o(this,t),s=a.on;s!==r&&(i=(r=s).copy()).on(e,n),a.on=i}}var Xi=Te.prototype.constructor;function Zi(t){return function(){this.style.removeProperty(t)}}function Ji(t,e,n){var r,i;function o(){var o=e.apply(this,arguments);return o!==i&&(r=(i=o)&&function(t,e,n){return function(r){this.style.setProperty(t,e(r),n)}}(t,o,n)),r}return o._value=e,o}var Qi=0;function to(t,e,n,r){this._groups=t,this._parents=e,this._name=n,this._id=r}function eo(t){return Te().transition(t)}function no(){return++Qi}var ro=Te.prototype;function io(t){return+t}function oo(t){return t*t}function ao(t){return t*(2-t)}function so(t){return((t*=2)<=1?t*t:--t*(2-t)+1)/2}function uo(t){return t*t*t}function co(t){return--t*t*t+1}function fo(t){return((t*=2)<=1?t*t*t:(t-=2)*t*t+2)/2}to.prototype=eo.prototype={constructor:to,select:function(t){var e=this._name,n=this._id;"function"!=typeof t&&(t=kt(t));for(var r=this._groups,i=r.length,o=new Array(i),a=0;a<i;++a)for(var s,u,c=r[a],f=c.length,l=o[a]=new Array(f),h=0;h<f;++h)(s=c[h])&&(u=t.call(s,s.__data__,h,c))&&("__data__"in s&&(u.__data__=s.__data__),l[h]=u,Ti(l[h],e,n,h,l,Ci(s,n)));return new to(o,this._parents,e,n)},selectAll:function(t){var e=this._name,n=this._id;"function"!=typeof t&&(t=At(t));for(var r=this._groups,i=r.length,o=[],a=[],s=0;s<i;++s)for(var u,c=r[s],f=c.length,l=0;l<f;++l)if(u=c[l]){for(var h,d=t.call(u,u.__data__,l,c),p=Ci(u,n),g=0,y=d.length;g<y;++g)(h=d[g])&&Ti(h,e,n,g,d,p);o.push(d),a.push(u)}return new to(o,a,e,n)},filter:function(t){"function"!=typeof t&&(t=St(t));for(var e=this._groups,n=e.length,r=new Array(n),i=0;i<n;++i)for(var o,a=e[i],s=a.length,u=r[i]=[],c=0;c<s;++c)(o=a[c])&&t.call(o,o.__data__,c,a)&&u.push(o);return new to(r,this._parents,this._name,this._id)},merge:function(t){if(t._id!==this._id)throw new Error;for(var e=this._groups,n=t._groups,r=e.length,i=n.length,o=Math.min(r,i),a=new Array(r),s=0;s<o;++s)for(var u,c=e[s],f=n[s],l=c.length,h=a[s]=new Array(l),d=0;d<l;++d)(u=c[d]||f[d])&&(h[d]=u);for(;s<r;++s)a[s]=e[s];return new to(a,this._parents,this._name,this._id)},selection:function(){return new Xi(this._groups,this._parents)},transition:function(){for(var t=this._name,e=this._id,n=no(),r=this._groups,i=r.length,o=0;o<i;++o)for(var a,s=r[o],u=s.length,c=0;c<u;++c)if(a=s[c]){var f=Ci(a,e);Ti(a,t,n,c,s,{time:f.time+f.delay+f.duration,delay:0,duration:f.duration,ease:f.ease})}return new to(r,this._parents,t,n)},call:ro.call,nodes:ro.nodes,node:ro.node,size:ro.size,empty:ro.empty,each:ro.each,on:function(t,e){var n=this._id;return arguments.length<2?Ci(this.node(),n).on.on(t):this.each(Ki(n,t,e))},attr:function(t,e){var n=mt(t),r="transform"===n?or:Bi;return this.attrTween(t,"function"==typeof e?(n.local?Ui:ji)(n,r,Ni(this,"attr."+t,e)):null==e?(n.local?Pi:Li)(n):(n.local?qi:Fi)(n,r,e))},attrTween:function(t,e){var n="attr."+t;if(arguments.length<2)return(n=this.tween(n))&&n._value;if(null==e)return this.tween(n,null);if("function"!=typeof e)throw new Error;var r=mt(t);return this.tween(n,(r.local?zi:Yi)(r,e))},style:function(t,e,n){var r="transform"==(t+="")?ir:Bi;return null==e?this.styleTween(t,function(t,e){var n,r,i;return function(){var o=Yt(this,t),a=(this.style.removeProperty(t),Yt(this,t));return o===a?null:o===n&&a===r?i:i=e(n=o,r=a)}}(t,r)).on("end.style."+t,Zi(t)):"function"==typeof e?this.styleTween(t,function(t,e,n){var r,i,o;return function(){var a=Yt(this,t),s=n(this),u=s+"";return null==s&&(this.style.removeProperty(t),u=s=Yt(this,t)),a===u?null:a===r&&u===i?o:(i=u,o=e(r=a,s))}}(t,r,Ni(this,"style."+t,e))).each(function(t,e){var n,r,i,o,a="style."+e,s="end."+a;return function(){var u=Di(this,t),c=u.on,f=null==u.value[a]?o||(o=Zi(e)):void 0;c===n&&i===f||(r=(n=c).copy()).on(s,i=f),u.on=r}}(this._id,t)):this.styleTween(t,function(t,e,n){var r,i,o=n+"";return function(){var a=Yt(this,t);return a===o?null:a===r?i:i=e(r=a,n)}}(t,r,e),n).on("end.style."+t,null)},styleTween:function(t,e,n){var r="style."+(t+="");if(arguments.length<2)return(r=this.tween(r))&&r._value;if(null==e)return this.tween(r,null);if("function"!=typeof e)throw new Error;return this.tween(r,Ji(t,e,null==n?"":n))},text:function(t){return this.tween("text","function"==typeof t?function(t){return function(){var e=t(this);this.textContent=null==e?"":e}}(Ni(this,"text",t)):function(t){return function(){this.textContent=t}}(null==t?"":t+""))},remove:function(){return this.on("end.remove",(t=this._id,function(){var e=this.parentNode;for(var n in this.__transition)if(+n!==t)return;e&&e.removeChild(this)}));var t},tween:function(t,e){var n=this._id;if(t+="",arguments.length<2){for(var r,i=Ci(this.node(),n).tween,o=0,a=i.length;o<a;++o)if((r=i[o]).name===t)return r.value;return null}return this.each((null==e?Ri:Ii)(n,t,e))},delay:function(t){var e=this._id;return arguments.length?this.each(("function"==typeof t?Vi:Hi)(e,t)):Ci(this.node(),e).delay},duration:function(t){var e=this._id;return arguments.length?this.each(("function"==typeof t?$i:Gi)(e,t)):Ci(this.node(),e).duration},ease:function(t){var e=this._id;return arguments.length?this.each(Wi(e,t)):Ci(this.node(),e).ease},end:function(){var t,e,n=this,r=n._id,i=n.size();return new Promise((function(o,a){var s={value:a},u={value:function(){0==--i&&o()}};n.each((function(){var n=Di(this,r),i=n.on;i!==t&&((e=(t=i).copy())._.cancel.push(s),e._.interrupt.push(s),e._.end.push(u)),n.on=e}))}))}};var lo=function t(e){function n(t){return Math.pow(t,e)}return e=+e,n.exponent=t,n}(3),ho=function t(e){function n(t){return 1-Math.pow(1-t,e)}return e=+e,n.exponent=t,n}(3),po=function t(e){function n(t){return((t*=2)<=1?Math.pow(t,e):2-Math.pow(2-t,e))/2}return e=+e,n.exponent=t,n}(3),go=Math.PI,yo=go/2;function bo(t){return 1-Math.cos(t*yo)}function mo(t){return Math.sin(t*yo)}function vo(t){return(1-Math.cos(go*t))/2}function _o(t){return Math.pow(2,10*t-10)}function wo(t){return 1-Math.pow(2,-10*t)}function xo(t){return((t*=2)<=1?Math.pow(2,10*t-10):2-Math.pow(2,10-10*t))/2}function ko(t){return 1-Math.sqrt(1-t*t)}function Eo(t){return Math.sqrt(1- --t*t)}function Ao(t){return((t*=2)<=1?1-Math.sqrt(1-t*t):Math.sqrt(1-(t-=2)*t)+1)/2}var So=4/11,To=6/11,Mo=8/11,Do=.75,Co=9/11,Oo=10/11,Ro=.9375,Io=21/22,No=63/64,Bo=1/So/So;function Lo(t){return 1-Po(1-t)}function Po(t){return(t=+t)<So?Bo*t*t:t<Mo?Bo*(t-=To)*t+Do:t<Oo?Bo*(t-=Co)*t+Ro:Bo*(t-=Io)*t+No}function Fo(t){return((t*=2)<=1?1-Po(1-t):Po(t-1)+1)/2}var qo=function t(e){function n(t){return t*t*((e+1)*t-e)}return e=+e,n.overshoot=t,n}(1.70158),jo=function t(e){function n(t){return--t*t*((e+1)*t+e)+1}return e=+e,n.overshoot=t,n}(1.70158),Uo=function t(e){function n(t){return((t*=2)<1?t*t*((e+1)*t-e):(t-=2)*t*((e+1)*t+e)+2)/2}return e=+e,n.overshoot=t,n}(1.70158),zo=2*Math.PI,Yo=function t(e,n){var r=Math.asin(1/(e=Math.max(1,e)))*(n/=zo);function i(t){return e*Math.pow(2,10*--t)*Math.sin((r-t)/n)}return i.amplitude=function(e){return t(e,n*zo)},i.period=function(n){return t(e,n)},i}(1,.3),Vo=function t(e,n){var r=Math.asin(1/(e=Math.max(1,e)))*(n/=zo);function i(t){return 1-e*Math.pow(2,-10*(t=+t))*Math.sin((t+r)/n)}return i.amplitude=function(e){return t(e,n*zo)},i.period=function(n){return t(e,n)},i}(1,.3),Ho=function t(e,n){var r=Math.asin(1/(e=Math.max(1,e)))*(n/=zo);function i(t){return((t=2*t-1)<0?e*Math.pow(2,10*t)*Math.sin((r-t)/n):2-e*Math.pow(2,-10*t)*Math.sin((r+t)/n))/2}return i.amplitude=function(e){return t(e,n*zo)},i.period=function(n){return t(e,n)},i}(1,.3),$o={time:null,delay:0,duration:250,ease:fo};function Go(t,e){for(var n;!(n=t.__transition)||!(n=n[e]);)if(!(t=t.parentNode))return $o.time=ui(),$o;return n}Te.prototype.interrupt=function(t){return this.each((function(){Oi(this,t)}))},Te.prototype.transition=function(t){var e,n;t instanceof to?(e=t._id,t=t._name):(e=no(),(n=$o).time=ui(),t=null==t?null:t+"");for(var r=this._groups,i=r.length,o=0;o<i;++o)for(var a,s=r[o],u=s.length,c=0;c<u;++c)(a=s[c])&&Ti(a,t,e,c,s,n||Go(a,e));return new to(r,this._parents,t,e)};var Wo=[null],Ko=function(t,e){var n,r,i=t.__transition;if(i)for(r in e=null==e?null:e+"",i)if((n=i[r]).state>wi&&n.name===e)return new to([[t]],Wo,e,+r);return null},Xo=function(t){return function(){return t}},Zo=function(t,e,n){this.target=t,this.type=e,this.selection=n};function Jo(){pe.stopImmediatePropagation()}var Qo=function(){pe.preventDefault(),pe.stopImmediatePropagation()},ta={name:"drag"},ea={name:"space"},na={name:"handle"},ra={name:"center"};function ia(t){return[+t[0],+t[1]]}function oa(t){return[ia(t[0]),ia(t[1])]}var aa={name:"x",handles:["w","e"].map(pa),input:function(t,e){return null==t?null:[[+t[0],e[0][1]],[+t[1],e[1][1]]]},output:function(t){return t&&[t[0][0],t[1][0]]}},sa={name:"y",handles:["n","s"].map(pa),input:function(t,e){return null==t?null:[[e[0][0],+t[0]],[e[1][0],+t[1]]]},output:function(t){return t&&[t[0][1],t[1][1]]}},ua={name:"xy",handles:["n","w","e","s","nw","ne","sw","se"].map(pa),input:function(t){return null==t?null:oa(t)},output:function(t){return t}},ca={overlay:"crosshair",selection:"move",n:"ns-resize",e:"ew-resize",s:"ns-resize",w:"ew-resize",nw:"nwse-resize",ne:"nesw-resize",se:"nwse-resize",sw:"nesw-resize"},fa={e:"w",w:"e",nw:"ne",ne:"nw",se:"sw",sw:"se"},la={n:"s",s:"n",nw:"sw",ne:"se",se:"ne",sw:"nw"},ha={overlay:1,selection:1,n:null,e:1,s:null,w:-1,nw:-1,ne:1,se:1,sw:-1},da={overlay:1,selection:1,n:-1,e:null,s:1,w:null,nw:-1,ne:-1,se:1,sw:1};function pa(t){return{type:t}}function ga(){return!pe.ctrlKey&&!pe.button}function ya(){var t=this.ownerSVGElement||this;return t.hasAttribute("viewBox")?[[(t=t.viewBox.baseVal).x,t.y],[t.x+t.width,t.y+t.height]]:[[0,0],[t.width.baseVal.value,t.height.baseVal.value]]}function ba(){return navigator.maxTouchPoints||"ontouchstart"in this}function ma(t){for(;!t.__brush;)if(!(t=t.parentNode))return;return t.__brush}function va(t){var e=t.__brush;return e?e.dim.output(e.selection):null}function _a(){return ka(aa)}function wa(){return ka(sa)}var xa=function(){return ka(ua)};function ka(t){var e,n=ya,r=ga,i=ba,o=!0,a=gt(u,"start","brush","end"),s=6;function u(e){var n=e.property("__brush",g).selectAll(".overlay").data([pa("overlay")]);n.enter().append("rect").attr("class","overlay").attr("pointer-events","all").attr("cursor",ca.overlay).merge(n).each((function(){var t=ma(this).extent;Me(this).attr("x",t[0][0]).attr("y",t[0][1]).attr("width",t[1][0]-t[0][0]).attr("height",t[1][1]-t[0][1])})),e.selectAll(".selection").data([pa("selection")]).enter().append("rect").attr("class","selection").attr("cursor",ca.selection).attr("fill","#777").attr("fill-opacity",.3).attr("stroke","#fff").attr("shape-rendering","crispEdges");var r=e.selectAll(".handle").data(t.handles,(function(t){return t.type}));r.exit().remove(),r.enter().append("rect").attr("class",(function(t){return"handle handle--"+t.type})).attr("cursor",(function(t){return ca[t.type]})),e.each(c).attr("fill","none").attr("pointer-events","all").on("mousedown.brush",h).filter(i).on("touchstart.brush",h).on("touchmove.brush",d).on("touchend.brush touchcancel.brush",p).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function c(){var t=Me(this),e=ma(this).selection;e?(t.selectAll(".selection").style("display",null).attr("x",e[0][0]).attr("y",e[0][1]).attr("width",e[1][0]-e[0][0]).attr("height",e[1][1]-e[0][1]),t.selectAll(".handle").style("display",null).attr("x",(function(t){return"e"===t.type[t.type.length-1]?e[1][0]-s/2:e[0][0]-s/2})).attr("y",(function(t){return"s"===t.type[0]?e[1][1]-s/2:e[0][1]-s/2})).attr("width",(function(t){return"n"===t.type||"s"===t.type?e[1][0]-e[0][0]+s:s})).attr("height",(function(t){return"e"===t.type||"w"===t.type?e[1][1]-e[0][1]+s:s}))):t.selectAll(".selection,.handle").style("display","none").attr("x",null).attr("y",null).attr("width",null).attr("height",null)}function f(t,e,n){return!n&&t.__brush.emitter||new l(t,e)}function l(t,e){this.that=t,this.args=e,this.state=t.__brush,this.active=0}function h(){if((!e||pe.touches)&&r.apply(this,arguments)){var n,i,a,s,u,l,h,d,p,g,y,b,m=this,v=pe.target.__data__.type,_="selection"===(o&&pe.metaKey?v="overlay":v)?ta:o&&pe.altKey?ra:na,w=t===sa?null:ha[v],x=t===aa?null:da[v],k=ma(m),E=k.extent,A=k.selection,S=E[0][0],T=E[0][1],M=E[1][0],D=E[1][1],C=0,O=0,R=w&&x&&o&&pe.shiftKey,I=pe.touches?(b=pe.changedTouches[0].identifier,function(t){return Pe(t,pe.touches,b)}):Be,N=I(m),B=N,L=f(m,arguments,!0).beforestart();"overlay"===v?(A&&(p=!0),k.selection=A=[[n=t===sa?S:N[0],a=t===aa?T:N[1]],[u=t===sa?M:n,h=t===aa?D:a]]):(n=A[0][0],a=A[0][1],u=A[1][0],h=A[1][1]),i=n,s=a,l=u,d=h;var P=Me(m).attr("pointer-events","none"),F=P.selectAll(".overlay").attr("cursor",ca[v]);if(pe.touches)L.moved=j,L.ended=z;else{var q=Me(pe.view).on("mousemove.brush",j,!0).on("mouseup.brush",z,!0);o&&q.on("keydown.brush",(function(){switch(pe.keyCode){case 16:R=w&&x;break;case 18:_===na&&(w&&(u=l-C*w,n=i+C*w),x&&(h=d-O*x,a=s+O*x),_=ra,U());break;case 32:_!==na&&_!==ra||(w<0?u=l-C:w>0&&(n=i-C),x<0?h=d-O:x>0&&(a=s-O),_=ea,F.attr("cursor",ca.selection),U());break;default:return}Qo()}),!0).on("keyup.brush",(function(){switch(pe.keyCode){case 16:R&&(g=y=R=!1,U());break;case 18:_===ra&&(w<0?u=l:w>0&&(n=i),x<0?h=d:x>0&&(a=s),_=na,U());break;case 32:_===ea&&(pe.altKey?(w&&(u=l-C*w,n=i+C*w),x&&(h=d-O*x,a=s+O*x),_=ra):(w<0?u=l:w>0&&(n=i),x<0?h=d:x>0&&(a=s),_=na),F.attr("cursor",ca[v]),U());break;default:return}Qo()}),!0),Ue(pe.view)}Jo(),Oi(m),c.call(m),L.start()}function j(){var t=I(m);!R||g||y||(Math.abs(t[0]-B[0])>Math.abs(t[1]-B[1])?y=!0:g=!0),B=t,p=!0,Qo(),U()}function U(){var t;switch(C=B[0]-N[0],O=B[1]-N[1],_){case ea:case ta:w&&(C=Math.max(S-n,Math.min(M-u,C)),i=n+C,l=u+C),x&&(O=Math.max(T-a,Math.min(D-h,O)),s=a+O,d=h+O);break;case na:w<0?(C=Math.max(S-n,Math.min(M-n,C)),i=n+C,l=u):w>0&&(C=Math.max(S-u,Math.min(M-u,C)),i=n,l=u+C),x<0?(O=Math.max(T-a,Math.min(D-a,O)),s=a+O,d=h):x>0&&(O=Math.max(T-h,Math.min(D-h,O)),s=a,d=h+O);break;case ra:w&&(i=Math.max(S,Math.min(M,n-C*w)),l=Math.max(S,Math.min(M,u+C*w))),x&&(s=Math.max(T,Math.min(D,a-O*x)),d=Math.max(T,Math.min(D,h+O*x)))}l<i&&(w*=-1,t=n,n=u,u=t,t=i,i=l,l=t,v in fa&&F.attr("cursor",ca[v=fa[v]])),d<s&&(x*=-1,t=a,a=h,h=t,t=s,s=d,d=t,v in la&&F.attr("cursor",ca[v=la[v]])),k.selection&&(A=k.selection),g&&(i=A[0][0],l=A[1][0]),y&&(s=A[0][1],d=A[1][1]),A[0][0]===i&&A[0][1]===s&&A[1][0]===l&&A[1][1]===d||(k.selection=[[i,s],[l,d]],c.call(m),L.brush())}function z(){if(Jo(),pe.touches){if(pe.touches.length)return;e&&clearTimeout(e),e=setTimeout((function(){e=null}),500)}else ze(pe.view,p),q.on("keydown.brush keyup.brush mousemove.brush mouseup.brush",null);P.attr("pointer-events","all"),F.attr("cursor",ca.overlay),k.selection&&(A=k.selection),function(t){return t[0][0]===t[1][0]||t[0][1]===t[1][1]}(A)&&(k.selection=null,c.call(m)),L.end()}}function d(){f(this,arguments).moved()}function p(){f(this,arguments).ended()}function g(){var e=this.__brush||{selection:null};return e.extent=oa(n.apply(this,arguments)),e.dim=t,e}return u.move=function(e,n){e.selection?e.on("start.brush",(function(){f(this,arguments).beforestart().start()})).on("interrupt.brush end.brush",(function(){f(this,arguments).end()})).tween("brush",(function(){var e=this,r=e.__brush,i=f(e,arguments),o=r.selection,a=t.input("function"==typeof n?n.apply(this,arguments):n,r.extent),s=Xn(o,a);function u(t){r.selection=1===t&&null===a?null:s(t),c.call(e),i.brush()}return null!==o&&null!==a?u:u(1)})):e.each((function(){var e=this,r=arguments,i=e.__brush,o=t.input("function"==typeof n?n.apply(e,r):n,i.extent),a=f(e,r).beforestart();Oi(e),i.selection=null===o?null:o,c.call(e),a.start().brush().end()}))},u.clear=function(t){u.move(t,null)},l.prototype={beforestart:function(){return 1==++this.active&&(this.state.emitter=this,this.starting=!0),this},start:function(){return this.starting?(this.starting=!1,this.emit("start")):this.emit("brush"),this},brush:function(){return this.emit("brush"),this},end:function(){return 0==--this.active&&(delete this.state.emitter,this.emit("end")),this},emit:function(e){_e(new Zo(u,e,t.output(this.state.selection)),a.apply,a,[e,this.that,this.args])}},u.extent=function(t){return arguments.length?(n="function"==typeof t?t:Xo(oa(t)),u):n},u.filter=function(t){return arguments.length?(r="function"==typeof t?t:Xo(!!t),u):r},u.handleSize=function(t){return arguments.length?(s=+t,u):s},u.keyModifiers=function(t){return arguments.length?(o=!!t,u):o},u.on=function(){var t=a.on.apply(a,arguments);return t===a?u:t},u}var Ea=Math.cos,Aa=Math.sin,Sa=Math.PI,Ta=Sa/2,Ma=2*Sa,Da=Math.max;function Ca(t){return function(e,n){return t(e.source.value+e.target.value,n.source.value+n.target.value)}}var Oa=function(){var t=0,e=null,n=null,r=null;function i(i){var o,a,s,u,c,f,l=i.length,h=[],d=x(l),p=[],g=[],y=g.groups=new Array(l),b=new Array(l*l);for(o=0,c=-1;++c<l;){for(a=0,f=-1;++f<l;)a+=i[c][f];h.push(a),p.push(x(l)),o+=a}for(e&&d.sort((function(t,n){return e(h[t],h[n])})),n&&p.forEach((function(t,e){t.sort((function(t,r){return n(i[e][t],i[e][r])}))})),u=(o=Da(0,Ma-t*l)/o)?t:Ma/l,a=0,c=-1;++c<l;){for(s=a,f=-1;++f<l;){var m=d[c],v=p[m][f],_=i[m][v],w=a,k=a+=_*o;b[v*l+m]={index:m,subindex:v,startAngle:w,endAngle:k,value:_}}y[m]={index:m,startAngle:s,endAngle:a,value:h[m]},a+=u}for(c=-1;++c<l;)for(f=c-1;++f<l;){var E=b[f*l+c],A=b[c*l+f];(E.value||A.value)&&g.push(E.value<A.value?{source:A,target:E}:{source:E,target:A})}return r?g.sort(r):g}return i.padAngle=function(e){return arguments.length?(t=Da(0,e),i):t},i.sortGroups=function(t){return arguments.length?(e=t,i):e},i.sortSubgroups=function(t){return arguments.length?(n=t,i):n},i.sortChords=function(t){return arguments.length?(null==t?r=null:(r=Ca(t))._=t,i):r&&r._},i},Ra=Array.prototype.slice,Ia=function(t){return function(){return t}},Na=Math.PI,Ba=2*Na,La=Ba-1e-6;function Pa(){this._x0=this._y0=this._x1=this._y1=null,this._=""}function Fa(){return new Pa}Pa.prototype=Fa.prototype={constructor:Pa,moveTo:function(t,e){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+e)},closePath:function(){null!==this._x1&&(this._x1=this._x0,this._y1=this._y0,this._+="Z")},lineTo:function(t,e){this._+="L"+(this._x1=+t)+","+(this._y1=+e)},quadraticCurveTo:function(t,e,n,r){this._+="Q"+ +t+","+ +e+","+(this._x1=+n)+","+(this._y1=+r)},bezierCurveTo:function(t,e,n,r,i,o){this._+="C"+ +t+","+ +e+","+ +n+","+ +r+","+(this._x1=+i)+","+(this._y1=+o)},arcTo:function(t,e,n,r,i){t=+t,e=+e,n=+n,r=+r,i=+i;var o=this._x1,a=this._y1,s=n-t,u=r-e,c=o-t,f=a-e,l=c*c+f*f;if(i<0)throw new Error("negative radius: "+i);if(null===this._x1)this._+="M"+(this._x1=t)+","+(this._y1=e);else if(l>1e-6)if(Math.abs(f*s-u*c)>1e-6&&i){var h=n-o,d=r-a,p=s*s+u*u,g=h*h+d*d,y=Math.sqrt(p),b=Math.sqrt(l),m=i*Math.tan((Na-Math.acos((p+l-g)/(2*y*b)))/2),v=m/b,_=m/y;Math.abs(v-1)>1e-6&&(this._+="L"+(t+v*c)+","+(e+v*f)),this._+="A"+i+","+i+",0,0,"+ +(f*h>c*d)+","+(this._x1=t+_*s)+","+(this._y1=e+_*u)}else this._+="L"+(this._x1=t)+","+(this._y1=e);else;},arc:function(t,e,n,r,i,o){t=+t,e=+e,o=!!o;var a=(n=+n)*Math.cos(r),s=n*Math.sin(r),u=t+a,c=e+s,f=1^o,l=o?r-i:i-r;if(n<0)throw new Error("negative radius: "+n);null===this._x1?this._+="M"+u+","+c:(Math.abs(this._x1-u)>1e-6||Math.abs(this._y1-c)>1e-6)&&(this._+="L"+u+","+c),n&&(l<0&&(l=l%Ba+Ba),l>La?this._+="A"+n+","+n+",0,1,"+f+","+(t-a)+","+(e-s)+"A"+n+","+n+",0,1,"+f+","+(this._x1=u)+","+(this._y1=c):l>1e-6&&(this._+="A"+n+","+n+",0,"+ +(l>=Na)+","+f+","+(this._x1=t+n*Math.cos(i))+","+(this._y1=e+n*Math.sin(i))))},rect:function(t,e,n,r){this._+="M"+(this._x0=this._x1=+t)+","+(this._y0=this._y1=+e)+"h"+ +n+"v"+ +r+"h"+-n+"Z"},toString:function(){return this._}};var qa=Fa;function ja(t){return t.source}function Ua(t){return t.target}function za(t){return t.radius}function Ya(t){return t.startAngle}function Va(t){return t.endAngle}var Ha=function(){var t=ja,e=Ua,n=za,r=Ya,i=Va,o=null;function a(){var a,s=Ra.call(arguments),u=t.apply(this,s),c=e.apply(this,s),f=+n.apply(this,(s[0]=u,s)),l=r.apply(this,s)-Ta,h=i.apply(this,s)-Ta,d=f*Ea(l),p=f*Aa(l),g=+n.apply(this,(s[0]=c,s)),y=r.apply(this,s)-Ta,b=i.apply(this,s)-Ta;if(o||(o=a=qa()),o.moveTo(d,p),o.arc(0,0,f,l,h),l===y&&h===b||(o.quadraticCurveTo(0,0,g*Ea(y),g*Aa(y)),o.arc(0,0,g,y,b)),o.quadraticCurveTo(0,0,d,p),o.closePath(),a)return o=null,a+""||null}return a.radius=function(t){return arguments.length?(n="function"==typeof t?t:Ia(+t),a):n},a.startAngle=function(t){return arguments.length?(r="function"==typeof t?t:Ia(+t),a):r},a.endAngle=function(t){return arguments.length?(i="function"==typeof t?t:Ia(+t),a):i},a.source=function(e){return arguments.length?(t=e,a):t},a.target=function(t){return arguments.length?(e=t,a):e},a.context=function(t){return arguments.length?(o=null==t?null:t,a):o},a};function $a(){}function Ga(t,e){var n=new $a;if(t instanceof $a)t.each((function(t,e){n.set(e,t)}));else if(Array.isArray(t)){var r,i=-1,o=t.length;if(null==e)for(;++i<o;)n.set(i,t[i]);else for(;++i<o;)n.set(e(r=t[i],i,t),r)}else if(t)for(var a in t)n.set(a,t[a]);return n}$a.prototype=Ga.prototype={constructor:$a,has:function(t){return"$"+t in this},get:function(t){return this["$"+t]},set:function(t,e){return this["$"+t]=e,this},remove:function(t){var e="$"+t;return e in this&&delete this[e]},clear:function(){for(var t in this)"$"===t[0]&&delete this[t]},keys:function(){var t=[];for(var e in this)"$"===e[0]&&t.push(e.slice(1));return t},values:function(){var t=[];for(var e in this)"$"===e[0]&&t.push(this[e]);return t},entries:function(){var t=[];for(var e in this)"$"===e[0]&&t.push({key:e.slice(1),value:this[e]});return t},size:function(){var t=0;for(var e in this)"$"===e[0]&&++t;return t},empty:function(){for(var t in this)if("$"===t[0])return!1;return!0},each:function(t){for(var e in this)"$"===e[0]&&t(this[e],e.slice(1),this)}};var Wa=Ga,Ka=function(){var t,e,n,r=[],i=[];function o(n,i,a,s){if(i>=r.length)return null!=t&&n.sort(t),null!=e?e(n):n;for(var u,c,f,l=-1,h=n.length,d=r[i++],p=Wa(),g=a();++l<h;)(f=p.get(u=d(c=n[l])+""))?f.push(c):p.set(u,[c]);return p.each((function(t,e){s(g,e,o(t,i,a,s))})),g}return n={object:function(t){return o(t,0,Xa,Za)},map:function(t){return o(t,0,Ja,Qa)},entries:function(t){return function t(n,o){if(++o>r.length)return n;var a,s=i[o-1];return null!=e&&o>=r.length?a=n.entries():(a=[],n.each((function(e,n){a.push({key:n,values:t(e,o)})}))),null!=s?a.sort((function(t,e){return s(t.key,e.key)})):a}(o(t,0,Ja,Qa),0)},key:function(t){return r.push(t),n},sortKeys:function(t){return i[r.length-1]=t,n},sortValues:function(e){return t=e,n},rollup:function(t){return e=t,n}}};function Xa(){return{}}function Za(t,e,n){t[e]=n}function Ja(){return Wa()}function Qa(t,e,n){t.set(e,n)}function ts(){}var es=Wa.prototype;function ns(t,e){var n=new ts;if(t instanceof ts)t.each((function(t){n.add(t)}));else if(t){var r=-1,i=t.length;if(null==e)for(;++r<i;)n.add(t[r]);else for(;++r<i;)n.add(e(t[r],r,t))}return n}ts.prototype=ns.prototype={constructor:ts,has:es.has,add:function(t){return this["$"+(t+="")]=t,this},remove:es.remove,clear:es.clear,values:es.keys,size:es.size,empty:es.empty,each:es.each};var rs=ns,is=function(t){var e=[];for(var n in t)e.push(n);return e},os=function(t){var e=[];for(var n in t)e.push(t[n]);return e},as=function(t){var e=[];for(var n in t)e.push({key:n,value:t[n]});return e},ss=Array.prototype.slice,us=function(t,e){return t-e},cs=function(t){for(var e=0,n=t.length,r=t[n-1][1]*t[0][0]-t[n-1][0]*t[0][1];++e<n;)r+=t[e-1][1]*t[e][0]-t[e-1][0]*t[e][1];return r},fs=function(t){return function(){return t}},ls=function(t,e){for(var n,r=-1,i=e.length;++r<i;)if(n=hs(t,e[r]))return n;return 0};function hs(t,e){for(var n=e[0],r=e[1],i=-1,o=0,a=t.length,s=a-1;o<a;s=o++){var u=t[o],c=u[0],f=u[1],l=t[s],h=l[0],d=l[1];if(ds(u,l,e))return 0;f>r!=d>r&&n<(h-c)*(r-f)/(d-f)+c&&(i=-i)}return i}function ds(t,e,n){var r,i,o,a;return function(t,e,n){return(e[0]-t[0])*(n[1]-t[1])==(n[0]-t[0])*(e[1]-t[1])}(t,e,n)&&(i=t[r=+(t[0]===e[0])],o=n[r],a=e[r],i<=o&&o<=a||a<=o&&o<=i)}var ps=function(){},gs=[[],[[[1,1.5],[.5,1]]],[[[1.5,1],[1,1.5]]],[[[1.5,1],[.5,1]]],[[[1,.5],[1.5,1]]],[[[1,1.5],[.5,1]],[[1,.5],[1.5,1]]],[[[1,.5],[1,1.5]]],[[[1,.5],[.5,1]]],[[[.5,1],[1,.5]]],[[[1,1.5],[1,.5]]],[[[.5,1],[1,.5]],[[1.5,1],[1,1.5]]],[[[1.5,1],[1,.5]]],[[[.5,1],[1.5,1]]],[[[1,1.5],[1.5,1]]],[[[.5,1],[1,1.5]]],[]],ys=function(){var t=1,e=1,n=D,r=s;function i(t){var e=n(t);if(Array.isArray(e))e=e.slice().sort(us);else{var r=y(t),i=r[0],a=r[1];e=M(i,a,e),e=x(Math.floor(i/e)*e,Math.floor(a/e)*e,e)}return e.map((function(e){return o(t,e)}))}function o(n,i){var o=[],s=[];return function(n,r,i){var o,s,u,c,f,l,h=new Array,d=new Array;o=s=-1,c=n[0]>=r,gs[c<<1].forEach(p);for(;++o<t-1;)u=c,c=n[o+1]>=r,gs[u|c<<1].forEach(p);gs[c<<0].forEach(p);for(;++s<e-1;){for(o=-1,c=n[s*t+t]>=r,f=n[s*t]>=r,gs[c<<1|f<<2].forEach(p);++o<t-1;)u=c,c=n[s*t+t+o+1]>=r,l=f,f=n[s*t+o+1]>=r,gs[u|c<<1|f<<2|l<<3].forEach(p);gs[c|f<<3].forEach(p)}o=-1,f=n[s*t]>=r,gs[f<<2].forEach(p);for(;++o<t-1;)l=f,f=n[s*t+o+1]>=r,gs[f<<2|l<<3].forEach(p);function p(t){var e,n,r=[t[0][0]+o,t[0][1]+s],u=[t[1][0]+o,t[1][1]+s],c=a(r),f=a(u);(e=d[c])?(n=h[f])?(delete d[e.end],delete h[n.start],e===n?(e.ring.push(u),i(e.ring)):h[e.start]=d[n.end]={start:e.start,end:n.end,ring:e.ring.concat(n.ring)}):(delete d[e.end],e.ring.push(u),d[e.end=f]=e):(e=h[f])?(n=d[c])?(delete h[e.start],delete d[n.end],e===n?(e.ring.push(u),i(e.ring)):h[n.start]=d[e.end]={start:n.start,end:e.end,ring:n.ring.concat(e.ring)}):(delete h[e.start],e.ring.unshift(r),h[e.start=c]=e):h[c]=d[f]={start:c,end:f,ring:[r,u]}}gs[f<<3].forEach(p)}(n,i,(function(t){r(t,n,i),cs(t)>0?o.push([t]):s.push(t)})),s.forEach((function(t){for(var e,n=0,r=o.length;n<r;++n)if(-1!==ls((e=o[n])[0],t))return void e.push(t)})),{type:"MultiPolygon",value:i,coordinates:o}}function a(e){return 2*e[0]+e[1]*(t+1)*4}function s(n,r,i){n.forEach((function(n){var o,a=n[0],s=n[1],u=0|a,c=0|s,f=r[c*t+u];a>0&&a<t&&u===a&&(o=r[c*t+u-1],n[0]=a+(i-o)/(f-o)-.5),s>0&&s<e&&c===s&&(o=r[(c-1)*t+u],n[1]=s+(i-o)/(f-o)-.5)}))}return i.contour=o,i.size=function(n){if(!arguments.length)return[t,e];var r=Math.ceil(n[0]),o=Math.ceil(n[1]);if(!(r>0&&o>0))throw new Error("invalid size");return t=r,e=o,i},i.thresholds=function(t){return arguments.length?(n="function"==typeof t?t:Array.isArray(t)?fs(ss.call(t)):fs(t),i):n},i.smooth=function(t){return arguments.length?(r=t?s:ps,i):r===s},i};function bs(t,e,n){for(var r=t.width,i=t.height,o=1+(n<<1),a=0;a<i;++a)for(var s=0,u=0;s<r+n;++s)s<r&&(u+=t.data[s+a*r]),s>=n&&(s>=o&&(u-=t.data[s-o+a*r]),e.data[s-n+a*r]=u/Math.min(s+1,r-1+o-s,o))}function ms(t,e,n){for(var r=t.width,i=t.height,o=1+(n<<1),a=0;a<r;++a)for(var s=0,u=0;s<i+n;++s)s<i&&(u+=t.data[a+s*r]),s>=n&&(s>=o&&(u-=t.data[a+(s-o)*r]),e.data[a+(s-n)*r]=u/Math.min(s+1,i-1+o-s,o))}function vs(t){return t[0]}function _s(t){return t[1]}function ws(){return 1}var xs=function(){var t=vs,e=_s,n=ws,r=960,i=500,o=20,a=2,s=3*o,u=r+2*s>>a,c=i+2*s>>a,f=fs(20);function l(r){var i=new Float32Array(u*c),l=new Float32Array(u*c);r.forEach((function(r,o,f){var l=+t(r,o,f)+s>>a,h=+e(r,o,f)+s>>a,d=+n(r,o,f);l>=0&&l<u&&h>=0&&h<c&&(i[l+h*u]+=d)})),bs({width:u,height:c,data:i},{width:u,height:c,data:l},o>>a),ms({width:u,height:c,data:l},{width:u,height:c,data:i},o>>a),bs({width:u,height:c,data:i},{width:u,height:c,data:l},o>>a),ms({width:u,height:c,data:l},{width:u,height:c,data:i},o>>a),bs({width:u,height:c,data:i},{width:u,height:c,data:l},o>>a),ms({width:u,height:c,data:l},{width:u,height:c,data:i},o>>a);var d=f(i);if(!Array.isArray(d)){var p=N(i);d=M(0,p,d),(d=x(0,Math.floor(p/d)*d,d)).shift()}return ys().thresholds(d).size([u,c])(i).map(h)}function h(t){return t.value*=Math.pow(2,-2*a),t.coordinates.forEach(d),t}function d(t){t.forEach(p)}function p(t){t.forEach(g)}function g(t){t[0]=t[0]*Math.pow(2,a)-s,t[1]=t[1]*Math.pow(2,a)-s}function y(){return u=r+2*(s=3*o)>>a,c=i+2*s>>a,l}return l.x=function(e){return arguments.length?(t="function"==typeof e?e:fs(+e),l):t},l.y=function(t){return arguments.length?(e="function"==typeof t?t:fs(+t),l):e},l.weight=function(t){return arguments.length?(n="function"==typeof t?t:fs(+t),l):n},l.size=function(t){if(!arguments.length)return[r,i];var e=Math.ceil(t[0]),n=Math.ceil(t[1]);if(!(e>=0||e>=0))throw new Error("invalid size");return r=e,i=n,y()},l.cellSize=function(t){if(!arguments.length)return 1<<a;if(!((t=+t)>=1))throw new Error("invalid cell size");return a=Math.floor(Math.log(t)/Math.LN2),y()},l.thresholds=function(t){return arguments.length?(f="function"==typeof t?t:Array.isArray(t)?fs(ss.call(t)):fs(t),l):f},l.bandwidth=function(t){if(!arguments.length)return Math.sqrt(o*(o+1));if(!((t=+t)>=0))throw new Error("invalid bandwidth");return o=Math.round((Math.sqrt(4*t*t+1)-1)/2),y()},l},ks={},Es={},As=34,Ss=10,Ts=13;function Ms(t){return new Function("d","return {"+t.map((function(t,e){return JSON.stringify(t)+": d["+e+"]"})).join(",")+"}")}function Ds(t){var e=Object.create(null),n=[];return t.forEach((function(t){for(var r in t)r in e||n.push(e[r]=r)})),n}function Cs(t,e){var n=t+"",r=n.length;return r<e?new Array(e-r+1).join(0)+n:n}function Os(t){var e,n=t.getUTCHours(),r=t.getUTCMinutes(),i=t.getUTCSeconds(),o=t.getUTCMilliseconds();return isNaN(t)?"Invalid Date":((e=t.getUTCFullYear())<0?"-"+Cs(-e,6):e>9999?"+"+Cs(e,6):Cs(e,4))+"-"+Cs(t.getUTCMonth()+1,2)+"-"+Cs(t.getUTCDate(),2)+(o?"T"+Cs(n,2)+":"+Cs(r,2)+":"+Cs(i,2)+"."+Cs(o,3)+"Z":i?"T"+Cs(n,2)+":"+Cs(r,2)+":"+Cs(i,2)+"Z":r||n?"T"+Cs(n,2)+":"+Cs(r,2)+"Z":"")}var Rs=function(t){var e=new RegExp('["'+t+"\n\r]"),n=t.charCodeAt(0);function r(t,e){var r,i=[],o=t.length,a=0,s=0,u=o<=0,c=!1;function f(){if(u)return Es;if(c)return c=!1,ks;var e,r,i=a;if(t.charCodeAt(i)===As){for(;a++<o&&t.charCodeAt(a)!==As||t.charCodeAt(++a)===As;);return(e=a)>=o?u=!0:(r=t.charCodeAt(a++))===Ss?c=!0:r===Ts&&(c=!0,t.charCodeAt(a)===Ss&&++a),t.slice(i+1,e-1).replace(/""/g,'"')}for(;a<o;){if((r=t.charCodeAt(e=a++))===Ss)c=!0;else if(r===Ts)c=!0,t.charCodeAt(a)===Ss&&++a;else if(r!==n)continue;return t.slice(i,e)}return u=!0,t.slice(i,o)}for(t.charCodeAt(o-1)===Ss&&--o,t.charCodeAt(o-1)===Ts&&--o;(r=f())!==Es;){for(var l=[];r!==ks&&r!==Es;)l.push(r),r=f();e&&null==(l=e(l,s++))||i.push(l)}return i}function i(e,n){return e.map((function(e){return n.map((function(t){return a(e[t])})).join(t)}))}function o(e){return e.map(a).join(t)}function a(t){return null==t?"":t instanceof Date?Os(t):e.test(t+="")?'"'+t.replace(/"/g,'""')+'"':t}return{parse:function(t,e){var n,i,o=r(t,(function(t,r){if(n)return n(t,r-1);i=t,n=e?function(t,e){var n=Ms(t);return function(r,i){return e(n(r),i,t)}}(t,e):Ms(t)}));return o.columns=i||[],o},parseRows:r,format:function(e,n){return null==n&&(n=Ds(e)),[n.map(a).join(t)].concat(i(e,n)).join("\n")},formatBody:function(t,e){return null==e&&(e=Ds(t)),i(t,e).join("\n")},formatRows:function(t){return t.map(o).join("\n")}}},Is=Rs(","),Ns=Is.parse,Bs=Is.parseRows,Ls=Is.format,Ps=Is.formatBody,Fs=Is.formatRows,qs=Rs("\t"),js=qs.parse,Us=qs.parseRows,zs=qs.format,Ys=qs.formatBody,Vs=qs.formatRows;function Hs(t){for(var e in t){var n,r=t[e].trim();if(r)if("true"===r)r=!0;else if("false"===r)r=!1;else if("NaN"===r)r=NaN;else if(isNaN(n=+r)){if(!/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/.test(r))continue;r=new Date(r)}else r=n;else r=null;t[e]=r}return t}function $s(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.blob()}var Gs=function(t,e){return fetch(t,e).then($s)};function Ws(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.arrayBuffer()}var Ks=function(t,e){return fetch(t,e).then(Ws)};function Xs(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.text()}var Zs=function(t,e){return fetch(t,e).then(Xs)};function Js(t){return function(e,n,r){return 2===arguments.length&&"function"==typeof n&&(r=n,n=void 0),Zs(e,n).then((function(e){return t(e,r)}))}}function Qs(t,e,n,r){3===arguments.length&&"function"==typeof n&&(r=n,n=void 0);var i=Rs(t);return Zs(e,n).then((function(t){return i.parse(t,r)}))}var tu=Js(Ns),eu=Js(js),nu=function(t,e){return new Promise((function(n,r){var i=new Image;for(var o in e)i[o]=e[o];i.onerror=r,i.onload=function(){n(i)},i.src=t}))};function ru(t){if(!t.ok)throw new Error(t.status+" "+t.statusText);return t.json()}var iu=function(t,e){return fetch(t,e).then(ru)};function ou(t){return function(e,n){return Zs(e,n).then((function(e){return(new DOMParser).parseFromString(e,t)}))}}var au=ou("application/xml"),su=ou("text/html"),uu=ou("image/svg+xml"),cu=function(t,e){var n;function r(){var r,i,o=n.length,a=0,s=0;for(r=0;r<o;++r)a+=(i=n[r]).x,s+=i.y;for(a=a/o-t,s=s/o-e,r=0;r<o;++r)(i=n[r]).x-=a,i.y-=s}return null==t&&(t=0),null==e&&(e=0),r.initialize=function(t){n=t},r.x=function(e){return arguments.length?(t=+e,r):t},r.y=function(t){return arguments.length?(e=+t,r):e},r},fu=function(t){return function(){return t}},lu=function(){return 1e-6*(Math.random()-.5)};function hu(t,e,n,r){if(isNaN(e)||isNaN(n))return t;var i,o,a,s,u,c,f,l,h,d=t._root,p={data:r},g=t._x0,y=t._y0,b=t._x1,m=t._y1;if(!d)return t._root=p,t;for(;d.length;)if((c=e>=(o=(g+b)/2))?g=o:b=o,(f=n>=(a=(y+m)/2))?y=a:m=a,i=d,!(d=d[l=f<<1|c]))return i[l]=p,t;if(s=+t._x.call(null,d.data),u=+t._y.call(null,d.data),e===s&&n===u)return p.next=d,i?i[l]=p:t._root=p,t;do{i=i?i[l]=new Array(4):t._root=new Array(4),(c=e>=(o=(g+b)/2))?g=o:b=o,(f=n>=(a=(y+m)/2))?y=a:m=a}while((l=f<<1|c)==(h=(u>=a)<<1|s>=o));return i[h]=d,i[l]=p,t}var du=function(t,e,n,r,i){this.node=t,this.x0=e,this.y0=n,this.x1=r,this.y1=i};function pu(t){return t[0]}function gu(t){return t[1]}function yu(t,e,n){var r=new bu(null==e?pu:e,null==n?gu:n,NaN,NaN,NaN,NaN);return null==t?r:r.addAll(t)}function bu(t,e,n,r,i,o){this._x=t,this._y=e,this._x0=n,this._y0=r,this._x1=i,this._y1=o,this._root=void 0}function mu(t){for(var e={data:t.data},n=e;t=t.next;)n=n.next={data:t.data};return e}var vu=yu.prototype=bu.prototype;function _u(t){return t.x+t.vx}function wu(t){return t.y+t.vy}vu.copy=function(){var t,e,n=new bu(this._x,this._y,this._x0,this._y0,this._x1,this._y1),r=this._root;if(!r)return n;if(!r.length)return n._root=mu(r),n;for(t=[{source:r,target:n._root=new Array(4)}];r=t.pop();)for(var i=0;i<4;++i)(e=r.source[i])&&(e.length?t.push({source:e,target:r.target[i]=new Array(4)}):r.target[i]=mu(e));return n},vu.add=function(t){var e=+this._x.call(null,t),n=+this._y.call(null,t);return hu(this.cover(e,n),e,n,t)},vu.addAll=function(t){var e,n,r,i,o=t.length,a=new Array(o),s=new Array(o),u=1/0,c=1/0,f=-1/0,l=-1/0;for(n=0;n<o;++n)isNaN(r=+this._x.call(null,e=t[n]))||isNaN(i=+this._y.call(null,e))||(a[n]=r,s[n]=i,r<u&&(u=r),r>f&&(f=r),i<c&&(c=i),i>l&&(l=i));if(u>f||c>l)return this;for(this.cover(u,c).cover(f,l),n=0;n<o;++n)hu(this,a[n],s[n],t[n]);return this},vu.cover=function(t,e){if(isNaN(t=+t)||isNaN(e=+e))return this;var n=this._x0,r=this._y0,i=this._x1,o=this._y1;if(isNaN(n))i=(n=Math.floor(t))+1,o=(r=Math.floor(e))+1;else{for(var a,s,u=i-n,c=this._root;n>t||t>=i||r>e||e>=o;)switch(s=(e<r)<<1|t<n,(a=new Array(4))[s]=c,c=a,u*=2,s){case 0:i=n+u,o=r+u;break;case 1:n=i-u,o=r+u;break;case 2:i=n+u,r=o-u;break;case 3:n=i-u,r=o-u}this._root&&this._root.length&&(this._root=c)}return this._x0=n,this._y0=r,this._x1=i,this._y1=o,this},vu.data=function(){var t=[];return this.visit((function(e){if(!e.length)do{t.push(e.data)}while(e=e.next)})),t},vu.extent=function(t){return arguments.length?this.cover(+t[0][0],+t[0][1]).cover(+t[1][0],+t[1][1]):isNaN(this._x0)?void 0:[[this._x0,this._y0],[this._x1,this._y1]]},vu.find=function(t,e,n){var r,i,o,a,s,u,c,f=this._x0,l=this._y0,h=this._x1,d=this._y1,p=[],g=this._root;for(g&&p.push(new du(g,f,l,h,d)),null==n?n=1/0:(f=t-n,l=e-n,h=t+n,d=e+n,n*=n);u=p.pop();)if(!(!(g=u.node)||(i=u.x0)>h||(o=u.y0)>d||(a=u.x1)<f||(s=u.y1)<l))if(g.length){var y=(i+a)/2,b=(o+s)/2;p.push(new du(g[3],y,b,a,s),new du(g[2],i,b,y,s),new du(g[1],y,o,a,b),new du(g[0],i,o,y,b)),(c=(e>=b)<<1|t>=y)&&(u=p[p.length-1],p[p.length-1]=p[p.length-1-c],p[p.length-1-c]=u)}else{var m=t-+this._x.call(null,g.data),v=e-+this._y.call(null,g.data),_=m*m+v*v;if(_<n){var w=Math.sqrt(n=_);f=t-w,l=e-w,h=t+w,d=e+w,r=g.data}}return r},vu.remove=function(t){if(isNaN(o=+this._x.call(null,t))||isNaN(a=+this._y.call(null,t)))return this;var e,n,r,i,o,a,s,u,c,f,l,h,d=this._root,p=this._x0,g=this._y0,y=this._x1,b=this._y1;if(!d)return this;if(d.length)for(;;){if((c=o>=(s=(p+y)/2))?p=s:y=s,(f=a>=(u=(g+b)/2))?g=u:b=u,e=d,!(d=d[l=f<<1|c]))return this;if(!d.length)break;(e[l+1&3]||e[l+2&3]||e[l+3&3])&&(n=e,h=l)}for(;d.data!==t;)if(r=d,!(d=d.next))return this;return(i=d.next)&&delete d.next,r?(i?r.next=i:delete r.next,this):e?(i?e[l]=i:delete e[l],(d=e[0]||e[1]||e[2]||e[3])&&d===(e[3]||e[2]||e[1]||e[0])&&!d.length&&(n?n[h]=d:this._root=d),this):(this._root=i,this)},vu.removeAll=function(t){for(var e=0,n=t.length;e<n;++e)this.remove(t[e]);return this},vu.root=function(){return this._root},vu.size=function(){var t=0;return this.visit((function(e){if(!e.length)do{++t}while(e=e.next)})),t},vu.visit=function(t){var e,n,r,i,o,a,s=[],u=this._root;for(u&&s.push(new du(u,this._x0,this._y0,this._x1,this._y1));e=s.pop();)if(!t(u=e.node,r=e.x0,i=e.y0,o=e.x1,a=e.y1)&&u.length){var c=(r+o)/2,f=(i+a)/2;(n=u[3])&&s.push(new du(n,c,f,o,a)),(n=u[2])&&s.push(new du(n,r,f,c,a)),(n=u[1])&&s.push(new du(n,c,i,o,f)),(n=u[0])&&s.push(new du(n,r,i,c,f))}return this},vu.visitAfter=function(t){var e,n=[],r=[];for(this._root&&n.push(new du(this._root,this._x0,this._y0,this._x1,this._y1));e=n.pop();){var i=e.node;if(i.length){var o,a=e.x0,s=e.y0,u=e.x1,c=e.y1,f=(a+u)/2,l=(s+c)/2;(o=i[0])&&n.push(new du(o,a,s,f,l)),(o=i[1])&&n.push(new du(o,f,s,u,l)),(o=i[2])&&n.push(new du(o,a,l,f,c)),(o=i[3])&&n.push(new du(o,f,l,u,c))}r.push(e)}for(;e=r.pop();)t(e.node,e.x0,e.y0,e.x1,e.y1);return this},vu.x=function(t){return arguments.length?(this._x=t,this):this._x},vu.y=function(t){return arguments.length?(this._y=t,this):this._y};var xu=function(t){var e,n,r=1,i=1;function o(){for(var t,o,s,u,c,f,l,h=e.length,d=0;d<i;++d)for(o=yu(e,_u,wu).visitAfter(a),t=0;t<h;++t)s=e[t],f=n[s.index],l=f*f,u=s.x+s.vx,c=s.y+s.vy,o.visit(p);function p(t,e,n,i,o){var a=t.data,h=t.r,d=f+h;if(!a)return e>u+d||i<u-d||n>c+d||o<c-d;if(a.index>s.index){var p=u-a.x-a.vx,g=c-a.y-a.vy,y=p*p+g*g;y<d*d&&(0===p&&(y+=(p=lu())*p),0===g&&(y+=(g=lu())*g),y=(d-(y=Math.sqrt(y)))/y*r,s.vx+=(p*=y)*(d=(h*=h)/(l+h)),s.vy+=(g*=y)*d,a.vx-=p*(d=1-d),a.vy-=g*d)}}}function a(t){if(t.data)return t.r=n[t.data.index];for(var e=t.r=0;e<4;++e)t[e]&&t[e].r>t.r&&(t.r=t[e].r)}function s(){if(e){var r,i,o=e.length;for(n=new Array(o),r=0;r<o;++r)i=e[r],n[i.index]=+t(i,r,e)}}return"function"!=typeof t&&(t=fu(null==t?1:+t)),o.initialize=function(t){e=t,s()},o.iterations=function(t){return arguments.length?(i=+t,o):i},o.strength=function(t){return arguments.length?(r=+t,o):r},o.radius=function(e){return arguments.length?(t="function"==typeof e?e:fu(+e),s(),o):t},o};function ku(t){return t.index}function Eu(t,e){var n=t.get(e);if(!n)throw new Error("missing: "+e);return n}var Au=function(t){var e,n,r,i,o,a=ku,s=function(t){return 1/Math.min(i[t.source.index],i[t.target.index])},u=fu(30),c=1;function f(r){for(var i=0,a=t.length;i<c;++i)for(var s,u,f,l,h,d,p,g=0;g<a;++g)u=(s=t[g]).source,l=(f=s.target).x+f.vx-u.x-u.vx||lu(),h=f.y+f.vy-u.y-u.vy||lu(),l*=d=((d=Math.sqrt(l*l+h*h))-n[g])/d*r*e[g],h*=d,f.vx-=l*(p=o[g]),f.vy-=h*p,u.vx+=l*(p=1-p),u.vy+=h*p}function l(){if(r){var s,u,c=r.length,f=t.length,l=Wa(r,a);for(s=0,i=new Array(c);s<f;++s)(u=t[s]).index=s,"object"!=typeof u.source&&(u.source=Eu(l,u.source)),"object"!=typeof u.target&&(u.target=Eu(l,u.target)),i[u.source.index]=(i[u.source.index]||0)+1,i[u.target.index]=(i[u.target.index]||0)+1;for(s=0,o=new Array(f);s<f;++s)u=t[s],o[s]=i[u.source.index]/(i[u.source.index]+i[u.target.index]);e=new Array(f),h(),n=new Array(f),d()}}function h(){if(r)for(var n=0,i=t.length;n<i;++n)e[n]=+s(t[n],n,t)}function d(){if(r)for(var e=0,i=t.length;e<i;++e)n[e]=+u(t[e],e,t)}return null==t&&(t=[]),f.initialize=function(t){r=t,l()},f.links=function(e){return arguments.length?(t=e,l(),f):t},f.id=function(t){return arguments.length?(a=t,f):a},f.iterations=function(t){return arguments.length?(c=+t,f):c},f.strength=function(t){return arguments.length?(s="function"==typeof t?t:fu(+t),h(),f):s},f.distance=function(t){return arguments.length?(u="function"==typeof t?t:fu(+t),d(),f):u},f};function Su(t){return t.x}function Tu(t){return t.y}var Mu=10,Du=Math.PI*(3-Math.sqrt(5)),Cu=function(t){var e,n=1,r=.001,i=1-Math.pow(r,1/300),o=0,a=.6,s=Wa(),u=li(f),c=gt("tick","end");function f(){l(),c.call("tick",e),n<r&&(u.stop(),c.call("end",e))}function l(r){var u,c,f=t.length;void 0===r&&(r=1);for(var l=0;l<r;++l)for(n+=(o-n)*i,s.each((function(t){t(n)})),u=0;u<f;++u)null==(c=t[u]).fx?c.x+=c.vx*=a:(c.x=c.fx,c.vx=0),null==c.fy?c.y+=c.vy*=a:(c.y=c.fy,c.vy=0);return e}function h(){for(var e,n=0,r=t.length;n<r;++n){if((e=t[n]).index=n,null!=e.fx&&(e.x=e.fx),null!=e.fy&&(e.y=e.fy),isNaN(e.x)||isNaN(e.y)){var i=Mu*Math.sqrt(n),o=n*Du;e.x=i*Math.cos(o),e.y=i*Math.sin(o)}(isNaN(e.vx)||isNaN(e.vy))&&(e.vx=e.vy=0)}}function d(e){return e.initialize&&e.initialize(t),e}return null==t&&(t=[]),h(),e={tick:l,restart:function(){return u.restart(f),e},stop:function(){return u.stop(),e},nodes:function(n){return arguments.length?(t=n,h(),s.each(d),e):t},alpha:function(t){return arguments.length?(n=+t,e):n},alphaMin:function(t){return arguments.length?(r=+t,e):r},alphaDecay:function(t){return arguments.length?(i=+t,e):+i},alphaTarget:function(t){return arguments.length?(o=+t,e):o},velocityDecay:function(t){return arguments.length?(a=1-t,e):1-a},force:function(t,n){return arguments.length>1?(null==n?s.remove(t):s.set(t,d(n)),e):s.get(t)},find:function(e,n,r){var i,o,a,s,u,c=0,f=t.length;for(null==r?r=1/0:r*=r,c=0;c<f;++c)(a=(i=e-(s=t[c]).x)*i+(o=n-s.y)*o)<r&&(u=s,r=a);return u},on:function(t,n){return arguments.length>1?(c.on(t,n),e):c.on(t)}}},Ou=function(){var t,e,n,r,i=fu(-30),o=1,a=1/0,s=.81;function u(r){var i,o=t.length,a=yu(t,Su,Tu).visitAfter(f);for(n=r,i=0;i<o;++i)e=t[i],a.visit(l)}function c(){if(t){var e,n,o=t.length;for(r=new Array(o),e=0;e<o;++e)n=t[e],r[n.index]=+i(n,e,t)}}function f(t){var e,n,i,o,a,s=0,u=0;if(t.length){for(i=o=a=0;a<4;++a)(e=t[a])&&(n=Math.abs(e.value))&&(s+=e.value,u+=n,i+=n*e.x,o+=n*e.y);t.x=i/u,t.y=o/u}else{(e=t).x=e.data.x,e.y=e.data.y;do{s+=r[e.data.index]}while(e=e.next)}t.value=s}function l(t,i,u,c){if(!t.value)return!0;var f=t.x-e.x,l=t.y-e.y,h=c-i,d=f*f+l*l;if(h*h/s<d)return d<a&&(0===f&&(d+=(f=lu())*f),0===l&&(d+=(l=lu())*l),d<o&&(d=Math.sqrt(o*d)),e.vx+=f*t.value*n/d,e.vy+=l*t.value*n/d),!0;if(!(t.length||d>=a)){(t.data!==e||t.next)&&(0===f&&(d+=(f=lu())*f),0===l&&(d+=(l=lu())*l),d<o&&(d=Math.sqrt(o*d)));do{t.data!==e&&(h=r[t.data.index]*n/d,e.vx+=f*h,e.vy+=l*h)}while(t=t.next)}}return u.initialize=function(e){t=e,c()},u.strength=function(t){return arguments.length?(i="function"==typeof t?t:fu(+t),c(),u):i},u.distanceMin=function(t){return arguments.length?(o=t*t,u):Math.sqrt(o)},u.distanceMax=function(t){return arguments.length?(a=t*t,u):Math.sqrt(a)},u.theta=function(t){return arguments.length?(s=t*t,u):Math.sqrt(s)},u},Ru=function(t,e,n){var r,i,o,a=fu(.1);function s(t){for(var a=0,s=r.length;a<s;++a){var u=r[a],c=u.x-e||1e-6,f=u.y-n||1e-6,l=Math.sqrt(c*c+f*f),h=(o[a]-l)*i[a]*t/l;u.vx+=c*h,u.vy+=f*h}}function u(){if(r){var e,n=r.length;for(i=new Array(n),o=new Array(n),e=0;e<n;++e)o[e]=+t(r[e],e,r),i[e]=isNaN(o[e])?0:+a(r[e],e,r)}}return"function"!=typeof t&&(t=fu(+t)),null==e&&(e=0),null==n&&(n=0),s.initialize=function(t){r=t,u()},s.strength=function(t){return arguments.length?(a="function"==typeof t?t:fu(+t),u(),s):a},s.radius=function(e){return arguments.length?(t="function"==typeof e?e:fu(+e),u(),s):t},s.x=function(t){return arguments.length?(e=+t,s):e},s.y=function(t){return arguments.length?(n=+t,s):n},s},Iu=function(t){var e,n,r,i=fu(.1);function o(t){for(var i,o=0,a=e.length;o<a;++o)(i=e[o]).vx+=(r[o]-i.x)*n[o]*t}function a(){if(e){var o,a=e.length;for(n=new Array(a),r=new Array(a),o=0;o<a;++o)n[o]=isNaN(r[o]=+t(e[o],o,e))?0:+i(e[o],o,e)}}return"function"!=typeof t&&(t=fu(null==t?0:+t)),o.initialize=function(t){e=t,a()},o.strength=function(t){return arguments.length?(i="function"==typeof t?t:fu(+t),a(),o):i},o.x=function(e){return arguments.length?(t="function"==typeof e?e:fu(+e),a(),o):t},o},Nu=function(t){var e,n,r,i=fu(.1);function o(t){for(var i,o=0,a=e.length;o<a;++o)(i=e[o]).vy+=(r[o]-i.y)*n[o]*t}function a(){if(e){var o,a=e.length;for(n=new Array(a),r=new Array(a),o=0;o<a;++o)n[o]=isNaN(r[o]=+t(e[o],o,e))?0:+i(e[o],o,e)}}return"function"!=typeof t&&(t=fu(null==t?0:+t)),o.initialize=function(t){e=t,a()},o.strength=function(t){return arguments.length?(i="function"==typeof t?t:fu(+t),a(),o):i},o.y=function(e){return arguments.length?(t="function"==typeof e?e:fu(+e),a(),o):t},o},Bu=function(t,e){if((n=(t=e?t.toExponential(e-1):t.toExponential()).indexOf("e"))<0)return null;var n,r=t.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+t.slice(n+1)]},Lu=function(t){return(t=Bu(Math.abs(t)))?t[1]:NaN},Pu=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function Fu(t){if(!(e=Pu.exec(t)))throw new Error("invalid format: "+t);var e;return new qu({fill:e[1],align:e[2],sign:e[3],symbol:e[4],zero:e[5],width:e[6],comma:e[7],precision:e[8]&&e[8].slice(1),trim:e[9],type:e[10]})}function qu(t){this.fill=void 0===t.fill?" ":t.fill+"",this.align=void 0===t.align?">":t.align+"",this.sign=void 0===t.sign?"-":t.sign+"",this.symbol=void 0===t.symbol?"":t.symbol+"",this.zero=!!t.zero,this.width=void 0===t.width?void 0:+t.width,this.comma=!!t.comma,this.precision=void 0===t.precision?void 0:+t.precision,this.trim=!!t.trim,this.type=void 0===t.type?"":t.type+""}Fu.prototype=qu.prototype,qu.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var ju,Uu,zu,Yu,Vu=function(t){t:for(var e,n=t.length,r=1,i=-1;r<n;++r)switch(t[r]){case".":i=e=r;break;case"0":0===i&&(i=r),e=r;break;default:if(i>0){if(!+t[r])break t;i=0}}return i>0?t.slice(0,i)+t.slice(e+1):t},Hu=function(t,e){var n=Bu(t,e);if(!n)return t+"";var r=n[0],i=n[1];return i<0?"0."+new Array(-i).join("0")+r:r.length>i+1?r.slice(0,i+1)+"."+r.slice(i+1):r+new Array(i-r.length+2).join("0")},$u={"%":function(t,e){return(100*t).toFixed(e)},b:function(t){return Math.round(t).toString(2)},c:function(t){return t+""},d:function(t){return Math.round(t).toString(10)},e:function(t,e){return t.toExponential(e)},f:function(t,e){return t.toFixed(e)},g:function(t,e){return t.toPrecision(e)},o:function(t){return Math.round(t).toString(8)},p:function(t,e){return Hu(100*t,e)},r:Hu,s:function(t,e){var n=Bu(t,e);if(!n)return t+"";var r=n[0],i=n[1],o=i-(ju=3*Math.max(-8,Math.min(8,Math.floor(i/3))))+1,a=r.length;return o===a?r:o>a?r+new Array(o-a+1).join("0"):o>0?r.slice(0,o)+"."+r.slice(o):"0."+new Array(1-o).join("0")+Bu(t,Math.max(0,e+o-1))[0]},X:function(t){return Math.round(t).toString(16).toUpperCase()},x:function(t){return Math.round(t).toString(16)}},Gu=function(t){return t},Wu=Array.prototype.map,Ku=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"],Xu=function(t){var e,n,r=void 0===t.grouping||void 0===t.thousands?Gu:(e=Wu.call(t.grouping,Number),n=t.thousands+"",function(t,r){for(var i=t.length,o=[],a=0,s=e[0],u=0;i>0&&s>0&&(u+s+1>r&&(s=Math.max(1,r-u)),o.push(t.substring(i-=s,i+s)),!((u+=s+1)>r));)s=e[a=(a+1)%e.length];return o.reverse().join(n)}),i=void 0===t.currency?"":t.currency[0]+"",o=void 0===t.currency?"":t.currency[1]+"",a=void 0===t.decimal?".":t.decimal+"",s=void 0===t.numerals?Gu:function(t){return function(e){return e.replace(/[0-9]/g,(function(e){return t[+e]}))}}(Wu.call(t.numerals,String)),u=void 0===t.percent?"%":t.percent+"",c=void 0===t.minus?"-":t.minus+"",f=void 0===t.nan?"NaN":t.nan+"";function l(t){var e=(t=Fu(t)).fill,n=t.align,l=t.sign,h=t.symbol,d=t.zero,p=t.width,g=t.comma,y=t.precision,b=t.trim,m=t.type;"n"===m?(g=!0,m="g"):$u[m]||(void 0===y&&(y=12),b=!0,m="g"),(d||"0"===e&&"="===n)&&(d=!0,e="0",n="=");var v="$"===h?i:"#"===h&&/[boxX]/.test(m)?"0"+m.toLowerCase():"",_="$"===h?o:/[%p]/.test(m)?u:"",w=$u[m],x=/[defgprs%]/.test(m);function k(t){var i,o,u,h=v,k=_;if("c"===m)k=w(t)+k,t="";else{var E=(t=+t)<0;if(t=isNaN(t)?f:w(Math.abs(t),y),b&&(t=Vu(t)),E&&0==+t&&(E=!1),h=(E?"("===l?l:c:"-"===l||"("===l?"":l)+h,k=("s"===m?Ku[8+ju/3]:"")+k+(E&&"("===l?")":""),x)for(i=-1,o=t.length;++i<o;)if(48>(u=t.charCodeAt(i))||u>57){k=(46===u?a+t.slice(i+1):t.slice(i))+k,t=t.slice(0,i);break}}g&&!d&&(t=r(t,1/0));var A=h.length+t.length+k.length,S=A<p?new Array(p-A+1).join(e):"";switch(g&&d&&(t=r(S+t,S.length?p-k.length:1/0),S=""),n){case"<":t=h+t+k+S;break;case"=":t=h+S+t+k;break;case"^":t=S.slice(0,A=S.length>>1)+h+t+k+S.slice(A);break;default:t=S+h+t+k}return s(t)}return y=void 0===y?6:/[gprs]/.test(m)?Math.max(1,Math.min(21,y)):Math.max(0,Math.min(20,y)),k.toString=function(){return t+""},k}return{format:l,formatPrefix:function(t,e){var n=l(((t=Fu(t)).type="f",t)),r=3*Math.max(-8,Math.min(8,Math.floor(Lu(e)/3))),i=Math.pow(10,-r),o=Ku[8+r/3];return function(t){return n(i*t)+o}}}};function Zu(t){return Uu=Xu(t),zu=Uu.format,Yu=Uu.formatPrefix,Uu}Zu({decimal:".",thousands:",",grouping:[3],currency:["$",""],minus:"-"});var Ju=function(t){return Math.max(0,-Lu(Math.abs(t)))},Qu=function(t,e){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(Lu(e)/3)))-Lu(Math.abs(t)))},tc=function(t,e){return t=Math.abs(t),e=Math.abs(e)-t,Math.max(0,Lu(e)-Lu(t))+1},ec=function(){return new nc};function nc(){this.reset()}nc.prototype={constructor:nc,reset:function(){this.s=this.t=0},add:function(t){ic(rc,t,this.t),ic(this,rc.s,this.s),this.s?this.t+=rc.t:this.s=rc.t},valueOf:function(){return this.s}};var rc=new nc;function ic(t,e,n){var r=t.s=e+n,i=r-e,o=r-i;t.t=e-o+(n-i)}var oc=1e-6,ac=1e-12,sc=Math.PI,uc=sc/2,cc=sc/4,fc=2*sc,lc=180/sc,hc=sc/180,dc=Math.abs,pc=Math.atan,gc=Math.atan2,yc=Math.cos,bc=Math.ceil,mc=Math.exp,vc=(Math.floor,Math.log),_c=Math.pow,wc=Math.sin,xc=Math.sign||function(t){return t>0?1:t<0?-1:0},kc=Math.sqrt,Ec=Math.tan;function Ac(t){return t>1?0:t<-1?sc:Math.acos(t)}function Sc(t){return t>1?uc:t<-1?-uc:Math.asin(t)}function Tc(t){return(t=wc(t/2))*t}function Mc(){}function Dc(t,e){t&&Oc.hasOwnProperty(t.type)&&Oc[t.type](t,e)}var Cc={Feature:function(t,e){Dc(t.geometry,e)},FeatureCollection:function(t,e){for(var n=t.features,r=-1,i=n.length;++r<i;)Dc(n[r].geometry,e)}},Oc={Sphere:function(t,e){e.sphere()},Point:function(t,e){t=t.coordinates,e.point(t[0],t[1],t[2])},MultiPoint:function(t,e){for(var n=t.coordinates,r=-1,i=n.length;++r<i;)t=n[r],e.point(t[0],t[1],t[2])},LineString:function(t,e){Rc(t.coordinates,e,0)},MultiLineString:function(t,e){for(var n=t.coordinates,r=-1,i=n.length;++r<i;)Rc(n[r],e,0)},Polygon:function(t,e){Ic(t.coordinates,e)},MultiPolygon:function(t,e){for(var n=t.coordinates,r=-1,i=n.length;++r<i;)Ic(n[r],e)},GeometryCollection:function(t,e){for(var n=t.geometries,r=-1,i=n.length;++r<i;)Dc(n[r],e)}};function Rc(t,e,n){var r,i=-1,o=t.length-n;for(e.lineStart();++i<o;)r=t[i],e.point(r[0],r[1],r[2]);e.lineEnd()}function Ic(t,e){var n=-1,r=t.length;for(e.polygonStart();++n<r;)Rc(t[n],e,1);e.polygonEnd()}var Nc,Bc,Lc,Pc,Fc,qc=function(t,e){t&&Cc.hasOwnProperty(t.type)?Cc[t.type](t,e):Dc(t,e)},jc=ec(),Uc=ec(),zc={point:Mc,lineStart:Mc,lineEnd:Mc,polygonStart:function(){jc.reset(),zc.lineStart=Yc,zc.lineEnd=Vc},polygonEnd:function(){var t=+jc;Uc.add(t<0?fc+t:t),this.lineStart=this.lineEnd=this.point=Mc},sphere:function(){Uc.add(fc)}};function Yc(){zc.point=Hc}function Vc(){$c(Nc,Bc)}function Hc(t,e){zc.point=$c,Nc=t,Bc=e,Lc=t*=hc,Pc=yc(e=(e*=hc)/2+cc),Fc=wc(e)}function $c(t,e){var n=(t*=hc)-Lc,r=n>=0?1:-1,i=r*n,o=yc(e=(e*=hc)/2+cc),a=wc(e),s=Fc*a,u=Pc*o+s*yc(i),c=s*r*wc(i);jc.add(gc(c,u)),Lc=t,Pc=o,Fc=a}var Gc=function(t){return Uc.reset(),qc(t,zc),2*Uc};function Wc(t){return[gc(t[1],t[0]),Sc(t[2])]}function Kc(t){var e=t[0],n=t[1],r=yc(n);return[r*yc(e),r*wc(e),wc(n)]}function Xc(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function Zc(t,e){return[t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]]}function Jc(t,e){t[0]+=e[0],t[1]+=e[1],t[2]+=e[2]}function Qc(t,e){return[t[0]*e,t[1]*e,t[2]*e]}function tf(t){var e=kc(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);t[0]/=e,t[1]/=e,t[2]/=e}var ef,nf,rf,of,af,sf,uf,cf,ff,lf,hf=ec(),df={point:pf,lineStart:yf,lineEnd:bf,polygonStart:function(){df.point=mf,df.lineStart=vf,df.lineEnd=_f,hf.reset(),zc.polygonStart()},polygonEnd:function(){zc.polygonEnd(),df.point=pf,df.lineStart=yf,df.lineEnd=bf,jc<0?(ef=-(rf=180),nf=-(of=90)):hf>oc?of=90:hf<-oc&&(nf=-90),lf[0]=ef,lf[1]=rf},sphere:function(){ef=-(rf=180),nf=-(of=90)}};function pf(t,e){ff.push(lf=[ef=t,rf=t]),e<nf&&(nf=e),e>of&&(of=e)}function gf(t,e){var n=Kc([t*hc,e*hc]);if(cf){var r=Zc(cf,n),i=Zc([r[1],-r[0],0],r);tf(i),i=Wc(i);var o,a=t-af,s=a>0?1:-1,u=i[0]*lc*s,c=dc(a)>180;c^(s*af<u&&u<s*t)?(o=i[1]*lc)>of&&(of=o):c^(s*af<(u=(u+360)%360-180)&&u<s*t)?(o=-i[1]*lc)<nf&&(nf=o):(e<nf&&(nf=e),e>of&&(of=e)),c?t<af?wf(ef,t)>wf(ef,rf)&&(rf=t):wf(t,rf)>wf(ef,rf)&&(ef=t):rf>=ef?(t<ef&&(ef=t),t>rf&&(rf=t)):t>af?wf(ef,t)>wf(ef,rf)&&(rf=t):wf(t,rf)>wf(ef,rf)&&(ef=t)}else ff.push(lf=[ef=t,rf=t]);e<nf&&(nf=e),e>of&&(of=e),cf=n,af=t}function yf(){df.point=gf}function bf(){lf[0]=ef,lf[1]=rf,df.point=pf,cf=null}function mf(t,e){if(cf){var n=t-af;hf.add(dc(n)>180?n+(n>0?360:-360):n)}else sf=t,uf=e;zc.point(t,e),gf(t,e)}function vf(){zc.lineStart()}function _f(){mf(sf,uf),zc.lineEnd(),dc(hf)>oc&&(ef=-(rf=180)),lf[0]=ef,lf[1]=rf,cf=null}function wf(t,e){return(e-=t)<0?e+360:e}function xf(t,e){return t[0]-e[0]}function kf(t,e){return t[0]<=t[1]?t[0]<=e&&e<=t[1]:e<t[0]||t[1]<e}var Ef,Af,Sf,Tf,Mf,Df,Cf,Of,Rf,If,Nf,Bf,Lf,Pf,Ff,qf,jf=function(t){var e,n,r,i,o,a,s;if(of=rf=-(ef=nf=1/0),ff=[],qc(t,df),n=ff.length){for(ff.sort(xf),e=1,o=[r=ff[0]];e<n;++e)kf(r,(i=ff[e])[0])||kf(r,i[1])?(wf(r[0],i[1])>wf(r[0],r[1])&&(r[1]=i[1]),wf(i[0],r[1])>wf(r[0],r[1])&&(r[0]=i[0])):o.push(r=i);for(a=-1/0,e=0,r=o[n=o.length-1];e<=n;r=i,++e)i=o[e],(s=wf(r[1],i[0]))>a&&(a=s,ef=i[0],rf=r[1])}return ff=lf=null,ef===1/0||nf===1/0?[[NaN,NaN],[NaN,NaN]]:[[ef,nf],[rf,of]]},Uf={sphere:Mc,point:zf,lineStart:Vf,lineEnd:Gf,polygonStart:function(){Uf.lineStart=Wf,Uf.lineEnd=Kf},polygonEnd:function(){Uf.lineStart=Vf,Uf.lineEnd=Gf}};function zf(t,e){t*=hc;var n=yc(e*=hc);Yf(n*yc(t),n*wc(t),wc(e))}function Yf(t,e,n){Sf+=(t-Sf)/++Ef,Tf+=(e-Tf)/Ef,Mf+=(n-Mf)/Ef}function Vf(){Uf.point=Hf}function Hf(t,e){t*=hc;var n=yc(e*=hc);Pf=n*yc(t),Ff=n*wc(t),qf=wc(e),Uf.point=$f,Yf(Pf,Ff,qf)}function $f(t,e){t*=hc;var n=yc(e*=hc),r=n*yc(t),i=n*wc(t),o=wc(e),a=gc(kc((a=Ff*o-qf*i)*a+(a=qf*r-Pf*o)*a+(a=Pf*i-Ff*r)*a),Pf*r+Ff*i+qf*o);Af+=a,Df+=a*(Pf+(Pf=r)),Cf+=a*(Ff+(Ff=i)),Of+=a*(qf+(qf=o)),Yf(Pf,Ff,qf)}function Gf(){Uf.point=zf}function Wf(){Uf.point=Xf}function Kf(){Zf(Bf,Lf),Uf.point=zf}function Xf(t,e){Bf=t,Lf=e,t*=hc,e*=hc,Uf.point=Zf;var n=yc(e);Pf=n*yc(t),Ff=n*wc(t),qf=wc(e),Yf(Pf,Ff,qf)}function Zf(t,e){t*=hc;var n=yc(e*=hc),r=n*yc(t),i=n*wc(t),o=wc(e),a=Ff*o-qf*i,s=qf*r-Pf*o,u=Pf*i-Ff*r,c=kc(a*a+s*s+u*u),f=Sc(c),l=c&&-f/c;Rf+=l*a,If+=l*s,Nf+=l*u,Af+=f,Df+=f*(Pf+(Pf=r)),Cf+=f*(Ff+(Ff=i)),Of+=f*(qf+(qf=o)),Yf(Pf,Ff,qf)}var Jf=function(t){Ef=Af=Sf=Tf=Mf=Df=Cf=Of=Rf=If=Nf=0,qc(t,Uf);var e=Rf,n=If,r=Nf,i=e*e+n*n+r*r;return i<ac&&(e=Df,n=Cf,r=Of,Af<oc&&(e=Sf,n=Tf,r=Mf),(i=e*e+n*n+r*r)<ac)?[NaN,NaN]:[gc(n,e)*lc,Sc(r/kc(i))*lc]},Qf=function(t){return function(){return t}},tl=function(t,e){function n(n,r){return n=t(n,r),e(n[0],n[1])}return t.invert&&e.invert&&(n.invert=function(n,r){return(n=e.invert(n,r))&&t.invert(n[0],n[1])}),n};function el(t,e){return[dc(t)>sc?t+Math.round(-t/fc)*fc:t,e]}function nl(t,e,n){return(t%=fc)?e||n?tl(il(t),ol(e,n)):il(t):e||n?ol(e,n):el}function rl(t){return function(e,n){return[(e+=t)>sc?e-fc:e<-sc?e+fc:e,n]}}function il(t){var e=rl(t);return e.invert=rl(-t),e}function ol(t,e){var n=yc(t),r=wc(t),i=yc(e),o=wc(e);function a(t,e){var a=yc(e),s=yc(t)*a,u=wc(t)*a,c=wc(e),f=c*n+s*r;return[gc(u*i-f*o,s*n-c*r),Sc(f*i+u*o)]}return a.invert=function(t,e){var a=yc(e),s=yc(t)*a,u=wc(t)*a,c=wc(e),f=c*i-u*o;return[gc(u*i+c*o,s*n+f*r),Sc(f*n-s*r)]},a}el.invert=el;var al=function(t){function e(e){return(e=t(e[0]*hc,e[1]*hc))[0]*=lc,e[1]*=lc,e}return t=nl(t[0]*hc,t[1]*hc,t.length>2?t[2]*hc:0),e.invert=function(e){return(e=t.invert(e[0]*hc,e[1]*hc))[0]*=lc,e[1]*=lc,e},e};function sl(t,e,n,r,i,o){if(n){var a=yc(e),s=wc(e),u=r*n;null==i?(i=e+r*fc,o=e-u/2):(i=ul(a,i),o=ul(a,o),(r>0?i<o:i>o)&&(i+=r*fc));for(var c,f=i;r>0?f>o:f<o;f-=u)c=Wc([a,-s*yc(f),-s*wc(f)]),t.point(c[0],c[1])}}function ul(t,e){(e=Kc(e))[0]-=t,tf(e);var n=Ac(-e[1]);return((-e[2]<0?-n:n)+fc-oc)%fc}var cl=function(){var t,e,n=Qf([0,0]),r=Qf(90),i=Qf(6),o={point:function(n,r){t.push(n=e(n,r)),n[0]*=lc,n[1]*=lc}};function a(){var a=n.apply(this,arguments),s=r.apply(this,arguments)*hc,u=i.apply(this,arguments)*hc;return t=[],e=nl(-a[0]*hc,-a[1]*hc,0).invert,sl(o,s,u,1),a={type:"Polygon",coordinates:[t]},t=e=null,a}return a.center=function(t){return arguments.length?(n="function"==typeof t?t:Qf([+t[0],+t[1]]),a):n},a.radius=function(t){return arguments.length?(r="function"==typeof t?t:Qf(+t),a):r},a.precision=function(t){return arguments.length?(i="function"==typeof t?t:Qf(+t),a):i},a},fl=function(){var t,e=[];return{point:function(e,n){t.push([e,n])},lineStart:function(){e.push(t=[])},lineEnd:Mc,rejoin:function(){e.length>1&&e.push(e.pop().concat(e.shift()))},result:function(){var n=e;return e=[],t=null,n}}},ll=function(t,e){return dc(t[0]-e[0])<oc&&dc(t[1]-e[1])<oc};function hl(t,e,n,r){this.x=t,this.z=e,this.o=n,this.e=r,this.v=!1,this.n=this.p=null}var dl=function(t,e,n,r,i){var o,a,s=[],u=[];if(t.forEach((function(t){if(!((e=t.length-1)<=0)){var e,n,r=t[0],a=t[e];if(ll(r,a)){for(i.lineStart(),o=0;o<e;++o)i.point((r=t[o])[0],r[1]);i.lineEnd()}else s.push(n=new hl(r,t,null,!0)),u.push(n.o=new hl(r,null,n,!1)),s.push(n=new hl(a,t,null,!1)),u.push(n.o=new hl(a,null,n,!0))}})),s.length){for(u.sort(e),pl(s),pl(u),o=0,a=u.length;o<a;++o)u[o].e=n=!n;for(var c,f,l=s[0];;){for(var h=l,d=!0;h.v;)if((h=h.n)===l)return;c=h.z,i.lineStart();do{if(h.v=h.o.v=!0,h.e){if(d)for(o=0,a=c.length;o<a;++o)i.point((f=c[o])[0],f[1]);else r(h.x,h.n.x,1,i);h=h.n}else{if(d)for(c=h.p.z,o=c.length-1;o>=0;--o)i.point((f=c[o])[0],f[1]);else r(h.x,h.p.x,-1,i);h=h.p}c=(h=h.o).z,d=!d}while(!h.v);i.lineEnd()}}};function pl(t){if(e=t.length){for(var e,n,r=0,i=t[0];++r<e;)i.n=n=t[r],n.p=i,i=n;i.n=n=t[0],n.p=i}}var gl=ec();function yl(t){return dc(t[0])<=sc?t[0]:xc(t[0])*((dc(t[0])+sc)%fc-sc)}var bl=function(t,e){var n=yl(e),r=e[1],i=wc(r),o=[wc(n),-yc(n),0],a=0,s=0;gl.reset(),1===i?r=uc+oc:-1===i&&(r=-uc-oc);for(var u=0,c=t.length;u<c;++u)if(l=(f=t[u]).length)for(var f,l,h=f[l-1],d=yl(h),p=h[1]/2+cc,g=wc(p),y=yc(p),b=0;b<l;++b,d=v,g=w,y=x,h=m){var m=f[b],v=yl(m),_=m[1]/2+cc,w=wc(_),x=yc(_),k=v-d,E=k>=0?1:-1,A=E*k,S=A>sc,T=g*w;if(gl.add(gc(T*E*wc(A),y*x+T*yc(A))),a+=S?k+E*fc:k,S^d>=n^v>=n){var M=Zc(Kc(h),Kc(m));tf(M);var D=Zc(o,M);tf(D);var C=(S^k>=0?-1:1)*Sc(D[2]);(r>C||r===C&&(M[0]||M[1]))&&(s+=S^k>=0?1:-1)}}return(a<-oc||a<oc&&gl<-oc)^1&s},ml=function(t,e,n,r){return function(i){var o,a,s,u=e(i),c=fl(),f=e(c),l=!1,h={point:d,lineStart:g,lineEnd:y,polygonStart:function(){h.point=b,h.lineStart=m,h.lineEnd=v,a=[],o=[]},polygonEnd:function(){h.point=d,h.lineStart=g,h.lineEnd=y,a=P(a);var t=bl(o,r);a.length?(l||(i.polygonStart(),l=!0),dl(a,_l,t,n,i)):t&&(l||(i.polygonStart(),l=!0),i.lineStart(),n(null,null,1,i),i.lineEnd()),l&&(i.polygonEnd(),l=!1),a=o=null},sphere:function(){i.polygonStart(),i.lineStart(),n(null,null,1,i),i.lineEnd(),i.polygonEnd()}};function d(e,n){t(e,n)&&i.point(e,n)}function p(t,e){u.point(t,e)}function g(){h.point=p,u.lineStart()}function y(){h.point=d,u.lineEnd()}function b(t,e){s.push([t,e]),f.point(t,e)}function m(){f.lineStart(),s=[]}function v(){b(s[0][0],s[0][1]),f.lineEnd();var t,e,n,r,u=f.clean(),h=c.result(),d=h.length;if(s.pop(),o.push(s),s=null,d)if(1&u){if((e=(n=h[0]).length-1)>0){for(l||(i.polygonStart(),l=!0),i.lineStart(),t=0;t<e;++t)i.point((r=n[t])[0],r[1]);i.lineEnd()}}else d>1&&2&u&&h.push(h.pop().concat(h.shift())),a.push(h.filter(vl))}return h}};function vl(t){return t.length>1}function _l(t,e){return((t=t.x)[0]<0?t[1]-uc-oc:uc-t[1])-((e=e.x)[0]<0?e[1]-uc-oc:uc-e[1])}var wl=ml((function(){return!0}),(function(t){var e,n=NaN,r=NaN,i=NaN;return{lineStart:function(){t.lineStart(),e=1},point:function(o,a){var s=o>0?sc:-sc,u=dc(o-n);dc(u-sc)<oc?(t.point(n,r=(r+a)/2>0?uc:-uc),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(s,r),t.point(o,r),e=0):i!==s&&u>=sc&&(dc(n-i)<oc&&(n-=i*oc),dc(o-s)<oc&&(o-=s*oc),r=function(t,e,n,r){var i,o,a=wc(t-n);return dc(a)>oc?pc((wc(e)*(o=yc(r))*wc(n)-wc(r)*(i=yc(e))*wc(t))/(i*o*a)):(e+r)/2}(n,r,o,a),t.point(i,r),t.lineEnd(),t.lineStart(),t.point(s,r),e=0),t.point(n=o,r=a),i=s},lineEnd:function(){t.lineEnd(),n=r=NaN},clean:function(){return 2-e}}}),(function(t,e,n,r){var i;if(null==t)i=n*uc,r.point(-sc,i),r.point(0,i),r.point(sc,i),r.point(sc,0),r.point(sc,-i),r.point(0,-i),r.point(-sc,-i),r.point(-sc,0),r.point(-sc,i);else if(dc(t[0]-e[0])>oc){var o=t[0]<e[0]?sc:-sc;i=n*o/2,r.point(-o,i),r.point(0,i),r.point(o,i)}else r.point(e[0],e[1])}),[-sc,-uc]);var xl=function(t){var e=yc(t),n=6*hc,r=e>0,i=dc(e)>oc;function o(t,n){return yc(t)*yc(n)>e}function a(t,n,r){var i=[1,0,0],o=Zc(Kc(t),Kc(n)),a=Xc(o,o),s=o[0],u=a-s*s;if(!u)return!r&&t;var c=e*a/u,f=-e*s/u,l=Zc(i,o),h=Qc(i,c);Jc(h,Qc(o,f));var d=l,p=Xc(h,d),g=Xc(d,d),y=p*p-g*(Xc(h,h)-1);if(!(y<0)){var b=kc(y),m=Qc(d,(-p-b)/g);if(Jc(m,h),m=Wc(m),!r)return m;var v,_=t[0],w=n[0],x=t[1],k=n[1];w<_&&(v=_,_=w,w=v);var E=w-_,A=dc(E-sc)<oc;if(!A&&k<x&&(v=x,x=k,k=v),A||E<oc?A?x+k>0^m[1]<(dc(m[0]-_)<oc?x:k):x<=m[1]&&m[1]<=k:E>sc^(_<=m[0]&&m[0]<=w)){var S=Qc(d,(-p+b)/g);return Jc(S,h),[m,Wc(S)]}}}function s(e,n){var i=r?t:sc-t,o=0;return e<-i?o|=1:e>i&&(o|=2),n<-i?o|=4:n>i&&(o|=8),o}return ml(o,(function(t){var e,n,u,c,f;return{lineStart:function(){c=u=!1,f=1},point:function(l,h){var d,p=[l,h],g=o(l,h),y=r?g?0:s(l,h):g?s(l+(l<0?sc:-sc),h):0;if(!e&&(c=u=g)&&t.lineStart(),g!==u&&(!(d=a(e,p))||ll(e,d)||ll(p,d))&&(p[0]+=oc,p[1]+=oc,g=o(p[0],p[1])),g!==u)f=0,g?(t.lineStart(),d=a(p,e),t.point(d[0],d[1])):(d=a(e,p),t.point(d[0],d[1]),t.lineEnd()),e=d;else if(i&&e&&r^g){var b;y&n||!(b=a(p,e,!0))||(f=0,r?(t.lineStart(),t.point(b[0][0],b[0][1]),t.point(b[1][0],b[1][1]),t.lineEnd()):(t.point(b[1][0],b[1][1]),t.lineEnd(),t.lineStart(),t.point(b[0][0],b[0][1])))}!g||e&&ll(e,p)||t.point(p[0],p[1]),e=p,u=g,n=y},lineEnd:function(){u&&t.lineEnd(),e=null},clean:function(){return f|(c&&u)<<1}}}),(function(e,r,i,o){sl(o,t,n,i,e,r)}),r?[0,-t]:[-sc,t-sc])},kl=function(t,e,n,r,i,o){var a,s=t[0],u=t[1],c=0,f=1,l=e[0]-s,h=e[1]-u;if(a=n-s,l||!(a>0)){if(a/=l,l<0){if(a<c)return;a<f&&(f=a)}else if(l>0){if(a>f)return;a>c&&(c=a)}if(a=i-s,l||!(a<0)){if(a/=l,l<0){if(a>f)return;a>c&&(c=a)}else if(l>0){if(a<c)return;a<f&&(f=a)}if(a=r-u,h||!(a>0)){if(a/=h,h<0){if(a<c)return;a<f&&(f=a)}else if(h>0){if(a>f)return;a>c&&(c=a)}if(a=o-u,h||!(a<0)){if(a/=h,h<0){if(a>f)return;a>c&&(c=a)}else if(h>0){if(a<c)return;a<f&&(f=a)}return c>0&&(t[0]=s+c*l,t[1]=u+c*h),f<1&&(e[0]=s+f*l,e[1]=u+f*h),!0}}}}},El=1e9,Al=-El;function Sl(t,e,n,r){function i(i,o){return t<=i&&i<=n&&e<=o&&o<=r}function o(i,o,s,c){var f=0,l=0;if(null==i||(f=a(i,s))!==(l=a(o,s))||u(i,o)<0^s>0)do{c.point(0===f||3===f?t:n,f>1?r:e)}while((f=(f+s+4)%4)!==l);else c.point(o[0],o[1])}function a(r,i){return dc(r[0]-t)<oc?i>0?0:3:dc(r[0]-n)<oc?i>0?2:1:dc(r[1]-e)<oc?i>0?1:0:i>0?3:2}function s(t,e){return u(t.x,e.x)}function u(t,e){var n=a(t,1),r=a(e,1);return n!==r?n-r:0===n?e[1]-t[1]:1===n?t[0]-e[0]:2===n?t[1]-e[1]:e[0]-t[0]}return function(a){var u,c,f,l,h,d,p,g,y,b,m,v=a,_=fl(),w={point:x,lineStart:function(){w.point=k,c&&c.push(f=[]);b=!0,y=!1,p=g=NaN},lineEnd:function(){u&&(k(l,h),d&&y&&_.rejoin(),u.push(_.result()));w.point=x,y&&v.lineEnd()},polygonStart:function(){v=_,u=[],c=[],m=!0},polygonEnd:function(){var e=function(){for(var e=0,n=0,i=c.length;n<i;++n)for(var o,a,s=c[n],u=1,f=s.length,l=s[0],h=l[0],d=l[1];u<f;++u)o=h,a=d,l=s[u],h=l[0],d=l[1],a<=r?d>r&&(h-o)*(r-a)>(d-a)*(t-o)&&++e:d<=r&&(h-o)*(r-a)<(d-a)*(t-o)&&--e;return e}(),n=m&&e,i=(u=P(u)).length;(n||i)&&(a.polygonStart(),n&&(a.lineStart(),o(null,null,1,a),a.lineEnd()),i&&dl(u,s,e,o,a),a.polygonEnd());v=a,u=c=f=null}};function x(t,e){i(t,e)&&v.point(t,e)}function k(o,a){var s=i(o,a);if(c&&f.push([o,a]),b)l=o,h=a,d=s,b=!1,s&&(v.lineStart(),v.point(o,a));else if(s&&y)v.point(o,a);else{var u=[p=Math.max(Al,Math.min(El,p)),g=Math.max(Al,Math.min(El,g))],_=[o=Math.max(Al,Math.min(El,o)),a=Math.max(Al,Math.min(El,a))];kl(u,_,t,e,n,r)?(y||(v.lineStart(),v.point(u[0],u[1])),v.point(_[0],_[1]),s||v.lineEnd(),m=!1):s&&(v.lineStart(),v.point(o,a),m=!1)}p=o,g=a,y=s}return w}}var Tl,Ml,Dl,Cl=function(){var t,e,n,r=0,i=0,o=960,a=500;return n={stream:function(n){return t&&e===n?t:t=Sl(r,i,o,a)(e=n)},extent:function(s){return arguments.length?(r=+s[0][0],i=+s[0][1],o=+s[1][0],a=+s[1][1],t=e=null,n):[[r,i],[o,a]]}}},Ol=ec(),Rl={sphere:Mc,point:Mc,lineStart:function(){Rl.point=Nl,Rl.lineEnd=Il},lineEnd:Mc,polygonStart:Mc,polygonEnd:Mc};function Il(){Rl.point=Rl.lineEnd=Mc}function Nl(t,e){Tl=t*=hc,Ml=wc(e*=hc),Dl=yc(e),Rl.point=Bl}function Bl(t,e){t*=hc;var n=wc(e*=hc),r=yc(e),i=dc(t-Tl),o=yc(i),a=r*wc(i),s=Dl*n-Ml*r*o,u=Ml*n+Dl*r*o;Ol.add(gc(kc(a*a+s*s),u)),Tl=t,Ml=n,Dl=r}var Ll=function(t){return Ol.reset(),qc(t,Rl),+Ol},Pl=[null,null],Fl={type:"LineString",coordinates:Pl},ql=function(t,e){return Pl[0]=t,Pl[1]=e,Ll(Fl)},jl={Feature:function(t,e){return zl(t.geometry,e)},FeatureCollection:function(t,e){for(var n=t.features,r=-1,i=n.length;++r<i;)if(zl(n[r].geometry,e))return!0;return!1}},Ul={Sphere:function(){return!0},Point:function(t,e){return Yl(t.coordinates,e)},MultiPoint:function(t,e){for(var n=t.coordinates,r=-1,i=n.length;++r<i;)if(Yl(n[r],e))return!0;return!1},LineString:function(t,e){return Vl(t.coordinates,e)},MultiLineString:function(t,e){for(var n=t.coordinates,r=-1,i=n.length;++r<i;)if(Vl(n[r],e))return!0;return!1},Polygon:function(t,e){return Hl(t.coordinates,e)},MultiPolygon:function(t,e){for(var n=t.coordinates,r=-1,i=n.length;++r<i;)if(Hl(n[r],e))return!0;return!1},GeometryCollection:function(t,e){for(var n=t.geometries,r=-1,i=n.length;++r<i;)if(zl(n[r],e))return!0;return!1}};function zl(t,e){return!(!t||!Ul.hasOwnProperty(t.type))&&Ul[t.type](t,e)}function Yl(t,e){return 0===ql(t,e)}function Vl(t,e){for(var n,r,i,o=0,a=t.length;o<a;o++){if(0===(r=ql(t[o],e)))return!0;if(o>0&&(i=ql(t[o],t[o-1]))>0&&n<=i&&r<=i&&(n+r-i)*(1-Math.pow((n-r)/i,2))<ac*i)return!0;n=r}return!1}function Hl(t,e){return!!bl(t.map($l),Gl(e))}function $l(t){return(t=t.map(Gl)).pop(),t}function Gl(t){return[t[0]*hc,t[1]*hc]}var Wl=function(t,e){return(t&&jl.hasOwnProperty(t.type)?jl[t.type]:zl)(t,e)};function Kl(t,e,n){var r=x(t,e-oc,n).concat(e);return function(t){return r.map((function(e){return[t,e]}))}}function Xl(t,e,n){var r=x(t,e-oc,n).concat(e);return function(t){return r.map((function(e){return[e,t]}))}}function Zl(){var t,e,n,r,i,o,a,s,u,c,f,l,h=10,d=h,p=90,g=360,y=2.5;function b(){return{type:"MultiLineString",coordinates:m()}}function m(){return x(bc(r/p)*p,n,p).map(f).concat(x(bc(s/g)*g,a,g).map(l)).concat(x(bc(e/h)*h,t,h).filter((function(t){return dc(t%p)>oc})).map(u)).concat(x(bc(o/d)*d,i,d).filter((function(t){return dc(t%g)>oc})).map(c))}return b.lines=function(){return m().map((function(t){return{type:"LineString",coordinates:t}}))},b.outline=function(){return{type:"Polygon",coordinates:[f(r).concat(l(a).slice(1),f(n).reverse().slice(1),l(s).reverse().slice(1))]}},b.extent=function(t){return arguments.length?b.extentMajor(t).extentMinor(t):b.extentMinor()},b.extentMajor=function(t){return arguments.length?(r=+t[0][0],n=+t[1][0],s=+t[0][1],a=+t[1][1],r>n&&(t=r,r=n,n=t),s>a&&(t=s,s=a,a=t),b.precision(y)):[[r,s],[n,a]]},b.extentMinor=function(n){return arguments.length?(e=+n[0][0],t=+n[1][0],o=+n[0][1],i=+n[1][1],e>t&&(n=e,e=t,t=n),o>i&&(n=o,o=i,i=n),b.precision(y)):[[e,o],[t,i]]},b.step=function(t){return arguments.length?b.stepMajor(t).stepMinor(t):b.stepMinor()},b.stepMajor=function(t){return arguments.length?(p=+t[0],g=+t[1],b):[p,g]},b.stepMinor=function(t){return arguments.length?(h=+t[0],d=+t[1],b):[h,d]},b.precision=function(h){return arguments.length?(y=+h,u=Kl(o,i,90),c=Xl(e,t,y),f=Kl(s,a,90),l=Xl(r,n,y),b):y},b.extentMajor([[-180,-90+oc],[180,90-oc]]).extentMinor([[-180,-80-oc],[180,80+oc]])}function Jl(){return Zl()()}var Ql,th,eh,nh,rh=function(t,e){var n=t[0]*hc,r=t[1]*hc,i=e[0]*hc,o=e[1]*hc,a=yc(r),s=wc(r),u=yc(o),c=wc(o),f=a*yc(n),l=a*wc(n),h=u*yc(i),d=u*wc(i),p=2*Sc(kc(Tc(o-r)+a*u*Tc(i-n))),g=wc(p),y=p?function(t){var e=wc(t*=p)/g,n=wc(p-t)/g,r=n*f+e*h,i=n*l+e*d,o=n*s+e*c;return[gc(i,r)*lc,gc(o,kc(r*r+i*i))*lc]}:function(){return[n*lc,r*lc]};return y.distance=p,y},ih=function(t){return t},oh=ec(),ah=ec(),sh={point:Mc,lineStart:Mc,lineEnd:Mc,polygonStart:function(){sh.lineStart=uh,sh.lineEnd=lh},polygonEnd:function(){sh.lineStart=sh.lineEnd=sh.point=Mc,oh.add(dc(ah)),ah.reset()},result:function(){var t=oh/2;return oh.reset(),t}};function uh(){sh.point=ch}function ch(t,e){sh.point=fh,Ql=eh=t,th=nh=e}function fh(t,e){ah.add(nh*t-eh*e),eh=t,nh=e}function lh(){fh(Ql,th)}var hh=sh,dh=1/0,ph=dh,gh=-dh,yh=gh;var bh,mh,vh,_h,wh={point:function(t,e){t<dh&&(dh=t);t>gh&&(gh=t);e<ph&&(ph=e);e>yh&&(yh=e)},lineStart:Mc,lineEnd:Mc,polygonStart:Mc,polygonEnd:Mc,result:function(){var t=[[dh,ph],[gh,yh]];return gh=yh=-(ph=dh=1/0),t}},xh=0,kh=0,Eh=0,Ah=0,Sh=0,Th=0,Mh=0,Dh=0,Ch=0,Oh={point:Rh,lineStart:Ih,lineEnd:Lh,polygonStart:function(){Oh.lineStart=Ph,Oh.lineEnd=Fh},polygonEnd:function(){Oh.point=Rh,Oh.lineStart=Ih,Oh.lineEnd=Lh},result:function(){var t=Ch?[Mh/Ch,Dh/Ch]:Th?[Ah/Th,Sh/Th]:Eh?[xh/Eh,kh/Eh]:[NaN,NaN];return xh=kh=Eh=Ah=Sh=Th=Mh=Dh=Ch=0,t}};function Rh(t,e){xh+=t,kh+=e,++Eh}function Ih(){Oh.point=Nh}function Nh(t,e){Oh.point=Bh,Rh(vh=t,_h=e)}function Bh(t,e){var n=t-vh,r=e-_h,i=kc(n*n+r*r);Ah+=i*(vh+t)/2,Sh+=i*(_h+e)/2,Th+=i,Rh(vh=t,_h=e)}function Lh(){Oh.point=Rh}function Ph(){Oh.point=qh}function Fh(){jh(bh,mh)}function qh(t,e){Oh.point=jh,Rh(bh=vh=t,mh=_h=e)}function jh(t,e){var n=t-vh,r=e-_h,i=kc(n*n+r*r);Ah+=i*(vh+t)/2,Sh+=i*(_h+e)/2,Th+=i,Mh+=(i=_h*t-vh*e)*(vh+t),Dh+=i*(_h+e),Ch+=3*i,Rh(vh=t,_h=e)}var Uh=Oh;function zh(t){this._context=t}zh.prototype={_radius:4.5,pointRadius:function(t){return this._radius=t,this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){0===this._line&&this._context.closePath(),this._point=NaN},point:function(t,e){switch(this._point){case 0:this._context.moveTo(t,e),this._point=1;break;case 1:this._context.lineTo(t,e);break;default:this._context.moveTo(t+this._radius,e),this._context.arc(t,e,this._radius,0,fc)}},result:Mc};var Yh,Vh,Hh,$h,Gh,Wh=ec(),Kh={point:Mc,lineStart:function(){Kh.point=Xh},lineEnd:function(){Yh&&Zh(Vh,Hh),Kh.point=Mc},polygonStart:function(){Yh=!0},polygonEnd:function(){Yh=null},result:function(){var t=+Wh;return Wh.reset(),t}};function Xh(t,e){Kh.point=Zh,Vh=$h=t,Hh=Gh=e}function Zh(t,e){$h-=t,Gh-=e,Wh.add(kc($h*$h+Gh*Gh)),$h=t,Gh=e}var Jh=Kh;function Qh(){this._string=[]}function td(t){return"m0,"+t+"a"+t+","+t+" 0 1,1 0,"+-2*t+"a"+t+","+t+" 0 1,1 0,"+2*t+"z"}Qh.prototype={_radius:4.5,_circle:td(4.5),pointRadius:function(t){return(t=+t)!==this._radius&&(this._radius=t,this._circle=null),this},polygonStart:function(){this._line=0},polygonEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){0===this._line&&this._string.push("Z"),this._point=NaN},point:function(t,e){switch(this._point){case 0:this._string.push("M",t,",",e),this._point=1;break;case 1:this._string.push("L",t,",",e);break;default:null==this._circle&&(this._circle=td(this._radius)),this._string.push("M",t,",",e,this._circle)}},result:function(){if(this._string.length){var t=this._string.join("");return this._string=[],t}return null}};var ed=function(t,e){var n,r,i=4.5;function o(t){return t&&("function"==typeof i&&r.pointRadius(+i.apply(this,arguments)),qc(t,n(r))),r.result()}return o.area=function(t){return qc(t,n(hh)),hh.result()},o.measure=function(t){return qc(t,n(Jh)),Jh.result()},o.bounds=function(t){return qc(t,n(wh)),wh.result()},o.centroid=function(t){return qc(t,n(Uh)),Uh.result()},o.projection=function(e){return arguments.length?(n=null==e?(t=null,ih):(t=e).stream,o):t},o.context=function(t){return arguments.length?(r=null==t?(e=null,new Qh):new zh(e=t),"function"!=typeof i&&r.pointRadius(i),o):e},o.pointRadius=function(t){return arguments.length?(i="function"==typeof t?t:(r.pointRadius(+t),+t),o):i},o.projection(t).context(e)},nd=function(t){return{stream:rd(t)}};function rd(t){return function(e){var n=new id;for(var r in t)n[r]=t[r];return n.stream=e,n}}function id(){}function od(t,e,n){var r=t.clipExtent&&t.clipExtent();return t.scale(150).translate([0,0]),null!=r&&t.clipExtent(null),qc(n,t.stream(wh)),e(wh.result()),null!=r&&t.clipExtent(r),t}function ad(t,e,n){return od(t,(function(n){var r=e[1][0]-e[0][0],i=e[1][1]-e[0][1],o=Math.min(r/(n[1][0]-n[0][0]),i/(n[1][1]-n[0][1])),a=+e[0][0]+(r-o*(n[1][0]+n[0][0]))/2,s=+e[0][1]+(i-o*(n[1][1]+n[0][1]))/2;t.scale(150*o).translate([a,s])}),n)}function sd(t,e,n){return ad(t,[[0,0],e],n)}function ud(t,e,n){return od(t,(function(n){var r=+e,i=r/(n[1][0]-n[0][0]),o=(r-i*(n[1][0]+n[0][0]))/2,a=-i*n[0][1];t.scale(150*i).translate([o,a])}),n)}function cd(t,e,n){return od(t,(function(n){var r=+e,i=r/(n[1][1]-n[0][1]),o=-i*n[0][0],a=(r-i*(n[1][1]+n[0][1]))/2;t.scale(150*i).translate([o,a])}),n)}id.prototype={constructor:id,point:function(t,e){this.stream.point(t,e)},sphere:function(){this.stream.sphere()},lineStart:function(){this.stream.lineStart()},lineEnd:function(){this.stream.lineEnd()},polygonStart:function(){this.stream.polygonStart()},polygonEnd:function(){this.stream.polygonEnd()}};var fd=16,ld=yc(30*hc),hd=function(t,e){return+e?function(t,e){function n(r,i,o,a,s,u,c,f,l,h,d,p,g,y){var b=c-r,m=f-i,v=b*b+m*m;if(v>4*e&&g--){var _=a+h,w=s+d,x=u+p,k=kc(_*_+w*w+x*x),E=Sc(x/=k),A=dc(dc(x)-1)<oc||dc(o-l)<oc?(o+l)/2:gc(w,_),S=t(A,E),T=S[0],M=S[1],D=T-r,C=M-i,O=m*D-b*C;(O*O/v>e||dc((b*D+m*C)/v-.5)>.3||a*h+s*d+u*p<ld)&&(n(r,i,o,a,s,u,T,M,A,_/=k,w/=k,x,g,y),y.point(T,M),n(T,M,A,_,w,x,c,f,l,h,d,p,g,y))}}return function(e){var r,i,o,a,s,u,c,f,l,h,d,p,g={point:y,lineStart:b,lineEnd:v,polygonStart:function(){e.polygonStart(),g.lineStart=_},polygonEnd:function(){e.polygonEnd(),g.lineStart=b}};function y(n,r){n=t(n,r),e.point(n[0],n[1])}function b(){f=NaN,g.point=m,e.lineStart()}function m(r,i){var o=Kc([r,i]),a=t(r,i);n(f,l,c,h,d,p,f=a[0],l=a[1],c=r,h=o[0],d=o[1],p=o[2],fd,e),e.point(f,l)}function v(){g.point=y,e.lineEnd()}function _(){b(),g.point=w,g.lineEnd=x}function w(t,e){m(r=t,e),i=f,o=l,a=h,s=d,u=p,g.point=m}function x(){n(f,l,c,h,d,p,i,o,r,a,s,u,fd,e),g.lineEnd=v,v()}return g}}(t,e):function(t){return rd({point:function(e,n){e=t(e,n),this.stream.point(e[0],e[1])}})}(t)};var dd=rd({point:function(t,e){this.stream.point(t*hc,e*hc)}});function pd(t,e,n){function r(r,i){return[e+t*r,n-t*i]}return r.invert=function(r,i){return[(r-e)/t,(n-i)/t]},r}function gd(t,e,n,r){var i=yc(r),o=wc(r),a=i*t,s=o*t,u=i/t,c=o/t,f=(o*n-i*e)/t,l=(o*e+i*n)/t;function h(t,r){return[a*t-s*r+e,n-s*t-a*r]}return h.invert=function(t,e){return[u*t-c*e+f,l-c*t-u*e]},h}function yd(t){return bd((function(){return t}))()}function bd(t){var e,n,r,i,o,a,s,u,c,f,l=150,h=480,d=250,p=0,g=0,y=0,b=0,m=0,v=0,_=null,w=wl,x=null,k=ih,E=.5;function A(t){return u(t[0]*hc,t[1]*hc)}function S(t){return(t=u.invert(t[0],t[1]))&&[t[0]*lc,t[1]*lc]}function T(){var t=gd(l,0,0,v).apply(null,e(p,g)),r=(v?gd:pd)(l,h-t[0],d-t[1],v);return n=nl(y,b,m),s=tl(e,r),u=tl(n,s),a=hd(s,E),M()}function M(){return c=f=null,A}return A.stream=function(t){return c&&f===t?c:c=dd(function(t){return rd({point:function(e,n){var r=t(e,n);return this.stream.point(r[0],r[1])}})}(n)(w(a(k(f=t)))))},A.preclip=function(t){return arguments.length?(w=t,_=void 0,M()):w},A.postclip=function(t){return arguments.length?(k=t,x=r=i=o=null,M()):k},A.clipAngle=function(t){return arguments.length?(w=+t?xl(_=t*hc):(_=null,wl),M()):_*lc},A.clipExtent=function(t){return arguments.length?(k=null==t?(x=r=i=o=null,ih):Sl(x=+t[0][0],r=+t[0][1],i=+t[1][0],o=+t[1][1]),M()):null==x?null:[[x,r],[i,o]]},A.scale=function(t){return arguments.length?(l=+t,T()):l},A.translate=function(t){return arguments.length?(h=+t[0],d=+t[1],T()):[h,d]},A.center=function(t){return arguments.length?(p=t[0]%360*hc,g=t[1]%360*hc,T()):[p*lc,g*lc]},A.rotate=function(t){return arguments.length?(y=t[0]%360*hc,b=t[1]%360*hc,m=t.length>2?t[2]%360*hc:0,T()):[y*lc,b*lc,m*lc]},A.angle=function(t){return arguments.length?(v=t%360*hc,T()):v*lc},A.precision=function(t){return arguments.length?(a=hd(s,E=t*t),M()):kc(E)},A.fitExtent=function(t,e){return ad(A,t,e)},A.fitSize=function(t,e){return sd(A,t,e)},A.fitWidth=function(t,e){return ud(A,t,e)},A.fitHeight=function(t,e){return cd(A,t,e)},function(){return e=t.apply(this,arguments),A.invert=e.invert&&S,T()}}function md(t){var e=0,n=sc/3,r=bd(t),i=r(e,n);return i.parallels=function(t){return arguments.length?r(e=t[0]*hc,n=t[1]*hc):[e*lc,n*lc]},i}function vd(t,e){var n=wc(t),r=(n+wc(e))/2;if(dc(r)<oc)return function(t){var e=yc(t);function n(t,n){return[t*e,wc(n)/e]}return n.invert=function(t,n){return[t/e,Sc(n*e)]},n}(t);var i=1+n*(2*r-n),o=kc(i)/r;function a(t,e){var n=kc(i-2*r*wc(e))/r;return[n*wc(t*=r),o-n*yc(t)]}return a.invert=function(t,e){var n=o-e;return[gc(t,dc(n))/r*xc(n),Sc((i-(t*t+n*n)*r*r)/(2*r))]},a}var _d=function(){return md(vd).scale(155.424).center([0,33.6442])},wd=function(){return _d().parallels([29.5,45.5]).scale(1070).translate([480,250]).rotate([96,0]).center([-.6,38.7])};var xd=function(){var t,e,n,r,i,o,a=wd(),s=_d().rotate([154,0]).center([-2,58.5]).parallels([55,65]),u=_d().rotate([157,0]).center([-3,19.9]).parallels([8,18]),c={point:function(t,e){o=[t,e]}};function f(t){var e=t[0],a=t[1];return o=null,n.point(e,a),o||(r.point(e,a),o)||(i.point(e,a),o)}function l(){return t=e=null,f}return f.invert=function(t){var e=a.scale(),n=a.translate(),r=(t[0]-n[0])/e,i=(t[1]-n[1])/e;return(i>=.12&&i<.234&&r>=-.425&&r<-.214?s:i>=.166&&i<.234&&r>=-.214&&r<-.115?u:a).invert(t)},f.stream=function(n){return t&&e===n?t:(r=[a.stream(e=n),s.stream(n),u.stream(n)],i=r.length,t={point:function(t,e){for(var n=-1;++n<i;)r[n].point(t,e)},sphere:function(){for(var t=-1;++t<i;)r[t].sphere()},lineStart:function(){for(var t=-1;++t<i;)r[t].lineStart()},lineEnd:function(){for(var t=-1;++t<i;)r[t].lineEnd()},polygonStart:function(){for(var t=-1;++t<i;)r[t].polygonStart()},polygonEnd:function(){for(var t=-1;++t<i;)r[t].polygonEnd()}});var r,i},f.precision=function(t){return arguments.length?(a.precision(t),s.precision(t),u.precision(t),l()):a.precision()},f.scale=function(t){return arguments.length?(a.scale(t),s.scale(.35*t),u.scale(t),f.translate(a.translate())):a.scale()},f.translate=function(t){if(!arguments.length)return a.translate();var e=a.scale(),o=+t[0],f=+t[1];return n=a.translate(t).clipExtent([[o-.455*e,f-.238*e],[o+.455*e,f+.238*e]]).stream(c),r=s.translate([o-.307*e,f+.201*e]).clipExtent([[o-.425*e+oc,f+.12*e+oc],[o-.214*e-oc,f+.234*e-oc]]).stream(c),i=u.translate([o-.205*e,f+.212*e]).clipExtent([[o-.214*e+oc,f+.166*e+oc],[o-.115*e-oc,f+.234*e-oc]]).stream(c),l()},f.fitExtent=function(t,e){return ad(f,t,e)},f.fitSize=function(t,e){return sd(f,t,e)},f.fitWidth=function(t,e){return ud(f,t,e)},f.fitHeight=function(t,e){return cd(f,t,e)},f.scale(1070)};function kd(t){return function(e,n){var r=yc(e),i=yc(n),o=t(r*i);return[o*i*wc(e),o*wc(n)]}}function Ed(t){return function(e,n){var r=kc(e*e+n*n),i=t(r),o=wc(i),a=yc(i);return[gc(e*o,r*a),Sc(r&&n*o/r)]}}var Ad=kd((function(t){return kc(2/(1+t))}));Ad.invert=Ed((function(t){return 2*Sc(t/2)}));var Sd=function(){return yd(Ad).scale(124.75).clipAngle(179.999)},Td=kd((function(t){return(t=Ac(t))&&t/wc(t)}));Td.invert=Ed((function(t){return t}));var Md=function(){return yd(Td).scale(79.4188).clipAngle(179.999)};function Dd(t,e){return[t,vc(Ec((uc+e)/2))]}Dd.invert=function(t,e){return[t,2*pc(mc(e))-uc]};var Cd=function(){return Od(Dd).scale(961/fc)};function Od(t){var e,n,r,i=yd(t),o=i.center,a=i.scale,s=i.translate,u=i.clipExtent,c=null;function f(){var o=sc*a(),s=i(al(i.rotate()).invert([0,0]));return u(null==c?[[s[0]-o,s[1]-o],[s[0]+o,s[1]+o]]:t===Dd?[[Math.max(s[0]-o,c),e],[Math.min(s[0]+o,n),r]]:[[c,Math.max(s[1]-o,e)],[n,Math.min(s[1]+o,r)]])}return i.scale=function(t){return arguments.length?(a(t),f()):a()},i.translate=function(t){return arguments.length?(s(t),f()):s()},i.center=function(t){return arguments.length?(o(t),f()):o()},i.clipExtent=function(t){return arguments.length?(null==t?c=e=n=r=null:(c=+t[0][0],e=+t[0][1],n=+t[1][0],r=+t[1][1]),f()):null==c?null:[[c,e],[n,r]]},f()}function Rd(t){return Ec((uc+t)/2)}function Id(t,e){var n=yc(t),r=t===e?wc(t):vc(n/yc(e))/vc(Rd(e)/Rd(t)),i=n*_c(Rd(t),r)/r;if(!r)return Dd;function o(t,e){i>0?e<-uc+oc&&(e=-uc+oc):e>uc-oc&&(e=uc-oc);var n=i/_c(Rd(e),r);return[n*wc(r*t),i-n*yc(r*t)]}return o.invert=function(t,e){var n=i-e,o=xc(r)*kc(t*t+n*n);return[gc(t,dc(n))/r*xc(n),2*pc(_c(i/o,1/r))-uc]},o}var Nd=function(){return md(Id).scale(109.5).parallels([30,30])};function Bd(t,e){return[t,e]}Bd.invert=Bd;var Ld=function(){return yd(Bd).scale(152.63)};function Pd(t,e){var n=yc(t),r=t===e?wc(t):(n-yc(e))/(e-t),i=n/r+t;if(dc(r)<oc)return Bd;function o(t,e){var n=i-e,o=r*t;return[n*wc(o),i-n*yc(o)]}return o.invert=function(t,e){var n=i-e;return[gc(t,dc(n))/r*xc(n),i-xc(r)*kc(t*t+n*n)]},o}var Fd=function(){return md(Pd).scale(131.154).center([0,13.9389])},qd=1.340264,jd=-.081106,Ud=893e-6,zd=.003796,Yd=kc(3)/2;function Vd(t,e){var n=Sc(Yd*wc(e)),r=n*n,i=r*r*r;return[t*yc(n)/(Yd*(qd+3*jd*r+i*(7*Ud+9*zd*r))),n*(qd+jd*r+i*(Ud+zd*r))]}Vd.invert=function(t,e){for(var n,r=e,i=r*r,o=i*i*i,a=0;a<12&&(o=(i=(r-=n=(r*(qd+jd*i+o*(Ud+zd*i))-e)/(qd+3*jd*i+o*(7*Ud+9*zd*i)))*r)*i*i,!(dc(n)<ac));++a);return[Yd*t*(qd+3*jd*i+o*(7*Ud+9*zd*i))/yc(r),Sc(wc(r)/Yd)]};var Hd=function(){return yd(Vd).scale(177.158)};function $d(t,e){var n=yc(e),r=yc(t)*n;return[n*wc(t)/r,wc(e)/r]}$d.invert=Ed(pc);var Gd=function(){return yd($d).scale(144.049).clipAngle(60)};function Wd(t,e,n,r){return 1===t&&1===e&&0===n&&0===r?ih:rd({point:function(i,o){this.stream.point(i*t+n,o*e+r)}})}var Kd=function(){var t,e,n,r,i,o,a=1,s=0,u=0,c=1,f=1,l=ih,h=null,d=ih;function p(){return r=i=null,o}return o={stream:function(t){return r&&i===t?r:r=l(d(i=t))},postclip:function(r){return arguments.length?(d=r,h=t=e=n=null,p()):d},clipExtent:function(r){return arguments.length?(d=null==r?(h=t=e=n=null,ih):Sl(h=+r[0][0],t=+r[0][1],e=+r[1][0],n=+r[1][1]),p()):null==h?null:[[h,t],[e,n]]},scale:function(t){return arguments.length?(l=Wd((a=+t)*c,a*f,s,u),p()):a},translate:function(t){return arguments.length?(l=Wd(a*c,a*f,s=+t[0],u=+t[1]),p()):[s,u]},reflectX:function(t){return arguments.length?(l=Wd(a*(c=t?-1:1),a*f,s,u),p()):c<0},reflectY:function(t){return arguments.length?(l=Wd(a*c,a*(f=t?-1:1),s,u),p()):f<0},fitExtent:function(t,e){return ad(o,t,e)},fitSize:function(t,e){return sd(o,t,e)},fitWidth:function(t,e){return ud(o,t,e)},fitHeight:function(t,e){return cd(o,t,e)}}};function Xd(t,e){var n=e*e,r=n*n;return[t*(.8707-.131979*n+r*(r*(.003971*n-.001529*r)-.013791)),e*(1.007226+n*(.015085+r*(.028874*n-.044475-.005916*r)))]}Xd.invert=function(t,e){var n,r=e,i=25;do{var o=r*r,a=o*o;r-=n=(r*(1.007226+o*(.015085+a*(.028874*o-.044475-.005916*a)))-e)/(1.007226+o*(.045255+a*(.259866*o-.311325-.005916*11*a)))}while(dc(n)>oc&&--i>0);return[t/(.8707+(o=r*r)*(o*(o*o*o*(.003971-.001529*o)-.013791)-.131979)),r]};var Zd=function(){return yd(Xd).scale(175.295)};function Jd(t,e){return[yc(e)*wc(t),wc(e)]}Jd.invert=Ed(Sc);var Qd=function(){return yd(Jd).scale(249.5).clipAngle(90+oc)};function tp(t,e){var n=yc(e),r=1+yc(t)*n;return[n*wc(t)/r,wc(e)/r]}tp.invert=Ed((function(t){return 2*pc(t)}));var ep=function(){return yd(tp).scale(250).clipAngle(142)};function np(t,e){return[vc(Ec((uc+e)/2)),-t]}np.invert=function(t,e){return[-e,2*pc(mc(t))-uc]};var rp=function(){var t=Od(np),e=t.center,n=t.rotate;return t.center=function(t){return arguments.length?e([-t[1],t[0]]):[(t=e())[1],-t[0]]},t.rotate=function(t){return arguments.length?n([t[0],t[1],t.length>2?t[2]+90:90]):[(t=n())[0],t[1],t[2]-90]},n([0,0,90]).scale(159.155)};function ip(t,e){return t.parent===e.parent?1:2}function op(t,e){return t+e.x}function ap(t,e){return Math.max(t,e.y)}var sp=function(){var t=ip,e=1,n=1,r=!1;function i(i){var o,a=0;i.eachAfter((function(e){var n=e.children;n?(e.x=function(t){return t.reduce(op,0)/t.length}(n),e.y=function(t){return 1+t.reduce(ap,0)}(n)):(e.x=o?a+=t(e,o):0,e.y=0,o=e)}));var s=function(t){for(var e;e=t.children;)t=e[0];return t}(i),u=function(t){for(var e;e=t.children;)t=e[e.length-1];return t}(i),c=s.x-t(s,u)/2,f=u.x+t(u,s)/2;return i.eachAfter(r?function(t){t.x=(t.x-i.x)*e,t.y=(i.y-t.y)*n}:function(t){t.x=(t.x-c)/(f-c)*e,t.y=(1-(i.y?t.y/i.y:1))*n})}return i.separation=function(e){return arguments.length?(t=e,i):t},i.size=function(t){return arguments.length?(r=!1,e=+t[0],n=+t[1],i):r?null:[e,n]},i.nodeSize=function(t){return arguments.length?(r=!0,e=+t[0],n=+t[1],i):r?[e,n]:null},i};function up(t){var e=0,n=t.children,r=n&&n.length;if(r)for(;--r>=0;)e+=n[r].value;else e=1;t.value=e}function cp(t,e){var n,r,i,o,a,s=new dp(t),u=+t.value&&(s.value=t.value),c=[s];for(null==e&&(e=fp);n=c.pop();)if(u&&(n.value=+n.data.value),(i=e(n.data))&&(a=i.length))for(n.children=new Array(a),o=a-1;o>=0;--o)c.push(r=n.children[o]=new dp(i[o])),r.parent=n,r.depth=n.depth+1;return s.eachBefore(hp)}function fp(t){return t.children}function lp(t){t.data=t.data.data}function hp(t){var e=0;do{t.height=e}while((t=t.parent)&&t.height<++e)}function dp(t){this.data=t,this.depth=this.height=0,this.parent=null}dp.prototype=cp.prototype={constructor:dp,count:function(){return this.eachAfter(up)},each:function(t){var e,n,r,i,o=this,a=[o];do{for(e=a.reverse(),a=[];o=e.pop();)if(t(o),n=o.children)for(r=0,i=n.length;r<i;++r)a.push(n[r])}while(a.length);return this},eachAfter:function(t){for(var e,n,r,i=this,o=[i],a=[];i=o.pop();)if(a.push(i),e=i.children)for(n=0,r=e.length;n<r;++n)o.push(e[n]);for(;i=a.pop();)t(i);return this},eachBefore:function(t){for(var e,n,r=this,i=[r];r=i.pop();)if(t(r),e=r.children)for(n=e.length-1;n>=0;--n)i.push(e[n]);return this},sum:function(t){return this.eachAfter((function(e){for(var n=+t(e.data)||0,r=e.children,i=r&&r.length;--i>=0;)n+=r[i].value;e.value=n}))},sort:function(t){return this.eachBefore((function(e){e.children&&e.children.sort(t)}))},path:function(t){for(var e=this,n=function(t,e){if(t===e)return t;var n=t.ancestors(),r=e.ancestors(),i=null;t=n.pop(),e=r.pop();for(;t===e;)i=t,t=n.pop(),e=r.pop();return i}(e,t),r=[e];e!==n;)e=e.parent,r.push(e);for(var i=r.length;t!==n;)r.splice(i,0,t),t=t.parent;return r},ancestors:function(){for(var t=this,e=[t];t=t.parent;)e.push(t);return e},descendants:function(){var t=[];return this.each((function(e){t.push(e)})),t},leaves:function(){var t=[];return this.eachBefore((function(e){e.children||t.push(e)})),t},links:function(){var t=this,e=[];return t.each((function(n){n!==t&&e.push({source:n.parent,target:n})})),e},copy:function(){return cp(this).eachBefore(lp)}};var pp=Array.prototype.slice;var gp=function(t){for(var e,n,r=0,i=(t=function(t){for(var e,n,r=t.length;r;)n=Math.random()*r--|0,e=t[r],t[r]=t[n],t[n]=e;return t}(pp.call(t))).length,o=[];r<i;)e=t[r],n&&mp(n,e)?++r:(n=_p(o=yp(o,e)),r=0);return n};function yp(t,e){var n,r;if(vp(e,t))return[e];for(n=0;n<t.length;++n)if(bp(e,t[n])&&vp(wp(t[n],e),t))return[t[n],e];for(n=0;n<t.length-1;++n)for(r=n+1;r<t.length;++r)if(bp(wp(t[n],t[r]),e)&&bp(wp(t[n],e),t[r])&&bp(wp(t[r],e),t[n])&&vp(xp(t[n],t[r],e),t))return[t[n],t[r],e];throw new Error}function bp(t,e){var n=t.r-e.r,r=e.x-t.x,i=e.y-t.y;return n<0||n*n<r*r+i*i}function mp(t,e){var n=t.r-e.r+1e-6,r=e.x-t.x,i=e.y-t.y;return n>0&&n*n>r*r+i*i}function vp(t,e){for(var n=0;n<e.length;++n)if(!mp(t,e[n]))return!1;return!0}function _p(t){switch(t.length){case 1:return{x:(e=t[0]).x,y:e.y,r:e.r};case 2:return wp(t[0],t[1]);case 3:return xp(t[0],t[1],t[2])}var e}function wp(t,e){var n=t.x,r=t.y,i=t.r,o=e.x,a=e.y,s=e.r,u=o-n,c=a-r,f=s-i,l=Math.sqrt(u*u+c*c);return{x:(n+o+u/l*f)/2,y:(r+a+c/l*f)/2,r:(l+i+s)/2}}function xp(t,e,n){var r=t.x,i=t.y,o=t.r,a=e.x,s=e.y,u=e.r,c=n.x,f=n.y,l=n.r,h=r-a,d=r-c,p=i-s,g=i-f,y=u-o,b=l-o,m=r*r+i*i-o*o,v=m-a*a-s*s+u*u,_=m-c*c-f*f+l*l,w=d*p-h*g,x=(p*_-g*v)/(2*w)-r,k=(g*y-p*b)/w,E=(d*v-h*_)/(2*w)-i,A=(h*b-d*y)/w,S=k*k+A*A-1,T=2*(o+x*k+E*A),M=x*x+E*E-o*o,D=-(S?(T+Math.sqrt(T*T-4*S*M))/(2*S):M/T);return{x:r+x+k*D,y:i+E+A*D,r:D}}function kp(t,e,n){var r,i,o,a,s=t.x-e.x,u=t.y-e.y,c=s*s+u*u;c?(i=e.r+n.r,i*=i,a=t.r+n.r,i>(a*=a)?(r=(c+a-i)/(2*c),o=Math.sqrt(Math.max(0,a/c-r*r)),n.x=t.x-r*s-o*u,n.y=t.y-r*u+o*s):(r=(c+i-a)/(2*c),o=Math.sqrt(Math.max(0,i/c-r*r)),n.x=e.x+r*s-o*u,n.y=e.y+r*u+o*s)):(n.x=e.x+n.r,n.y=e.y)}function Ep(t,e){var n=t.r+e.r-1e-6,r=e.x-t.x,i=e.y-t.y;return n>0&&n*n>r*r+i*i}function Ap(t){var e=t._,n=t.next._,r=e.r+n.r,i=(e.x*n.r+n.x*e.r)/r,o=(e.y*n.r+n.y*e.r)/r;return i*i+o*o}function Sp(t){this._=t,this.next=null,this.previous=null}function Tp(t){if(!(i=t.length))return 0;var e,n,r,i,o,a,s,u,c,f,l;if((e=t[0]).x=0,e.y=0,!(i>1))return e.r;if(n=t[1],e.x=-n.r,n.x=e.r,n.y=0,!(i>2))return e.r+n.r;kp(n,e,r=t[2]),e=new Sp(e),n=new Sp(n),r=new Sp(r),e.next=r.previous=n,n.next=e.previous=r,r.next=n.previous=e;t:for(s=3;s<i;++s){kp(e._,n._,r=t[s]),r=new Sp(r),u=n.next,c=e.previous,f=n._.r,l=e._.r;do{if(f<=l){if(Ep(u._,r._)){n=u,e.next=n,n.previous=e,--s;continue t}f+=u._.r,u=u.next}else{if(Ep(c._,r._)){(e=c).next=n,n.previous=e,--s;continue t}l+=c._.r,c=c.previous}}while(u!==c.next);for(r.previous=e,r.next=n,e.next=n.previous=n=r,o=Ap(e);(r=r.next)!==n;)(a=Ap(r))<o&&(e=r,o=a);n=e.next}for(e=[n._],r=n;(r=r.next)!==n;)e.push(r._);for(r=gp(e),s=0;s<i;++s)(e=t[s]).x-=r.x,e.y-=r.y;return r.r}var Mp=function(t){return Tp(t),t};function Dp(t){return null==t?null:Cp(t)}function Cp(t){if("function"!=typeof t)throw new Error;return t}function Op(){return 0}var Rp=function(t){return function(){return t}};function Ip(t){return Math.sqrt(t.value)}var Np=function(){var t=null,e=1,n=1,r=Op;function i(i){return i.x=e/2,i.y=n/2,t?i.eachBefore(Bp(t)).eachAfter(Lp(r,.5)).eachBefore(Pp(1)):i.eachBefore(Bp(Ip)).eachAfter(Lp(Op,1)).eachAfter(Lp(r,i.r/Math.min(e,n))).eachBefore(Pp(Math.min(e,n)/(2*i.r))),i}return i.radius=function(e){return arguments.length?(t=Dp(e),i):t},i.size=function(t){return arguments.length?(e=+t[0],n=+t[1],i):[e,n]},i.padding=function(t){return arguments.length?(r="function"==typeof t?t:Rp(+t),i):r},i};function Bp(t){return function(e){e.children||(e.r=Math.max(0,+t(e)||0))}}function Lp(t,e){return function(n){if(r=n.children){var r,i,o,a=r.length,s=t(n)*e||0;if(s)for(i=0;i<a;++i)r[i].r+=s;if(o=Tp(r),s)for(i=0;i<a;++i)r[i].r-=s;n.r=o+s}}}function Pp(t){return function(e){var n=e.parent;e.r*=t,n&&(e.x=n.x+t*e.x,e.y=n.y+t*e.y)}}var Fp=function(t){t.x0=Math.round(t.x0),t.y0=Math.round(t.y0),t.x1=Math.round(t.x1),t.y1=Math.round(t.y1)},qp=function(t,e,n,r,i){for(var o,a=t.children,s=-1,u=a.length,c=t.value&&(r-e)/t.value;++s<u;)(o=a[s]).y0=n,o.y1=i,o.x0=e,o.x1=e+=o.value*c},jp=function(){var t=1,e=1,n=0,r=!1;function i(i){var o=i.height+1;return i.x0=i.y0=n,i.x1=t,i.y1=e/o,i.eachBefore(function(t,e){return function(r){r.children&&qp(r,r.x0,t*(r.depth+1)/e,r.x1,t*(r.depth+2)/e);var i=r.x0,o=r.y0,a=r.x1-n,s=r.y1-n;a<i&&(i=a=(i+a)/2),s<o&&(o=s=(o+s)/2),r.x0=i,r.y0=o,r.x1=a,r.y1=s}}(e,o)),r&&i.eachBefore(Fp),i}return i.round=function(t){return arguments.length?(r=!!t,i):r},i.size=function(n){return arguments.length?(t=+n[0],e=+n[1],i):[t,e]},i.padding=function(t){return arguments.length?(n=+t,i):n},i},Up="$",zp={depth:-1},Yp={};function Vp(t){return t.id}function Hp(t){return t.parentId}var $p=function(){var t=Vp,e=Hp;function n(n){var r,i,o,a,s,u,c,f=n.length,l=new Array(f),h={};for(i=0;i<f;++i)r=n[i],s=l[i]=new dp(r),null!=(u=t(r,i,n))&&(u+="")&&(h[c=Up+(s.id=u)]=c in h?Yp:s);for(i=0;i<f;++i)if(s=l[i],null!=(u=e(n[i],i,n))&&(u+="")){if(!(a=h[Up+u]))throw new Error("missing: "+u);if(a===Yp)throw new Error("ambiguous: "+u);a.children?a.children.push(s):a.children=[s],s.parent=a}else{if(o)throw new Error("multiple roots");o=s}if(!o)throw new Error("no root");if(o.parent=zp,o.eachBefore((function(t){t.depth=t.parent.depth+1,--f})).eachBefore(hp),o.parent=null,f>0)throw new Error("cycle");return o}return n.id=function(e){return arguments.length?(t=Cp(e),n):t},n.parentId=function(t){return arguments.length?(e=Cp(t),n):e},n};function Gp(t,e){return t.parent===e.parent?1:2}function Wp(t){var e=t.children;return e?e[0]:t.t}function Kp(t){var e=t.children;return e?e[e.length-1]:t.t}function Xp(t,e,n){var r=n/(e.i-t.i);e.c-=r,e.s+=n,t.c+=r,e.z+=n,e.m+=n}function Zp(t,e,n){return t.a.parent===e.parent?t.a:n}function Jp(t,e){this._=t,this.parent=null,this.children=null,this.A=null,this.a=this,this.z=0,this.m=0,this.c=0,this.s=0,this.t=null,this.i=e}Jp.prototype=Object.create(dp.prototype);var Qp=function(){var t=Gp,e=1,n=1,r=null;function i(i){var u=function(t){for(var e,n,r,i,o,a=new Jp(t,0),s=[a];e=s.pop();)if(r=e._.children)for(e.children=new Array(o=r.length),i=o-1;i>=0;--i)s.push(n=e.children[i]=new Jp(r[i],i)),n.parent=e;return(a.parent=new Jp(null,0)).children=[a],a}(i);if(u.eachAfter(o),u.parent.m=-u.z,u.eachBefore(a),r)i.eachBefore(s);else{var c=i,f=i,l=i;i.eachBefore((function(t){t.x<c.x&&(c=t),t.x>f.x&&(f=t),t.depth>l.depth&&(l=t)}));var h=c===f?1:t(c,f)/2,d=h-c.x,p=e/(f.x+h+d),g=n/(l.depth||1);i.eachBefore((function(t){t.x=(t.x+d)*p,t.y=t.depth*g}))}return i}function o(e){var n=e.children,r=e.parent.children,i=e.i?r[e.i-1]:null;if(n){!function(t){for(var e,n=0,r=0,i=t.children,o=i.length;--o>=0;)(e=i[o]).z+=n,e.m+=n,n+=e.s+(r+=e.c)}(e);var o=(n[0].z+n[n.length-1].z)/2;i?(e.z=i.z+t(e._,i._),e.m=e.z-o):e.z=o}else i&&(e.z=i.z+t(e._,i._));e.parent.A=function(e,n,r){if(n){for(var i,o=e,a=e,s=n,u=o.parent.children[0],c=o.m,f=a.m,l=s.m,h=u.m;s=Kp(s),o=Wp(o),s&&o;)u=Wp(u),(a=Kp(a)).a=e,(i=s.z+l-o.z-c+t(s._,o._))>0&&(Xp(Zp(s,e,r),e,i),c+=i,f+=i),l+=s.m,c+=o.m,h+=u.m,f+=a.m;s&&!Kp(a)&&(a.t=s,a.m+=l-f),o&&!Wp(u)&&(u.t=o,u.m+=c-h,r=e)}return r}(e,i,e.parent.A||r[0])}function a(t){t._.x=t.z+t.parent.m,t.m+=t.parent.m}function s(t){t.x*=e,t.y=t.depth*n}return i.separation=function(e){return arguments.length?(t=e,i):t},i.size=function(t){return arguments.length?(r=!1,e=+t[0],n=+t[1],i):r?null:[e,n]},i.nodeSize=function(t){return arguments.length?(r=!0,e=+t[0],n=+t[1],i):r?[e,n]:null},i},tg=function(t,e,n,r,i){for(var o,a=t.children,s=-1,u=a.length,c=t.value&&(i-n)/t.value;++s<u;)(o=a[s]).x0=e,o.x1=r,o.y0=n,o.y1=n+=o.value*c},eg=(1+Math.sqrt(5))/2;function ng(t,e,n,r,i,o){for(var a,s,u,c,f,l,h,d,p,g,y,b=[],m=e.children,v=0,_=0,w=m.length,x=e.value;v<w;){u=i-n,c=o-r;do{f=m[_++].value}while(!f&&_<w);for(l=h=f,y=f*f*(g=Math.max(c/u,u/c)/(x*t)),p=Math.max(h/y,y/l);_<w;++_){if(f+=s=m[_].value,s<l&&(l=s),s>h&&(h=s),y=f*f*g,(d=Math.max(h/y,y/l))>p){f-=s;break}p=d}b.push(a={value:f,dice:u<c,children:m.slice(v,_)}),a.dice?qp(a,n,r,i,x?r+=c*f/x:o):tg(a,n,r,x?n+=u*f/x:i,o),x-=f,v=_}return b}var rg=function t(e){function n(t,n,r,i,o){ng(e,t,n,r,i,o)}return n.ratio=function(e){return t((e=+e)>1?e:1)},n}(eg),ig=function(){var t=rg,e=!1,n=1,r=1,i=[0],o=Op,a=Op,s=Op,u=Op,c=Op;function f(t){return t.x0=t.y0=0,t.x1=n,t.y1=r,t.eachBefore(l),i=[0],e&&t.eachBefore(Fp),t}function l(e){var n=i[e.depth],r=e.x0+n,f=e.y0+n,l=e.x1-n,h=e.y1-n;l<r&&(r=l=(r+l)/2),h<f&&(f=h=(f+h)/2),e.x0=r,e.y0=f,e.x1=l,e.y1=h,e.children&&(n=i[e.depth+1]=o(e)/2,r+=c(e)-n,f+=a(e)-n,(l-=s(e)-n)<r&&(r=l=(r+l)/2),(h-=u(e)-n)<f&&(f=h=(f+h)/2),t(e,r,f,l,h))}return f.round=function(t){return arguments.length?(e=!!t,f):e},f.size=function(t){return arguments.length?(n=+t[0],r=+t[1],f):[n,r]},f.tile=function(e){return arguments.length?(t=Cp(e),f):t},f.padding=function(t){return arguments.length?f.paddingInner(t).paddingOuter(t):f.paddingInner()},f.paddingInner=function(t){return arguments.length?(o="function"==typeof t?t:Rp(+t),f):o},f.paddingOuter=function(t){return arguments.length?f.paddingTop(t).paddingRight(t).paddingBottom(t).paddingLeft(t):f.paddingTop()},f.paddingTop=function(t){return arguments.length?(a="function"==typeof t?t:Rp(+t),f):a},f.paddingRight=function(t){return arguments.length?(s="function"==typeof t?t:Rp(+t),f):s},f.paddingBottom=function(t){return arguments.length?(u="function"==typeof t?t:Rp(+t),f):u},f.paddingLeft=function(t){return arguments.length?(c="function"==typeof t?t:Rp(+t),f):c},f},og=function(t,e,n,r,i){var o,a,s=t.children,u=s.length,c=new Array(u+1);for(c[0]=a=o=0;o<u;++o)c[o+1]=a+=s[o].value;!function t(e,n,r,i,o,a,u){if(e>=n-1){var f=s[e];return f.x0=i,f.y0=o,f.x1=a,void(f.y1=u)}var l=c[e],h=r/2+l,d=e+1,p=n-1;for(;d<p;){var g=d+p>>>1;c[g]<h?d=g+1:p=g}h-c[d-1]<c[d]-h&&e+1<d&&--d;var y=c[d]-l,b=r-y;if(a-i>u-o){var m=(i*b+a*y)/r;t(e,d,y,i,o,m,u),t(d,n,b,m,o,a,u)}else{var v=(o*b+u*y)/r;t(e,d,y,i,o,a,v),t(d,n,b,i,v,a,u)}}(0,u,t.value,e,n,r,i)},ag=function(t,e,n,r,i){(1&t.depth?tg:qp)(t,e,n,r,i)},sg=function t(e){function n(t,n,r,i,o){if((a=t._squarify)&&a.ratio===e)for(var a,s,u,c,f,l=-1,h=a.length,d=t.value;++l<h;){for(u=(s=a[l]).children,c=s.value=0,f=u.length;c<f;++c)s.value+=u[c].value;s.dice?qp(s,n,r,i,r+=(o-r)*s.value/d):tg(s,n,r,n+=(i-n)*s.value/d,o),d-=s.value}else t._squarify=a=ng(e,t,n,r,i,o),a.ratio=e}return n.ratio=function(e){return t((e=+e)>1?e:1)},n}(eg),ug=function(t){for(var e,n=-1,r=t.length,i=t[r-1],o=0;++n<r;)e=i,i=t[n],o+=e[1]*i[0]-e[0]*i[1];return o/2},cg=function(t){for(var e,n,r=-1,i=t.length,o=0,a=0,s=t[i-1],u=0;++r<i;)e=s,s=t[r],u+=n=e[0]*s[1]-s[0]*e[1],o+=(e[0]+s[0])*n,a+=(e[1]+s[1])*n;return[o/(u*=3),a/u]},fg=function(t,e,n){return(e[0]-t[0])*(n[1]-t[1])-(e[1]-t[1])*(n[0]-t[0])};function lg(t,e){return t[0]-e[0]||t[1]-e[1]}function hg(t){for(var e=t.length,n=[0,1],r=2,i=2;i<e;++i){for(;r>1&&fg(t[n[r-2]],t[n[r-1]],t[i])<=0;)--r;n[r++]=i}return n.slice(0,r)}var dg=function(t){if((n=t.length)<3)return null;var e,n,r=new Array(n),i=new Array(n);for(e=0;e<n;++e)r[e]=[+t[e][0],+t[e][1],e];for(r.sort(lg),e=0;e<n;++e)i[e]=[r[e][0],-r[e][1]];var o=hg(r),a=hg(i),s=a[0]===o[0],u=a[a.length-1]===o[o.length-1],c=[];for(e=o.length-1;e>=0;--e)c.push(t[r[o[e]][2]]);for(e=+s;e<a.length-u;++e)c.push(t[r[a[e]][2]]);return c},pg=function(t,e){for(var n,r,i=t.length,o=t[i-1],a=e[0],s=e[1],u=o[0],c=o[1],f=!1,l=0;l<i;++l)n=(o=t[l])[0],(r=o[1])>s!=c>s&&a<(u-n)*(s-r)/(c-r)+n&&(f=!f),u=n,c=r;return f},gg=function(t){for(var e,n,r=-1,i=t.length,o=t[i-1],a=o[0],s=o[1],u=0;++r<i;)e=a,n=s,e-=a=(o=t[r])[0],n-=s=o[1],u+=Math.sqrt(e*e+n*n);return u},yg=function(){return Math.random()},bg=function t(e){function n(t,n){return t=null==t?0:+t,n=null==n?1:+n,1===arguments.length?(n=t,t=0):n-=t,function(){return e()*n+t}}return n.source=t,n}(yg),mg=function t(e){function n(t,n){var r,i;return t=null==t?0:+t,n=null==n?1:+n,function(){var o;if(null!=r)o=r,r=null;else do{r=2*e()-1,o=2*e()-1,i=r*r+o*o}while(!i||i>1);return t+n*o*Math.sqrt(-2*Math.log(i)/i)}}return n.source=t,n}(yg),vg=function t(e){function n(){var t=mg.source(e).apply(this,arguments);return function(){return Math.exp(t())}}return n.source=t,n}(yg),_g=function t(e){function n(t){return function(){for(var n=0,r=0;r<t;++r)n+=e();return n}}return n.source=t,n}(yg),wg=function t(e){function n(t){var n=_g.source(e)(t);return function(){return n()/t}}return n.source=t,n}(yg),xg=function t(e){function n(t){return function(){return-Math.log(1-e())/t}}return n.source=t,n}(yg);function kg(t,e){switch(arguments.length){case 0:break;case 1:this.range(t);break;default:this.range(e).domain(t)}return this}function Eg(t,e){switch(arguments.length){case 0:break;case 1:this.interpolator(t);break;default:this.interpolator(e).domain(t)}return this}var Ag=Array.prototype,Sg=Ag.map,Tg=Ag.slice,Mg={name:"implicit"};function Dg(){var t=Wa(),e=[],n=[],r=Mg;function i(i){var o=i+"",a=t.get(o);if(!a){if(r!==Mg)return r;t.set(o,a=e.push(i))}return n[(a-1)%n.length]}return i.domain=function(n){if(!arguments.length)return e.slice();e=[],t=Wa();for(var r,o,a=-1,s=n.length;++a<s;)t.has(o=(r=n[a])+"")||t.set(o,e.push(r));return i},i.range=function(t){return arguments.length?(n=Tg.call(t),i):n.slice()},i.unknown=function(t){return arguments.length?(r=t,i):r},i.copy=function(){return Dg(e,n).unknown(r)},kg.apply(i,arguments),i}function Cg(){var t,e,n=Dg().unknown(void 0),r=n.domain,i=n.range,o=[0,1],a=!1,s=0,u=0,c=.5;function f(){var n=r().length,f=o[1]<o[0],l=o[f-0],h=o[1-f];t=(h-l)/Math.max(1,n-s+2*u),a&&(t=Math.floor(t)),l+=(h-l-t*(n-s))*c,e=t*(1-s),a&&(l=Math.round(l),e=Math.round(e));var d=x(n).map((function(e){return l+t*e}));return i(f?d.reverse():d)}return delete n.unknown,n.domain=function(t){return arguments.length?(r(t),f()):r()},n.range=function(t){return arguments.length?(o=[+t[0],+t[1]],f()):o.slice()},n.rangeRound=function(t){return o=[+t[0],+t[1]],a=!0,f()},n.bandwidth=function(){return e},n.step=function(){return t},n.round=function(t){return arguments.length?(a=!!t,f()):a},n.padding=function(t){return arguments.length?(s=Math.min(1,u=+t),f()):s},n.paddingInner=function(t){return arguments.length?(s=Math.min(1,t),f()):s},n.paddingOuter=function(t){return arguments.length?(u=+t,f()):u},n.align=function(t){return arguments.length?(c=Math.max(0,Math.min(1,t)),f()):c},n.copy=function(){return Cg(r(),o).round(a).paddingInner(s).paddingOuter(u).align(c)},kg.apply(f(),arguments)}function Og(){return function t(e){var n=e.copy;return e.padding=e.paddingOuter,delete e.paddingInner,delete e.paddingOuter,e.copy=function(){return t(n())},e}(Cg.apply(null,arguments).paddingInner(1))}var Rg=function(t){return function(){return t}},Ig=function(t){return+t},Ng=[0,1];function Bg(t){return t}function Lg(t,e){return(e-=t=+t)?function(n){return(n-t)/e}:Rg(isNaN(e)?NaN:.5)}function Pg(t){var e,n=t[0],r=t[t.length-1];return n>r&&(e=n,n=r,r=e),function(t){return Math.max(n,Math.min(r,t))}}function Fg(t,e,n){var r=t[0],i=t[1],o=e[0],a=e[1];return i<r?(r=Lg(i,r),o=n(a,o)):(r=Lg(r,i),o=n(o,a)),function(t){return o(r(t))}}function qg(t,e,n){var r=Math.min(t.length,e.length)-1,i=new Array(r),o=new Array(r),a=-1;for(t[r]<t[0]&&(t=t.slice().reverse(),e=e.slice().reverse());++a<r;)i[a]=Lg(t[a],t[a+1]),o[a]=n(e[a],e[a+1]);return function(e){var n=u(t,e,1,r)-1;return o[n](i[n](e))}}function jg(t,e){return e.domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown())}function Ug(){var t,e,n,r,i,o,a=Ng,s=Ng,u=Xn,c=Bg;function f(){return r=Math.min(a.length,s.length)>2?qg:Fg,i=o=null,l}function l(e){return isNaN(e=+e)?n:(i||(i=r(a.map(t),s,u)))(t(c(e)))}return l.invert=function(n){return c(e((o||(o=r(s,a.map(t),Un)))(n)))},l.domain=function(t){return arguments.length?(a=Sg.call(t,Ig),c===Bg||(c=Pg(a)),f()):a.slice()},l.range=function(t){return arguments.length?(s=Tg.call(t),f()):s.slice()},l.rangeRound=function(t){return s=Tg.call(t),u=Qn,f()},l.clamp=function(t){return arguments.length?(c=t?Pg(a):Bg,l):c!==Bg},l.interpolate=function(t){return arguments.length?(u=t,f()):u},l.unknown=function(t){return arguments.length?(n=t,l):n},function(n,r){return t=n,e=r,f()}}function zg(t,e){return Ug()(t,e)}var Yg=function(t,e,n,r){var i,o=M(t,e,n);switch((r=Fu(null==r?",f":r)).type){case"s":var a=Math.max(Math.abs(t),Math.abs(e));return null!=r.precision||isNaN(i=Qu(o,a))||(r.precision=i),Yu(r,a);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(i=tc(o,Math.max(Math.abs(t),Math.abs(e))))||(r.precision=i-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(i=Ju(o))||(r.precision=i-2*("%"===r.type))}return zu(r)};function Vg(t){var e=t.domain;return t.ticks=function(t){var n=e();return S(n[0],n[n.length-1],null==t?10:t)},t.tickFormat=function(t,n){var r=e();return Yg(r[0],r[r.length-1],null==t?10:t,n)},t.nice=function(n){null==n&&(n=10);var r,i=e(),o=0,a=i.length-1,s=i[o],u=i[a];return u<s&&(r=s,s=u,u=r,r=o,o=a,a=r),(r=T(s,u,n))>0?r=T(s=Math.floor(s/r)*r,u=Math.ceil(u/r)*r,n):r<0&&(r=T(s=Math.ceil(s*r)/r,u=Math.floor(u*r)/r,n)),r>0?(i[o]=Math.floor(s/r)*r,i[a]=Math.ceil(u/r)*r,e(i)):r<0&&(i[o]=Math.ceil(s*r)/r,i[a]=Math.floor(u*r)/r,e(i)),t},t}function Hg(){var t=zg(Bg,Bg);return t.copy=function(){return jg(t,Hg())},kg.apply(t,arguments),Vg(t)}function $g(t){var e;function n(t){return isNaN(t=+t)?e:t}return n.invert=n,n.domain=n.range=function(e){return arguments.length?(t=Sg.call(e,Ig),n):t.slice()},n.unknown=function(t){return arguments.length?(e=t,n):e},n.copy=function(){return $g(t).unknown(e)},t=arguments.length?Sg.call(t,Ig):[0,1],Vg(n)}var Gg=function(t,e){var n,r=0,i=(t=t.slice()).length-1,o=t[r],a=t[i];return a<o&&(n=r,r=i,i=n,n=o,o=a,a=n),t[r]=e.floor(o),t[i]=e.ceil(a),t};function Wg(t){return Math.log(t)}function Kg(t){return Math.exp(t)}function Xg(t){return-Math.log(-t)}function Zg(t){return-Math.exp(-t)}function Jg(t){return isFinite(t)?+("1e"+t):t<0?0:t}function Qg(t){return function(e){return-t(-e)}}function ty(t){var e,n,r=t(Wg,Kg),i=r.domain,o=10;function a(){return e=function(t){return t===Math.E?Math.log:10===t&&Math.log10||2===t&&Math.log2||(t=Math.log(t),function(e){return Math.log(e)/t})}(o),n=function(t){return 10===t?Jg:t===Math.E?Math.exp:function(e){return Math.pow(t,e)}}(o),i()[0]<0?(e=Qg(e),n=Qg(n),t(Xg,Zg)):t(Wg,Kg),r}return r.base=function(t){return arguments.length?(o=+t,a()):o},r.domain=function(t){return arguments.length?(i(t),a()):i()},r.ticks=function(t){var r,a=i(),s=a[0],u=a[a.length-1];(r=u<s)&&(h=s,s=u,u=h);var c,f,l,h=e(s),d=e(u),p=null==t?10:+t,g=[];if(!(o%1)&&d-h<p){if(h=Math.round(h)-1,d=Math.round(d)+1,s>0){for(;h<d;++h)for(f=1,c=n(h);f<o;++f)if(!((l=c*f)<s)){if(l>u)break;g.push(l)}}else for(;h<d;++h)for(f=o-1,c=n(h);f>=1;--f)if(!((l=c*f)<s)){if(l>u)break;g.push(l)}}else g=S(h,d,Math.min(d-h,p)).map(n);return r?g.reverse():g},r.tickFormat=function(t,i){if(null==i&&(i=10===o?".0e":","),"function"!=typeof i&&(i=zu(i)),t===1/0)return i;null==t&&(t=10);var a=Math.max(1,o*t/r.ticks().length);return function(t){var r=t/n(Math.round(e(t)));return r*o<o-.5&&(r*=o),r<=a?i(t):""}},r.nice=function(){return i(Gg(i(),{floor:function(t){return n(Math.floor(e(t)))},ceil:function(t){return n(Math.ceil(e(t)))}}))},r}function ey(){var t=ty(Ug()).domain([1,10]);return t.copy=function(){return jg(t,ey()).base(t.base())},kg.apply(t,arguments),t}function ny(t){return function(e){return Math.sign(e)*Math.log1p(Math.abs(e/t))}}function ry(t){return function(e){return Math.sign(e)*Math.expm1(Math.abs(e))*t}}function iy(t){var e=1,n=t(ny(e),ry(e));return n.constant=function(n){return arguments.length?t(ny(e=+n),ry(e)):e},Vg(n)}function oy(){var t=iy(Ug());return t.copy=function(){return jg(t,oy()).constant(t.constant())},kg.apply(t,arguments)}function ay(t){return function(e){return e<0?-Math.pow(-e,t):Math.pow(e,t)}}function sy(t){return t<0?-Math.sqrt(-t):Math.sqrt(t)}function uy(t){return t<0?-t*t:t*t}function cy(t){var e=t(Bg,Bg),n=1;function r(){return 1===n?t(Bg,Bg):.5===n?t(sy,uy):t(ay(n),ay(1/n))}return e.exponent=function(t){return arguments.length?(n=+t,r()):n},Vg(e)}function fy(){var t=cy(Ug());return t.copy=function(){return jg(t,fy()).exponent(t.exponent())},kg.apply(t,arguments),t}function ly(){return fy.apply(null,arguments).exponent(.5)}function hy(){var t,e=[],n=[],i=[];function o(){var t=0,r=Math.max(1,n.length);for(i=new Array(r-1);++t<r;)i[t-1]=O(e,t/r);return a}function a(e){return isNaN(e=+e)?t:n[u(i,e)]}return a.invertExtent=function(t){var r=n.indexOf(t);return r<0?[NaN,NaN]:[r>0?i[r-1]:e[0],r<i.length?i[r]:e[e.length-1]]},a.domain=function(t){if(!arguments.length)return e.slice();e=[];for(var n,i=0,a=t.length;i<a;++i)null==(n=t[i])||isNaN(n=+n)||e.push(n);return e.sort(r),o()},a.range=function(t){return arguments.length?(n=Tg.call(t),o()):n.slice()},a.unknown=function(e){return arguments.length?(t=e,a):t},a.quantiles=function(){return i.slice()},a.copy=function(){return hy().domain(e).range(n).unknown(t)},kg.apply(a,arguments)}function dy(){var t,e=0,n=1,r=1,i=[.5],o=[0,1];function a(e){return e<=e?o[u(i,e,0,r)]:t}function s(){var t=-1;for(i=new Array(r);++t<r;)i[t]=((t+1)*n-(t-r)*e)/(r+1);return a}return a.domain=function(t){return arguments.length?(e=+t[0],n=+t[1],s()):[e,n]},a.range=function(t){return arguments.length?(r=(o=Tg.call(t)).length-1,s()):o.slice()},a.invertExtent=function(t){var a=o.indexOf(t);return a<0?[NaN,NaN]:a<1?[e,i[0]]:a>=r?[i[r-1],n]:[i[a-1],i[a]]},a.unknown=function(e){return arguments.length?(t=e,a):a},a.thresholds=function(){return i.slice()},a.copy=function(){return dy().domain([e,n]).range(o).unknown(t)},kg.apply(Vg(a),arguments)}function py(){var t,e=[.5],n=[0,1],r=1;function i(i){return i<=i?n[u(e,i,0,r)]:t}return i.domain=function(t){return arguments.length?(e=Tg.call(t),r=Math.min(e.length,n.length-1),i):e.slice()},i.range=function(t){return arguments.length?(n=Tg.call(t),r=Math.min(e.length,n.length-1),i):n.slice()},i.invertExtent=function(t){var r=n.indexOf(t);return[e[r-1],e[r]]},i.unknown=function(e){return arguments.length?(t=e,i):t},i.copy=function(){return py().domain(e).range(n).unknown(t)},kg.apply(i,arguments)}var gy=new Date,yy=new Date;function by(t,e,n,r){function i(e){return t(e=0===arguments.length?new Date:new Date(+e)),e}return i.floor=function(e){return t(e=new Date(+e)),e},i.ceil=function(n){return t(n=new Date(n-1)),e(n,1),t(n),n},i.round=function(t){var e=i(t),n=i.ceil(t);return t-e<n-t?e:n},i.offset=function(t,n){return e(t=new Date(+t),null==n?1:Math.floor(n)),t},i.range=function(n,r,o){var a,s=[];if(n=i.ceil(n),o=null==o?1:Math.floor(o),!(n<r&&o>0))return s;do{s.push(a=new Date(+n)),e(n,o),t(n)}while(a<n&&n<r);return s},i.filter=function(n){return by((function(e){if(e>=e)for(;t(e),!n(e);)e.setTime(e-1)}),(function(t,r){if(t>=t)if(r<0)for(;++r<=0;)for(;e(t,-1),!n(t););else for(;--r>=0;)for(;e(t,1),!n(t););}))},n&&(i.count=function(e,r){return gy.setTime(+e),yy.setTime(+r),t(gy),t(yy),Math.floor(n(gy,yy))},i.every=function(t){return t=Math.floor(t),isFinite(t)&&t>0?t>1?i.filter(r?function(e){return r(e)%t==0}:function(e){return i.count(0,e)%t==0}):i:null}),i}var my=by((function(t){t.setMonth(0,1),t.setHours(0,0,0,0)}),(function(t,e){t.setFullYear(t.getFullYear()+e)}),(function(t,e){return e.getFullYear()-t.getFullYear()}),(function(t){return t.getFullYear()}));my.every=function(t){return isFinite(t=Math.floor(t))&&t>0?by((function(e){e.setFullYear(Math.floor(e.getFullYear()/t)*t),e.setMonth(0,1),e.setHours(0,0,0,0)}),(function(e,n){e.setFullYear(e.getFullYear()+n*t)})):null};var vy=my,_y=my.range,wy=by((function(t){t.setDate(1),t.setHours(0,0,0,0)}),(function(t,e){t.setMonth(t.getMonth()+e)}),(function(t,e){return e.getMonth()-t.getMonth()+12*(e.getFullYear()-t.getFullYear())}),(function(t){return t.getMonth()})),xy=wy,ky=wy.range,Ey=6e4,Ay=6048e5;function Sy(t){return by((function(e){e.setDate(e.getDate()-(e.getDay()+7-t)%7),e.setHours(0,0,0,0)}),(function(t,e){t.setDate(t.getDate()+7*e)}),(function(t,e){return(e-t-(e.getTimezoneOffset()-t.getTimezoneOffset())*Ey)/Ay}))}var Ty=Sy(0),My=Sy(1),Dy=Sy(2),Cy=Sy(3),Oy=Sy(4),Ry=Sy(5),Iy=Sy(6),Ny=Ty.range,By=My.range,Ly=Dy.range,Py=Cy.range,Fy=Oy.range,qy=Ry.range,jy=Iy.range,Uy=by((function(t){t.setHours(0,0,0,0)}),(function(t,e){t.setDate(t.getDate()+e)}),(function(t,e){return(e-t-(e.getTimezoneOffset()-t.getTimezoneOffset())*Ey)/864e5}),(function(t){return t.getDate()-1})),zy=Uy,Yy=Uy.range,Vy=by((function(t){t.setTime(t-t.getMilliseconds()-1e3*t.getSeconds()-t.getMinutes()*Ey)}),(function(t,e){t.setTime(+t+36e5*e)}),(function(t,e){return(e-t)/36e5}),(function(t){return t.getHours()})),Hy=Vy,$y=Vy.range,Gy=by((function(t){t.setTime(t-t.getMilliseconds()-1e3*t.getSeconds())}),(function(t,e){t.setTime(+t+e*Ey)}),(function(t,e){return(e-t)/Ey}),(function(t){return t.getMinutes()})),Wy=Gy,Ky=Gy.range,Xy=by((function(t){t.setTime(t-t.getMilliseconds())}),(function(t,e){t.setTime(+t+1e3*e)}),(function(t,e){return(e-t)/1e3}),(function(t){return t.getUTCSeconds()})),Zy=Xy,Jy=Xy.range,Qy=by((function(){}),(function(t,e){t.setTime(+t+e)}),(function(t,e){return e-t}));Qy.every=function(t){return t=Math.floor(t),isFinite(t)&&t>0?t>1?by((function(e){e.setTime(Math.floor(e/t)*t)}),(function(e,n){e.setTime(+e+n*t)}),(function(e,n){return(n-e)/t})):Qy:null};var tb=Qy,eb=Qy.range;function nb(t){return by((function(e){e.setUTCDate(e.getUTCDate()-(e.getUTCDay()+7-t)%7),e.setUTCHours(0,0,0,0)}),(function(t,e){t.setUTCDate(t.getUTCDate()+7*e)}),(function(t,e){return(e-t)/Ay}))}var rb=nb(0),ib=nb(1),ob=nb(2),ab=nb(3),sb=nb(4),ub=nb(5),cb=nb(6),fb=rb.range,lb=ib.range,hb=ob.range,db=ab.range,pb=sb.range,gb=ub.range,yb=cb.range,bb=by((function(t){t.setUTCHours(0,0,0,0)}),(function(t,e){t.setUTCDate(t.getUTCDate()+e)}),(function(t,e){return(e-t)/864e5}),(function(t){return t.getUTCDate()-1})),mb=bb,vb=bb.range,_b=by((function(t){t.setUTCMonth(0,1),t.setUTCHours(0,0,0,0)}),(function(t,e){t.setUTCFullYear(t.getUTCFullYear()+e)}),(function(t,e){return e.getUTCFullYear()-t.getUTCFullYear()}),(function(t){return t.getUTCFullYear()}));_b.every=function(t){return isFinite(t=Math.floor(t))&&t>0?by((function(e){e.setUTCFullYear(Math.floor(e.getUTCFullYear()/t)*t),e.setUTCMonth(0,1),e.setUTCHours(0,0,0,0)}),(function(e,n){e.setUTCFullYear(e.getUTCFullYear()+n*t)})):null};var wb=_b,xb=_b.range;function kb(t){if(0<=t.y&&t.y<100){var e=new Date(-1,t.m,t.d,t.H,t.M,t.S,t.L);return e.setFullYear(t.y),e}return new Date(t.y,t.m,t.d,t.H,t.M,t.S,t.L)}function Eb(t){if(0<=t.y&&t.y<100){var e=new Date(Date.UTC(-1,t.m,t.d,t.H,t.M,t.S,t.L));return e.setUTCFullYear(t.y),e}return new Date(Date.UTC(t.y,t.m,t.d,t.H,t.M,t.S,t.L))}function Ab(t){return{y:t,m:0,d:1,H:0,M:0,S:0,L:0}}function Sb(t){var e=t.dateTime,n=t.date,r=t.time,i=t.periods,o=t.days,a=t.shortDays,s=t.months,u=t.shortMonths,c=Fb(i),f=qb(i),l=Fb(o),h=qb(o),d=Fb(a),p=qb(a),g=Fb(s),y=qb(s),b=Fb(u),m=qb(u),v={a:function(t){return a[t.getDay()]},A:function(t){return o[t.getDay()]},b:function(t){return u[t.getMonth()]},B:function(t){return s[t.getMonth()]},c:null,d:om,e:om,f:fm,H:am,I:sm,j:um,L:cm,m:lm,M:hm,p:function(t){return i[+(t.getHours()>=12)]},Q:jm,s:Um,S:dm,u:pm,U:gm,V:ym,w:bm,W:mm,x:null,X:null,y:vm,Y:_m,Z:wm,"%":qm},_={a:function(t){return a[t.getUTCDay()]},A:function(t){return o[t.getUTCDay()]},b:function(t){return u[t.getUTCMonth()]},B:function(t){return s[t.getUTCMonth()]},c:null,d:xm,e:xm,f:Tm,H:km,I:Em,j:Am,L:Sm,m:Mm,M:Dm,p:function(t){return i[+(t.getUTCHours()>=12)]},Q:jm,s:Um,S:Cm,u:Om,U:Rm,V:Im,w:Nm,W:Bm,x:null,X:null,y:Lm,Y:Pm,Z:Fm,"%":qm},w={a:function(t,e,n){var r=d.exec(e.slice(n));return r?(t.w=p[r[0].toLowerCase()],n+r[0].length):-1},A:function(t,e,n){var r=l.exec(e.slice(n));return r?(t.w=h[r[0].toLowerCase()],n+r[0].length):-1},b:function(t,e,n){var r=b.exec(e.slice(n));return r?(t.m=m[r[0].toLowerCase()],n+r[0].length):-1},B:function(t,e,n){var r=g.exec(e.slice(n));return r?(t.m=y[r[0].toLowerCase()],n+r[0].length):-1},c:function(t,n,r){return E(t,e,n,r)},d:Kb,e:Kb,f:em,H:Zb,I:Zb,j:Xb,L:tm,m:Wb,M:Jb,p:function(t,e,n){var r=c.exec(e.slice(n));return r?(t.p=f[r[0].toLowerCase()],n+r[0].length):-1},Q:rm,s:im,S:Qb,u:Ub,U:zb,V:Yb,w:jb,W:Vb,x:function(t,e,r){return E(t,n,e,r)},X:function(t,e,n){return E(t,r,e,n)},y:$b,Y:Hb,Z:Gb,"%":nm};function x(t,e){return function(n){var r,i,o,a=[],s=-1,u=0,c=t.length;for(n instanceof Date||(n=new Date(+n));++s<c;)37===t.charCodeAt(s)&&(a.push(t.slice(u,s)),null!=(i=Rb[r=t.charAt(++s)])?r=t.charAt(++s):i="e"===r?" ":"0",(o=e[r])&&(r=o(n,i)),a.push(r),u=s+1);return a.push(t.slice(u,s)),a.join("")}}function k(t,e){return function(n){var r,i,o=Ab(1900);if(E(o,t,n+="",0)!=n.length)return null;if("Q"in o)return new Date(o.Q);if("p"in o&&(o.H=o.H%12+12*o.p),"V"in o){if(o.V<1||o.V>53)return null;"w"in o||(o.w=1),"Z"in o?(i=(r=Eb(Ab(o.y))).getUTCDay(),r=i>4||0===i?ib.ceil(r):ib(r),r=mb.offset(r,7*(o.V-1)),o.y=r.getUTCFullYear(),o.m=r.getUTCMonth(),o.d=r.getUTCDate()+(o.w+6)%7):(i=(r=e(Ab(o.y))).getDay(),r=i>4||0===i?My.ceil(r):My(r),r=zy.offset(r,7*(o.V-1)),o.y=r.getFullYear(),o.m=r.getMonth(),o.d=r.getDate()+(o.w+6)%7)}else("W"in o||"U"in o)&&("w"in o||(o.w="u"in o?o.u%7:"W"in o?1:0),i="Z"in o?Eb(Ab(o.y)).getUTCDay():e(Ab(o.y)).getDay(),o.m=0,o.d="W"in o?(o.w+6)%7+7*o.W-(i+5)%7:o.w+7*o.U-(i+6)%7);return"Z"in o?(o.H+=o.Z/100|0,o.M+=o.Z%100,Eb(o)):e(o)}}function E(t,e,n,r){for(var i,o,a=0,s=e.length,u=n.length;a<s;){if(r>=u)return-1;if(37===(i=e.charCodeAt(a++))){if(i=e.charAt(a++),!(o=w[i in Rb?e.charAt(a++):i])||(r=o(t,n,r))<0)return-1}else if(i!=n.charCodeAt(r++))return-1}return r}return(v.x=x(n,v),v.X=x(r,v),v.c=x(e,v),_.x=x(n,_),_.X=x(r,_),_.c=x(e,_),{format:function(t){var e=x(t+="",v);return e.toString=function(){return t},e},parse:function(t){var e=k(t+="",kb);return e.toString=function(){return t},e},utcFormat:function(t){var e=x(t+="",_);return e.toString=function(){return t},e},utcParse:function(t){var e=k(t,Eb);return e.toString=function(){return t},e}})}var Tb,Mb,Db,Cb,Ob,Rb={"-":"",_:" ",0:"0"},Ib=/^\s*\d+/,Nb=/^%/,Bb=/[\\^$*+?|[\]().{}]/g;function Lb(t,e,n){var r=t<0?"-":"",i=(r?-t:t)+"",o=i.length;return r+(o<n?new Array(n-o+1).join(e)+i:i)}function Pb(t){return t.replace(Bb,"\\$&")}function Fb(t){return new RegExp("^(?:"+t.map(Pb).join("|")+")","i")}function qb(t){for(var e={},n=-1,r=t.length;++n<r;)e[t[n].toLowerCase()]=n;return e}function jb(t,e,n){var r=Ib.exec(e.slice(n,n+1));return r?(t.w=+r[0],n+r[0].length):-1}function Ub(t,e,n){var r=Ib.exec(e.slice(n,n+1));return r?(t.u=+r[0],n+r[0].length):-1}function zb(t,e,n){var r=Ib.exec(e.slice(n,n+2));return r?(t.U=+r[0],n+r[0].length):-1}function Yb(t,e,n){var r=Ib.exec(e.slice(n,n+2));return r?(t.V=+r[0],n+r[0].length):-1}function Vb(t,e,n){var r=Ib.exec(e.slice(n,n+2));return r?(t.W=+r[0],n+r[0].length):-1}function Hb(t,e,n){var r=Ib.exec(e.slice(n,n+4));return r?(t.y=+r[0],n+r[0].length):-1}function $b(t,e,n){var r=Ib.exec(e.slice(n,n+2));return r?(t.y=+r[0]+(+r[0]>68?1900:2e3),n+r[0].length):-1}function Gb(t,e,n){var r=/^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(e.slice(n,n+6));return r?(t.Z=r[1]?0:-(r[2]+(r[3]||"00")),n+r[0].length):-1}function Wb(t,e,n){var r=Ib.exec(e.slice(n,n+2));return r?(t.m=r[0]-1,n+r[0].length):-1}function Kb(t,e,n){var r=Ib.exec(e.slice(n,n+2));return r?(t.d=+r[0],n+r[0].length):-1}function Xb(t,e,n){var r=Ib.exec(e.slice(n,n+3));return r?(t.m=0,t.d=+r[0],n+r[0].length):-1}function Zb(t,e,n){var r=Ib.exec(e.slice(n,n+2));return r?(t.H=+r[0],n+r[0].length):-1}function Jb(t,e,n){var r=Ib.exec(e.slice(n,n+2));return r?(t.M=+r[0],n+r[0].length):-1}function Qb(t,e,n){var r=Ib.exec(e.slice(n,n+2));return r?(t.S=+r[0],n+r[0].length):-1}function tm(t,e,n){var r=Ib.exec(e.slice(n,n+3));return r?(t.L=+r[0],n+r[0].length):-1}function em(t,e,n){var r=Ib.exec(e.slice(n,n+6));return r?(t.L=Math.floor(r[0]/1e3),n+r[0].length):-1}function nm(t,e,n){var r=Nb.exec(e.slice(n,n+1));return r?n+r[0].length:-1}function rm(t,e,n){var r=Ib.exec(e.slice(n));return r?(t.Q=+r[0],n+r[0].length):-1}function im(t,e,n){var r=Ib.exec(e.slice(n));return r?(t.Q=1e3*+r[0],n+r[0].length):-1}function om(t,e){return Lb(t.getDate(),e,2)}function am(t,e){return Lb(t.getHours(),e,2)}function sm(t,e){return Lb(t.getHours()%12||12,e,2)}function um(t,e){return Lb(1+zy.count(vy(t),t),e,3)}function cm(t,e){return Lb(t.getMilliseconds(),e,3)}function fm(t,e){return cm(t,e)+"000"}function lm(t,e){return Lb(t.getMonth()+1,e,2)}function hm(t,e){return Lb(t.getMinutes(),e,2)}function dm(t,e){return Lb(t.getSeconds(),e,2)}function pm(t){var e=t.getDay();return 0===e?7:e}function gm(t,e){return Lb(Ty.count(vy(t),t),e,2)}function ym(t,e){var n=t.getDay();return t=n>=4||0===n?Oy(t):Oy.ceil(t),Lb(Oy.count(vy(t),t)+(4===vy(t).getDay()),e,2)}function bm(t){return t.getDay()}function mm(t,e){return Lb(My.count(vy(t),t),e,2)}function vm(t,e){return Lb(t.getFullYear()%100,e,2)}function _m(t,e){return Lb(t.getFullYear()%1e4,e,4)}function wm(t){var e=t.getTimezoneOffset();return(e>0?"-":(e*=-1,"+"))+Lb(e/60|0,"0",2)+Lb(e%60,"0",2)}function xm(t,e){return Lb(t.getUTCDate(),e,2)}function km(t,e){return Lb(t.getUTCHours(),e,2)}function Em(t,e){return Lb(t.getUTCHours()%12||12,e,2)}function Am(t,e){return Lb(1+mb.count(wb(t),t),e,3)}function Sm(t,e){return Lb(t.getUTCMilliseconds(),e,3)}function Tm(t,e){return Sm(t,e)+"000"}function Mm(t,e){return Lb(t.getUTCMonth()+1,e,2)}function Dm(t,e){return Lb(t.getUTCMinutes(),e,2)}function Cm(t,e){return Lb(t.getUTCSeconds(),e,2)}function Om(t){var e=t.getUTCDay();return 0===e?7:e}function Rm(t,e){return Lb(rb.count(wb(t),t),e,2)}function Im(t,e){var n=t.getUTCDay();return t=n>=4||0===n?sb(t):sb.ceil(t),Lb(sb.count(wb(t),t)+(4===wb(t).getUTCDay()),e,2)}function Nm(t){return t.getUTCDay()}function Bm(t,e){return Lb(ib.count(wb(t),t),e,2)}function Lm(t,e){return Lb(t.getUTCFullYear()%100,e,2)}function Pm(t,e){return Lb(t.getUTCFullYear()%1e4,e,4)}function Fm(){return"+0000"}function qm(){return"%"}function jm(t){return+t}function Um(t){return Math.floor(+t/1e3)}function zm(t){return Tb=Sb(t),Mb=Tb.format,Db=Tb.parse,Cb=Tb.utcFormat,Ob=Tb.utcParse,Tb}zm({dateTime:"%x, %X",date:"%-m/%-d/%Y",time:"%-I:%M:%S %p",periods:["AM","PM"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]});var Ym=Date.prototype.toISOString?function(t){return t.toISOString()}:Cb("%Y-%m-%dT%H:%M:%S.%LZ");var Vm=+new Date("2000-01-01T00:00:00.000Z")?function(t){var e=new Date(t);return isNaN(e)?null:e}:Ob("%Y-%m-%dT%H:%M:%S.%LZ"),Hm=1e3,$m=60*Hm,Gm=60*$m,Wm=24*Gm,Km=7*Wm,Xm=30*Wm,Zm=365*Wm;function Jm(t){return new Date(t)}function Qm(t){return t instanceof Date?+t:+new Date(+t)}function tv(t,e,n,r,o,a,s,u,c){var f=zg(Bg,Bg),l=f.invert,h=f.domain,d=c(".%L"),p=c(":%S"),g=c("%I:%M"),y=c("%I %p"),b=c("%a %d"),m=c("%b %d"),v=c("%B"),_=c("%Y"),w=[[s,1,Hm],[s,5,5*Hm],[s,15,15*Hm],[s,30,30*Hm],[a,1,$m],[a,5,5*$m],[a,15,15*$m],[a,30,30*$m],[o,1,Gm],[o,3,3*Gm],[o,6,6*Gm],[o,12,12*Gm],[r,1,Wm],[r,2,2*Wm],[n,1,Km],[e,1,Xm],[e,3,3*Xm],[t,1,Zm]];function x(i){return(s(i)<i?d:a(i)<i?p:o(i)<i?g:r(i)<i?y:e(i)<i?n(i)<i?b:m:t(i)<i?v:_)(i)}function k(e,n,r,o){if(null==e&&(e=10),"number"==typeof e){var a=Math.abs(r-n)/e,s=i((function(t){return t[2]})).right(w,a);s===w.length?(o=M(n/Zm,r/Zm,e),e=t):s?(o=(s=w[a/w[s-1][2]<w[s][2]/a?s-1:s])[1],e=s[0]):(o=Math.max(M(n,r,e),1),e=u)}return null==o?e:e.every(o)}return f.invert=function(t){return new Date(l(t))},f.domain=function(t){return arguments.length?h(Sg.call(t,Qm)):h().map(Jm)},f.ticks=function(t,e){var n,r=h(),i=r[0],o=r[r.length-1],a=o<i;return a&&(n=i,i=o,o=n),n=(n=k(t,i,o,e))?n.range(i,o+1):[],a?n.reverse():n},f.tickFormat=function(t,e){return null==e?x:c(e)},f.nice=function(t,e){var n=h();return(t=k(t,n[0],n[n.length-1],e))?h(Gg(n,t)):f},f.copy=function(){return jg(f,tv(t,e,n,r,o,a,s,u,c))},f}var ev=function(){return kg.apply(tv(vy,xy,Ty,zy,Hy,Wy,Zy,tb,Mb).domain([new Date(2e3,0,1),new Date(2e3,0,2)]),arguments)},nv=by((function(t){t.setUTCDate(1),t.setUTCHours(0,0,0,0)}),(function(t,e){t.setUTCMonth(t.getUTCMonth()+e)}),(function(t,e){return e.getUTCMonth()-t.getUTCMonth()+12*(e.getUTCFullYear()-t.getUTCFullYear())}),(function(t){return t.getUTCMonth()})),rv=nv,iv=nv.range,ov=by((function(t){t.setUTCMinutes(0,0,0)}),(function(t,e){t.setTime(+t+36e5*e)}),(function(t,e){return(e-t)/36e5}),(function(t){return t.getUTCHours()})),av=ov,sv=ov.range,uv=by((function(t){t.setUTCSeconds(0,0)}),(function(t,e){t.setTime(+t+e*Ey)}),(function(t,e){return(e-t)/Ey}),(function(t){return t.getUTCMinutes()})),cv=uv,fv=uv.range,lv=function(){return kg.apply(tv(wb,rv,rb,mb,av,cv,Zy,tb,Cb).domain([Date.UTC(2e3,0,1),Date.UTC(2e3,0,2)]),arguments)};function hv(){var t,e,n,r,i,o=0,a=1,s=Bg,u=!1;function c(e){return isNaN(e=+e)?i:s(0===n?.5:(e=(r(e)-t)*n,u?Math.max(0,Math.min(1,e)):e))}return c.domain=function(i){return arguments.length?(t=r(o=+i[0]),e=r(a=+i[1]),n=t===e?0:1/(e-t),c):[o,a]},c.clamp=function(t){return arguments.length?(u=!!t,c):u},c.interpolator=function(t){return arguments.length?(s=t,c):s},c.unknown=function(t){return arguments.length?(i=t,c):i},function(i){return r=i,t=i(o),e=i(a),n=t===e?0:1/(e-t),c}}function dv(t,e){return e.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown())}function pv(){var t=Vg(hv()(Bg));return t.copy=function(){return dv(t,pv())},Eg.apply(t,arguments)}function gv(){var t=ty(hv()).domain([1,10]);return t.copy=function(){return dv(t,gv()).base(t.base())},Eg.apply(t,arguments)}function yv(){var t=iy(hv());return t.copy=function(){return dv(t,yv()).constant(t.constant())},Eg.apply(t,arguments)}function bv(){var t=cy(hv());return t.copy=function(){return dv(t,bv()).exponent(t.exponent())},Eg.apply(t,arguments)}function mv(){return bv.apply(null,arguments).exponent(.5)}function vv(){var t=[],e=Bg;function n(n){if(!isNaN(n=+n))return e((u(t,n)-1)/(t.length-1))}return n.domain=function(e){if(!arguments.length)return t.slice();t=[];for(var i,o=0,a=e.length;o<a;++o)null==(i=e[o])||isNaN(i=+i)||t.push(i);return t.sort(r),n},n.interpolator=function(t){return arguments.length?(e=t,n):e},n.copy=function(){return vv(e).domain(t)},Eg.apply(n,arguments)}function _v(){var t,e,n,r,i,o,a,s=0,u=.5,c=1,f=Bg,l=!1;function h(t){return isNaN(t=+t)?a:(t=.5+((t=+o(t))-e)*(t<e?r:i),f(l?Math.max(0,Math.min(1,t)):t))}return h.domain=function(a){return arguments.length?(t=o(s=+a[0]),e=o(u=+a[1]),n=o(c=+a[2]),r=t===e?0:.5/(e-t),i=e===n?0:.5/(n-e),h):[s,u,c]},h.clamp=function(t){return arguments.length?(l=!!t,h):l},h.interpolator=function(t){return arguments.length?(f=t,h):f},h.unknown=function(t){return arguments.length?(a=t,h):a},function(a){return o=a,t=a(s),e=a(u),n=a(c),r=t===e?0:.5/(e-t),i=e===n?0:.5/(n-e),h}}function wv(){var t=Vg(_v()(Bg));return t.copy=function(){return dv(t,wv())},Eg.apply(t,arguments)}function xv(){var t=ty(_v()).domain([.1,1,10]);return t.copy=function(){return dv(t,xv()).base(t.base())},Eg.apply(t,arguments)}function kv(){var t=iy(_v());return t.copy=function(){return dv(t,kv()).constant(t.constant())},Eg.apply(t,arguments)}function Ev(){var t=cy(_v());return t.copy=function(){return dv(t,Ev()).exponent(t.exponent())},Eg.apply(t,arguments)}function Av(){return Ev.apply(null,arguments).exponent(.5)}var Sv=function(t){for(var e=t.length/6|0,n=new Array(e),r=0;r<e;)n[r]="#"+t.slice(6*r,6*++r);return n},Tv=Sv("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf"),Mv=Sv("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666"),Dv=Sv("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666"),Cv=Sv("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928"),Ov=Sv("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2"),Rv=Sv("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc"),Iv=Sv("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999"),Nv=Sv("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3"),Bv=Sv("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"),Lv=Sv("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab"),Pv=function(t){return Pn(t[t.length-1])},Fv=new Array(3).concat("d8b365f5f5f55ab4ac","a6611adfc27d80cdc1018571","a6611adfc27df5f5f580cdc1018571","8c510ad8b365f6e8c3c7eae55ab4ac01665e","8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e","8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e","8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e","5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30","5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30").map(Sv),qv=Pv(Fv),jv=new Array(3).concat("af8dc3f7f7f77fbf7b","7b3294c2a5cfa6dba0008837","7b3294c2a5cff7f7f7a6dba0008837","762a83af8dc3e7d4e8d9f0d37fbf7b1b7837","762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837","762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837","762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837","40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b","40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b").map(Sv),Uv=Pv(jv),zv=new Array(3).concat("e9a3c9f7f7f7a1d76a","d01c8bf1b6dab8e1864dac26","d01c8bf1b6daf7f7f7b8e1864dac26","c51b7de9a3c9fde0efe6f5d0a1d76a4d9221","c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221","c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221","c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221","8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419","8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419").map(Sv),Yv=Pv(zv),Vv=new Array(3).concat("998ec3f7f7f7f1a340","5e3c99b2abd2fdb863e66101","5e3c99b2abd2f7f7f7fdb863e66101","542788998ec3d8daebfee0b6f1a340b35806","542788998ec3d8daebf7f7f7fee0b6f1a340b35806","5427888073acb2abd2d8daebfee0b6fdb863e08214b35806","5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806","2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08","2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08").map(Sv),Hv=Pv(Vv),$v=new Array(3).concat("ef8a62f7f7f767a9cf","ca0020f4a58292c5de0571b0","ca0020f4a582f7f7f792c5de0571b0","b2182bef8a62fddbc7d1e5f067a9cf2166ac","b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac","b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac","b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac","67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061","67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061").map(Sv),Gv=Pv($v),Wv=new Array(3).concat("ef8a62ffffff999999","ca0020f4a582bababa404040","ca0020f4a582ffffffbababa404040","b2182bef8a62fddbc7e0e0e09999994d4d4d","b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d","b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d","b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d","67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a","67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a").map(Sv),Kv=Pv(Wv),Xv=new Array(3).concat("fc8d59ffffbf91bfdb","d7191cfdae61abd9e92c7bb6","d7191cfdae61ffffbfabd9e92c7bb6","d73027fc8d59fee090e0f3f891bfdb4575b4","d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4","d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4","d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4","a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695","a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695").map(Sv),Zv=Pv(Xv),Jv=new Array(3).concat("fc8d59ffffbf91cf60","d7191cfdae61a6d96a1a9641","d7191cfdae61ffffbfa6d96a1a9641","d73027fc8d59fee08bd9ef8b91cf601a9850","d73027fc8d59fee08bffffbfd9ef8b91cf601a9850","d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850","d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850","a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837","a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837").map(Sv),Qv=Pv(Jv),t_=new Array(3).concat("fc8d59ffffbf99d594","d7191cfdae61abdda42b83ba","d7191cfdae61ffffbfabdda42b83ba","d53e4ffc8d59fee08be6f59899d5943288bd","d53e4ffc8d59fee08bffffbfe6f59899d5943288bd","d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd","d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd","9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2","9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2").map(Sv),e_=Pv(t_),n_=new Array(3).concat("e5f5f999d8c92ca25f","edf8fbb2e2e266c2a4238b45","edf8fbb2e2e266c2a42ca25f006d2c","edf8fbccece699d8c966c2a42ca25f006d2c","edf8fbccece699d8c966c2a441ae76238b45005824","f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824","f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b").map(Sv),r_=Pv(n_),i_=new Array(3).concat("e0ecf49ebcda8856a7","edf8fbb3cde38c96c688419d","edf8fbb3cde38c96c68856a7810f7c","edf8fbbfd3e69ebcda8c96c68856a7810f7c","edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b","f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b","f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b").map(Sv),o_=Pv(i_),a_=new Array(3).concat("e0f3dba8ddb543a2ca","f0f9e8bae4bc7bccc42b8cbe","f0f9e8bae4bc7bccc443a2ca0868ac","f0f9e8ccebc5a8ddb57bccc443a2ca0868ac","f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e","f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e","f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081").map(Sv),s_=Pv(a_),u_=new Array(3).concat("fee8c8fdbb84e34a33","fef0d9fdcc8afc8d59d7301f","fef0d9fdcc8afc8d59e34a33b30000","fef0d9fdd49efdbb84fc8d59e34a33b30000","fef0d9fdd49efdbb84fc8d59ef6548d7301f990000","fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000","fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000").map(Sv),c_=Pv(u_),f_=new Array(3).concat("ece2f0a6bddb1c9099","f6eff7bdc9e167a9cf02818a","f6eff7bdc9e167a9cf1c9099016c59","f6eff7d0d1e6a6bddb67a9cf1c9099016c59","f6eff7d0d1e6a6bddb67a9cf3690c002818a016450","fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450","fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636").map(Sv),l_=Pv(f_),h_=new Array(3).concat("ece7f2a6bddb2b8cbe","f1eef6bdc9e174a9cf0570b0","f1eef6bdc9e174a9cf2b8cbe045a8d","f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d","f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b","fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b","fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858").map(Sv),d_=Pv(h_),p_=new Array(3).concat("e7e1efc994c7dd1c77","f1eef6d7b5d8df65b0ce1256","f1eef6d7b5d8df65b0dd1c77980043","f1eef6d4b9dac994c7df65b0dd1c77980043","f1eef6d4b9dac994c7df65b0e7298ace125691003f","f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f","f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f").map(Sv),g_=Pv(p_),y_=new Array(3).concat("fde0ddfa9fb5c51b8a","feebe2fbb4b9f768a1ae017e","feebe2fbb4b9f768a1c51b8a7a0177","feebe2fcc5c0fa9fb5f768a1c51b8a7a0177","feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177","fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177","fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a").map(Sv),b_=Pv(y_),m_=new Array(3).concat("edf8b17fcdbb2c7fb8","ffffcca1dab441b6c4225ea8","ffffcca1dab441b6c42c7fb8253494","ffffccc7e9b47fcdbb41b6c42c7fb8253494","ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84","ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84","ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58").map(Sv),v_=Pv(m_),__=new Array(3).concat("f7fcb9addd8e31a354","ffffccc2e69978c679238443","ffffccc2e69978c67931a354006837","ffffccd9f0a3addd8e78c67931a354006837","ffffccd9f0a3addd8e78c67941ab5d238443005a32","ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32","ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529").map(Sv),w_=Pv(__),x_=new Array(3).concat("fff7bcfec44fd95f0e","ffffd4fed98efe9929cc4c02","ffffd4fed98efe9929d95f0e993404","ffffd4fee391fec44ffe9929d95f0e993404","ffffd4fee391fec44ffe9929ec7014cc4c028c2d04","ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04","ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506").map(Sv),k_=Pv(x_),E_=new Array(3).concat("ffeda0feb24cf03b20","ffffb2fecc5cfd8d3ce31a1c","ffffb2fecc5cfd8d3cf03b20bd0026","ffffb2fed976feb24cfd8d3cf03b20bd0026","ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026","ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026","ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026").map(Sv),A_=Pv(E_),S_=new Array(3).concat("deebf79ecae13182bd","eff3ffbdd7e76baed62171b5","eff3ffbdd7e76baed63182bd08519c","eff3ffc6dbef9ecae16baed63182bd08519c","eff3ffc6dbef9ecae16baed64292c62171b5084594","f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594","f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b").map(Sv),T_=Pv(S_),M_=new Array(3).concat("e5f5e0a1d99b31a354","edf8e9bae4b374c476238b45","edf8e9bae4b374c47631a354006d2c","edf8e9c7e9c0a1d99b74c47631a354006d2c","edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32","f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32","f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b").map(Sv),D_=Pv(M_),C_=new Array(3).concat("f0f0f0bdbdbd636363","f7f7f7cccccc969696525252","f7f7f7cccccc969696636363252525","f7f7f7d9d9d9bdbdbd969696636363252525","f7f7f7d9d9d9bdbdbd969696737373525252252525","fffffff0f0f0d9d9d9bdbdbd969696737373525252252525","fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000").map(Sv),O_=Pv(C_),R_=new Array(3).concat("efedf5bcbddc756bb1","f2f0f7cbc9e29e9ac86a51a3","f2f0f7cbc9e29e9ac8756bb154278f","f2f0f7dadaebbcbddc9e9ac8756bb154278f","f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486","fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486","fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d").map(Sv),I_=Pv(R_),N_=new Array(3).concat("fee0d2fc9272de2d26","fee5d9fcae91fb6a4acb181d","fee5d9fcae91fb6a4ade2d26a50f15","fee5d9fcbba1fc9272fb6a4ade2d26a50f15","fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d","fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d","fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d").map(Sv),B_=Pv(N_),L_=new Array(3).concat("fee6cefdae6be6550d","feeddefdbe85fd8d3cd94701","feeddefdbe85fd8d3ce6550da63603","feeddefdd0a2fdae6bfd8d3ce6550da63603","feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04","fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04","fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704").map(Sv),P_=Pv(L_),F_=function(t){return t=Math.max(0,Math.min(1,t)),"rgb("+Math.max(0,Math.min(255,Math.round(-4.54-t*(35.34-t*(2381.73-t*(6402.7-t*(7024.72-2710.57*t)))))))+", "+Math.max(0,Math.min(255,Math.round(32.49+t*(170.73+t*(52.82-t*(131.46-t*(176.58-67.37*t)))))))+", "+Math.max(0,Math.min(255,Math.round(81.24+t*(442.36-t*(2482.43-t*(6167.24-t*(6614.94-2475.67*t)))))))+")"},q_=Wr(Vr(300,.5,0),Vr(-240,.5,1)),j_=Wr(Vr(-100,.75,.35),Vr(80,1.5,.8)),U_=Wr(Vr(260,.75,.35),Vr(80,1.5,.8)),z_=Vr(),Y_=function(t){(t<0||t>1)&&(t-=Math.floor(t));var e=Math.abs(t-.5);return z_.h=360*t-100,z_.s=1.5-1.5*e,z_.l=.8-.9*e,z_+""},V_=bn(),H_=Math.PI/3,$_=2*Math.PI/3,G_=function(t){var e;return t=(.5-t)*Math.PI,V_.r=255*(e=Math.sin(t))*e,V_.g=255*(e=Math.sin(t+H_))*e,V_.b=255*(e=Math.sin(t+$_))*e,V_+""},W_=function(t){return t=Math.max(0,Math.min(1,t)),"rgb("+Math.max(0,Math.min(255,Math.round(34.61+t*(1172.33-t*(10793.56-t*(33300.12-t*(38394.49-14825.05*t)))))))+", "+Math.max(0,Math.min(255,Math.round(23.31+t*(557.33+t*(1225.33-t*(3574.96-t*(1073.77+707.56*t)))))))+", "+Math.max(0,Math.min(255,Math.round(27.2+t*(3211.1-t*(15327.97-t*(27814-t*(22569.18-6838.66*t)))))))+")"};function K_(t){var e=t.length;return function(n){return t[Math.max(0,Math.min(e-1,Math.floor(n*e)))]}}var X_=K_(Sv("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")),Z_=K_(Sv("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf")),J_=K_(Sv("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")),Q_=K_(Sv("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921")),tw=function(t){return function(){return t}},ew=Math.abs,nw=Math.atan2,rw=Math.cos,iw=Math.max,ow=Math.min,aw=Math.sin,sw=Math.sqrt,uw=1e-12,cw=Math.PI,fw=cw/2,lw=2*cw;function hw(t){return t>=1?fw:t<=-1?-fw:Math.asin(t)}function dw(t){return t.innerRadius}function pw(t){return t.outerRadius}function gw(t){return t.startAngle}function yw(t){return t.endAngle}function bw(t){return t&&t.padAngle}function mw(t,e,n,r,i,o,a){var s=t-n,u=e-r,c=(a?o:-o)/sw(s*s+u*u),f=c*u,l=-c*s,h=t+f,d=e+l,p=n+f,g=r+l,y=(h+p)/2,b=(d+g)/2,m=p-h,v=g-d,_=m*m+v*v,w=i-o,x=h*g-p*d,k=(v<0?-1:1)*sw(iw(0,w*w*_-x*x)),E=(x*v-m*k)/_,A=(-x*m-v*k)/_,S=(x*v+m*k)/_,T=(-x*m+v*k)/_,M=E-y,D=A-b,C=S-y,O=T-b;return M*M+D*D>C*C+O*O&&(E=S,A=T),{cx:E,cy:A,x01:-f,y01:-l,x11:E*(i/w-1),y11:A*(i/w-1)}}var vw=function(){var t=dw,e=pw,n=tw(0),r=null,i=gw,o=yw,a=bw,s=null;function u(){var u,c,f,l=+t.apply(this,arguments),h=+e.apply(this,arguments),d=i.apply(this,arguments)-fw,p=o.apply(this,arguments)-fw,g=ew(p-d),y=p>d;if(s||(s=u=qa()),h<l&&(c=h,h=l,l=c),h>uw)if(g>lw-uw)s.moveTo(h*rw(d),h*aw(d)),s.arc(0,0,h,d,p,!y),l>uw&&(s.moveTo(l*rw(p),l*aw(p)),s.arc(0,0,l,p,d,y));else{var b,m,v=d,_=p,w=d,x=p,k=g,E=g,A=a.apply(this,arguments)/2,S=A>uw&&(r?+r.apply(this,arguments):sw(l*l+h*h)),T=ow(ew(h-l)/2,+n.apply(this,arguments)),M=T,D=T;if(S>uw){var C=hw(S/l*aw(A)),O=hw(S/h*aw(A));(k-=2*C)>uw?(w+=C*=y?1:-1,x-=C):(k=0,w=x=(d+p)/2),(E-=2*O)>uw?(v+=O*=y?1:-1,_-=O):(E=0,v=_=(d+p)/2)}var R=h*rw(v),I=h*aw(v),N=l*rw(x),B=l*aw(x);if(T>uw){var L,P=h*rw(_),F=h*aw(_),q=l*rw(w),j=l*aw(w);if(g<cw&&(L=function(t,e,n,r,i,o,a,s){var u=n-t,c=r-e,f=a-i,l=s-o,h=l*u-f*c;if(!(h*h<uw))return[t+(h=(f*(e-o)-l*(t-i))/h)*u,e+h*c]}(R,I,q,j,P,F,N,B))){var U=R-L[0],z=I-L[1],Y=P-L[0],V=F-L[1],H=1/aw(((f=(U*Y+z*V)/(sw(U*U+z*z)*sw(Y*Y+V*V)))>1?0:f<-1?cw:Math.acos(f))/2),$=sw(L[0]*L[0]+L[1]*L[1]);M=ow(T,(l-$)/(H-1)),D=ow(T,(h-$)/(H+1))}}E>uw?D>uw?(b=mw(q,j,R,I,h,D,y),m=mw(P,F,N,B,h,D,y),s.moveTo(b.cx+b.x01,b.cy+b.y01),D<T?s.arc(b.cx,b.cy,D,nw(b.y01,b.x01),nw(m.y01,m.x01),!y):(s.arc(b.cx,b.cy,D,nw(b.y01,b.x01),nw(b.y11,b.x11),!y),s.arc(0,0,h,nw(b.cy+b.y11,b.cx+b.x11),nw(m.cy+m.y11,m.cx+m.x11),!y),s.arc(m.cx,m.cy,D,nw(m.y11,m.x11),nw(m.y01,m.x01),!y))):(s.moveTo(R,I),s.arc(0,0,h,v,_,!y)):s.moveTo(R,I),l>uw&&k>uw?M>uw?(b=mw(N,B,P,F,l,-M,y),m=mw(R,I,q,j,l,-M,y),s.lineTo(b.cx+b.x01,b.cy+b.y01),M<T?s.arc(b.cx,b.cy,M,nw(b.y01,b.x01),nw(m.y01,m.x01),!y):(s.arc(b.cx,b.cy,M,nw(b.y01,b.x01),nw(b.y11,b.x11),!y),s.arc(0,0,l,nw(b.cy+b.y11,b.cx+b.x11),nw(m.cy+m.y11,m.cx+m.x11),y),s.arc(m.cx,m.cy,M,nw(m.y11,m.x11),nw(m.y01,m.x01),!y))):s.arc(0,0,l,x,w,y):s.lineTo(N,B)}else s.moveTo(0,0);if(s.closePath(),u)return s=null,u+""||null}return u.centroid=function(){var n=(+t.apply(this,arguments)+ +e.apply(this,arguments))/2,r=(+i.apply(this,arguments)+ +o.apply(this,arguments))/2-cw/2;return[rw(r)*n,aw(r)*n]},u.innerRadius=function(e){return arguments.length?(t="function"==typeof e?e:tw(+e),u):t},u.outerRadius=function(t){return arguments.length?(e="function"==typeof t?t:tw(+t),u):e},u.cornerRadius=function(t){return arguments.length?(n="function"==typeof t?t:tw(+t),u):n},u.padRadius=function(t){return arguments.length?(r=null==t?null:"function"==typeof t?t:tw(+t),u):r},u.startAngle=function(t){return arguments.length?(i="function"==typeof t?t:tw(+t),u):i},u.endAngle=function(t){return arguments.length?(o="function"==typeof t?t:tw(+t),u):o},u.padAngle=function(t){return arguments.length?(a="function"==typeof t?t:tw(+t),u):a},u.context=function(t){return arguments.length?(s=null==t?null:t,u):s},u};function _w(t){this._context=t}_w.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._point=0},lineEnd:function(){(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,e){switch(t=+t,e=+e,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,e):this._context.moveTo(t,e);break;case 1:this._point=2;default:this._context.lineTo(t,e)}}};var ww=function(t){return new _w(t)};function xw(t){return t[0]}function kw(t){return t[1]}var Ew=function(){var t=xw,e=kw,n=tw(!0),r=null,i=ww,o=null;function a(a){var s,u,c,f=a.length,l=!1;for(null==r&&(o=i(c=qa())),s=0;s<=f;++s)!(s<f&&n(u=a[s],s,a))===l&&((l=!l)?o.lineStart():o.lineEnd()),l&&o.point(+t(u,s,a),+e(u,s,a));if(c)return o=null,c+""||null}return a.x=function(e){return arguments.length?(t="function"==typeof e?e:tw(+e),a):t},a.y=function(t){return arguments.length?(e="function"==typeof t?t:tw(+t),a):e},a.defined=function(t){return arguments.length?(n="function"==typeof t?t:tw(!!t),a):n},a.curve=function(t){return arguments.length?(i=t,null!=r&&(o=i(r)),a):i},a.context=function(t){return arguments.length?(null==t?r=o=null:o=i(r=t),a):r},a},Aw=function(){var t=xw,e=null,n=tw(0),r=kw,i=tw(!0),o=null,a=ww,s=null;function u(u){var c,f,l,h,d,p=u.length,g=!1,y=new Array(p),b=new Array(p);for(null==o&&(s=a(d=qa())),c=0;c<=p;++c){if(!(c<p&&i(h=u[c],c,u))===g)if(g=!g)f=c,s.areaStart(),s.lineStart();else{for(s.lineEnd(),s.lineStart(),l=c-1;l>=f;--l)s.point(y[l],b[l]);s.lineEnd(),s.areaEnd()}g&&(y[c]=+t(h,c,u),b[c]=+n(h,c,u),s.point(e?+e(h,c,u):y[c],r?+r(h,c,u):b[c]))}if(d)return s=null,d+""||null}function c(){return Ew().defined(i).curve(a).context(o)}return u.x=function(n){return arguments.length?(t="function"==typeof n?n:tw(+n),e=null,u):t},u.x0=function(e){return arguments.length?(t="function"==typeof e?e:tw(+e),u):t},u.x1=function(t){return arguments.length?(e=null==t?null:"function"==typeof t?t:tw(+t),u):e},u.y=function(t){return arguments.length?(n="function"==typeof t?t:tw(+t),r=null,u):n},u.y0=function(t){return arguments.length?(n="function"==typeof t?t:tw(+t),u):n},u.y1=function(t){return arguments.length?(r=null==t?null:"function"==typeof t?t:tw(+t),u):r},u.lineX0=u.lineY0=function(){return c().x(t).y(n)},u.lineY1=function(){return c().x(t).y(r)},u.lineX1=function(){return c().x(e).y(n)},u.defined=function(t){return arguments.length?(i="function"==typeof t?t:tw(!!t),u):i},u.curve=function(t){return arguments.length?(a=t,null!=o&&(s=a(o)),u):a},u.context=function(t){return arguments.length?(null==t?o=s=null:s=a(o=t),u):o},u},Sw=function(t,e){return e<t?-1:e>t?1:e>=t?0:NaN},Tw=function(t){return t},Mw=function(){var t=Tw,e=Sw,n=null,r=tw(0),i=tw(lw),o=tw(0);function a(a){var s,u,c,f,l,h=a.length,d=0,p=new Array(h),g=new Array(h),y=+r.apply(this,arguments),b=Math.min(lw,Math.max(-lw,i.apply(this,arguments)-y)),m=Math.min(Math.abs(b)/h,o.apply(this,arguments)),v=m*(b<0?-1:1);for(s=0;s<h;++s)(l=g[p[s]=s]=+t(a[s],s,a))>0&&(d+=l);for(null!=e?p.sort((function(t,n){return e(g[t],g[n])})):null!=n&&p.sort((function(t,e){return n(a[t],a[e])})),s=0,c=d?(b-h*v)/d:0;s<h;++s,y=f)u=p[s],f=y+((l=g[u])>0?l*c:0)+v,g[u]={data:a[u],index:s,value:l,startAngle:y,endAngle:f,padAngle:m};return g}return a.value=function(e){return arguments.length?(t="function"==typeof e?e:tw(+e),a):t},a.sortValues=function(t){return arguments.length?(e=t,n=null,a):e},a.sort=function(t){return arguments.length?(n=t,e=null,a):n},a.startAngle=function(t){return arguments.length?(r="function"==typeof t?t:tw(+t),a):r},a.endAngle=function(t){return arguments.length?(i="function"==typeof t?t:tw(+t),a):i},a.padAngle=function(t){return arguments.length?(o="function"==typeof t?t:tw(+t),a):o},a},Dw=Ow(ww);function Cw(t){this._curve=t}function Ow(t){function e(e){return new Cw(t(e))}return e._curve=t,e}function Rw(t){var e=t.curve;return t.angle=t.x,delete t.x,t.radius=t.y,delete t.y,t.curve=function(t){return arguments.length?e(Ow(t)):e()._curve},t}Cw.prototype={areaStart:function(){this._curve.areaStart()},areaEnd:function(){this._curve.areaEnd()},lineStart:function(){this._curve.lineStart()},lineEnd:function(){this._curve.lineEnd()},point:function(t,e){this._curve.point(e*Math.sin(t),e*-Math.cos(t))}};var Iw=function(){return Rw(Ew().curve(Dw))},Nw=function(){var t=Aw().curve(Dw),e=t.curve,n=t.lineX0,r=t.lineX1,i=t.lineY0,o=t.lineY1;return t.angle=t.x,delete t.x,t.startAngle=t.x0,delete t.x0,t.endAngle=t.x1,delete t.x1,t.radius=t.y,delete t.y,t.innerRadius=t.y0,delete t.y0,t.outerRadius=t.y1,delete t.y1,t.lineStartAngle=function(){return Rw(n())},delete t.lineX0,t.lineEndAngle=function(){return Rw(r())},delete t.lineX1,t.lineInnerRadius=function(){return Rw(i())},delete t.lineY0,t.lineOuterRadius=function(){return Rw(o())},delete t.lineY1,t.curve=function(t){return arguments.length?e(Ow(t)):e()._curve},t},Bw=function(t,e){return[(e=+e)*Math.cos(t-=Math.PI/2),e*Math.sin(t)]},Lw=Array.prototype.slice;function Pw(t){return t.source}function Fw(t){return t.target}function qw(t){var e=Pw,n=Fw,r=xw,i=kw,o=null;function a(){var a,s=Lw.call(arguments),u=e.apply(this,s),c=n.apply(this,s);if(o||(o=a=qa()),t(o,+r.apply(this,(s[0]=u,s)),+i.apply(this,s),+r.apply(this,(s[0]=c,s)),+i.apply(this,s)),a)return o=null,a+""||null}return a.source=function(t){return arguments.length?(e=t,a):e},a.target=function(t){return arguments.length?(n=t,a):n},a.x=function(t){return arguments.length?(r="function"==typeof t?t:tw(+t),a):r},a.y=function(t){return arguments.length?(i="function"==typeof t?t:tw(+t),a):i},a.context=function(t){return arguments.length?(o=null==t?null:t,a):o},a}function jw(t,e,n,r,i){t.moveTo(e,n),t.bezierCurveTo(e=(e+r)/2,n,e,i,r,i)}function Uw(t,e,n,r,i){t.moveTo(e,n),t.bezierCurveTo(e,n=(n+i)/2,r,n,r,i)}function zw(t,e,n,r,i){var o=Bw(e,n),a=Bw(e,n=(n+i)/2),s=Bw(r,n),u=Bw(r,i);t.moveTo(o[0],o[1]),t.bezierCurveTo(a[0],a[1],s[0],s[1],u[0],u[1])}function Yw(){return qw(jw)}function Vw(){return qw(Uw)}function Hw(){var t=qw(zw);return t.angle=t.x,delete t.x,t.radius=t.y,delete t.y,t}var $w={draw:function(t,e){var n=Math.sqrt(e/cw);t.moveTo(n,0),t.arc(0,0,n,0,lw)}},Gw={draw:function(t,e){var n=Math.sqrt(e/5)/2;t.moveTo(-3*n,-n),t.lineTo(-n,-n),t.lineTo(-n,-3*n),t.lineTo(n,-3*n),t.lineTo(n,-n),t.lineTo(3*n,-n),t.lineTo(3*n,n),t.lineTo(n,n),t.lineTo(n,3*n),t.lineTo(-n,3*n),t.lineTo(-n,n),t.lineTo(-3*n,n),t.closePath()}},Ww=Math.sqrt(1/3),Kw=2*Ww,Xw={draw:function(t,e){var n=Math.sqrt(e/Kw),r=n*Ww;t.moveTo(0,-n),t.lineTo(r,0),t.lineTo(0,n),t.lineTo(-r,0),t.closePath()}},Zw=Math.sin(cw/10)/Math.sin(7*cw/10),Jw=Math.sin(lw/10)*Zw,Qw=-Math.cos(lw/10)*Zw,tx={draw:function(t,e){var n=Math.sqrt(.8908130915292852*e),r=Jw*n,i=Qw*n;t.moveTo(0,-n),t.lineTo(r,i);for(var o=1;o<5;++o){var a=lw*o/5,s=Math.cos(a),u=Math.sin(a);t.lineTo(u*n,-s*n),t.lineTo(s*r-u*i,u*r+s*i)}t.closePath()}},ex={draw:function(t,e){var n=Math.sqrt(e),r=-n/2;t.rect(r,r,n,n)}},nx=Math.sqrt(3),rx={draw:function(t,e){var n=-Math.sqrt(e/(3*nx));t.moveTo(0,2*n),t.lineTo(-nx*n,-n),t.lineTo(nx*n,-n),t.closePath()}},ix=Math.sqrt(3)/2,ox=1/Math.sqrt(12),ax=3*(ox/2+1),sx={draw:function(t,e){var n=Math.sqrt(e/ax),r=n/2,i=n*ox,o=r,a=n*ox+n,s=-o,u=a;t.moveTo(r,i),t.lineTo(o,a),t.lineTo(s,u),t.lineTo(-.5*r-ix*i,ix*r+-.5*i),t.lineTo(-.5*o-ix*a,ix*o+-.5*a),t.lineTo(-.5*s-ix*u,ix*s+-.5*u),t.lineTo(-.5*r+ix*i,-.5*i-ix*r),t.lineTo(-.5*o+ix*a,-.5*a-ix*o),t.lineTo(-.5*s+ix*u,-.5*u-ix*s),t.closePath()}},ux=[$w,Gw,Xw,ex,tx,rx,sx],cx=function(){var t=tw($w),e=tw(64),n=null;function r(){var r;if(n||(n=r=qa()),t.apply(this,arguments).draw(n,+e.apply(this,arguments)),r)return n=null,r+""||null}return r.type=function(e){return arguments.length?(t="function"==typeof e?e:tw(e),r):t},r.size=function(t){return arguments.length?(e="function"==typeof t?t:tw(+t),r):e},r.context=function(t){return arguments.length?(n=null==t?null:t,r):n},r},fx=function(){};function lx(t,e,n){t._context.bezierCurveTo((2*t._x0+t._x1)/3,(2*t._y0+t._y1)/3,(t._x0+2*t._x1)/3,(t._y0+2*t._y1)/3,(t._x0+4*t._x1+e)/6,(t._y0+4*t._y1+n)/6)}function hx(t){this._context=t}hx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){switch(this._point){case 3:lx(this,this._x1,this._y1);case 2:this._context.lineTo(this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,e){switch(t=+t,e=+e,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,e):this._context.moveTo(t,e);break;case 1:this._point=2;break;case 2:this._point=3,this._context.lineTo((5*this._x0+this._x1)/6,(5*this._y0+this._y1)/6);default:lx(this,t,e)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=e}};var dx=function(t){return new hx(t)};function px(t){this._context=t}px.prototype={areaStart:fx,areaEnd:fx,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._y0=this._y1=this._y2=this._y3=this._y4=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x2,this._y2),this._context.closePath();break;case 2:this._context.moveTo((this._x2+2*this._x3)/3,(this._y2+2*this._y3)/3),this._context.lineTo((this._x3+2*this._x2)/3,(this._y3+2*this._y2)/3),this._context.closePath();break;case 3:this.point(this._x2,this._y2),this.point(this._x3,this._y3),this.point(this._x4,this._y4)}},point:function(t,e){switch(t=+t,e=+e,this._point){case 0:this._point=1,this._x2=t,this._y2=e;break;case 1:this._point=2,this._x3=t,this._y3=e;break;case 2:this._point=3,this._x4=t,this._y4=e,this._context.moveTo((this._x0+4*this._x1+t)/6,(this._y0+4*this._y1+e)/6);break;default:lx(this,t,e)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=e}};var gx=function(t){return new px(t)};function yx(t){this._context=t}yx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,e){switch(t=+t,e=+e,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3;var n=(this._x0+4*this._x1+t)/6,r=(this._y0+4*this._y1+e)/6;this._line?this._context.lineTo(n,r):this._context.moveTo(n,r);break;case 3:this._point=4;default:lx(this,t,e)}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=e}};var bx=function(t){return new yx(t)};function mx(t,e){this._basis=new hx(t),this._beta=e}mx.prototype={lineStart:function(){this._x=[],this._y=[],this._basis.lineStart()},lineEnd:function(){var t=this._x,e=this._y,n=t.length-1;if(n>0)for(var r,i=t[0],o=e[0],a=t[n]-i,s=e[n]-o,u=-1;++u<=n;)r=u/n,this._basis.point(this._beta*t[u]+(1-this._beta)*(i+r*a),this._beta*e[u]+(1-this._beta)*(o+r*s));this._x=this._y=null,this._basis.lineEnd()},point:function(t,e){this._x.push(+t),this._y.push(+e)}};var vx=function t(e){function n(t){return 1===e?new hx(t):new mx(t,e)}return n.beta=function(e){return t(+e)},n}(.85);function _x(t,e,n){t._context.bezierCurveTo(t._x1+t._k*(t._x2-t._x0),t._y1+t._k*(t._y2-t._y0),t._x2+t._k*(t._x1-e),t._y2+t._k*(t._y1-n),t._x2,t._y2)}function wx(t,e){this._context=t,this._k=(1-e)/6}wx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:_x(this,this._x1,this._y1)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,e){switch(t=+t,e=+e,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,e):this._context.moveTo(t,e);break;case 1:this._point=2,this._x1=t,this._y1=e;break;case 2:this._point=3;default:_x(this,t,e)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=e}};var xx=function t(e){function n(t){return new wx(t,e)}return n.tension=function(e){return t(+e)},n}(0);function kx(t,e){this._context=t,this._k=(1-e)/6}kx.prototype={areaStart:fx,areaEnd:fx,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,e){switch(t=+t,e=+e,this._point){case 0:this._point=1,this._x3=t,this._y3=e;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=e);break;case 2:this._point=3,this._x5=t,this._y5=e;break;default:_x(this,t,e)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=e}};var Ex=function t(e){function n(t){return new kx(t,e)}return n.tension=function(e){return t(+e)},n}(0);function Ax(t,e){this._context=t,this._k=(1-e)/6}Ax.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,e){switch(t=+t,e=+e,this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:_x(this,t,e)}this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=e}};var Sx=function t(e){function n(t){return new Ax(t,e)}return n.tension=function(e){return t(+e)},n}(0);function Tx(t,e,n){var r=t._x1,i=t._y1,o=t._x2,a=t._y2;if(t._l01_a>uw){var s=2*t._l01_2a+3*t._l01_a*t._l12_a+t._l12_2a,u=3*t._l01_a*(t._l01_a+t._l12_a);r=(r*s-t._x0*t._l12_2a+t._x2*t._l01_2a)/u,i=(i*s-t._y0*t._l12_2a+t._y2*t._l01_2a)/u}if(t._l23_a>uw){var c=2*t._l23_2a+3*t._l23_a*t._l12_a+t._l12_2a,f=3*t._l23_a*(t._l23_a+t._l12_a);o=(o*c+t._x1*t._l23_2a-e*t._l12_2a)/f,a=(a*c+t._y1*t._l23_2a-n*t._l12_2a)/f}t._context.bezierCurveTo(r,i,o,a,t._x2,t._y2)}function Mx(t,e){this._context=t,this._alpha=e}Mx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x2,this._y2);break;case 3:this.point(this._x2,this._y2)}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,e){if(t=+t,e=+e,this._point){var n=this._x2-t,r=this._y2-e;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(n*n+r*r,this._alpha))}switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,e):this._context.moveTo(t,e);break;case 1:this._point=2;break;case 2:this._point=3;default:Tx(this,t,e)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=e}};var Dx=function t(e){function n(t){return e?new Mx(t,e):new wx(t,0)}return n.alpha=function(e){return t(+e)},n}(.5);function Cx(t,e){this._context=t,this._alpha=e}Cx.prototype={areaStart:fx,areaEnd:fx,lineStart:function(){this._x0=this._x1=this._x2=this._x3=this._x4=this._x5=this._y0=this._y1=this._y2=this._y3=this._y4=this._y5=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){switch(this._point){case 1:this._context.moveTo(this._x3,this._y3),this._context.closePath();break;case 2:this._context.lineTo(this._x3,this._y3),this._context.closePath();break;case 3:this.point(this._x3,this._y3),this.point(this._x4,this._y4),this.point(this._x5,this._y5)}},point:function(t,e){if(t=+t,e=+e,this._point){var n=this._x2-t,r=this._y2-e;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(n*n+r*r,this._alpha))}switch(this._point){case 0:this._point=1,this._x3=t,this._y3=e;break;case 1:this._point=2,this._context.moveTo(this._x4=t,this._y4=e);break;case 2:this._point=3,this._x5=t,this._y5=e;break;default:Tx(this,t,e)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=e}};var Ox=function t(e){function n(t){return e?new Cx(t,e):new kx(t,0)}return n.alpha=function(e){return t(+e)},n}(.5);function Rx(t,e){this._context=t,this._alpha=e}Rx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._x2=this._y0=this._y1=this._y2=NaN,this._l01_a=this._l12_a=this._l23_a=this._l01_2a=this._l12_2a=this._l23_2a=this._point=0},lineEnd:function(){(this._line||0!==this._line&&3===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,e){if(t=+t,e=+e,this._point){var n=this._x2-t,r=this._y2-e;this._l23_a=Math.sqrt(this._l23_2a=Math.pow(n*n+r*r,this._alpha))}switch(this._point){case 0:this._point=1;break;case 1:this._point=2;break;case 2:this._point=3,this._line?this._context.lineTo(this._x2,this._y2):this._context.moveTo(this._x2,this._y2);break;case 3:this._point=4;default:Tx(this,t,e)}this._l01_a=this._l12_a,this._l12_a=this._l23_a,this._l01_2a=this._l12_2a,this._l12_2a=this._l23_2a,this._x0=this._x1,this._x1=this._x2,this._x2=t,this._y0=this._y1,this._y1=this._y2,this._y2=e}};var Ix=function t(e){function n(t){return e?new Rx(t,e):new Ax(t,0)}return n.alpha=function(e){return t(+e)},n}(.5);function Nx(t){this._context=t}Nx.prototype={areaStart:fx,areaEnd:fx,lineStart:function(){this._point=0},lineEnd:function(){this._point&&this._context.closePath()},point:function(t,e){t=+t,e=+e,this._point?this._context.lineTo(t,e):(this._point=1,this._context.moveTo(t,e))}};var Bx=function(t){return new Nx(t)};function Lx(t){return t<0?-1:1}function Px(t,e,n){var r=t._x1-t._x0,i=e-t._x1,o=(t._y1-t._y0)/(r||i<0&&-0),a=(n-t._y1)/(i||r<0&&-0),s=(o*i+a*r)/(r+i);return(Lx(o)+Lx(a))*Math.min(Math.abs(o),Math.abs(a),.5*Math.abs(s))||0}function Fx(t,e){var n=t._x1-t._x0;return n?(3*(t._y1-t._y0)/n-e)/2:e}function qx(t,e,n){var r=t._x0,i=t._y0,o=t._x1,a=t._y1,s=(o-r)/3;t._context.bezierCurveTo(r+s,i+s*e,o-s,a-s*n,o,a)}function jx(t){this._context=t}function Ux(t){this._context=new zx(t)}function zx(t){this._context=t}function Yx(t){return new jx(t)}function Vx(t){return new Ux(t)}function Hx(t){this._context=t}function $x(t){var e,n,r=t.length-1,i=new Array(r),o=new Array(r),a=new Array(r);for(i[0]=0,o[0]=2,a[0]=t[0]+2*t[1],e=1;e<r-1;++e)i[e]=1,o[e]=4,a[e]=4*t[e]+2*t[e+1];for(i[r-1]=2,o[r-1]=7,a[r-1]=8*t[r-1]+t[r],e=1;e<r;++e)n=i[e]/o[e-1],o[e]-=n,a[e]-=n*a[e-1];for(i[r-1]=a[r-1]/o[r-1],e=r-2;e>=0;--e)i[e]=(a[e]-i[e+1])/o[e];for(o[r-1]=(t[r]+i[r-1])/2,e=0;e<r-1;++e)o[e]=2*t[e+1]-i[e+1];return[i,o]}jx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x0=this._x1=this._y0=this._y1=this._t0=NaN,this._point=0},lineEnd:function(){switch(this._point){case 2:this._context.lineTo(this._x1,this._y1);break;case 3:qx(this,this._t0,Fx(this,this._t0))}(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line=1-this._line},point:function(t,e){var n=NaN;if(e=+e,(t=+t)!==this._x1||e!==this._y1){switch(this._point){case 0:this._point=1,this._line?this._context.lineTo(t,e):this._context.moveTo(t,e);break;case 1:this._point=2;break;case 2:this._point=3,qx(this,Fx(this,n=Px(this,t,e)),n);break;default:qx(this,this._t0,n=Px(this,t,e))}this._x0=this._x1,this._x1=t,this._y0=this._y1,this._y1=e,this._t0=n}}},(Ux.prototype=Object.create(jx.prototype)).point=function(t,e){jx.prototype.point.call(this,e,t)},zx.prototype={moveTo:function(t,e){this._context.moveTo(e,t)},closePath:function(){this._context.closePath()},lineTo:function(t,e){this._context.lineTo(e,t)},bezierCurveTo:function(t,e,n,r,i,o){this._context.bezierCurveTo(e,t,r,n,o,i)}},Hx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=[],this._y=[]},lineEnd:function(){var t=this._x,e=this._y,n=t.length;if(n)if(this._line?this._context.lineTo(t[0],e[0]):this._context.moveTo(t[0],e[0]),2===n)this._context.lineTo(t[1],e[1]);else for(var r=$x(t),i=$x(e),o=0,a=1;a<n;++o,++a)this._context.bezierCurveTo(r[0][o],i[0][o],r[1][o],i[1][o],t[a],e[a]);(this._line||0!==this._line&&1===n)&&this._context.closePath(),this._line=1-this._line,this._x=this._y=null},point:function(t,e){this._x.push(+t),this._y.push(+e)}};var Gx=function(t){return new Hx(t)};function Wx(t,e){this._context=t,this._t=e}Wx.prototype={areaStart:function(){this._line=0},areaEnd:function(){this._line=NaN},lineStart:function(){this._x=this._y=NaN,this._point=0},lineEnd:function(){0<this._t&&this._t<1&&2===this._point&&this._context.lineTo(this._x,this._y),(this._line||0!==this._line&&1===this._point)&&this._context.closePath(),this._line>=0&&(this._t=1-this._t,this._line=1-this._line)},point:function(t,e){switch(t=+t,e=+e,this._point){case 0:this._point=1,this._line?this._context.lineTo(t,e):this._context.moveTo(t,e);break;case 1:this._point=2;default:if(this._t<=0)this._context.lineTo(this._x,e),this._context.lineTo(t,e);else{var n=this._x*(1-this._t)+t*this._t;this._context.lineTo(n,this._y),this._context.lineTo(n,e)}}this._x=t,this._y=e}};var Kx=function(t){return new Wx(t,.5)};function Xx(t){return new Wx(t,0)}function Zx(t){return new Wx(t,1)}var Jx=function(t,e){if((i=t.length)>1)for(var n,r,i,o=1,a=t[e[0]],s=a.length;o<i;++o)for(r=a,a=t[e[o]],n=0;n<s;++n)a[n][1]+=a[n][0]=isNaN(r[n][1])?r[n][0]:r[n][1]},Qx=function(t){for(var e=t.length,n=new Array(e);--e>=0;)n[e]=e;return n};function tk(t,e){return t[e]}var ek=function(){var t=tw([]),e=Qx,n=Jx,r=tk;function i(i){var o,a,s=t.apply(this,arguments),u=i.length,c=s.length,f=new Array(c);for(o=0;o<c;++o){for(var l,h=s[o],d=f[o]=new Array(u),p=0;p<u;++p)d[p]=l=[0,+r(i[p],h,p,i)],l.data=i[p];d.key=h}for(o=0,a=e(f);o<c;++o)f[a[o]].index=o;return n(f,a),f}return i.keys=function(e){return arguments.length?(t="function"==typeof e?e:tw(Lw.call(e)),i):t},i.value=function(t){return arguments.length?(r="function"==typeof t?t:tw(+t),i):r},i.order=function(t){return arguments.length?(e=null==t?Qx:"function"==typeof t?t:tw(Lw.call(t)),i):e},i.offset=function(t){return arguments.length?(n=null==t?Jx:t,i):n},i},nk=function(t,e){if((r=t.length)>0){for(var n,r,i,o=0,a=t[0].length;o<a;++o){for(i=n=0;n<r;++n)i+=t[n][o][1]||0;if(i)for(n=0;n<r;++n)t[n][o][1]/=i}Jx(t,e)}},rk=function(t,e){if((s=t.length)>0)for(var n,r,i,o,a,s,u=0,c=t[e[0]].length;u<c;++u)for(o=a=0,n=0;n<s;++n)(i=(r=t[e[n]][u])[1]-r[0])>=0?(r[0]=o,r[1]=o+=i):i<0?(r[1]=a,r[0]=a+=i):r[0]=o},ik=function(t,e){if((n=t.length)>0){for(var n,r=0,i=t[e[0]],o=i.length;r<o;++r){for(var a=0,s=0;a<n;++a)s+=t[a][r][1]||0;i[r][1]+=i[r][0]=-s/2}Jx(t,e)}},ok=function(t,e){if((i=t.length)>0&&(r=(n=t[e[0]]).length)>0){for(var n,r,i,o=0,a=1;a<r;++a){for(var s=0,u=0,c=0;s<i;++s){for(var f=t[e[s]],l=f[a][1]||0,h=(l-(f[a-1][1]||0))/2,d=0;d<s;++d){var p=t[e[d]];h+=(p[a][1]||0)-(p[a-1][1]||0)}u+=l,c+=h*l}n[a-1][1]+=n[a-1][0]=o,u&&(o-=c/u)}n[a-1][1]+=n[a-1][0]=o,Jx(t,e)}},ak=function(t){var e=t.map(sk);return Qx(t).sort((function(t,n){return e[t]-e[n]}))};function sk(t){for(var e,n=-1,r=0,i=t.length,o=-1/0;++n<i;)(e=+t[n][1])>o&&(o=e,r=n);return r}var uk=function(t){var e=t.map(ck);return Qx(t).sort((function(t,n){return e[t]-e[n]}))};function ck(t){for(var e,n=0,r=-1,i=t.length;++r<i;)(e=+t[r][1])&&(n+=e);return n}var fk=function(t){return uk(t).reverse()},lk=function(t){var e,n,r=t.length,i=t.map(ck),o=ak(t),a=0,s=0,u=[],c=[];for(e=0;e<r;++e)n=o[e],a<s?(a+=i[n],u.push(n)):(s+=i[n],c.push(n));return c.reverse().concat(u)},hk=function(t){return Qx(t).reverse()},dk=function(t){return function(){return t}};function pk(t){return t[0]}function gk(t){return t[1]}function yk(){this._=null}function bk(t){t.U=t.C=t.L=t.R=t.P=t.N=null}function mk(t,e){var n=e,r=e.R,i=n.U;i?i.L===n?i.L=r:i.R=r:t._=r,r.U=i,n.U=r,n.R=r.L,n.R&&(n.R.U=n),r.L=n}function vk(t,e){var n=e,r=e.L,i=n.U;i?i.L===n?i.L=r:i.R=r:t._=r,r.U=i,n.U=r,n.L=r.R,n.L&&(n.L.U=n),r.R=n}function _k(t){for(;t.L;)t=t.L;return t}yk.prototype={constructor:yk,insert:function(t,e){var n,r,i;if(t){if(e.P=t,e.N=t.N,t.N&&(t.N.P=e),t.N=e,t.R){for(t=t.R;t.L;)t=t.L;t.L=e}else t.R=e;n=t}else this._?(t=_k(this._),e.P=null,e.N=t,t.P=t.L=e,n=t):(e.P=e.N=null,this._=e,n=null);for(e.L=e.R=null,e.U=n,e.C=!0,t=e;n&&n.C;)n===(r=n.U).L?(i=r.R)&&i.C?(n.C=i.C=!1,r.C=!0,t=r):(t===n.R&&(mk(this,n),n=(t=n).U),n.C=!1,r.C=!0,vk(this,r)):(i=r.L)&&i.C?(n.C=i.C=!1,r.C=!0,t=r):(t===n.L&&(vk(this,n),n=(t=n).U),n.C=!1,r.C=!0,mk(this,r)),n=t.U;this._.C=!1},remove:function(t){t.N&&(t.N.P=t.P),t.P&&(t.P.N=t.N),t.N=t.P=null;var e,n,r,i=t.U,o=t.L,a=t.R;if(n=o?a?_k(a):o:a,i?i.L===t?i.L=n:i.R=n:this._=n,o&&a?(r=n.C,n.C=t.C,n.L=o,o.U=n,n!==a?(i=n.U,n.U=t.U,t=n.R,i.L=t,n.R=a,a.U=n):(n.U=i,i=n,t=n.R)):(r=t.C,t=n),t&&(t.U=i),!r)if(t&&t.C)t.C=!1;else{do{if(t===this._)break;if(t===i.L){if((e=i.R).C&&(e.C=!1,i.C=!0,mk(this,i),e=i.R),e.L&&e.L.C||e.R&&e.R.C){e.R&&e.R.C||(e.L.C=!1,e.C=!0,vk(this,e),e=i.R),e.C=i.C,i.C=e.R.C=!1,mk(this,i),t=this._;break}}else if((e=i.L).C&&(e.C=!1,i.C=!0,vk(this,i),e=i.L),e.L&&e.L.C||e.R&&e.R.C){e.L&&e.L.C||(e.R.C=!1,e.C=!0,mk(this,e),e=i.L),e.C=i.C,i.C=e.L.C=!1,vk(this,i),t=this._;break}e.C=!0,t=i,i=i.U}while(!t.C);t&&(t.C=!1)}}};var wk=yk;function xk(t,e,n,r){var i=[null,null],o=$k.push(i)-1;return i.left=t,i.right=e,n&&Ek(i,t,e,n),r&&Ek(i,e,t,r),Vk[t.index].halfedges.push(o),Vk[e.index].halfedges.push(o),i}function kk(t,e,n){var r=[e,n];return r.left=t,r}function Ek(t,e,n,r){t[0]||t[1]?t.left===n?t[1]=r:t[0]=r:(t[0]=r,t.left=e,t.right=n)}function Ak(t,e,n,r,i){var o,a=t[0],s=t[1],u=a[0],c=a[1],f=0,l=1,h=s[0]-u,d=s[1]-c;if(o=e-u,h||!(o>0)){if(o/=h,h<0){if(o<f)return;o<l&&(l=o)}else if(h>0){if(o>l)return;o>f&&(f=o)}if(o=r-u,h||!(o<0)){if(o/=h,h<0){if(o>l)return;o>f&&(f=o)}else if(h>0){if(o<f)return;o<l&&(l=o)}if(o=n-c,d||!(o>0)){if(o/=d,d<0){if(o<f)return;o<l&&(l=o)}else if(d>0){if(o>l)return;o>f&&(f=o)}if(o=i-c,d||!(o<0)){if(o/=d,d<0){if(o>l)return;o>f&&(f=o)}else if(d>0){if(o<f)return;o<l&&(l=o)}return!(f>0||l<1)||(f>0&&(t[0]=[u+f*h,c+f*d]),l<1&&(t[1]=[u+l*h,c+l*d]),!0)}}}}}function Sk(t,e,n,r,i){var o=t[1];if(o)return!0;var a,s,u=t[0],c=t.left,f=t.right,l=c[0],h=c[1],d=f[0],p=f[1],g=(l+d)/2,y=(h+p)/2;if(p===h){if(g<e||g>=r)return;if(l>d){if(u){if(u[1]>=i)return}else u=[g,n];o=[g,i]}else{if(u){if(u[1]<n)return}else u=[g,i];o=[g,n]}}else if(s=y-(a=(l-d)/(p-h))*g,a<-1||a>1)if(l>d){if(u){if(u[1]>=i)return}else u=[(n-s)/a,n];o=[(i-s)/a,i]}else{if(u){if(u[1]<n)return}else u=[(i-s)/a,i];o=[(n-s)/a,n]}else if(h<p){if(u){if(u[0]>=r)return}else u=[e,a*e+s];o=[r,a*r+s]}else{if(u){if(u[0]<e)return}else u=[r,a*r+s];o=[e,a*e+s]}return t[0]=u,t[1]=o,!0}function Tk(t,e){var n=t.site,r=e.left,i=e.right;return n===i&&(i=r,r=n),i?Math.atan2(i[1]-r[1],i[0]-r[0]):(n===r?(r=e[1],i=e[0]):(r=e[0],i=e[1]),Math.atan2(r[0]-i[0],i[1]-r[1]))}function Mk(t,e){return e[+(e.left!==t.site)]}function Dk(t,e){return e[+(e.left===t.site)]}var Ck,Ok=[];function Rk(){bk(this),this.x=this.y=this.arc=this.site=this.cy=null}function Ik(t){var e=t.P,n=t.N;if(e&&n){var r=e.site,i=t.site,o=n.site;if(r!==o){var a=i[0],s=i[1],u=r[0]-a,c=r[1]-s,f=o[0]-a,l=o[1]-s,h=2*(u*l-c*f);if(!(h>=-Wk)){var d=u*u+c*c,p=f*f+l*l,g=(l*d-c*p)/h,y=(u*p-f*d)/h,b=Ok.pop()||new Rk;b.arc=t,b.site=i,b.x=g+a,b.y=(b.cy=y+s)+Math.sqrt(g*g+y*y),t.circle=b;for(var m=null,v=Hk._;v;)if(b.y<v.y||b.y===v.y&&b.x<=v.x){if(!v.L){m=v.P;break}v=v.L}else{if(!v.R){m=v;break}v=v.R}Hk.insert(m,b),m||(Ck=b)}}}}function Nk(t){var e=t.circle;e&&(e.P||(Ck=e.N),Hk.remove(e),Ok.push(e),bk(e),t.circle=null)}var Bk=[];function Lk(){bk(this),this.edge=this.site=this.circle=null}function Pk(t){var e=Bk.pop()||new Lk;return e.site=t,e}function Fk(t){Nk(t),Yk.remove(t),Bk.push(t),bk(t)}function qk(t){var e=t.circle,n=e.x,r=e.cy,i=[n,r],o=t.P,a=t.N,s=[t];Fk(t);for(var u=o;u.circle&&Math.abs(n-u.circle.x)<Gk&&Math.abs(r-u.circle.cy)<Gk;)o=u.P,s.unshift(u),Fk(u),u=o;s.unshift(u),Nk(u);for(var c=a;c.circle&&Math.abs(n-c.circle.x)<Gk&&Math.abs(r-c.circle.cy)<Gk;)a=c.N,s.push(c),Fk(c),c=a;s.push(c),Nk(c);var f,l=s.length;for(f=1;f<l;++f)c=s[f],u=s[f-1],Ek(c.edge,u.site,c.site,i);u=s[0],(c=s[l-1]).edge=xk(u.site,c.site,null,i),Ik(u),Ik(c)}function jk(t){for(var e,n,r,i,o=t[0],a=t[1],s=Yk._;s;)if((r=Uk(s,a)-o)>Gk)s=s.L;else{if(!((i=o-zk(s,a))>Gk)){r>-Gk?(e=s.P,n=s):i>-Gk?(e=s,n=s.N):e=n=s;break}if(!s.R){e=s;break}s=s.R}!function(t){Vk[t.index]={site:t,halfedges:[]}}(t);var u=Pk(t);if(Yk.insert(e,u),e||n){if(e===n)return Nk(e),n=Pk(e.site),Yk.insert(u,n),u.edge=n.edge=xk(e.site,u.site),Ik(e),void Ik(n);if(n){Nk(e),Nk(n);var c=e.site,f=c[0],l=c[1],h=t[0]-f,d=t[1]-l,p=n.site,g=p[0]-f,y=p[1]-l,b=2*(h*y-d*g),m=h*h+d*d,v=g*g+y*y,_=[(y*m-d*v)/b+f,(h*v-g*m)/b+l];Ek(n.edge,c,p,_),u.edge=xk(c,t,null,_),n.edge=xk(t,p,null,_),Ik(e),Ik(n)}else u.edge=xk(e.site,u.site)}}function Uk(t,e){var n=t.site,r=n[0],i=n[1],o=i-e;if(!o)return r;var a=t.P;if(!a)return-1/0;var s=(n=a.site)[0],u=n[1],c=u-e;if(!c)return s;var f=s-r,l=1/o-1/c,h=f/c;return l?(-h+Math.sqrt(h*h-2*l*(f*f/(-2*c)-u+c/2+i-o/2)))/l+r:(r+s)/2}function zk(t,e){var n=t.N;if(n)return Uk(n,e);var r=t.site;return r[1]===e?r[0]:1/0}var Yk,Vk,Hk,$k,Gk=1e-6,Wk=1e-12;function Kk(t,e){return e[1]-t[1]||e[0]-t[0]}function Xk(t,e){var n,r,i,o=t.sort(Kk).pop();for($k=[],Vk=new Array(t.length),Yk=new wk,Hk=new wk;;)if(i=Ck,o&&(!i||o[1]<i.y||o[1]===i.y&&o[0]<i.x))o[0]===n&&o[1]===r||(jk(o),n=o[0],r=o[1]),o=t.pop();else{if(!i)break;qk(i.arc)}if(function(){for(var t,e,n,r,i=0,o=Vk.length;i<o;++i)if((t=Vk[i])&&(r=(e=t.halfedges).length)){var a=new Array(r),s=new Array(r);for(n=0;n<r;++n)a[n]=n,s[n]=Tk(t,$k[e[n]]);for(a.sort((function(t,e){return s[e]-s[t]})),n=0;n<r;++n)s[n]=e[a[n]];for(n=0;n<r;++n)e[n]=s[n]}}(),e){var a=+e[0][0],s=+e[0][1],u=+e[1][0],c=+e[1][1];!function(t,e,n,r){for(var i,o=$k.length;o--;)Sk(i=$k[o],t,e,n,r)&&Ak(i,t,e,n,r)&&(Math.abs(i[0][0]-i[1][0])>Gk||Math.abs(i[0][1]-i[1][1])>Gk)||delete $k[o]}(a,s,u,c),function(t,e,n,r){var i,o,a,s,u,c,f,l,h,d,p,g,y=Vk.length,b=!0;for(i=0;i<y;++i)if(o=Vk[i]){for(a=o.site,s=(u=o.halfedges).length;s--;)$k[u[s]]||u.splice(s,1);for(s=0,c=u.length;s<c;)p=(d=Dk(o,$k[u[s]]))[0],g=d[1],l=(f=Mk(o,$k[u[++s%c]]))[0],h=f[1],(Math.abs(p-l)>Gk||Math.abs(g-h)>Gk)&&(u.splice(s,0,$k.push(kk(a,d,Math.abs(p-t)<Gk&&r-g>Gk?[t,Math.abs(l-t)<Gk?h:r]:Math.abs(g-r)<Gk&&n-p>Gk?[Math.abs(h-r)<Gk?l:n,r]:Math.abs(p-n)<Gk&&g-e>Gk?[n,Math.abs(l-n)<Gk?h:e]:Math.abs(g-e)<Gk&&p-t>Gk?[Math.abs(h-e)<Gk?l:t,e]:null))-1),++c);c&&(b=!1)}if(b){var m,v,_,w=1/0;for(i=0,b=null;i<y;++i)(o=Vk[i])&&(_=(m=(a=o.site)[0]-t)*m+(v=a[1]-e)*v)<w&&(w=_,b=o);if(b){var x=[t,e],k=[t,r],E=[n,r],A=[n,e];b.halfedges.push($k.push(kk(a=b.site,x,k))-1,$k.push(kk(a,k,E))-1,$k.push(kk(a,E,A))-1,$k.push(kk(a,A,x))-1)}}for(i=0;i<y;++i)(o=Vk[i])&&(o.halfedges.length||delete Vk[i])}(a,s,u,c)}this.edges=$k,this.cells=Vk,Yk=Hk=$k=Vk=null}Xk.prototype={constructor:Xk,polygons:function(){var t=this.edges;return this.cells.map((function(e){var n=e.halfedges.map((function(n){return Mk(e,t[n])}));return n.data=e.site.data,n}))},triangles:function(){var t=[],e=this.edges;return this.cells.forEach((function(n,r){if(o=(i=n.halfedges).length)for(var i,o,a,s,u,c,f=n.site,l=-1,h=e[i[o-1]],d=h.left===f?h.right:h.left;++l<o;)a=d,d=(h=e[i[l]]).left===f?h.right:h.left,a&&d&&r<a.index&&r<d.index&&(u=a,c=d,((s=f)[0]-c[0])*(u[1]-s[1])-(s[0]-u[0])*(c[1]-s[1])<0)&&t.push([f.data,a.data,d.data])})),t},links:function(){return this.edges.filter((function(t){return t.right})).map((function(t){return{source:t.left.data,target:t.right.data}}))},find:function(t,e,n){for(var r,i,o=this,a=o._found||0,s=o.cells.length;!(i=o.cells[a]);)if(++a>=s)return null;var u=t-i.site[0],c=e-i.site[1],f=u*u+c*c;do{i=o.cells[r=a],a=null,i.halfedges.forEach((function(n){var r=o.edges[n],s=r.left;if(s!==i.site&&s||(s=r.right)){var u=t-s[0],c=e-s[1],l=u*u+c*c;l<f&&(f=l,a=s.index)}}))}while(null!==a);return o._found=r,null==n||f<=n*n?i.site:null}};var Zk=function(){var t=pk,e=gk,n=null;function r(r){return new Xk(r.map((function(n,i){var o=[Math.round(t(n,i,r)/Gk)*Gk,Math.round(e(n,i,r)/Gk)*Gk];return o.index=i,o.data=n,o})),n)}return r.polygons=function(t){return r(t).polygons()},r.links=function(t){return r(t).links()},r.triangles=function(t){return r(t).triangles()},r.x=function(e){return arguments.length?(t="function"==typeof e?e:dk(+e),r):t},r.y=function(t){return arguments.length?(e="function"==typeof t?t:dk(+t),r):e},r.extent=function(t){return arguments.length?(n=null==t?null:[[+t[0][0],+t[0][1]],[+t[1][0],+t[1][1]]],r):n&&[[n[0][0],n[0][1]],[n[1][0],n[1][1]]]},r.size=function(t){return arguments.length?(n=null==t?null:[[0,0],[+t[0],+t[1]]],r):n&&[n[1][0]-n[0][0],n[1][1]-n[0][1]]},r},Jk=function(t){return function(){return t}};function Qk(t,e,n){this.target=t,this.type=e,this.transform=n}function tE(t,e,n){this.k=t,this.x=e,this.y=n}tE.prototype={constructor:tE,scale:function(t){return 1===t?this:new tE(this.k*t,this.x,this.y)},translate:function(t,e){return 0===t&0===e?this:new tE(this.k,this.x+this.k*t,this.y+this.k*e)},apply:function(t){return[t[0]*this.k+this.x,t[1]*this.k+this.y]},applyX:function(t){return t*this.k+this.x},applyY:function(t){return t*this.k+this.y},invert:function(t){return[(t[0]-this.x)/this.k,(t[1]-this.y)/this.k]},invertX:function(t){return(t-this.x)/this.k},invertY:function(t){return(t-this.y)/this.k},rescaleX:function(t){return t.copy().domain(t.range().map(this.invertX,this).map(t.invert,t))},rescaleY:function(t){return t.copy().domain(t.range().map(this.invertY,this).map(t.invert,t))},toString:function(){return"translate("+this.x+","+this.y+") scale("+this.k+")"}};var eE=new tE(1,0,0);function nE(t){for(;!t.__zoom;)if(!(t=t.parentNode))return eE;return t.__zoom}function rE(){pe.stopImmediatePropagation()}nE.prototype=tE.prototype;var iE=function(){pe.preventDefault(),pe.stopImmediatePropagation()};function oE(){return!pe.ctrlKey&&!pe.button}function aE(){var t=this;return t instanceof SVGElement?(t=t.ownerSVGElement||t).hasAttribute("viewBox")?[[(t=t.viewBox.baseVal).x,t.y],[t.x+t.width,t.y+t.height]]:[[0,0],[t.width.baseVal.value,t.height.baseVal.value]]:[[0,0],[t.clientWidth,t.clientHeight]]}function sE(){return this.__zoom||eE}function uE(){return-pe.deltaY*(1===pe.deltaMode?.05:pe.deltaMode?1:.002)}function cE(){return navigator.maxTouchPoints||"ontouchstart"in this}function fE(t,e,n){var r=t.invertX(e[0][0])-n[0][0],i=t.invertX(e[1][0])-n[1][0],o=t.invertY(e[0][1])-n[0][1],a=t.invertY(e[1][1])-n[1][1];return t.translate(i>r?(r+i)/2:Math.min(0,r)||Math.max(0,i),a>o?(o+a)/2:Math.min(0,o)||Math.max(0,a))}var lE=function(){var t,e,n=oE,r=aE,i=fE,o=uE,a=cE,s=[0,1/0],u=[[-1/0,-1/0],[1/0,1/0]],c=250,f=ur,l=gt("start","zoom","end"),h=500,d=150,p=0;function g(t){t.property("__zoom",sE).on("wheel.zoom",x).on("mousedown.zoom",k).on("dblclick.zoom",E).filter(a).on("touchstart.zoom",A).on("touchmove.zoom",S).on("touchend.zoom touchcancel.zoom",T).style("touch-action","none").style("-webkit-tap-highlight-color","rgba(0,0,0,0)")}function y(t,e){return(e=Math.max(s[0],Math.min(s[1],e)))===t.k?t:new tE(e,t.x,t.y)}function b(t,e,n){var r=e[0]-n[0]*t.k,i=e[1]-n[1]*t.k;return r===t.x&&i===t.y?t:new tE(t.k,r,i)}function m(t){return[(+t[0][0]+ +t[1][0])/2,(+t[0][1]+ +t[1][1])/2]}function v(t,e,n){t.on("start.zoom",(function(){_(this,arguments).start()})).on("interrupt.zoom end.zoom",(function(){_(this,arguments).end()})).tween("zoom",(function(){var t=this,i=arguments,o=_(t,i),a=r.apply(t,i),s=null==n?m(a):"function"==typeof n?n.apply(t,i):n,u=Math.max(a[1][0]-a[0][0],a[1][1]-a[0][1]),c=t.__zoom,l="function"==typeof e?e.apply(t,i):e,h=f(c.invert(s).concat(u/c.k),l.invert(s).concat(u/l.k));return function(t){if(1===t)t=l;else{var e=h(t),n=u/e[2];t=new tE(n,s[0]-e[0]*n,s[1]-e[1]*n)}o.zoom(null,t)}}))}function _(t,e,n){return!n&&t.__zooming||new w(t,e)}function w(t,e){this.that=t,this.args=e,this.active=0,this.extent=r.apply(t,e),this.taps=0}function x(){if(n.apply(this,arguments)){var t=_(this,arguments),e=this.__zoom,r=Math.max(s[0],Math.min(s[1],e.k*Math.pow(2,o.apply(this,arguments)))),a=Be(this);if(t.wheel)t.mouse[0][0]===a[0]&&t.mouse[0][1]===a[1]||(t.mouse[1]=e.invert(t.mouse[0]=a)),clearTimeout(t.wheel);else{if(e.k===r)return;t.mouse=[a,e.invert(a)],Oi(this),t.start()}iE(),t.wheel=setTimeout((function(){t.wheel=null,t.end()}),d),t.zoom("mouse",i(b(y(e,r),t.mouse[0],t.mouse[1]),t.extent,u))}}function k(){if(!e&&n.apply(this,arguments)){var t=_(this,arguments,!0),r=Me(pe.view).on("mousemove.zoom",(function(){if(iE(),!t.moved){var e=pe.clientX-a,n=pe.clientY-s;t.moved=e*e+n*n>p}t.zoom("mouse",i(b(t.that.__zoom,t.mouse[0]=Be(t.that),t.mouse[1]),t.extent,u))}),!0).on("mouseup.zoom",(function(){r.on("mousemove.zoom mouseup.zoom",null),ze(pe.view,t.moved),iE(),t.end()}),!0),o=Be(this),a=pe.clientX,s=pe.clientY;Ue(pe.view),rE(),t.mouse=[o,this.__zoom.invert(o)],Oi(this),t.start()}}function E(){if(n.apply(this,arguments)){var t=this.__zoom,e=Be(this),o=t.invert(e),a=t.k*(pe.shiftKey?.5:2),s=i(b(y(t,a),e,o),r.apply(this,arguments),u);iE(),c>0?Me(this).transition().duration(c).call(v,s,e):Me(this).call(g.transform,s)}}function A(){if(n.apply(this,arguments)){var e,r,i,o,a=pe.touches,s=a.length,u=_(this,arguments,pe.changedTouches.length===s);for(rE(),r=0;r<s;++r)i=a[r],o=[o=Pe(this,a,i.identifier),this.__zoom.invert(o),i.identifier],u.touch0?u.touch1||u.touch0[2]===o[2]||(u.touch1=o,u.taps=0):(u.touch0=o,e=!0,u.taps=1+!!t);t&&(t=clearTimeout(t)),e&&(u.taps<2&&(t=setTimeout((function(){t=null}),h)),Oi(this),u.start())}}function S(){if(this.__zooming){var e,n,r,o,a=_(this,arguments),s=pe.changedTouches,c=s.length;for(iE(),t&&(t=clearTimeout(t)),a.taps=0,e=0;e<c;++e)n=s[e],r=Pe(this,s,n.identifier),a.touch0&&a.touch0[2]===n.identifier?a.touch0[0]=r:a.touch1&&a.touch1[2]===n.identifier&&(a.touch1[0]=r);if(n=a.that.__zoom,a.touch1){var f=a.touch0[0],l=a.touch0[1],h=a.touch1[0],d=a.touch1[1],p=(p=h[0]-f[0])*p+(p=h[1]-f[1])*p,g=(g=d[0]-l[0])*g+(g=d[1]-l[1])*g;n=y(n,Math.sqrt(p/g)),r=[(f[0]+h[0])/2,(f[1]+h[1])/2],o=[(l[0]+d[0])/2,(l[1]+d[1])/2]}else{if(!a.touch0)return;r=a.touch0[0],o=a.touch0[1]}a.zoom("touch",i(b(n,r,o),a.extent,u))}}function T(){if(this.__zooming){var t,n,r=_(this,arguments),i=pe.changedTouches,o=i.length;for(rE(),e&&clearTimeout(e),e=setTimeout((function(){e=null}),h),t=0;t<o;++t)n=i[t],r.touch0&&r.touch0[2]===n.identifier?delete r.touch0:r.touch1&&r.touch1[2]===n.identifier&&delete r.touch1;if(r.touch1&&!r.touch0&&(r.touch0=r.touch1,delete r.touch1),r.touch0)r.touch0[1]=this.__zoom.invert(r.touch0[0]);else if(r.end(),2===r.taps){var a=Me(this).on("dblclick.zoom");a&&a.apply(this,arguments)}}}return g.transform=function(t,e,n){var r=t.selection?t.selection():t;r.property("__zoom",sE),t!==r?v(t,e,n):r.interrupt().each((function(){_(this,arguments).start().zoom(null,"function"==typeof e?e.apply(this,arguments):e).end()}))},g.scaleBy=function(t,e,n){g.scaleTo(t,(function(){var t=this.__zoom.k,n="function"==typeof e?e.apply(this,arguments):e;return t*n}),n)},g.scaleTo=function(t,e,n){g.transform(t,(function(){var t=r.apply(this,arguments),o=this.__zoom,a=null==n?m(t):"function"==typeof n?n.apply(this,arguments):n,s=o.invert(a),c="function"==typeof e?e.apply(this,arguments):e;return i(b(y(o,c),a,s),t,u)}),n)},g.translateBy=function(t,e,n){g.transform(t,(function(){return i(this.__zoom.translate("function"==typeof e?e.apply(this,arguments):e,"function"==typeof n?n.apply(this,arguments):n),r.apply(this,arguments),u)}))},g.translateTo=function(t,e,n,o){g.transform(t,(function(){var t=r.apply(this,arguments),a=this.__zoom,s=null==o?m(t):"function"==typeof o?o.apply(this,arguments):o;return i(eE.translate(s[0],s[1]).scale(a.k).translate("function"==typeof e?-e.apply(this,arguments):-e,"function"==typeof n?-n.apply(this,arguments):-n),t,u)}),o)},w.prototype={start:function(){return 1==++this.active&&(this.that.__zooming=this,this.emit("start")),this},zoom:function(t,e){return this.mouse&&"mouse"!==t&&(this.mouse[1]=e.invert(this.mouse[0])),this.touch0&&"touch"!==t&&(this.touch0[1]=e.invert(this.touch0[0])),this.touch1&&"touch"!==t&&(this.touch1[1]=e.invert(this.touch1[0])),this.that.__zoom=e,this.emit("zoom"),this},end:function(){return 0==--this.active&&(delete this.that.__zooming,this.emit("end")),this},emit:function(t){_e(new Qk(g,t,this.that.__zoom),l.apply,l,[t,this.that,this.args])}},g.wheelDelta=function(t){return arguments.length?(o="function"==typeof t?t:Jk(+t),g):o},g.filter=function(t){return arguments.length?(n="function"==typeof t?t:Jk(!!t),g):n},g.touchable=function(t){return arguments.length?(a="function"==typeof t?t:Jk(!!t),g):a},g.extent=function(t){return arguments.length?(r="function"==typeof t?t:Jk([[+t[0][0],+t[0][1]],[+t[1][0],+t[1][1]]]),g):r},g.scaleExtent=function(t){return arguments.length?(s[0]=+t[0],s[1]=+t[1],g):[s[0],s[1]]},g.translateExtent=function(t){return arguments.length?(u[0][0]=+t[0][0],u[1][0]=+t[1][0],u[0][1]=+t[0][1],u[1][1]=+t[1][1],g):[[u[0][0],u[0][1]],[u[1][0],u[1][1]]]},g.constrain=function(t){return arguments.length?(i=t,g):i},g.duration=function(t){return arguments.length?(c=+t,g):c},g.interpolate=function(t){return arguments.length?(f=t,g):f},g.on=function(){var t=l.on.apply(l,arguments);return t===l?g:t},g.clickDistance=function(t){return arguments.length?(p=(t=+t)*t,g):Math.sqrt(p)},g};n.d(e,"version",(function(){return"5.12.0"})),n.d(e,"bisect",(function(){return u})),n.d(e,"bisectRight",(function(){return a})),n.d(e,"bisectLeft",(function(){return s})),n.d(e,"ascending",(function(){return r})),n.d(e,"bisector",(function(){return i})),n.d(e,"cross",(function(){return l})),n.d(e,"descending",(function(){return h})),n.d(e,"deviation",(function(){return g})),n.d(e,"extent",(function(){return y})),n.d(e,"histogram",(function(){return C})),n.d(e,"thresholdFreedmanDiaconis",(function(){return R})),n.d(e,"thresholdScott",(function(){return I})),n.d(e,"thresholdSturges",(function(){return D})),n.d(e,"max",(function(){return N})),n.d(e,"mean",(function(){return B})),n.d(e,"median",(function(){return L})),n.d(e,"merge",(function(){return P})),n.d(e,"min",(function(){return F})),n.d(e,"pairs",(function(){return c})),n.d(e,"permute",(function(){return q})),n.d(e,"quantile",(function(){return O})),n.d(e,"range",(function(){return x})),n.d(e,"scan",(function(){return j})),n.d(e,"shuffle",(function(){return U})),n.d(e,"sum",(function(){return z})),n.d(e,"ticks",(function(){return S})),n.d(e,"tickIncrement",(function(){return T})),n.d(e,"tickStep",(function(){return M})),n.d(e,"transpose",(function(){return Y})),n.d(e,"variance",(function(){return p})),n.d(e,"zip",(function(){return H})),n.d(e,"axisTop",(function(){return ot})),n.d(e,"axisRight",(function(){return at})),n.d(e,"axisBottom",(function(){return st})),n.d(e,"axisLeft",(function(){return ut})),n.d(e,"brush",(function(){return xa})),n.d(e,"brushX",(function(){return _a})),n.d(e,"brushY",(function(){return wa})),n.d(e,"brushSelection",(function(){return va})),n.d(e,"chord",(function(){return Oa})),n.d(e,"ribbon",(function(){return Ha})),n.d(e,"nest",(function(){return Ka})),n.d(e,"set",(function(){return rs})),n.d(e,"map",(function(){return Wa})),n.d(e,"keys",(function(){return is})),n.d(e,"values",(function(){return os})),n.d(e,"entries",(function(){return as})),n.d(e,"color",(function(){return dn})),n.d(e,"rgb",(function(){return bn})),n.d(e,"hsl",(function(){return En})),n.d(e,"lab",(function(){return kr})),n.d(e,"hcl",(function(){return Or})),n.d(e,"lch",(function(){return Cr})),n.d(e,"gray",(function(){return xr})),n.d(e,"cubehelix",(function(){return Vr})),n.d(e,"contours",(function(){return ys})),n.d(e,"contourDensity",(function(){return xs})),n.d(e,"dispatch",(function(){return gt})),n.d(e,"drag",(function(){return Ke})),n.d(e,"dragDisable",(function(){return Ue})),n.d(e,"dragEnable",(function(){return ze})),n.d(e,"dsvFormat",(function(){return Rs})),n.d(e,"csvParse",(function(){return Ns})),n.d(e,"csvParseRows",(function(){return Bs})),n.d(e,"csvFormat",(function(){return Ls})),n.d(e,"csvFormatBody",(function(){return Ps})),n.d(e,"csvFormatRows",(function(){return Fs})),n.d(e,"tsvParse",(function(){return js})),n.d(e,"tsvParseRows",(function(){return Us})),n.d(e,"tsvFormat",(function(){return zs})),n.d(e,"tsvFormatBody",(function(){return Ys})),n.d(e,"tsvFormatRows",(function(){return Vs})),n.d(e,"autoType",(function(){return Hs})),n.d(e,"easeLinear",(function(){return io})),n.d(e,"easeQuad",(function(){return so})),n.d(e,"easeQuadIn",(function(){return oo})),n.d(e,"easeQuadOut",(function(){return ao})),n.d(e,"easeQuadInOut",(function(){return so})),n.d(e,"easeCubic",(function(){return fo})),n.d(e,"easeCubicIn",(function(){return uo})),n.d(e,"easeCubicOut",(function(){return co})),n.d(e,"easeCubicInOut",(function(){return fo})),n.d(e,"easePoly",(function(){return po})),n.d(e,"easePolyIn",(function(){return lo})),n.d(e,"easePolyOut",(function(){return ho})),n.d(e,"easePolyInOut",(function(){return po})),n.d(e,"easeSin",(function(){return vo})),n.d(e,"easeSinIn",(function(){return bo})),n.d(e,"easeSinOut",(function(){return mo})),n.d(e,"easeSinInOut",(function(){return vo})),n.d(e,"easeExp",(function(){return xo})),n.d(e,"easeExpIn",(function(){return _o})),n.d(e,"easeExpOut",(function(){return wo})),n.d(e,"easeExpInOut",(function(){return xo})),n.d(e,"easeCircle",(function(){return Ao})),n.d(e,"easeCircleIn",(function(){return ko})),n.d(e,"easeCircleOut",(function(){return Eo})),n.d(e,"easeCircleInOut",(function(){return Ao})),n.d(e,"easeBounce",(function(){return Po})),n.d(e,"easeBounceIn",(function(){return Lo})),n.d(e,"easeBounceOut",(function(){return Po})),n.d(e,"easeBounceInOut",(function(){return Fo})),n.d(e,"easeBack",(function(){return Uo})),n.d(e,"easeBackIn",(function(){return qo})),n.d(e,"easeBackOut",(function(){return jo})),n.d(e,"easeBackInOut",(function(){return Uo})),n.d(e,"easeElastic",(function(){return Vo})),n.d(e,"easeElasticIn",(function(){return Yo})),n.d(e,"easeElasticOut",(function(){return Vo})),n.d(e,"easeElasticInOut",(function(){return Ho})),n.d(e,"blob",(function(){return Gs})),n.d(e,"buffer",(function(){return Ks})),n.d(e,"dsv",(function(){return Qs})),n.d(e,"csv",(function(){return tu})),n.d(e,"tsv",(function(){return eu})),n.d(e,"image",(function(){return nu})),n.d(e,"json",(function(){return iu})),n.d(e,"text",(function(){return Zs})),n.d(e,"xml",(function(){return au})),n.d(e,"html",(function(){return su})),n.d(e,"svg",(function(){return uu})),n.d(e,"forceCenter",(function(){return cu})),n.d(e,"forceCollide",(function(){return xu})),n.d(e,"forceLink",(function(){return Au})),n.d(e,"forceManyBody",(function(){return Ou})),n.d(e,"forceRadial",(function(){return Ru})),n.d(e,"forceSimulation",(function(){return Cu})),n.d(e,"forceX",(function(){return Iu})),n.d(e,"forceY",(function(){return Nu})),n.d(e,"formatDefaultLocale",(function(){return Zu})),n.d(e,"format",(function(){return zu})),n.d(e,"formatPrefix",(function(){return Yu})),n.d(e,"formatLocale",(function(){return Xu})),n.d(e,"formatSpecifier",(function(){return Fu})),n.d(e,"FormatSpecifier",(function(){return qu})),n.d(e,"precisionFixed",(function(){return Ju})),n.d(e,"precisionPrefix",(function(){return Qu})),n.d(e,"precisionRound",(function(){return tc})),n.d(e,"geoArea",(function(){return Gc})),n.d(e,"geoBounds",(function(){return jf})),n.d(e,"geoCentroid",(function(){return Jf})),n.d(e,"geoCircle",(function(){return cl})),n.d(e,"geoClipAntimeridian",(function(){return wl})),n.d(e,"geoClipCircle",(function(){return xl})),n.d(e,"geoClipExtent",(function(){return Cl})),n.d(e,"geoClipRectangle",(function(){return Sl})),n.d(e,"geoContains",(function(){return Wl})),n.d(e,"geoDistance",(function(){return ql})),n.d(e,"geoGraticule",(function(){return Zl})),n.d(e,"geoGraticule10",(function(){return Jl})),n.d(e,"geoInterpolate",(function(){return rh})),n.d(e,"geoLength",(function(){return Ll})),n.d(e,"geoPath",(function(){return ed})),n.d(e,"geoAlbers",(function(){return wd})),n.d(e,"geoAlbersUsa",(function(){return xd})),n.d(e,"geoAzimuthalEqualArea",(function(){return Sd})),n.d(e,"geoAzimuthalEqualAreaRaw",(function(){return Ad})),n.d(e,"geoAzimuthalEquidistant",(function(){return Md})),n.d(e,"geoAzimuthalEquidistantRaw",(function(){return Td})),n.d(e,"geoConicConformal",(function(){return Nd})),n.d(e,"geoConicConformalRaw",(function(){return Id})),n.d(e,"geoConicEqualArea",(function(){return _d})),n.d(e,"geoConicEqualAreaRaw",(function(){return vd})),n.d(e,"geoConicEquidistant",(function(){return Fd})),n.d(e,"geoConicEquidistantRaw",(function(){return Pd})),n.d(e,"geoEqualEarth",(function(){return Hd})),n.d(e,"geoEqualEarthRaw",(function(){return Vd})),n.d(e,"geoEquirectangular",(function(){return Ld})),n.d(e,"geoEquirectangularRaw",(function(){return Bd})),n.d(e,"geoGnomonic",(function(){return Gd})),n.d(e,"geoGnomonicRaw",(function(){return $d})),n.d(e,"geoIdentity",(function(){return Kd})),n.d(e,"geoProjection",(function(){return yd})),n.d(e,"geoProjectionMutator",(function(){return bd})),n.d(e,"geoMercator",(function(){return Cd})),n.d(e,"geoMercatorRaw",(function(){return Dd})),n.d(e,"geoNaturalEarth1",(function(){return Zd})),n.d(e,"geoNaturalEarth1Raw",(function(){return Xd})),n.d(e,"geoOrthographic",(function(){return Qd})),n.d(e,"geoOrthographicRaw",(function(){return Jd})),n.d(e,"geoStereographic",(function(){return ep})),n.d(e,"geoStereographicRaw",(function(){return tp})),n.d(e,"geoTransverseMercator",(function(){return rp})),n.d(e,"geoTransverseMercatorRaw",(function(){return np})),n.d(e,"geoRotation",(function(){return al})),n.d(e,"geoStream",(function(){return qc})),n.d(e,"geoTransform",(function(){return nd})),n.d(e,"cluster",(function(){return sp})),n.d(e,"hierarchy",(function(){return cp})),n.d(e,"pack",(function(){return Np})),n.d(e,"packSiblings",(function(){return Mp})),n.d(e,"packEnclose",(function(){return gp})),n.d(e,"partition",(function(){return jp})),n.d(e,"stratify",(function(){return $p})),n.d(e,"tree",(function(){return Qp})),n.d(e,"treemap",(function(){return ig})),n.d(e,"treemapBinary",(function(){return og})),n.d(e,"treemapDice",(function(){return qp})),n.d(e,"treemapSlice",(function(){return tg})),n.d(e,"treemapSliceDice",(function(){return ag})),n.d(e,"treemapSquarify",(function(){return rg})),n.d(e,"treemapResquarify",(function(){return sg})),n.d(e,"interpolate",(function(){return Xn})),n.d(e,"interpolateArray",(function(){return qn})),n.d(e,"interpolateBasis",(function(){return Mn})),n.d(e,"interpolateBasisClosed",(function(){return Dn})),n.d(e,"interpolateDate",(function(){return jn})),n.d(e,"interpolateDiscrete",(function(){return Zn})),n.d(e,"interpolateHue",(function(){return Jn})),n.d(e,"interpolateNumber",(function(){return Un})),n.d(e,"interpolateObject",(function(){return zn})),n.d(e,"interpolateRound",(function(){return Qn})),n.d(e,"interpolateString",(function(){return Kn})),n.d(e,"interpolateTransformCss",(function(){return ir})),n.d(e,"interpolateTransformSvg",(function(){return or})),n.d(e,"interpolateZoom",(function(){return ur})),n.d(e,"interpolateRgb",(function(){return Bn})),n.d(e,"interpolateRgbBasis",(function(){return Pn})),n.d(e,"interpolateRgbBasisClosed",(function(){return Fn})),n.d(e,"interpolateHsl",(function(){return fr})),n.d(e,"interpolateHslLong",(function(){return lr})),n.d(e,"interpolateLab",(function(){return Nr})),n.d(e,"interpolateHcl",(function(){return Lr})),n.d(e,"interpolateHclLong",(function(){return Pr})),n.d(e,"interpolateCubehelix",(function(){return Gr})),n.d(e,"interpolateCubehelixLong",(function(){return Wr})),n.d(e,"piecewise",(function(){return Kr})),n.d(e,"quantize",(function(){return Jr})),n.d(e,"path",(function(){return qa})),n.d(e,"polygonArea",(function(){return ug})),n.d(e,"polygonCentroid",(function(){return cg})),n.d(e,"polygonHull",(function(){return dg})),n.d(e,"polygonContains",(function(){return pg})),n.d(e,"polygonLength",(function(){return gg})),n.d(e,"quadtree",(function(){return yu})),n.d(e,"randomUniform",(function(){return bg})),n.d(e,"randomNormal",(function(){return mg})),n.d(e,"randomLogNormal",(function(){return vg})),n.d(e,"randomBates",(function(){return wg})),n.d(e,"randomIrwinHall",(function(){return _g})),n.d(e,"randomExponential",(function(){return xg})),n.d(e,"scaleBand",(function(){return Cg})),n.d(e,"scalePoint",(function(){return Og})),n.d(e,"scaleIdentity",(function(){return $g})),n.d(e,"scaleLinear",(function(){return Hg})),n.d(e,"scaleLog",(function(){return ey})),n.d(e,"scaleSymlog",(function(){return oy})),n.d(e,"scaleOrdinal",(function(){return Dg})),n.d(e,"scaleImplicit",(function(){return Mg})),n.d(e,"scalePow",(function(){return fy})),n.d(e,"scaleSqrt",(function(){return ly})),n.d(e,"scaleQuantile",(function(){return hy})),n.d(e,"scaleQuantize",(function(){return dy})),n.d(e,"scaleThreshold",(function(){return py})),n.d(e,"scaleTime",(function(){return ev})),n.d(e,"scaleUtc",(function(){return lv})),n.d(e,"scaleSequential",(function(){return pv})),n.d(e,"scaleSequentialLog",(function(){return gv})),n.d(e,"scaleSequentialPow",(function(){return bv})),n.d(e,"scaleSequentialSqrt",(function(){return mv})),n.d(e,"scaleSequentialSymlog",(function(){return yv})),n.d(e,"scaleSequentialQuantile",(function(){return vv})),n.d(e,"scaleDiverging",(function(){return wv})),n.d(e,"scaleDivergingLog",(function(){return xv})),n.d(e,"scaleDivergingPow",(function(){return Ev})),n.d(e,"scaleDivergingSqrt",(function(){return Av})),n.d(e,"scaleDivergingSymlog",(function(){return kv})),n.d(e,"tickFormat",(function(){return Yg})),n.d(e,"schemeCategory10",(function(){return Tv})),n.d(e,"schemeAccent",(function(){return Mv})),n.d(e,"schemeDark2",(function(){return Dv})),n.d(e,"schemePaired",(function(){return Cv})),n.d(e,"schemePastel1",(function(){return Ov})),n.d(e,"schemePastel2",(function(){return Rv})),n.d(e,"schemeSet1",(function(){return Iv})),n.d(e,"schemeSet2",(function(){return Nv})),n.d(e,"schemeSet3",(function(){return Bv})),n.d(e,"schemeTableau10",(function(){return Lv})),n.d(e,"interpolateBrBG",(function(){return qv})),n.d(e,"schemeBrBG",(function(){return Fv})),n.d(e,"interpolatePRGn",(function(){return Uv})),n.d(e,"schemePRGn",(function(){return jv})),n.d(e,"interpolatePiYG",(function(){return Yv})),n.d(e,"schemePiYG",(function(){return zv})),n.d(e,"interpolatePuOr",(function(){return Hv})),n.d(e,"schemePuOr",(function(){return Vv})),n.d(e,"interpolateRdBu",(function(){return Gv})),n.d(e,"schemeRdBu",(function(){return $v})),n.d(e,"interpolateRdGy",(function(){return Kv})),n.d(e,"schemeRdGy",(function(){return Wv})),n.d(e,"interpolateRdYlBu",(function(){return Zv})),n.d(e,"schemeRdYlBu",(function(){return Xv})),n.d(e,"interpolateRdYlGn",(function(){return Qv})),n.d(e,"schemeRdYlGn",(function(){return Jv})),n.d(e,"interpolateSpectral",(function(){return e_})),n.d(e,"schemeSpectral",(function(){return t_})),n.d(e,"interpolateBuGn",(function(){return r_})),n.d(e,"schemeBuGn",(function(){return n_})),n.d(e,"interpolateBuPu",(function(){return o_})),n.d(e,"schemeBuPu",(function(){return i_})),n.d(e,"interpolateGnBu",(function(){return s_})),n.d(e,"schemeGnBu",(function(){return a_})),n.d(e,"interpolateOrRd",(function(){return c_})),n.d(e,"schemeOrRd",(function(){return u_})),n.d(e,"interpolatePuBuGn",(function(){return l_})),n.d(e,"schemePuBuGn",(function(){return f_})),n.d(e,"interpolatePuBu",(function(){return d_})),n.d(e,"schemePuBu",(function(){return h_})),n.d(e,"interpolatePuRd",(function(){return g_})),n.d(e,"schemePuRd",(function(){return p_})),n.d(e,"interpolateRdPu",(function(){return b_})),n.d(e,"schemeRdPu",(function(){return y_})),n.d(e,"interpolateYlGnBu",(function(){return v_})),n.d(e,"schemeYlGnBu",(function(){return m_})),n.d(e,"interpolateYlGn",(function(){return w_})),n.d(e,"schemeYlGn",(function(){return __})),n.d(e,"interpolateYlOrBr",(function(){return k_})),n.d(e,"schemeYlOrBr",(function(){return x_})),n.d(e,"interpolateYlOrRd",(function(){return A_})),n.d(e,"schemeYlOrRd",(function(){return E_})),n.d(e,"interpolateBlues",(function(){return T_})),n.d(e,"schemeBlues",(function(){return S_})),n.d(e,"interpolateGreens",(function(){return D_})),n.d(e,"schemeGreens",(function(){return M_})),n.d(e,"interpolateGreys",(function(){return O_})),n.d(e,"schemeGreys",(function(){return C_})),n.d(e,"interpolatePurples",(function(){return I_})),n.d(e,"schemePurples",(function(){return R_})),n.d(e,"interpolateReds",(function(){return B_})),n.d(e,"schemeReds",(function(){return N_})),n.d(e,"interpolateOranges",(function(){return P_})),n.d(e,"schemeOranges",(function(){return L_})),n.d(e,"interpolateCividis",(function(){return F_})),n.d(e,"interpolateCubehelixDefault",(function(){return q_})),n.d(e,"interpolateRainbow",(function(){return Y_})),n.d(e,"interpolateWarm",(function(){return j_})),n.d(e,"interpolateCool",(function(){return U_})),n.d(e,"interpolateSinebow",(function(){return G_})),n.d(e,"interpolateTurbo",(function(){return W_})),n.d(e,"interpolateViridis",(function(){return X_})),n.d(e,"interpolateMagma",(function(){return Z_})),n.d(e,"interpolateInferno",(function(){return J_})),n.d(e,"interpolatePlasma",(function(){return Q_})),n.d(e,"create",(function(){return De})),n.d(e,"creator",(function(){return wt})),n.d(e,"local",(function(){return Oe})),n.d(e,"matcher",(function(){return St})),n.d(e,"mouse",(function(){return Be})),n.d(e,"namespace",(function(){return mt})),n.d(e,"namespaces",(function(){return bt})),n.d(e,"clientPoint",(function(){return Ne})),n.d(e,"select",(function(){return Me})),n.d(e,"selectAll",(function(){return Le})),n.d(e,"selection",(function(){return Te})),n.d(e,"selector",(function(){return kt})),n.d(e,"selectorAll",(function(){return At})),n.d(e,"style",(function(){return Yt})),n.d(e,"touch",(function(){return Pe})),n.d(e,"touches",(function(){return Fe})),n.d(e,"window",(function(){return qt})),n.d(e,"event",(function(){return pe})),n.d(e,"customEvent",(function(){return _e})),n.d(e,"arc",(function(){return vw})),n.d(e,"area",(function(){return Aw})),n.d(e,"line",(function(){return Ew})),n.d(e,"pie",(function(){return Mw})),n.d(e,"areaRadial",(function(){return Nw})),n.d(e,"radialArea",(function(){return Nw})),n.d(e,"lineRadial",(function(){return Iw})),n.d(e,"radialLine",(function(){return Iw})),n.d(e,"pointRadial",(function(){return Bw})),n.d(e,"linkHorizontal",(function(){return Yw})),n.d(e,"linkVertical",(function(){return Vw})),n.d(e,"linkRadial",(function(){return Hw})),n.d(e,"symbol",(function(){return cx})),n.d(e,"symbols",(function(){return ux})),n.d(e,"symbolCircle",(function(){return $w})),n.d(e,"symbolCross",(function(){return Gw})),n.d(e,"symbolDiamond",(function(){return Xw})),n.d(e,"symbolSquare",(function(){return ex})),n.d(e,"symbolStar",(function(){return tx})),n.d(e,"symbolTriangle",(function(){return rx})),n.d(e,"symbolWye",(function(){return sx})),n.d(e,"curveBasisClosed",(function(){return gx})),n.d(e,"curveBasisOpen",(function(){return bx})),n.d(e,"curveBasis",(function(){return dx})),n.d(e,"curveBundle",(function(){return vx})),n.d(e,"curveCardinalClosed",(function(){return Ex})),n.d(e,"curveCardinalOpen",(function(){return Sx})),n.d(e,"curveCardinal",(function(){return xx})),n.d(e,"curveCatmullRomClosed",(function(){return Ox})),n.d(e,"curveCatmullRomOpen",(function(){return Ix})),n.d(e,"curveCatmullRom",(function(){return Dx})),n.d(e,"curveLinearClosed",(function(){return Bx})),n.d(e,"curveLinear",(function(){return ww})),n.d(e,"curveMonotoneX",(function(){return Yx})),n.d(e,"curveMonotoneY",(function(){return Vx})),n.d(e,"curveNatural",(function(){return Gx})),n.d(e,"curveStep",(function(){return Kx})),n.d(e,"curveStepAfter",(function(){return Zx})),n.d(e,"curveStepBefore",(function(){return Xx})),n.d(e,"stack",(function(){return ek})),n.d(e,"stackOffsetExpand",(function(){return nk})),n.d(e,"stackOffsetDiverging",(function(){return rk})),n.d(e,"stackOffsetNone",(function(){return Jx})),n.d(e,"stackOffsetSilhouette",(function(){return ik})),n.d(e,"stackOffsetWiggle",(function(){return ok})),n.d(e,"stackOrderAppearance",(function(){return ak})),n.d(e,"stackOrderAscending",(function(){return uk})),n.d(e,"stackOrderDescending",(function(){return fk})),n.d(e,"stackOrderInsideOut",(function(){return lk})),n.d(e,"stackOrderNone",(function(){return Qx})),n.d(e,"stackOrderReverse",(function(){return hk})),n.d(e,"timeInterval",(function(){return by})),n.d(e,"timeMillisecond",(function(){return tb})),n.d(e,"timeMilliseconds",(function(){return eb})),n.d(e,"utcMillisecond",(function(){return tb})),n.d(e,"utcMilliseconds",(function(){return eb})),n.d(e,"timeSecond",(function(){return Zy})),n.d(e,"timeSeconds",(function(){return Jy})),n.d(e,"utcSecond",(function(){return Zy})),n.d(e,"utcSeconds",(function(){return Jy})),n.d(e,"timeMinute",(function(){return Wy})),n.d(e,"timeMinutes",(function(){return Ky})),n.d(e,"timeHour",(function(){return Hy})),n.d(e,"timeHours",(function(){return $y})),n.d(e,"timeDay",(function(){return zy})),n.d(e,"timeDays",(function(){return Yy})),n.d(e,"timeWeek",(function(){return Ty})),n.d(e,"timeWeeks",(function(){return Ny})),n.d(e,"timeSunday",(function(){return Ty})),n.d(e,"timeSundays",(function(){return Ny})),n.d(e,"timeMonday",(function(){return My})),n.d(e,"timeMondays",(function(){return By})),n.d(e,"timeTuesday",(function(){return Dy})),n.d(e,"timeTuesdays",(function(){return Ly})),n.d(e,"timeWednesday",(function(){return Cy})),n.d(e,"timeWednesdays",(function(){return Py})),n.d(e,"timeThursday",(function(){return Oy})),n.d(e,"timeThursdays",(function(){return Fy})),n.d(e,"timeFriday",(function(){return Ry})),n.d(e,"timeFridays",(function(){return qy})),n.d(e,"timeSaturday",(function(){return Iy})),n.d(e,"timeSaturdays",(function(){return jy})),n.d(e,"timeMonth",(function(){return xy})),n.d(e,"timeMonths",(function(){return ky})),n.d(e,"timeYear",(function(){return vy})),n.d(e,"timeYears",(function(){return _y})),n.d(e,"utcMinute",(function(){return cv})),n.d(e,"utcMinutes",(function(){return fv})),n.d(e,"utcHour",(function(){return av})),n.d(e,"utcHours",(function(){return sv})),n.d(e,"utcDay",(function(){return mb})),n.d(e,"utcDays",(function(){return vb})),n.d(e,"utcWeek",(function(){return rb})),n.d(e,"utcWeeks",(function(){return fb})),n.d(e,"utcSunday",(function(){return rb})),n.d(e,"utcSundays",(function(){return fb})),n.d(e,"utcMonday",(function(){return ib})),n.d(e,"utcMondays",(function(){return lb})),n.d(e,"utcTuesday",(function(){return ob})),n.d(e,"utcTuesdays",(function(){return hb})),n.d(e,"utcWednesday",(function(){return ab})),n.d(e,"utcWednesdays",(function(){return db})),n.d(e,"utcThursday",(function(){return sb})),n.d(e,"utcThursdays",(function(){return pb})),n.d(e,"utcFriday",(function(){return ub})),n.d(e,"utcFridays",(function(){return gb})),n.d(e,"utcSaturday",(function(){return cb})),n.d(e,"utcSaturdays",(function(){return yb})),n.d(e,"utcMonth",(function(){return rv})),n.d(e,"utcMonths",(function(){return iv})),n.d(e,"utcYear",(function(){return wb})),n.d(e,"utcYears",(function(){return xb})),n.d(e,"timeFormatDefaultLocale",(function(){return zm})),n.d(e,"timeFormat",(function(){return Mb})),n.d(e,"timeParse",(function(){return Db})),n.d(e,"utcFormat",(function(){return Cb})),n.d(e,"utcParse",(function(){return Ob})),n.d(e,"timeFormatLocale",(function(){return Sb})),n.d(e,"isoFormat",(function(){return Ym})),n.d(e,"isoParse",(function(){return Vm})),n.d(e,"now",(function(){return ui})),n.d(e,"timer",(function(){return li})),n.d(e,"timerFlush",(function(){return hi})),n.d(e,"timeout",(function(){return yi})),n.d(e,"interval",(function(){return bi})),n.d(e,"transition",(function(){return eo})),n.d(e,"active",(function(){return Ko})),n.d(e,"interrupt",(function(){return Oi})),n.d(e,"voronoi",(function(){return Zk})),n.d(e,"zoom",(function(){return lE})),n.d(e,"zoomTransform",(function(){return nE})),n.d(e,"zoomIdentity",(function(){return eE}))},function(t,e,n){(function(t,r){var i=function(){var t=function(t,e,n,r){for(n=n||{},r=t.length;r--;n[t[r]]=e);return n},e=[1,2],n=[1,3],r=[1,4],i=[2,4],o=[1,9],a=[1,11],s=[1,12],u=[1,14],c=[1,15],f=[1,17],l=[1,18],h=[1,19],d=[1,20],p=[1,21],g=[1,22],y=[1,24],b=[1,25],m=[1,4,5,10,15,16,18,20,21,22,23,24,26,28,29,30,41],v=[1,33],_=[4,5,10,15,16,18,20,21,22,23,24,26,30,41],w=[4,5,10,15,16,18,20,21,22,23,24,26,29,30,41],x=[4,5,10,15,16,18,20,21,22,23,24,26,28,30,41],k=[39,40,41],E={trace:function(){},yy:{},symbols_:{error:2,start:3,SPACE:4,NL:5,SD:6,document:7,line:8,statement:9,participant:10,actor:11,AS:12,restOfLine:13,signal:14,activate:15,deactivate:16,note_statement:17,title:18,text2:19,loop:20,end:21,rect:22,opt:23,alt:24,else_sections:25,par:26,par_sections:27,and:28,else:29,note:30,placement:31,over:32,actor_pair:33,spaceList:34,",":35,left_of:36,right_of:37,signaltype:38,"+":39,"-":40,ACTOR:41,SOLID_OPEN_ARROW:42,DOTTED_OPEN_ARROW:43,SOLID_ARROW:44,DOTTED_ARROW:45,SOLID_CROSS:46,DOTTED_CROSS:47,TXT:48,$accept:0,$end:1},terminals_:{2:"error",4:"SPACE",5:"NL",6:"SD",10:"participant",12:"AS",13:"restOfLine",15:"activate",16:"deactivate",18:"title",20:"loop",21:"end",22:"rect",23:"opt",24:"alt",26:"par",28:"and",29:"else",30:"note",32:"over",35:",",36:"left_of",37:"right_of",39:"+",40:"-",41:"ACTOR",42:"SOLID_OPEN_ARROW",43:"DOTTED_OPEN_ARROW",44:"SOLID_ARROW",45:"DOTTED_ARROW",46:"SOLID_CROSS",47:"DOTTED_CROSS",48:"TXT"},productions_:[0,[3,2],[3,2],[3,2],[7,0],[7,2],[8,2],[8,1],[8,1],[9,5],[9,3],[9,2],[9,3],[9,3],[9,2],[9,3],[9,4],[9,4],[9,4],[9,4],[9,4],[27,1],[27,4],[25,1],[25,4],[17,4],[17,4],[34,2],[34,1],[33,3],[33,1],[31,1],[31,1],[14,5],[14,5],[14,4],[11,1],[38,1],[38,1],[38,1],[38,1],[38,1],[38,1],[19,1]],performAction:function(t,e,n,r,i,o,a){var s=o.length-1;switch(i){case 3:return r.apply(o[s]),o[s];case 4:this.$=[];break;case 5:o[s-1].push(o[s]),this.$=o[s-1];break;case 6:case 7:this.$=o[s];break;case 8:this.$=[];break;case 9:o[s-3].description=o[s-1],this.$=o[s-3];break;case 10:this.$=o[s-1];break;case 12:this.$={type:"activeStart",signalType:r.LINETYPE.ACTIVE_START,actor:o[s-1]};break;case 13:this.$={type:"activeEnd",signalType:r.LINETYPE.ACTIVE_END,actor:o[s-1]};break;case 15:this.$=[{type:"setTitle",text:o[s-1]}];break;case 16:o[s-1].unshift({type:"loopStart",loopText:o[s-2],signalType:r.LINETYPE.LOOP_START}),o[s-1].push({type:"loopEnd",loopText:o[s-2],signalType:r.LINETYPE.LOOP_END}),this.$=o[s-1];break;case 17:o[s-1].unshift({type:"rectStart",color:o[s-2],signalType:r.LINETYPE.RECT_START}),o[s-1].push({type:"rectEnd",color:o[s-2],signalType:r.LINETYPE.RECT_END}),this.$=o[s-1];break;case 18:o[s-1].unshift({type:"optStart",optText:o[s-2],signalType:r.LINETYPE.OPT_START}),o[s-1].push({type:"optEnd",optText:o[s-2],signalType:r.LINETYPE.OPT_END}),this.$=o[s-1];break;case 19:o[s-1].unshift({type:"altStart",altText:o[s-2],signalType:r.LINETYPE.ALT_START}),o[s-1].push({type:"altEnd",signalType:r.LINETYPE.ALT_END}),this.$=o[s-1];break;case 20:o[s-1].unshift({type:"parStart",parText:o[s-2],signalType:r.LINETYPE.PAR_START}),o[s-1].push({type:"parEnd",signalType:r.LINETYPE.PAR_END}),this.$=o[s-1];break;case 22:this.$=o[s-3].concat([{type:"and",parText:o[s-1],signalType:r.LINETYPE.PAR_AND},o[s]]);break;case 24:this.$=o[s-3].concat([{type:"else",altText:o[s-1],signalType:r.LINETYPE.ALT_ELSE},o[s]]);break;case 25:this.$=[o[s-1],{type:"addNote",placement:o[s-2],actor:o[s-1].actor,text:o[s]}];break;case 26:o[s-2]=[].concat(o[s-1],o[s-1]).slice(0,2),o[s-2][0]=o[s-2][0].actor,o[s-2][1]=o[s-2][1].actor,this.$=[o[s-1],{type:"addNote",placement:r.PLACEMENT.OVER,actor:o[s-2].slice(0,2),text:o[s]}];break;case 29:this.$=[o[s-2],o[s]];break;case 30:this.$=o[s];break;case 31:this.$=r.PLACEMENT.LEFTOF;break;case 32:this.$=r.PLACEMENT.RIGHTOF;break;case 33:this.$=[o[s-4],o[s-1],{type:"addMessage",from:o[s-4].actor,to:o[s-1].actor,signalType:o[s-3],msg:o[s]},{type:"activeStart",signalType:r.LINETYPE.ACTIVE_START,actor:o[s-1]}];break;case 34:this.$=[o[s-4],o[s-1],{type:"addMessage",from:o[s-4].actor,to:o[s-1].actor,signalType:o[s-3],msg:o[s]},{type:"activeEnd",signalType:r.LINETYPE.ACTIVE_END,actor:o[s-4]}];break;case 35:this.$=[o[s-3],o[s-1],{type:"addMessage",from:o[s-3].actor,to:o[s-1].actor,signalType:o[s-2],msg:o[s]}];break;case 36:this.$={type:"addActor",actor:o[s]};break;case 37:this.$=r.LINETYPE.SOLID_OPEN;break;case 38:this.$=r.LINETYPE.DOTTED_OPEN;break;case 39:this.$=r.LINETYPE.SOLID;break;case 40:this.$=r.LINETYPE.DOTTED;break;case 41:this.$=r.LINETYPE.SOLID_CROSS;break;case 42:this.$=r.LINETYPE.DOTTED_CROSS;break;case 43:this.$=o[s].substring(1).trim().replace(/\\n/gm,"\n")}},table:[{3:1,4:e,5:n,6:r},{1:[3]},{3:5,4:e,5:n,6:r},{3:6,4:e,5:n,6:r},t([1,4,5,10,15,16,18,20,22,23,24,26,30,41],i,{7:7}),{1:[2,1]},{1:[2,2]},{1:[2,3],4:o,5:a,8:8,9:10,10:s,11:23,14:13,15:u,16:c,17:16,18:f,20:l,22:h,23:d,24:p,26:g,30:y,41:b},t(m,[2,5]),{9:26,10:s,11:23,14:13,15:u,16:c,17:16,18:f,20:l,22:h,23:d,24:p,26:g,30:y,41:b},t(m,[2,7]),t(m,[2,8]),{11:27,41:b},{5:[1,28]},{11:29,41:b},{11:30,41:b},{5:[1,31]},{19:32,48:v},{13:[1,34]},{13:[1,35]},{13:[1,36]},{13:[1,37]},{13:[1,38]},{38:39,42:[1,40],43:[1,41],44:[1,42],45:[1,43],46:[1,44],47:[1,45]},{31:46,32:[1,47],36:[1,48],37:[1,49]},t([5,12,35,42,43,44,45,46,47,48],[2,36]),t(m,[2,6]),{5:[1,51],12:[1,50]},t(m,[2,11]),{5:[1,52]},{5:[1,53]},t(m,[2,14]),{5:[1,54]},{5:[2,43]},t(_,i,{7:55}),t(_,i,{7:56}),t(_,i,{7:57}),t(w,i,{25:58,7:59}),t(x,i,{27:60,7:61}),{11:64,39:[1,62],40:[1,63],41:b},t(k,[2,37]),t(k,[2,38]),t(k,[2,39]),t(k,[2,40]),t(k,[2,41]),t(k,[2,42]),{11:65,41:b},{11:67,33:66,41:b},{41:[2,31]},{41:[2,32]},{13:[1,68]},t(m,[2,10]),t(m,[2,12]),t(m,[2,13]),t(m,[2,15]),{4:o,5:a,8:8,9:10,10:s,11:23,14:13,15:u,16:c,17:16,18:f,20:l,21:[1,69],22:h,23:d,24:p,26:g,30:y,41:b},{4:o,5:a,8:8,9:10,10:s,11:23,14:13,15:u,16:c,17:16,18:f,20:l,21:[1,70],22:h,23:d,24:p,26:g,30:y,41:b},{4:o,5:a,8:8,9:10,10:s,11:23,14:13,15:u,16:c,17:16,18:f,20:l,21:[1,71],22:h,23:d,24:p,26:g,30:y,41:b},{21:[1,72]},{4:o,5:a,8:8,9:10,10:s,11:23,14:13,15:u,16:c,17:16,18:f,20:l,21:[2,23],22:h,23:d,24:p,26:g,29:[1,73],30:y,41:b},{21:[1,74]},{4:o,5:a,8:8,9:10,10:s,11:23,14:13,15:u,16:c,17:16,18:f,20:l,21:[2,21],22:h,23:d,24:p,26:g,28:[1,75],30:y,41:b},{11:76,41:b},{11:77,41:b},{19:78,48:v},{19:79,48:v},{19:80,48:v},{35:[1,81],48:[2,30]},{5:[1,82]},t(m,[2,16]),t(m,[2,17]),t(m,[2,18]),t(m,[2,19]),{13:[1,83]},t(m,[2,20]),{13:[1,84]},{19:85,48:v},{19:86,48:v},{5:[2,35]},{5:[2,25]},{5:[2,26]},{11:87,41:b},t(m,[2,9]),t(w,i,{7:59,25:88}),t(x,i,{7:61,27:89}),{5:[2,33]},{5:[2,34]},{48:[2,29]},{21:[2,24]},{21:[2,22]}],defaultActions:{5:[2,1],6:[2,2],33:[2,43],48:[2,31],49:[2,32],78:[2,35],79:[2,25],80:[2,26],85:[2,33],86:[2,34],87:[2,29],88:[2,24],89:[2,22]},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],r=[],i=[null],o=[],a=this.table,s="",u=0,c=0,f=0,l=2,h=1,d=o.slice.call(arguments,1),p=Object.create(this.lexer),g={yy:{}};for(var y in this.yy)Object.prototype.hasOwnProperty.call(this.yy,y)&&(g.yy[y]=this.yy[y]);p.setInput(t,g.yy),g.yy.lexer=p,g.yy.parser=this,void 0===p.yylloc&&(p.yylloc={});var b=p.yylloc;o.push(b);var m=p.options&&p.options.ranges;function v(){var t;return"number"!=typeof(t=r.pop()||p.lex()||h)&&(t instanceof Array&&(t=(r=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof g.yy.parseError?this.parseError=g.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var _,w,x,k,E,A,S,T,M,D={};;){if(x=n[n.length-1],this.defaultActions[x]?k=this.defaultActions[x]:(null==_&&(_=v()),k=a[x]&&a[x][_]),void 0===k||!k.length||!k[0]){var C="";for(A in M=[],a[x])this.terminals_[A]&&A>l&&M.push("'"+this.terminals_[A]+"'");C=p.showPosition?"Parse error on line "+(u+1)+":\n"+p.showPosition()+"\nExpecting "+M.join(", ")+", got '"+(this.terminals_[_]||_)+"'":"Parse error on line "+(u+1)+": Unexpected "+(_==h?"end of input":"'"+(this.terminals_[_]||_)+"'"),this.parseError(C,{text:p.match,token:this.terminals_[_]||_,line:p.yylineno,loc:b,expected:M})}if(k[0]instanceof Array&&k.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+_);switch(k[0]){case 1:n.push(_),i.push(p.yytext),o.push(p.yylloc),n.push(k[1]),_=null,w?(_=w,w=null):(c=p.yyleng,s=p.yytext,u=p.yylineno,b=p.yylloc,f>0&&f--);break;case 2:if(S=this.productions_[k[1]][1],D.$=i[i.length-S],D._$={first_line:o[o.length-(S||1)].first_line,last_line:o[o.length-1].last_line,first_column:o[o.length-(S||1)].first_column,last_column:o[o.length-1].last_column},m&&(D._$.range=[o[o.length-(S||1)].range[0],o[o.length-1].range[1]]),void 0!==(E=this.performAction.apply(D,[s,c,u,g.yy,k[1],i,o].concat(d))))return E;S&&(n=n.slice(0,-1*S*2),i=i.slice(0,-1*S),o=o.slice(0,-1*S)),n.push(this.productions_[k[1]][0]),i.push(D.$),o.push(D._$),T=a[n[n.length-2]][n[n.length-1]],n.push(T);break;case 3:return!0}}return!0}},A={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var r=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var i=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===r.length?this.yylloc.first_column:0)+r[r.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[i[0],i[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,r,i;if(this.options.backtrack_lexer&&(i={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(i.yylloc.range=this.yylloc.range.slice(0))),(r=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=r.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:r?r[r.length-1].length-r[r.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var o in i)this[o]=i[o];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,r;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var i=this._currentRules(),o=0;o<i.length;o++)if((n=this._input.match(this.rules[i[o]]))&&(!e||n[0].length>e[0].length)){if(e=n,r=o,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,i[o])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,i[r]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(t,e,n,r){switch(n){case 0:return 5;case 1:case 2:case 3:case 4:break;case 5:return this.begin("ID"),10;case 6:return e.yytext=e.yytext.trim(),this.begin("ALIAS"),41;case 7:return this.popState(),this.popState(),this.begin("LINE"),12;case 8:return this.popState(),this.popState(),5;case 9:return this.begin("LINE"),20;case 10:return this.begin("LINE"),22;case 11:return this.begin("LINE"),23;case 12:return this.begin("LINE"),24;case 13:return this.begin("LINE"),29;case 14:return this.begin("LINE"),26;case 15:return this.begin("LINE"),28;case 16:return this.popState(),13;case 17:return 21;case 18:return 36;case 19:return 37;case 20:return 32;case 21:return 30;case 22:return this.begin("ID"),15;case 23:return this.begin("ID"),16;case 24:return 18;case 25:return 6;case 26:return 35;case 27:return 5;case 28:return e.yytext=e.yytext.trim(),41;case 29:return 44;case 30:return 45;case 31:return 42;case 32:return 43;case 33:return 46;case 34:return 47;case 35:return 48;case 36:return 39;case 37:return 40;case 38:return 5;case 39:return"INVALID"}},rules:[/^(?:[\n]+)/i,/^(?:\s+)/i,/^(?:((?!\n)\s)+)/i,/^(?:#[^\n]*)/i,/^(?:%[^\n]*)/i,/^(?:participant\b)/i,/^(?:[^\->:\n,;]+?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i,/^(?:as\b)/i,/^(?:(?:))/i,/^(?:loop\b)/i,/^(?:rect\b)/i,/^(?:opt\b)/i,/^(?:alt\b)/i,/^(?:else\b)/i,/^(?:par\b)/i,/^(?:and\b)/i,/^(?:[^#\n;]*)/i,/^(?:end\b)/i,/^(?:left of\b)/i,/^(?:right of\b)/i,/^(?:over\b)/i,/^(?:note\b)/i,/^(?:activate\b)/i,/^(?:deactivate\b)/i,/^(?:title\b)/i,/^(?:sequenceDiagram\b)/i,/^(?:,)/i,/^(?:;)/i,/^(?:[^\+\->:\n,;]+)/i,/^(?:->>)/i,/^(?:-->>)/i,/^(?:->)/i,/^(?:-->)/i,/^(?:-[x])/i,/^(?:--[x])/i,/^(?::[^#\n;]+)/i,/^(?:\+)/i,/^(?:-)/i,/^(?:$)/i,/^(?:.)/i],conditions:{LINE:{rules:[2,3,16],inclusive:!1},ALIAS:{rules:[2,3,7,8],inclusive:!1},ID:{rules:[2,3,6],inclusive:!1},INITIAL:{rules:[0,1,3,4,5,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39],inclusive:!0}}};function S(){this.yy={}}return E.lexer=A,S.prototype=E,E.Parser=S,new S}();e.parser=i,e.Parser=i.Parser,e.parse=function(){return i.parse.apply(i,arguments)},e.main=function(r){r[1]||(console.log("Usage: "+r[0]+" FILE"),t.exit(1));var i=n(28).readFileSync(n(29).normalize(r[1]),"utf8");return e.parser.parse(i)},n.c[n.s]===r&&e.main(t.argv.slice(1))}).call(this,n(7),n(9)(t))},function(t,e){"function"==typeof Object.create?t.exports=function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(t,e){if(e){t.super_=e;var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}}},function(t,e,n){var r=n(8),i=r.Buffer;function o(t,e){for(var n in t)e[n]=t[n]}function a(t,e,n){return i(t,e,n)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?t.exports=r:(o(r,e),e.Buffer=a),a.prototype=Object.create(i.prototype),o(i,a),a.from=function(t,e,n){if("number"==typeof t)throw new TypeError("Argument must not be a number");return i(t,e,n)},a.alloc=function(t,e,n){if("number"!=typeof t)throw new TypeError("Argument must be a number");var r=i(t);return void 0!==e?"string"==typeof n?r.fill(e,n):r.fill(e):r.fill(0),r},a.allocUnsafe=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return i(t)},a.allocUnsafeSlow=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return r.SlowBuffer(t)}},function(t,e,n){var r;try{r={cloneDeep:n(348),constant:n(99),defaults:n(176),each:n(100),filter:n(150),find:n(349),flatten:n(178),forEach:n(148),forIn:n(354),has:n(106),isUndefined:n(161),last:n(355),map:n(162),mapValues:n(356),max:n(357),merge:n(359),min:n(364),minBy:n(365),now:n(366),pick:n(183),range:n(184),reduce:n(164),sortBy:n(373),uniqueId:n(185),values:n(169),zipObject:n(378)}}catch(t){}r||(r=window._),t.exports=r},function(t,e,n){(function(t){!function(t,e){"use strict";function r(t,e){if(!t)throw new Error(e||"Assertion failed")}function i(t,e){t.super_=e;var n=function(){};n.prototype=e.prototype,t.prototype=new n,t.prototype.constructor=t}function o(t,e,n){if(o.isBN(t))return t;this.negative=0,this.words=null,this.length=0,this.red=null,null!==t&&("le"!==e&&"be"!==e||(n=e,e=10),this._init(t||0,e||10,n||"be"))}var a;"object"==typeof t?t.exports=o:e.BN=o,o.BN=o,o.wordSize=26;try{a=n(457).Buffer}catch(t){}function s(t,e,n){for(var r=0,i=Math.min(t.length,n),o=e;o<i;o++){var a=t.charCodeAt(o)-48;r<<=4,r|=a>=49&&a<=54?a-49+10:a>=17&&a<=22?a-17+10:15&a}return r}function u(t,e,n,r){for(var i=0,o=Math.min(t.length,n),a=e;a<o;a++){var s=t.charCodeAt(a)-48;i*=r,i+=s>=49?s-49+10:s>=17?s-17+10:s}return i}o.isBN=function(t){return t instanceof o||null!==t&&"object"==typeof t&&t.constructor.wordSize===o.wordSize&&Array.isArray(t.words)},o.max=function(t,e){return t.cmp(e)>0?t:e},o.min=function(t,e){return t.cmp(e)<0?t:e},o.prototype._init=function(t,e,n){if("number"==typeof t)return this._initNumber(t,e,n);if("object"==typeof t)return this._initArray(t,e,n);"hex"===e&&(e=16),r(e===(0|e)&&e>=2&&e<=36);var i=0;"-"===(t=t.toString().replace(/\s+/g,""))[0]&&i++,16===e?this._parseHex(t,i):this._parseBase(t,e,i),"-"===t[0]&&(this.negative=1),this.strip(),"le"===n&&this._initArray(this.toArray(),e,n)},o.prototype._initNumber=function(t,e,n){t<0&&(this.negative=1,t=-t),t<67108864?(this.words=[67108863&t],this.length=1):t<4503599627370496?(this.words=[67108863&t,t/67108864&67108863],this.length=2):(r(t<9007199254740992),this.words=[67108863&t,t/67108864&67108863,1],this.length=3),"le"===n&&this._initArray(this.toArray(),e,n)},o.prototype._initArray=function(t,e,n){if(r("number"==typeof t.length),t.length<=0)return this.words=[0],this.length=1,this;this.length=Math.ceil(t.length/3),this.words=new Array(this.length);for(var i=0;i<this.length;i++)this.words[i]=0;var o,a,s=0;if("be"===n)for(i=t.length-1,o=0;i>=0;i-=3)a=t[i]|t[i-1]<<8|t[i-2]<<16,this.words[o]|=a<<s&67108863,this.words[o+1]=a>>>26-s&67108863,(s+=24)>=26&&(s-=26,o++);else if("le"===n)for(i=0,o=0;i<t.length;i+=3)a=t[i]|t[i+1]<<8|t[i+2]<<16,this.words[o]|=a<<s&67108863,this.words[o+1]=a>>>26-s&67108863,(s+=24)>=26&&(s-=26,o++);return this.strip()},o.prototype._parseHex=function(t,e){this.length=Math.ceil((t.length-e)/6),this.words=new Array(this.length);for(var n=0;n<this.length;n++)this.words[n]=0;var r,i,o=0;for(n=t.length-6,r=0;n>=e;n-=6)i=s(t,n,n+6),this.words[r]|=i<<o&67108863,this.words[r+1]|=i>>>26-o&4194303,(o+=24)>=26&&(o-=26,r++);n+6!==e&&(i=s(t,e,n+6),this.words[r]|=i<<o&67108863,this.words[r+1]|=i>>>26-o&4194303),this.strip()},o.prototype._parseBase=function(t,e,n){this.words=[0],this.length=1;for(var r=0,i=1;i<=67108863;i*=e)r++;r--,i=i/e|0;for(var o=t.length-n,a=o%r,s=Math.min(o,o-a)+n,c=0,f=n;f<s;f+=r)c=u(t,f,f+r,e),this.imuln(i),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c);if(0!==a){var l=1;for(c=u(t,f,t.length,e),f=0;f<a;f++)l*=e;this.imuln(l),this.words[0]+c<67108864?this.words[0]+=c:this._iaddn(c)}},o.prototype.copy=function(t){t.words=new Array(this.length);for(var e=0;e<this.length;e++)t.words[e]=this.words[e];t.length=this.length,t.negative=this.negative,t.red=this.red},o.prototype.clone=function(){var t=new o(null);return this.copy(t),t},o.prototype._expand=function(t){for(;this.length<t;)this.words[this.length++]=0;return this},o.prototype.strip=function(){for(;this.length>1&&0===this.words[this.length-1];)this.length--;return this._normSign()},o.prototype._normSign=function(){return 1===this.length&&0===this.words[0]&&(this.negative=0),this},o.prototype.inspect=function(){return(this.red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var c=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],f=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],l=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function h(t,e,n){n.negative=e.negative^t.negative;var r=t.length+e.length|0;n.length=r,r=r-1|0;var i=0|t.words[0],o=0|e.words[0],a=i*o,s=67108863&a,u=a/67108864|0;n.words[0]=s;for(var c=1;c<r;c++){for(var f=u>>>26,l=67108863&u,h=Math.min(c,e.length-1),d=Math.max(0,c-t.length+1);d<=h;d++){var p=c-d|0;f+=(a=(i=0|t.words[p])*(o=0|e.words[d])+l)/67108864|0,l=67108863&a}n.words[c]=0|l,u=0|f}return 0!==u?n.words[c]=0|u:n.length--,n.strip()}o.prototype.toString=function(t,e){var n;if(e=0|e||1,16===(t=t||10)||"hex"===t){n="";for(var i=0,o=0,a=0;a<this.length;a++){var s=this.words[a],u=(16777215&(s<<i|o)).toString(16);n=0!==(o=s>>>24-i&16777215)||a!==this.length-1?c[6-u.length]+u+n:u+n,(i+=2)>=26&&(i-=26,a--)}for(0!==o&&(n=o.toString(16)+n);n.length%e!=0;)n="0"+n;return 0!==this.negative&&(n="-"+n),n}if(t===(0|t)&&t>=2&&t<=36){var h=f[t],d=l[t];n="";var p=this.clone();for(p.negative=0;!p.isZero();){var g=p.modn(d).toString(t);n=(p=p.idivn(d)).isZero()?g+n:c[h-g.length]+g+n}for(this.isZero()&&(n="0"+n);n.length%e!=0;)n="0"+n;return 0!==this.negative&&(n="-"+n),n}r(!1,"Base should be between 2 and 36")},o.prototype.toNumber=function(){var t=this.words[0];return 2===this.length?t+=67108864*this.words[1]:3===this.length&&1===this.words[2]?t+=4503599627370496+67108864*this.words[1]:this.length>2&&r(!1,"Number can only safely store up to 53 bits"),0!==this.negative?-t:t},o.prototype.toJSON=function(){return this.toString(16)},o.prototype.toBuffer=function(t,e){return r(void 0!==a),this.toArrayLike(a,t,e)},o.prototype.toArray=function(t,e){return this.toArrayLike(Array,t,e)},o.prototype.toArrayLike=function(t,e,n){var i=this.byteLength(),o=n||Math.max(1,i);r(i<=o,"byte array longer than desired length"),r(o>0,"Requested array length <= 0"),this.strip();var a,s,u="le"===e,c=new t(o),f=this.clone();if(u){for(s=0;!f.isZero();s++)a=f.andln(255),f.iushrn(8),c[s]=a;for(;s<o;s++)c[s]=0}else{for(s=0;s<o-i;s++)c[s]=0;for(s=0;!f.isZero();s++)a=f.andln(255),f.iushrn(8),c[o-s-1]=a}return c},Math.clz32?o.prototype._countBits=function(t){return 32-Math.clz32(t)}:o.prototype._countBits=function(t){var e=t,n=0;return e>=4096&&(n+=13,e>>>=13),e>=64&&(n+=7,e>>>=7),e>=8&&(n+=4,e>>>=4),e>=2&&(n+=2,e>>>=2),n+e},o.prototype._zeroBits=function(t){if(0===t)return 26;var e=t,n=0;return 0==(8191&e)&&(n+=13,e>>>=13),0==(127&e)&&(n+=7,e>>>=7),0==(15&e)&&(n+=4,e>>>=4),0==(3&e)&&(n+=2,e>>>=2),0==(1&e)&&n++,n},o.prototype.bitLength=function(){var t=this.words[this.length-1],e=this._countBits(t);return 26*(this.length-1)+e},o.prototype.zeroBits=function(){if(this.isZero())return 0;for(var t=0,e=0;e<this.length;e++){var n=this._zeroBits(this.words[e]);if(t+=n,26!==n)break}return t},o.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},o.prototype.toTwos=function(t){return 0!==this.negative?this.abs().inotn(t).iaddn(1):this.clone()},o.prototype.fromTwos=function(t){return this.testn(t-1)?this.notn(t).iaddn(1).ineg():this.clone()},o.prototype.isNeg=function(){return 0!==this.negative},o.prototype.neg=function(){return this.clone().ineg()},o.prototype.ineg=function(){return this.isZero()||(this.negative^=1),this},o.prototype.iuor=function(t){for(;this.length<t.length;)this.words[this.length++]=0;for(var e=0;e<t.length;e++)this.words[e]=this.words[e]|t.words[e];return this.strip()},o.prototype.ior=function(t){return r(0==(this.negative|t.negative)),this.iuor(t)},o.prototype.or=function(t){return this.length>t.length?this.clone().ior(t):t.clone().ior(this)},o.prototype.uor=function(t){return this.length>t.length?this.clone().iuor(t):t.clone().iuor(this)},o.prototype.iuand=function(t){var e;e=this.length>t.length?t:this;for(var n=0;n<e.length;n++)this.words[n]=this.words[n]&t.words[n];return this.length=e.length,this.strip()},o.prototype.iand=function(t){return r(0==(this.negative|t.negative)),this.iuand(t)},o.prototype.and=function(t){return this.length>t.length?this.clone().iand(t):t.clone().iand(this)},o.prototype.uand=function(t){return this.length>t.length?this.clone().iuand(t):t.clone().iuand(this)},o.prototype.iuxor=function(t){var e,n;this.length>t.length?(e=this,n=t):(e=t,n=this);for(var r=0;r<n.length;r++)this.words[r]=e.words[r]^n.words[r];if(this!==e)for(;r<e.length;r++)this.words[r]=e.words[r];return this.length=e.length,this.strip()},o.prototype.ixor=function(t){return r(0==(this.negative|t.negative)),this.iuxor(t)},o.prototype.xor=function(t){return this.length>t.length?this.clone().ixor(t):t.clone().ixor(this)},o.prototype.uxor=function(t){return this.length>t.length?this.clone().iuxor(t):t.clone().iuxor(this)},o.prototype.inotn=function(t){r("number"==typeof t&&t>=0);var e=0|Math.ceil(t/26),n=t%26;this._expand(e),n>0&&e--;for(var i=0;i<e;i++)this.words[i]=67108863&~this.words[i];return n>0&&(this.words[i]=~this.words[i]&67108863>>26-n),this.strip()},o.prototype.notn=function(t){return this.clone().inotn(t)},o.prototype.setn=function(t,e){r("number"==typeof t&&t>=0);var n=t/26|0,i=t%26;return this._expand(n+1),this.words[n]=e?this.words[n]|1<<i:this.words[n]&~(1<<i),this.strip()},o.prototype.iadd=function(t){var e,n,r;if(0!==this.negative&&0===t.negative)return this.negative=0,e=this.isub(t),this.negative^=1,this._normSign();if(0===this.negative&&0!==t.negative)return t.negative=0,e=this.isub(t),t.negative=1,e._normSign();this.length>t.length?(n=this,r=t):(n=t,r=this);for(var i=0,o=0;o<r.length;o++)e=(0|n.words[o])+(0|r.words[o])+i,this.words[o]=67108863&e,i=e>>>26;for(;0!==i&&o<n.length;o++)e=(0|n.words[o])+i,this.words[o]=67108863&e,i=e>>>26;if(this.length=n.length,0!==i)this.words[this.length]=i,this.length++;else if(n!==this)for(;o<n.length;o++)this.words[o]=n.words[o];return this},o.prototype.add=function(t){var e;return 0!==t.negative&&0===this.negative?(t.negative=0,e=this.sub(t),t.negative^=1,e):0===t.negative&&0!==this.negative?(this.negative=0,e=t.sub(this),this.negative=1,e):this.length>t.length?this.clone().iadd(t):t.clone().iadd(this)},o.prototype.isub=function(t){if(0!==t.negative){t.negative=0;var e=this.iadd(t);return t.negative=1,e._normSign()}if(0!==this.negative)return this.negative=0,this.iadd(t),this.negative=1,this._normSign();var n,r,i=this.cmp(t);if(0===i)return this.negative=0,this.length=1,this.words[0]=0,this;i>0?(n=this,r=t):(n=t,r=this);for(var o=0,a=0;a<r.length;a++)o=(e=(0|n.words[a])-(0|r.words[a])+o)>>26,this.words[a]=67108863&e;for(;0!==o&&a<n.length;a++)o=(e=(0|n.words[a])+o)>>26,this.words[a]=67108863&e;if(0===o&&a<n.length&&n!==this)for(;a<n.length;a++)this.words[a]=n.words[a];return this.length=Math.max(this.length,a),n!==this&&(this.negative=1),this.strip()},o.prototype.sub=function(t){return this.clone().isub(t)};var d=function(t,e,n){var r,i,o,a=t.words,s=e.words,u=n.words,c=0,f=0|a[0],l=8191&f,h=f>>>13,d=0|a[1],p=8191&d,g=d>>>13,y=0|a[2],b=8191&y,m=y>>>13,v=0|a[3],_=8191&v,w=v>>>13,x=0|a[4],k=8191&x,E=x>>>13,A=0|a[5],S=8191&A,T=A>>>13,M=0|a[6],D=8191&M,C=M>>>13,O=0|a[7],R=8191&O,I=O>>>13,N=0|a[8],B=8191&N,L=N>>>13,P=0|a[9],F=8191&P,q=P>>>13,j=0|s[0],U=8191&j,z=j>>>13,Y=0|s[1],V=8191&Y,H=Y>>>13,$=0|s[2],G=8191&$,W=$>>>13,K=0|s[3],X=8191&K,Z=K>>>13,J=0|s[4],Q=8191&J,tt=J>>>13,et=0|s[5],nt=8191&et,rt=et>>>13,it=0|s[6],ot=8191&it,at=it>>>13,st=0|s[7],ut=8191&st,ct=st>>>13,ft=0|s[8],lt=8191&ft,ht=ft>>>13,dt=0|s[9],pt=8191&dt,gt=dt>>>13;n.negative=t.negative^e.negative,n.length=19;var yt=(c+(r=Math.imul(l,U))|0)+((8191&(i=(i=Math.imul(l,z))+Math.imul(h,U)|0))<<13)|0;c=((o=Math.imul(h,z))+(i>>>13)|0)+(yt>>>26)|0,yt&=67108863,r=Math.imul(p,U),i=(i=Math.imul(p,z))+Math.imul(g,U)|0,o=Math.imul(g,z);var bt=(c+(r=r+Math.imul(l,V)|0)|0)+((8191&(i=(i=i+Math.imul(l,H)|0)+Math.imul(h,V)|0))<<13)|0;c=((o=o+Math.imul(h,H)|0)+(i>>>13)|0)+(bt>>>26)|0,bt&=67108863,r=Math.imul(b,U),i=(i=Math.imul(b,z))+Math.imul(m,U)|0,o=Math.imul(m,z),r=r+Math.imul(p,V)|0,i=(i=i+Math.imul(p,H)|0)+Math.imul(g,V)|0,o=o+Math.imul(g,H)|0;var mt=(c+(r=r+Math.imul(l,G)|0)|0)+((8191&(i=(i=i+Math.imul(l,W)|0)+Math.imul(h,G)|0))<<13)|0;c=((o=o+Math.imul(h,W)|0)+(i>>>13)|0)+(mt>>>26)|0,mt&=67108863,r=Math.imul(_,U),i=(i=Math.imul(_,z))+Math.imul(w,U)|0,o=Math.imul(w,z),r=r+Math.imul(b,V)|0,i=(i=i+Math.imul(b,H)|0)+Math.imul(m,V)|0,o=o+Math.imul(m,H)|0,r=r+Math.imul(p,G)|0,i=(i=i+Math.imul(p,W)|0)+Math.imul(g,G)|0,o=o+Math.imul(g,W)|0;var vt=(c+(r=r+Math.imul(l,X)|0)|0)+((8191&(i=(i=i+Math.imul(l,Z)|0)+Math.imul(h,X)|0))<<13)|0;c=((o=o+Math.imul(h,Z)|0)+(i>>>13)|0)+(vt>>>26)|0,vt&=67108863,r=Math.imul(k,U),i=(i=Math.imul(k,z))+Math.imul(E,U)|0,o=Math.imul(E,z),r=r+Math.imul(_,V)|0,i=(i=i+Math.imul(_,H)|0)+Math.imul(w,V)|0,o=o+Math.imul(w,H)|0,r=r+Math.imul(b,G)|0,i=(i=i+Math.imul(b,W)|0)+Math.imul(m,G)|0,o=o+Math.imul(m,W)|0,r=r+Math.imul(p,X)|0,i=(i=i+Math.imul(p,Z)|0)+Math.imul(g,X)|0,o=o+Math.imul(g,Z)|0;var _t=(c+(r=r+Math.imul(l,Q)|0)|0)+((8191&(i=(i=i+Math.imul(l,tt)|0)+Math.imul(h,Q)|0))<<13)|0;c=((o=o+Math.imul(h,tt)|0)+(i>>>13)|0)+(_t>>>26)|0,_t&=67108863,r=Math.imul(S,U),i=(i=Math.imul(S,z))+Math.imul(T,U)|0,o=Math.imul(T,z),r=r+Math.imul(k,V)|0,i=(i=i+Math.imul(k,H)|0)+Math.imul(E,V)|0,o=o+Math.imul(E,H)|0,r=r+Math.imul(_,G)|0,i=(i=i+Math.imul(_,W)|0)+Math.imul(w,G)|0,o=o+Math.imul(w,W)|0,r=r+Math.imul(b,X)|0,i=(i=i+Math.imul(b,Z)|0)+Math.imul(m,X)|0,o=o+Math.imul(m,Z)|0,r=r+Math.imul(p,Q)|0,i=(i=i+Math.imul(p,tt)|0)+Math.imul(g,Q)|0,o=o+Math.imul(g,tt)|0;var wt=(c+(r=r+Math.imul(l,nt)|0)|0)+((8191&(i=(i=i+Math.imul(l,rt)|0)+Math.imul(h,nt)|0))<<13)|0;c=((o=o+Math.imul(h,rt)|0)+(i>>>13)|0)+(wt>>>26)|0,wt&=67108863,r=Math.imul(D,U),i=(i=Math.imul(D,z))+Math.imul(C,U)|0,o=Math.imul(C,z),r=r+Math.imul(S,V)|0,i=(i=i+Math.imul(S,H)|0)+Math.imul(T,V)|0,o=o+Math.imul(T,H)|0,r=r+Math.imul(k,G)|0,i=(i=i+Math.imul(k,W)|0)+Math.imul(E,G)|0,o=o+Math.imul(E,W)|0,r=r+Math.imul(_,X)|0,i=(i=i+Math.imul(_,Z)|0)+Math.imul(w,X)|0,o=o+Math.imul(w,Z)|0,r=r+Math.imul(b,Q)|0,i=(i=i+Math.imul(b,tt)|0)+Math.imul(m,Q)|0,o=o+Math.imul(m,tt)|0,r=r+Math.imul(p,nt)|0,i=(i=i+Math.imul(p,rt)|0)+Math.imul(g,nt)|0,o=o+Math.imul(g,rt)|0;var xt=(c+(r=r+Math.imul(l,ot)|0)|0)+((8191&(i=(i=i+Math.imul(l,at)|0)+Math.imul(h,ot)|0))<<13)|0;c=((o=o+Math.imul(h,at)|0)+(i>>>13)|0)+(xt>>>26)|0,xt&=67108863,r=Math.imul(R,U),i=(i=Math.imul(R,z))+Math.imul(I,U)|0,o=Math.imul(I,z),r=r+Math.imul(D,V)|0,i=(i=i+Math.imul(D,H)|0)+Math.imul(C,V)|0,o=o+Math.imul(C,H)|0,r=r+Math.imul(S,G)|0,i=(i=i+Math.imul(S,W)|0)+Math.imul(T,G)|0,o=o+Math.imul(T,W)|0,r=r+Math.imul(k,X)|0,i=(i=i+Math.imul(k,Z)|0)+Math.imul(E,X)|0,o=o+Math.imul(E,Z)|0,r=r+Math.imul(_,Q)|0,i=(i=i+Math.imul(_,tt)|0)+Math.imul(w,Q)|0,o=o+Math.imul(w,tt)|0,r=r+Math.imul(b,nt)|0,i=(i=i+Math.imul(b,rt)|0)+Math.imul(m,nt)|0,o=o+Math.imul(m,rt)|0,r=r+Math.imul(p,ot)|0,i=(i=i+Math.imul(p,at)|0)+Math.imul(g,ot)|0,o=o+Math.imul(g,at)|0;var kt=(c+(r=r+Math.imul(l,ut)|0)|0)+((8191&(i=(i=i+Math.imul(l,ct)|0)+Math.imul(h,ut)|0))<<13)|0;c=((o=o+Math.imul(h,ct)|0)+(i>>>13)|0)+(kt>>>26)|0,kt&=67108863,r=Math.imul(B,U),i=(i=Math.imul(B,z))+Math.imul(L,U)|0,o=Math.imul(L,z),r=r+Math.imul(R,V)|0,i=(i=i+Math.imul(R,H)|0)+Math.imul(I,V)|0,o=o+Math.imul(I,H)|0,r=r+Math.imul(D,G)|0,i=(i=i+Math.imul(D,W)|0)+Math.imul(C,G)|0,o=o+Math.imul(C,W)|0,r=r+Math.imul(S,X)|0,i=(i=i+Math.imul(S,Z)|0)+Math.imul(T,X)|0,o=o+Math.imul(T,Z)|0,r=r+Math.imul(k,Q)|0,i=(i=i+Math.imul(k,tt)|0)+Math.imul(E,Q)|0,o=o+Math.imul(E,tt)|0,r=r+Math.imul(_,nt)|0,i=(i=i+Math.imul(_,rt)|0)+Math.imul(w,nt)|0,o=o+Math.imul(w,rt)|0,r=r+Math.imul(b,ot)|0,i=(i=i+Math.imul(b,at)|0)+Math.imul(m,ot)|0,o=o+Math.imul(m,at)|0,r=r+Math.imul(p,ut)|0,i=(i=i+Math.imul(p,ct)|0)+Math.imul(g,ut)|0,o=o+Math.imul(g,ct)|0;var Et=(c+(r=r+Math.imul(l,lt)|0)|0)+((8191&(i=(i=i+Math.imul(l,ht)|0)+Math.imul(h,lt)|0))<<13)|0;c=((o=o+Math.imul(h,ht)|0)+(i>>>13)|0)+(Et>>>26)|0,Et&=67108863,r=Math.imul(F,U),i=(i=Math.imul(F,z))+Math.imul(q,U)|0,o=Math.imul(q,z),r=r+Math.imul(B,V)|0,i=(i=i+Math.imul(B,H)|0)+Math.imul(L,V)|0,o=o+Math.imul(L,H)|0,r=r+Math.imul(R,G)|0,i=(i=i+Math.imul(R,W)|0)+Math.imul(I,G)|0,o=o+Math.imul(I,W)|0,r=r+Math.imul(D,X)|0,i=(i=i+Math.imul(D,Z)|0)+Math.imul(C,X)|0,o=o+Math.imul(C,Z)|0,r=r+Math.imul(S,Q)|0,i=(i=i+Math.imul(S,tt)|0)+Math.imul(T,Q)|0,o=o+Math.imul(T,tt)|0,r=r+Math.imul(k,nt)|0,i=(i=i+Math.imul(k,rt)|0)+Math.imul(E,nt)|0,o=o+Math.imul(E,rt)|0,r=r+Math.imul(_,ot)|0,i=(i=i+Math.imul(_,at)|0)+Math.imul(w,ot)|0,o=o+Math.imul(w,at)|0,r=r+Math.imul(b,ut)|0,i=(i=i+Math.imul(b,ct)|0)+Math.imul(m,ut)|0,o=o+Math.imul(m,ct)|0,r=r+Math.imul(p,lt)|0,i=(i=i+Math.imul(p,ht)|0)+Math.imul(g,lt)|0,o=o+Math.imul(g,ht)|0;var At=(c+(r=r+Math.imul(l,pt)|0)|0)+((8191&(i=(i=i+Math.imul(l,gt)|0)+Math.imul(h,pt)|0))<<13)|0;c=((o=o+Math.imul(h,gt)|0)+(i>>>13)|0)+(At>>>26)|0,At&=67108863,r=Math.imul(F,V),i=(i=Math.imul(F,H))+Math.imul(q,V)|0,o=Math.imul(q,H),r=r+Math.imul(B,G)|0,i=(i=i+Math.imul(B,W)|0)+Math.imul(L,G)|0,o=o+Math.imul(L,W)|0,r=r+Math.imul(R,X)|0,i=(i=i+Math.imul(R,Z)|0)+Math.imul(I,X)|0,o=o+Math.imul(I,Z)|0,r=r+Math.imul(D,Q)|0,i=(i=i+Math.imul(D,tt)|0)+Math.imul(C,Q)|0,o=o+Math.imul(C,tt)|0,r=r+Math.imul(S,nt)|0,i=(i=i+Math.imul(S,rt)|0)+Math.imul(T,nt)|0,o=o+Math.imul(T,rt)|0,r=r+Math.imul(k,ot)|0,i=(i=i+Math.imul(k,at)|0)+Math.imul(E,ot)|0,o=o+Math.imul(E,at)|0,r=r+Math.imul(_,ut)|0,i=(i=i+Math.imul(_,ct)|0)+Math.imul(w,ut)|0,o=o+Math.imul(w,ct)|0,r=r+Math.imul(b,lt)|0,i=(i=i+Math.imul(b,ht)|0)+Math.imul(m,lt)|0,o=o+Math.imul(m,ht)|0;var St=(c+(r=r+Math.imul(p,pt)|0)|0)+((8191&(i=(i=i+Math.imul(p,gt)|0)+Math.imul(g,pt)|0))<<13)|0;c=((o=o+Math.imul(g,gt)|0)+(i>>>13)|0)+(St>>>26)|0,St&=67108863,r=Math.imul(F,G),i=(i=Math.imul(F,W))+Math.imul(q,G)|0,o=Math.imul(q,W),r=r+Math.imul(B,X)|0,i=(i=i+Math.imul(B,Z)|0)+Math.imul(L,X)|0,o=o+Math.imul(L,Z)|0,r=r+Math.imul(R,Q)|0,i=(i=i+Math.imul(R,tt)|0)+Math.imul(I,Q)|0,o=o+Math.imul(I,tt)|0,r=r+Math.imul(D,nt)|0,i=(i=i+Math.imul(D,rt)|0)+Math.imul(C,nt)|0,o=o+Math.imul(C,rt)|0,r=r+Math.imul(S,ot)|0,i=(i=i+Math.imul(S,at)|0)+Math.imul(T,ot)|0,o=o+Math.imul(T,at)|0,r=r+Math.imul(k,ut)|0,i=(i=i+Math.imul(k,ct)|0)+Math.imul(E,ut)|0,o=o+Math.imul(E,ct)|0,r=r+Math.imul(_,lt)|0,i=(i=i+Math.imul(_,ht)|0)+Math.imul(w,lt)|0,o=o+Math.imul(w,ht)|0;var Tt=(c+(r=r+Math.imul(b,pt)|0)|0)+((8191&(i=(i=i+Math.imul(b,gt)|0)+Math.imul(m,pt)|0))<<13)|0;c=((o=o+Math.imul(m,gt)|0)+(i>>>13)|0)+(Tt>>>26)|0,Tt&=67108863,r=Math.imul(F,X),i=(i=Math.imul(F,Z))+Math.imul(q,X)|0,o=Math.imul(q,Z),r=r+Math.imul(B,Q)|0,i=(i=i+Math.imul(B,tt)|0)+Math.imul(L,Q)|0,o=o+Math.imul(L,tt)|0,r=r+Math.imul(R,nt)|0,i=(i=i+Math.imul(R,rt)|0)+Math.imul(I,nt)|0,o=o+Math.imul(I,rt)|0,r=r+Math.imul(D,ot)|0,i=(i=i+Math.imul(D,at)|0)+Math.imul(C,ot)|0,o=o+Math.imul(C,at)|0,r=r+Math.imul(S,ut)|0,i=(i=i+Math.imul(S,ct)|0)+Math.imul(T,ut)|0,o=o+Math.imul(T,ct)|0,r=r+Math.imul(k,lt)|0,i=(i=i+Math.imul(k,ht)|0)+Math.imul(E,lt)|0,o=o+Math.imul(E,ht)|0;var Mt=(c+(r=r+Math.imul(_,pt)|0)|0)+((8191&(i=(i=i+Math.imul(_,gt)|0)+Math.imul(w,pt)|0))<<13)|0;c=((o=o+Math.imul(w,gt)|0)+(i>>>13)|0)+(Mt>>>26)|0,Mt&=67108863,r=Math.imul(F,Q),i=(i=Math.imul(F,tt))+Math.imul(q,Q)|0,o=Math.imul(q,tt),r=r+Math.imul(B,nt)|0,i=(i=i+Math.imul(B,rt)|0)+Math.imul(L,nt)|0,o=o+Math.imul(L,rt)|0,r=r+Math.imul(R,ot)|0,i=(i=i+Math.imul(R,at)|0)+Math.imul(I,ot)|0,o=o+Math.imul(I,at)|0,r=r+Math.imul(D,ut)|0,i=(i=i+Math.imul(D,ct)|0)+Math.imul(C,ut)|0,o=o+Math.imul(C,ct)|0,r=r+Math.imul(S,lt)|0,i=(i=i+Math.imul(S,ht)|0)+Math.imul(T,lt)|0,o=o+Math.imul(T,ht)|0;var Dt=(c+(r=r+Math.imul(k,pt)|0)|0)+((8191&(i=(i=i+Math.imul(k,gt)|0)+Math.imul(E,pt)|0))<<13)|0;c=((o=o+Math.imul(E,gt)|0)+(i>>>13)|0)+(Dt>>>26)|0,Dt&=67108863,r=Math.imul(F,nt),i=(i=Math.imul(F,rt))+Math.imul(q,nt)|0,o=Math.imul(q,rt),r=r+Math.imul(B,ot)|0,i=(i=i+Math.imul(B,at)|0)+Math.imul(L,ot)|0,o=o+Math.imul(L,at)|0,r=r+Math.imul(R,ut)|0,i=(i=i+Math.imul(R,ct)|0)+Math.imul(I,ut)|0,o=o+Math.imul(I,ct)|0,r=r+Math.imul(D,lt)|0,i=(i=i+Math.imul(D,ht)|0)+Math.imul(C,lt)|0,o=o+Math.imul(C,ht)|0;var Ct=(c+(r=r+Math.imul(S,pt)|0)|0)+((8191&(i=(i=i+Math.imul(S,gt)|0)+Math.imul(T,pt)|0))<<13)|0;c=((o=o+Math.imul(T,gt)|0)+(i>>>13)|0)+(Ct>>>26)|0,Ct&=67108863,r=Math.imul(F,ot),i=(i=Math.imul(F,at))+Math.imul(q,ot)|0,o=Math.imul(q,at),r=r+Math.imul(B,ut)|0,i=(i=i+Math.imul(B,ct)|0)+Math.imul(L,ut)|0,o=o+Math.imul(L,ct)|0,r=r+Math.imul(R,lt)|0,i=(i=i+Math.imul(R,ht)|0)+Math.imul(I,lt)|0,o=o+Math.imul(I,ht)|0;var Ot=(c+(r=r+Math.imul(D,pt)|0)|0)+((8191&(i=(i=i+Math.imul(D,gt)|0)+Math.imul(C,pt)|0))<<13)|0;c=((o=o+Math.imul(C,gt)|0)+(i>>>13)|0)+(Ot>>>26)|0,Ot&=67108863,r=Math.imul(F,ut),i=(i=Math.imul(F,ct))+Math.imul(q,ut)|0,o=Math.imul(q,ct),r=r+Math.imul(B,lt)|0,i=(i=i+Math.imul(B,ht)|0)+Math.imul(L,lt)|0,o=o+Math.imul(L,ht)|0;var Rt=(c+(r=r+Math.imul(R,pt)|0)|0)+((8191&(i=(i=i+Math.imul(R,gt)|0)+Math.imul(I,pt)|0))<<13)|0;c=((o=o+Math.imul(I,gt)|0)+(i>>>13)|0)+(Rt>>>26)|0,Rt&=67108863,r=Math.imul(F,lt),i=(i=Math.imul(F,ht))+Math.imul(q,lt)|0,o=Math.imul(q,ht);var It=(c+(r=r+Math.imul(B,pt)|0)|0)+((8191&(i=(i=i+Math.imul(B,gt)|0)+Math.imul(L,pt)|0))<<13)|0;c=((o=o+Math.imul(L,gt)|0)+(i>>>13)|0)+(It>>>26)|0,It&=67108863;var Nt=(c+(r=Math.imul(F,pt))|0)+((8191&(i=(i=Math.imul(F,gt))+Math.imul(q,pt)|0))<<13)|0;return c=((o=Math.imul(q,gt))+(i>>>13)|0)+(Nt>>>26)|0,Nt&=67108863,u[0]=yt,u[1]=bt,u[2]=mt,u[3]=vt,u[4]=_t,u[5]=wt,u[6]=xt,u[7]=kt,u[8]=Et,u[9]=At,u[10]=St,u[11]=Tt,u[12]=Mt,u[13]=Dt,u[14]=Ct,u[15]=Ot,u[16]=Rt,u[17]=It,u[18]=Nt,0!==c&&(u[19]=c,n.length++),n};function p(t,e,n){return(new g).mulp(t,e,n)}function g(t,e){this.x=t,this.y=e}Math.imul||(d=h),o.prototype.mulTo=function(t,e){var n=this.length+t.length;return 10===this.length&&10===t.length?d(this,t,e):n<63?h(this,t,e):n<1024?function(t,e,n){n.negative=e.negative^t.negative,n.length=t.length+e.length;for(var r=0,i=0,o=0;o<n.length-1;o++){var a=i;i=0;for(var s=67108863&r,u=Math.min(o,e.length-1),c=Math.max(0,o-t.length+1);c<=u;c++){var f=o-c,l=(0|t.words[f])*(0|e.words[c]),h=67108863&l;s=67108863&(h=h+s|0),i+=(a=(a=a+(l/67108864|0)|0)+(h>>>26)|0)>>>26,a&=67108863}n.words[o]=s,r=a,a=i}return 0!==r?n.words[o]=r:n.length--,n.strip()}(this,t,e):p(this,t,e)},g.prototype.makeRBT=function(t){for(var e=new Array(t),n=o.prototype._countBits(t)-1,r=0;r<t;r++)e[r]=this.revBin(r,n,t);return e},g.prototype.revBin=function(t,e,n){if(0===t||t===n-1)return t;for(var r=0,i=0;i<e;i++)r|=(1&t)<<e-i-1,t>>=1;return r},g.prototype.permute=function(t,e,n,r,i,o){for(var a=0;a<o;a++)r[a]=e[t[a]],i[a]=n[t[a]]},g.prototype.transform=function(t,e,n,r,i,o){this.permute(o,t,e,n,r,i);for(var a=1;a<i;a<<=1)for(var s=a<<1,u=Math.cos(2*Math.PI/s),c=Math.sin(2*Math.PI/s),f=0;f<i;f+=s)for(var l=u,h=c,d=0;d<a;d++){var p=n[f+d],g=r[f+d],y=n[f+d+a],b=r[f+d+a],m=l*y-h*b;b=l*b+h*y,y=m,n[f+d]=p+y,r[f+d]=g+b,n[f+d+a]=p-y,r[f+d+a]=g-b,d!==s&&(m=u*l-c*h,h=u*h+c*l,l=m)}},g.prototype.guessLen13b=function(t,e){var n=1|Math.max(e,t),r=1&n,i=0;for(n=n/2|0;n;n>>>=1)i++;return 1<<i+1+r},g.prototype.conjugate=function(t,e,n){if(!(n<=1))for(var r=0;r<n/2;r++){var i=t[r];t[r]=t[n-r-1],t[n-r-1]=i,i=e[r],e[r]=-e[n-r-1],e[n-r-1]=-i}},g.prototype.normalize13b=function(t,e){for(var n=0,r=0;r<e/2;r++){var i=8192*Math.round(t[2*r+1]/e)+Math.round(t[2*r]/e)+n;t[r]=67108863&i,n=i<67108864?0:i/67108864|0}return t},g.prototype.convert13b=function(t,e,n,i){for(var o=0,a=0;a<e;a++)o+=0|t[a],n[2*a]=8191&o,o>>>=13,n[2*a+1]=8191&o,o>>>=13;for(a=2*e;a<i;++a)n[a]=0;r(0===o),r(0==(-8192&o))},g.prototype.stub=function(t){for(var e=new Array(t),n=0;n<t;n++)e[n]=0;return e},g.prototype.mulp=function(t,e,n){var r=2*this.guessLen13b(t.length,e.length),i=this.makeRBT(r),o=this.stub(r),a=new Array(r),s=new Array(r),u=new Array(r),c=new Array(r),f=new Array(r),l=new Array(r),h=n.words;h.length=r,this.convert13b(t.words,t.length,a,r),this.convert13b(e.words,e.length,c,r),this.transform(a,o,s,u,r,i),this.transform(c,o,f,l,r,i);for(var d=0;d<r;d++){var p=s[d]*f[d]-u[d]*l[d];u[d]=s[d]*l[d]+u[d]*f[d],s[d]=p}return this.conjugate(s,u,r),this.transform(s,u,h,o,r,i),this.conjugate(h,o,r),this.normalize13b(h,r),n.negative=t.negative^e.negative,n.length=t.length+e.length,n.strip()},o.prototype.mul=function(t){var e=new o(null);return e.words=new Array(this.length+t.length),this.mulTo(t,e)},o.prototype.mulf=function(t){var e=new o(null);return e.words=new Array(this.length+t.length),p(this,t,e)},o.prototype.imul=function(t){return this.clone().mulTo(t,this)},o.prototype.imuln=function(t){r("number"==typeof t),r(t<67108864);for(var e=0,n=0;n<this.length;n++){var i=(0|this.words[n])*t,o=(67108863&i)+(67108863&e);e>>=26,e+=i/67108864|0,e+=o>>>26,this.words[n]=67108863&o}return 0!==e&&(this.words[n]=e,this.length++),this},o.prototype.muln=function(t){return this.clone().imuln(t)},o.prototype.sqr=function(){return this.mul(this)},o.prototype.isqr=function(){return this.imul(this.clone())},o.prototype.pow=function(t){var e=function(t){for(var e=new Array(t.bitLength()),n=0;n<e.length;n++){var r=n/26|0,i=n%26;e[n]=(t.words[r]&1<<i)>>>i}return e}(t);if(0===e.length)return new o(1);for(var n=this,r=0;r<e.length&&0===e[r];r++,n=n.sqr());if(++r<e.length)for(var i=n.sqr();r<e.length;r++,i=i.sqr())0!==e[r]&&(n=n.mul(i));return n},o.prototype.iushln=function(t){r("number"==typeof t&&t>=0);var e,n=t%26,i=(t-n)/26,o=67108863>>>26-n<<26-n;if(0!==n){var a=0;for(e=0;e<this.length;e++){var s=this.words[e]&o,u=(0|this.words[e])-s<<n;this.words[e]=u|a,a=s>>>26-n}a&&(this.words[e]=a,this.length++)}if(0!==i){for(e=this.length-1;e>=0;e--)this.words[e+i]=this.words[e];for(e=0;e<i;e++)this.words[e]=0;this.length+=i}return this.strip()},o.prototype.ishln=function(t){return r(0===this.negative),this.iushln(t)},o.prototype.iushrn=function(t,e,n){var i;r("number"==typeof t&&t>=0),i=e?(e-e%26)/26:0;var o=t%26,a=Math.min((t-o)/26,this.length),s=67108863^67108863>>>o<<o,u=n;if(i-=a,i=Math.max(0,i),u){for(var c=0;c<a;c++)u.words[c]=this.words[c];u.length=a}if(0===a);else if(this.length>a)for(this.length-=a,c=0;c<this.length;c++)this.words[c]=this.words[c+a];else this.words[0]=0,this.length=1;var f=0;for(c=this.length-1;c>=0&&(0!==f||c>=i);c--){var l=0|this.words[c];this.words[c]=f<<26-o|l>>>o,f=l&s}return u&&0!==f&&(u.words[u.length++]=f),0===this.length&&(this.words[0]=0,this.length=1),this.strip()},o.prototype.ishrn=function(t,e,n){return r(0===this.negative),this.iushrn(t,e,n)},o.prototype.shln=function(t){return this.clone().ishln(t)},o.prototype.ushln=function(t){return this.clone().iushln(t)},o.prototype.shrn=function(t){return this.clone().ishrn(t)},o.prototype.ushrn=function(t){return this.clone().iushrn(t)},o.prototype.testn=function(t){r("number"==typeof t&&t>=0);var e=t%26,n=(t-e)/26,i=1<<e;return!(this.length<=n)&&!!(this.words[n]&i)},o.prototype.imaskn=function(t){r("number"==typeof t&&t>=0);var e=t%26,n=(t-e)/26;if(r(0===this.negative,"imaskn works only with positive numbers"),this.length<=n)return this;if(0!==e&&n++,this.length=Math.min(n,this.length),0!==e){var i=67108863^67108863>>>e<<e;this.words[this.length-1]&=i}return this.strip()},o.prototype.maskn=function(t){return this.clone().imaskn(t)},o.prototype.iaddn=function(t){return r("number"==typeof t),r(t<67108864),t<0?this.isubn(-t):0!==this.negative?1===this.length&&(0|this.words[0])<t?(this.words[0]=t-(0|this.words[0]),this.negative=0,this):(this.negative=0,this.isubn(t),this.negative=1,this):this._iaddn(t)},o.prototype._iaddn=function(t){this.words[0]+=t;for(var e=0;e<this.length&&this.words[e]>=67108864;e++)this.words[e]-=67108864,e===this.length-1?this.words[e+1]=1:this.words[e+1]++;return this.length=Math.max(this.length,e+1),this},o.prototype.isubn=function(t){if(r("number"==typeof t),r(t<67108864),t<0)return this.iaddn(-t);if(0!==this.negative)return this.negative=0,this.iaddn(t),this.negative=1,this;if(this.words[0]-=t,1===this.length&&this.words[0]<0)this.words[0]=-this.words[0],this.negative=1;else for(var e=0;e<this.length&&this.words[e]<0;e++)this.words[e]+=67108864,this.words[e+1]-=1;return this.strip()},o.prototype.addn=function(t){return this.clone().iaddn(t)},o.prototype.subn=function(t){return this.clone().isubn(t)},o.prototype.iabs=function(){return this.negative=0,this},o.prototype.abs=function(){return this.clone().iabs()},o.prototype._ishlnsubmul=function(t,e,n){var i,o,a=t.length+n;this._expand(a);var s=0;for(i=0;i<t.length;i++){o=(0|this.words[i+n])+s;var u=(0|t.words[i])*e;s=((o-=67108863&u)>>26)-(u/67108864|0),this.words[i+n]=67108863&o}for(;i<this.length-n;i++)s=(o=(0|this.words[i+n])+s)>>26,this.words[i+n]=67108863&o;if(0===s)return this.strip();for(r(-1===s),s=0,i=0;i<this.length;i++)s=(o=-(0|this.words[i])+s)>>26,this.words[i]=67108863&o;return this.negative=1,this.strip()},o.prototype._wordDiv=function(t,e){var n=(this.length,t.length),r=this.clone(),i=t,a=0|i.words[i.length-1];0!==(n=26-this._countBits(a))&&(i=i.ushln(n),r.iushln(n),a=0|i.words[i.length-1]);var s,u=r.length-i.length;if("mod"!==e){(s=new o(null)).length=u+1,s.words=new Array(s.length);for(var c=0;c<s.length;c++)s.words[c]=0}var f=r.clone()._ishlnsubmul(i,1,u);0===f.negative&&(r=f,s&&(s.words[u]=1));for(var l=u-1;l>=0;l--){var h=67108864*(0|r.words[i.length+l])+(0|r.words[i.length+l-1]);for(h=Math.min(h/a|0,67108863),r._ishlnsubmul(i,h,l);0!==r.negative;)h--,r.negative=0,r._ishlnsubmul(i,1,l),r.isZero()||(r.negative^=1);s&&(s.words[l]=h)}return s&&s.strip(),r.strip(),"div"!==e&&0!==n&&r.iushrn(n),{div:s||null,mod:r}},o.prototype.divmod=function(t,e,n){return r(!t.isZero()),this.isZero()?{div:new o(0),mod:new o(0)}:0!==this.negative&&0===t.negative?(s=this.neg().divmod(t,e),"mod"!==e&&(i=s.div.neg()),"div"!==e&&(a=s.mod.neg(),n&&0!==a.negative&&a.iadd(t)),{div:i,mod:a}):0===this.negative&&0!==t.negative?(s=this.divmod(t.neg(),e),"mod"!==e&&(i=s.div.neg()),{div:i,mod:s.mod}):0!=(this.negative&t.negative)?(s=this.neg().divmod(t.neg(),e),"div"!==e&&(a=s.mod.neg(),n&&0!==a.negative&&a.isub(t)),{div:s.div,mod:a}):t.length>this.length||this.cmp(t)<0?{div:new o(0),mod:this}:1===t.length?"div"===e?{div:this.divn(t.words[0]),mod:null}:"mod"===e?{div:null,mod:new o(this.modn(t.words[0]))}:{div:this.divn(t.words[0]),mod:new o(this.modn(t.words[0]))}:this._wordDiv(t,e);var i,a,s},o.prototype.div=function(t){return this.divmod(t,"div",!1).div},o.prototype.mod=function(t){return this.divmod(t,"mod",!1).mod},o.prototype.umod=function(t){return this.divmod(t,"mod",!0).mod},o.prototype.divRound=function(t){var e=this.divmod(t);if(e.mod.isZero())return e.div;var n=0!==e.div.negative?e.mod.isub(t):e.mod,r=t.ushrn(1),i=t.andln(1),o=n.cmp(r);return o<0||1===i&&0===o?e.div:0!==e.div.negative?e.div.isubn(1):e.div.iaddn(1)},o.prototype.modn=function(t){r(t<=67108863);for(var e=(1<<26)%t,n=0,i=this.length-1;i>=0;i--)n=(e*n+(0|this.words[i]))%t;return n},o.prototype.idivn=function(t){r(t<=67108863);for(var e=0,n=this.length-1;n>=0;n--){var i=(0|this.words[n])+67108864*e;this.words[n]=i/t|0,e=i%t}return this.strip()},o.prototype.divn=function(t){return this.clone().idivn(t)},o.prototype.egcd=function(t){r(0===t.negative),r(!t.isZero());var e=this,n=t.clone();e=0!==e.negative?e.umod(t):e.clone();for(var i=new o(1),a=new o(0),s=new o(0),u=new o(1),c=0;e.isEven()&&n.isEven();)e.iushrn(1),n.iushrn(1),++c;for(var f=n.clone(),l=e.clone();!e.isZero();){for(var h=0,d=1;0==(e.words[0]&d)&&h<26;++h,d<<=1);if(h>0)for(e.iushrn(h);h-- >0;)(i.isOdd()||a.isOdd())&&(i.iadd(f),a.isub(l)),i.iushrn(1),a.iushrn(1);for(var p=0,g=1;0==(n.words[0]&g)&&p<26;++p,g<<=1);if(p>0)for(n.iushrn(p);p-- >0;)(s.isOdd()||u.isOdd())&&(s.iadd(f),u.isub(l)),s.iushrn(1),u.iushrn(1);e.cmp(n)>=0?(e.isub(n),i.isub(s),a.isub(u)):(n.isub(e),s.isub(i),u.isub(a))}return{a:s,b:u,gcd:n.iushln(c)}},o.prototype._invmp=function(t){r(0===t.negative),r(!t.isZero());var e=this,n=t.clone();e=0!==e.negative?e.umod(t):e.clone();for(var i,a=new o(1),s=new o(0),u=n.clone();e.cmpn(1)>0&&n.cmpn(1)>0;){for(var c=0,f=1;0==(e.words[0]&f)&&c<26;++c,f<<=1);if(c>0)for(e.iushrn(c);c-- >0;)a.isOdd()&&a.iadd(u),a.iushrn(1);for(var l=0,h=1;0==(n.words[0]&h)&&l<26;++l,h<<=1);if(l>0)for(n.iushrn(l);l-- >0;)s.isOdd()&&s.iadd(u),s.iushrn(1);e.cmp(n)>=0?(e.isub(n),a.isub(s)):(n.isub(e),s.isub(a))}return(i=0===e.cmpn(1)?a:s).cmpn(0)<0&&i.iadd(t),i},o.prototype.gcd=function(t){if(this.isZero())return t.abs();if(t.isZero())return this.abs();var e=this.clone(),n=t.clone();e.negative=0,n.negative=0;for(var r=0;e.isEven()&&n.isEven();r++)e.iushrn(1),n.iushrn(1);for(;;){for(;e.isEven();)e.iushrn(1);for(;n.isEven();)n.iushrn(1);var i=e.cmp(n);if(i<0){var o=e;e=n,n=o}else if(0===i||0===n.cmpn(1))break;e.isub(n)}return n.iushln(r)},o.prototype.invm=function(t){return this.egcd(t).a.umod(t)},o.prototype.isEven=function(){return 0==(1&this.words[0])},o.prototype.isOdd=function(){return 1==(1&this.words[0])},o.prototype.andln=function(t){return this.words[0]&t},o.prototype.bincn=function(t){r("number"==typeof t);var e=t%26,n=(t-e)/26,i=1<<e;if(this.length<=n)return this._expand(n+1),this.words[n]|=i,this;for(var o=i,a=n;0!==o&&a<this.length;a++){var s=0|this.words[a];o=(s+=o)>>>26,s&=67108863,this.words[a]=s}return 0!==o&&(this.words[a]=o,this.length++),this},o.prototype.isZero=function(){return 1===this.length&&0===this.words[0]},o.prototype.cmpn=function(t){var e,n=t<0;if(0!==this.negative&&!n)return-1;if(0===this.negative&&n)return 1;if(this.strip(),this.length>1)e=1;else{n&&(t=-t),r(t<=67108863,"Number is too big");var i=0|this.words[0];e=i===t?0:i<t?-1:1}return 0!==this.negative?0|-e:e},o.prototype.cmp=function(t){if(0!==this.negative&&0===t.negative)return-1;if(0===this.negative&&0!==t.negative)return 1;var e=this.ucmp(t);return 0!==this.negative?0|-e:e},o.prototype.ucmp=function(t){if(this.length>t.length)return 1;if(this.length<t.length)return-1;for(var e=0,n=this.length-1;n>=0;n--){var r=0|this.words[n],i=0|t.words[n];if(r!==i){r<i?e=-1:r>i&&(e=1);break}}return e},o.prototype.gtn=function(t){return 1===this.cmpn(t)},o.prototype.gt=function(t){return 1===this.cmp(t)},o.prototype.gten=function(t){return this.cmpn(t)>=0},o.prototype.gte=function(t){return this.cmp(t)>=0},o.prototype.ltn=function(t){return-1===this.cmpn(t)},o.prototype.lt=function(t){return-1===this.cmp(t)},o.prototype.lten=function(t){return this.cmpn(t)<=0},o.prototype.lte=function(t){return this.cmp(t)<=0},o.prototype.eqn=function(t){return 0===this.cmpn(t)},o.prototype.eq=function(t){return 0===this.cmp(t)},o.red=function(t){return new x(t)},o.prototype.toRed=function(t){return r(!this.red,"Already a number in reduction context"),r(0===this.negative,"red works only with positives"),t.convertTo(this)._forceRed(t)},o.prototype.fromRed=function(){return r(this.red,"fromRed works only with numbers in reduction context"),this.red.convertFrom(this)},o.prototype._forceRed=function(t){return this.red=t,this},o.prototype.forceRed=function(t){return r(!this.red,"Already a number in reduction context"),this._forceRed(t)},o.prototype.redAdd=function(t){return r(this.red,"redAdd works only with red numbers"),this.red.add(this,t)},o.prototype.redIAdd=function(t){return r(this.red,"redIAdd works only with red numbers"),this.red.iadd(this,t)},o.prototype.redSub=function(t){return r(this.red,"redSub works only with red numbers"),this.red.sub(this,t)},o.prototype.redISub=function(t){return r(this.red,"redISub works only with red numbers"),this.red.isub(this,t)},o.prototype.redShl=function(t){return r(this.red,"redShl works only with red numbers"),this.red.shl(this,t)},o.prototype.redMul=function(t){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,t),this.red.mul(this,t)},o.prototype.redIMul=function(t){return r(this.red,"redMul works only with red numbers"),this.red._verify2(this,t),this.red.imul(this,t)},o.prototype.redSqr=function(){return r(this.red,"redSqr works only with red numbers"),this.red._verify1(this),this.red.sqr(this)},o.prototype.redISqr=function(){return r(this.red,"redISqr works only with red numbers"),this.red._verify1(this),this.red.isqr(this)},o.prototype.redSqrt=function(){return r(this.red,"redSqrt works only with red numbers"),this.red._verify1(this),this.red.sqrt(this)},o.prototype.redInvm=function(){return r(this.red,"redInvm works only with red numbers"),this.red._verify1(this),this.red.invm(this)},o.prototype.redNeg=function(){return r(this.red,"redNeg works only with red numbers"),this.red._verify1(this),this.red.neg(this)},o.prototype.redPow=function(t){return r(this.red&&!t.red,"redPow(normalNum)"),this.red._verify1(this),this.red.pow(this,t)};var y={k256:null,p224:null,p192:null,p25519:null};function b(t,e){this.name=t,this.p=new o(e,16),this.n=this.p.bitLength(),this.k=new o(1).iushln(this.n).isub(this.p),this.tmp=this._tmp()}function m(){b.call(this,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")}function v(){b.call(this,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")}function _(){b.call(this,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")}function w(){b.call(this,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")}function x(t){if("string"==typeof t){var e=o._prime(t);this.m=e.p,this.prime=e}else r(t.gtn(1),"modulus must be greater than 1"),this.m=t,this.prime=null}function k(t){x.call(this,t),this.shift=this.m.bitLength(),this.shift%26!=0&&(this.shift+=26-this.shift%26),this.r=new o(1).iushln(this.shift),this.r2=this.imod(this.r.sqr()),this.rinv=this.r._invmp(this.m),this.minv=this.rinv.mul(this.r).isubn(1).div(this.m),this.minv=this.minv.umod(this.r),this.minv=this.r.sub(this.minv)}b.prototype._tmp=function(){var t=new o(null);return t.words=new Array(Math.ceil(this.n/13)),t},b.prototype.ireduce=function(t){var e,n=t;do{this.split(n,this.tmp),e=(n=(n=this.imulK(n)).iadd(this.tmp)).bitLength()}while(e>this.n);var r=e<this.n?-1:n.ucmp(this.p);return 0===r?(n.words[0]=0,n.length=1):r>0?n.isub(this.p):n.strip(),n},b.prototype.split=function(t,e){t.iushrn(this.n,0,e)},b.prototype.imulK=function(t){return t.imul(this.k)},i(m,b),m.prototype.split=function(t,e){for(var n=Math.min(t.length,9),r=0;r<n;r++)e.words[r]=t.words[r];if(e.length=n,t.length<=9)return t.words[0]=0,void(t.length=1);var i=t.words[9];for(e.words[e.length++]=4194303&i,r=10;r<t.length;r++){var o=0|t.words[r];t.words[r-10]=(4194303&o)<<4|i>>>22,i=o}i>>>=22,t.words[r-10]=i,0===i&&t.length>10?t.length-=10:t.length-=9},m.prototype.imulK=function(t){t.words[t.length]=0,t.words[t.length+1]=0,t.length+=2;for(var e=0,n=0;n<t.length;n++){var r=0|t.words[n];e+=977*r,t.words[n]=67108863&e,e=64*r+(e/67108864|0)}return 0===t.words[t.length-1]&&(t.length--,0===t.words[t.length-1]&&t.length--),t},i(v,b),i(_,b),i(w,b),w.prototype.imulK=function(t){for(var e=0,n=0;n<t.length;n++){var r=19*(0|t.words[n])+e,i=67108863&r;r>>>=26,t.words[n]=i,e=r}return 0!==e&&(t.words[t.length++]=e),t},o._prime=function(t){if(y[t])return y[t];var e;if("k256"===t)e=new m;else if("p224"===t)e=new v;else if("p192"===t)e=new _;else{if("p25519"!==t)throw new Error("Unknown prime "+t);e=new w}return y[t]=e,e},x.prototype._verify1=function(t){r(0===t.negative,"red works only with positives"),r(t.red,"red works only with red numbers")},x.prototype._verify2=function(t,e){r(0==(t.negative|e.negative),"red works only with positives"),r(t.red&&t.red===e.red,"red works only with red numbers")},x.prototype.imod=function(t){return this.prime?this.prime.ireduce(t)._forceRed(this):t.umod(this.m)._forceRed(this)},x.prototype.neg=function(t){return t.isZero()?t.clone():this.m.sub(t)._forceRed(this)},x.prototype.add=function(t,e){this._verify2(t,e);var n=t.add(e);return n.cmp(this.m)>=0&&n.isub(this.m),n._forceRed(this)},x.prototype.iadd=function(t,e){this._verify2(t,e);var n=t.iadd(e);return n.cmp(this.m)>=0&&n.isub(this.m),n},x.prototype.sub=function(t,e){this._verify2(t,e);var n=t.sub(e);return n.cmpn(0)<0&&n.iadd(this.m),n._forceRed(this)},x.prototype.isub=function(t,e){this._verify2(t,e);var n=t.isub(e);return n.cmpn(0)<0&&n.iadd(this.m),n},x.prototype.shl=function(t,e){return this._verify1(t),this.imod(t.ushln(e))},x.prototype.imul=function(t,e){return this._verify2(t,e),this.imod(t.imul(e))},x.prototype.mul=function(t,e){return this._verify2(t,e),this.imod(t.mul(e))},x.prototype.isqr=function(t){return this.imul(t,t.clone())},x.prototype.sqr=function(t){return this.mul(t,t)},x.prototype.sqrt=function(t){if(t.isZero())return t.clone();var e=this.m.andln(3);if(r(e%2==1),3===e){var n=this.m.add(new o(1)).iushrn(2);return this.pow(t,n)}for(var i=this.m.subn(1),a=0;!i.isZero()&&0===i.andln(1);)a++,i.iushrn(1);r(!i.isZero());var s=new o(1).toRed(this),u=s.redNeg(),c=this.m.subn(1).iushrn(1),f=this.m.bitLength();for(f=new o(2*f*f).toRed(this);0!==this.pow(f,c).cmp(u);)f.redIAdd(u);for(var l=this.pow(f,i),h=this.pow(t,i.addn(1).iushrn(1)),d=this.pow(t,i),p=a;0!==d.cmp(s);){for(var g=d,y=0;0!==g.cmp(s);y++)g=g.redSqr();r(y<p);var b=this.pow(l,new o(1).iushln(p-y-1));h=h.redMul(b),l=b.redSqr(),d=d.redMul(l),p=y}return h},x.prototype.invm=function(t){var e=t._invmp(this.m);return 0!==e.negative?(e.negative=0,this.imod(e).redNeg()):this.imod(e)},x.prototype.pow=function(t,e){if(e.isZero())return new o(1).toRed(this);if(0===e.cmpn(1))return t.clone();var n=new Array(16);n[0]=new o(1).toRed(this),n[1]=t;for(var r=2;r<n.length;r++)n[r]=this.mul(n[r-1],t);var i=n[0],a=0,s=0,u=e.bitLength()%26;for(0===u&&(u=26),r=e.length-1;r>=0;r--){for(var c=e.words[r],f=u-1;f>=0;f--){var l=c>>f&1;i!==n[0]&&(i=this.sqr(i)),0!==l||0!==a?(a<<=1,a|=l,(4===++s||0===r&&0===f)&&(i=this.mul(i,n[a]),s=0,a=0)):s=0}u=26}return i},x.prototype.convertTo=function(t){var e=t.umod(this.m);return e===t?e.clone():e},x.prototype.convertFrom=function(t){var e=t.clone();return e.red=null,e},o.mont=function(t){return new k(t)},i(k,x),k.prototype.convertTo=function(t){return this.imod(t.ushln(this.shift))},k.prototype.convertFrom=function(t){var e=this.imod(t.mul(this.rinv));return e.red=null,e},k.prototype.imul=function(t,e){if(t.isZero()||e.isZero())return t.words[0]=0,t.length=1,t;var n=t.imul(e),r=n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),i=n.isub(r).iushrn(this.shift),o=i;return i.cmp(this.m)>=0?o=i.isub(this.m):i.cmpn(0)<0&&(o=i.iadd(this.m)),o._forceRed(this)},k.prototype.mul=function(t,e){if(t.isZero()||e.isZero())return new o(0)._forceRed(this);var n=t.mul(e),r=n.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),i=n.isub(r).iushrn(this.shift),a=i;return i.cmp(this.m)>=0?a=i.isub(this.m):i.cmpn(0)<0&&(a=i.iadd(this.m)),a._forceRed(this)},k.prototype.invm=function(t){return this.imod(t._invmp(this.m).mul(this.r2))._forceRed(this)}}(t,this)}).call(this,n(9)(t))},function(t,e){var n=Array.isArray;t.exports=n},function(t,e){var n,r,i=t.exports={};function o(){throw new Error("setTimeout has not been defined")}function a(){throw new Error("clearTimeout has not been defined")}function s(t){if(n===setTimeout)return setTimeout(t,0);if((n===o||!n)&&setTimeout)return n=setTimeout,setTimeout(t,0);try{return n(t,0)}catch(e){try{return n.call(null,t,0)}catch(e){return n.call(this,t,0)}}}!function(){try{n="function"==typeof setTimeout?setTimeout:o}catch(t){n=o}try{r="function"==typeof clearTimeout?clearTimeout:a}catch(t){r=a}}();var u,c=[],f=!1,l=-1;function h(){f&&u&&(f=!1,u.length?c=u.concat(c):l=-1,c.length&&d())}function d(){if(!f){var t=s(h);f=!0;for(var e=c.length;e;){for(u=c,c=[];++l<e;)u&&u[l].run();l=-1,e=c.length}u=null,f=!1,function(t){if(r===clearTimeout)return clearTimeout(t);if((r===a||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(t);try{r(t)}catch(e){try{return r.call(null,t)}catch(e){return r.call(this,t)}}}(t)}}function p(t,e){this.fun=t,this.array=e}function g(){}i.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];c.push(new p(t,e)),1!==c.length||f||s(d)},p.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=g,i.addListener=g,i.once=g,i.off=g,i.removeListener=g,i.removeAllListeners=g,i.emit=g,i.prependListener=g,i.prependOnceListener=g,i.listeners=function(t){return[]},i.binding=function(t){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(t){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(t,e,n){"use strict";(function(t){
+/*!
+ * The buffer module from node.js, for the browser.
+ *
+ * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
+ * @license  MIT
+ */
+var r=n(419),i=n(420),o=n(191);function a(){return u.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function s(t,e){if(a()<e)throw new RangeError("Invalid typed array length");return u.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=u.prototype:(null===t&&(t=new u(e)),t.length=e),t}function u(t,e,n){if(!(u.TYPED_ARRAY_SUPPORT||this instanceof u))return new u(t,e,n);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return l(this,t)}return c(this,t,e,n)}function c(t,e,n,r){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,n,r){if(e.byteLength,n<0||e.byteLength<n)throw new RangeError("'offset' is out of bounds");if(e.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");e=void 0===n&&void 0===r?new Uint8Array(e):void 0===r?new Uint8Array(e,n):new Uint8Array(e,n,r);u.TYPED_ARRAY_SUPPORT?(t=e).__proto__=u.prototype:t=h(t,e);return t}(t,e,n,r):"string"==typeof e?function(t,e,n){"string"==typeof n&&""!==n||(n="utf8");if(!u.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|p(e,n),i=(t=s(t,r)).write(e,n);i!==r&&(t=t.slice(0,i));return t}(t,e,n):function(t,e){if(u.isBuffer(e)){var n=0|d(e.length);return 0===(t=s(t,n)).length?t:(e.copy(t,0,0,n),t)}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||(r=e.length)!=r?s(t,0):h(t,e);if("Buffer"===e.type&&o(e.data))return h(t,e.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function f(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function l(t,e){if(f(e),t=s(t,e<0?0:0|d(e)),!u.TYPED_ARRAY_SUPPORT)for(var n=0;n<e;++n)t[n]=0;return t}function h(t,e){var n=e.length<0?0:0|d(e.length);t=s(t,n);for(var r=0;r<n;r+=1)t[r]=255&e[r];return t}function d(t){if(t>=a())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+a().toString(16)+" bytes");return 0|t}function p(t,e){if(u.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var n=t.length;if(0===n)return 0;for(var r=!1;;)switch(e){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return U(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return z(t).length;default:if(r)return U(t).length;e=(""+e).toLowerCase(),r=!0}}function g(t,e,n){var r=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return C(this,e,n);case"utf8":case"utf-8":return S(this,e,n);case"ascii":return M(this,e,n);case"latin1":case"binary":return D(this,e,n);case"base64":return A(this,e,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,e,n);default:if(r)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),r=!0}}function y(t,e,n){var r=t[e];t[e]=t[n],t[n]=r}function b(t,e,n,r,i){if(0===t.length)return-1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=i?0:t.length-1),n<0&&(n=t.length+n),n>=t.length){if(i)return-1;n=t.length-1}else if(n<0){if(!i)return-1;n=0}if("string"==typeof e&&(e=u.from(e,r)),u.isBuffer(e))return 0===e.length?-1:m(t,e,n,r,i);if("number"==typeof e)return e&=255,u.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(t,e,n):Uint8Array.prototype.lastIndexOf.call(t,e,n):m(t,[e],n,r,i);throw new TypeError("val must be string, number or Buffer")}function m(t,e,n,r,i){var o,a=1,s=t.length,u=e.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(t.length<2||e.length<2)return-1;a=2,s/=2,u/=2,n/=2}function c(t,e){return 1===a?t[e]:t.readUInt16BE(e*a)}if(i){var f=-1;for(o=n;o<s;o++)if(c(t,o)===c(e,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===u)return f*a}else-1!==f&&(o-=o-f),f=-1}else for(n+u>s&&(n=s-u),o=n;o>=0;o--){for(var l=!0,h=0;h<u;h++)if(c(t,o+h)!==c(e,h)){l=!1;break}if(l)return o}return-1}function v(t,e,n,r){n=Number(n)||0;var i=t.length-n;r?(r=Number(r))>i&&(r=i):r=i;var o=e.length;if(o%2!=0)throw new TypeError("Invalid hex string");r>o/2&&(r=o/2);for(var a=0;a<r;++a){var s=parseInt(e.substr(2*a,2),16);if(isNaN(s))return a;t[n+a]=s}return a}function _(t,e,n,r){return Y(U(e,t.length-n),t,n,r)}function w(t,e,n,r){return Y(function(t){for(var e=[],n=0;n<t.length;++n)e.push(255&t.charCodeAt(n));return e}(e),t,n,r)}function x(t,e,n,r){return w(t,e,n,r)}function k(t,e,n,r){return Y(z(e),t,n,r)}function E(t,e,n,r){return Y(function(t,e){for(var n,r,i,o=[],a=0;a<t.length&&!((e-=2)<0);++a)n=t.charCodeAt(a),r=n>>8,i=n%256,o.push(i),o.push(r);return o}(e,t.length-n),t,n,r)}function A(t,e,n){return 0===e&&n===t.length?r.fromByteArray(t):r.fromByteArray(t.slice(e,n))}function S(t,e,n){n=Math.min(t.length,n);for(var r=[],i=e;i<n;){var o,a,s,u,c=t[i],f=null,l=c>239?4:c>223?3:c>191?2:1;if(i+l<=n)switch(l){case 1:c<128&&(f=c);break;case 2:128==(192&(o=t[i+1]))&&(u=(31&c)<<6|63&o)>127&&(f=u);break;case 3:o=t[i+1],a=t[i+2],128==(192&o)&&128==(192&a)&&(u=(15&c)<<12|(63&o)<<6|63&a)>2047&&(u<55296||u>57343)&&(f=u);break;case 4:o=t[i+1],a=t[i+2],s=t[i+3],128==(192&o)&&128==(192&a)&&128==(192&s)&&(u=(15&c)<<18|(63&o)<<12|(63&a)<<6|63&s)>65535&&u<1114112&&(f=u)}null===f?(f=65533,l=1):f>65535&&(f-=65536,r.push(f>>>10&1023|55296),f=56320|1023&f),r.push(f),i+=l}return function(t){var e=t.length;if(e<=T)return String.fromCharCode.apply(String,t);var n="",r=0;for(;r<e;)n+=String.fromCharCode.apply(String,t.slice(r,r+=T));return n}(r)}e.Buffer=u,e.SlowBuffer=function(t){+t!=t&&(t=0);return u.alloc(+t)},e.INSPECT_MAX_BYTES=50,u.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}(),e.kMaxLength=a(),u.poolSize=8192,u._augment=function(t){return t.__proto__=u.prototype,t},u.from=function(t,e,n){return c(null,t,e,n)},u.TYPED_ARRAY_SUPPORT&&(u.prototype.__proto__=Uint8Array.prototype,u.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&u[Symbol.species]===u&&Object.defineProperty(u,Symbol.species,{value:null,configurable:!0})),u.alloc=function(t,e,n){return function(t,e,n,r){return f(e),e<=0?s(t,e):void 0!==n?"string"==typeof r?s(t,e).fill(n,r):s(t,e).fill(n):s(t,e)}(null,t,e,n)},u.allocUnsafe=function(t){return l(null,t)},u.allocUnsafeSlow=function(t){return l(null,t)},u.isBuffer=function(t){return!(null==t||!t._isBuffer)},u.compare=function(t,e){if(!u.isBuffer(t)||!u.isBuffer(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var n=t.length,r=e.length,i=0,o=Math.min(n,r);i<o;++i)if(t[i]!==e[i]){n=t[i],r=e[i];break}return n<r?-1:r<n?1:0},u.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(t,e){if(!o(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return u.alloc(0);var n;if(void 0===e)for(e=0,n=0;n<t.length;++n)e+=t[n].length;var r=u.allocUnsafe(e),i=0;for(n=0;n<t.length;++n){var a=t[n];if(!u.isBuffer(a))throw new TypeError('"list" argument must be an Array of Buffers');a.copy(r,i),i+=a.length}return r},u.byteLength=p,u.prototype._isBuffer=!0,u.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)y(this,e,e+1);return this},u.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)y(this,e,e+3),y(this,e+1,e+2);return this},u.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)y(this,e,e+7),y(this,e+1,e+6),y(this,e+2,e+5),y(this,e+3,e+4);return this},u.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?S(this,0,t):g.apply(this,arguments)},u.prototype.equals=function(t){if(!u.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===u.compare(this,t)},u.prototype.inspect=function(){var t="",n=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(t+=" ... ")),"<Buffer "+t+">"},u.prototype.compare=function(t,e,n,r,i){if(!u.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===n&&(n=t?t.length:0),void 0===r&&(r=0),void 0===i&&(i=this.length),e<0||n>t.length||r<0||i>this.length)throw new RangeError("out of range index");if(r>=i&&e>=n)return 0;if(r>=i)return-1;if(e>=n)return 1;if(this===t)return 0;for(var o=(i>>>=0)-(r>>>=0),a=(n>>>=0)-(e>>>=0),s=Math.min(o,a),c=this.slice(r,i),f=t.slice(e,n),l=0;l<s;++l)if(c[l]!==f[l]){o=c[l],a=f[l];break}return o<a?-1:a<o?1:0},u.prototype.includes=function(t,e,n){return-1!==this.indexOf(t,e,n)},u.prototype.indexOf=function(t,e,n){return b(this,t,e,n,!0)},u.prototype.lastIndexOf=function(t,e,n){return b(this,t,e,n,!1)},u.prototype.write=function(t,e,n,r){if(void 0===e)r="utf8",n=this.length,e=0;else if(void 0===n&&"string"==typeof e)r=e,n=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}var i=this.length-e;if((void 0===n||n>i)&&(n=i),t.length>0&&(n<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var o=!1;;)switch(r){case"hex":return v(this,t,e,n);case"utf8":case"utf-8":return _(this,t,e,n);case"ascii":return w(this,t,e,n);case"latin1":case"binary":return x(this,t,e,n);case"base64":return k(this,t,e,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,t,e,n);default:if(o)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),o=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var T=4096;function M(t,e,n){var r="";n=Math.min(t.length,n);for(var i=e;i<n;++i)r+=String.fromCharCode(127&t[i]);return r}function D(t,e,n){var r="";n=Math.min(t.length,n);for(var i=e;i<n;++i)r+=String.fromCharCode(t[i]);return r}function C(t,e,n){var r=t.length;(!e||e<0)&&(e=0),(!n||n<0||n>r)&&(n=r);for(var i="",o=e;o<n;++o)i+=j(t[o]);return i}function O(t,e,n){for(var r=t.slice(e,n),i="",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function R(t,e,n){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>n)throw new RangeError("Trying to access beyond buffer length")}function I(t,e,n,r,i,o){if(!u.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>i||e<o)throw new RangeError('"value" argument is out of bounds');if(n+r>t.length)throw new RangeError("Index out of range")}function N(t,e,n,r){e<0&&(e=65535+e+1);for(var i=0,o=Math.min(t.length-n,2);i<o;++i)t[n+i]=(e&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function B(t,e,n,r){e<0&&(e=4294967295+e+1);for(var i=0,o=Math.min(t.length-n,4);i<o;++i)t[n+i]=e>>>8*(r?i:3-i)&255}function L(t,e,n,r,i,o){if(n+r>t.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function P(t,e,n,r,o){return o||L(t,0,n,4),i.write(t,e,n,r,23,4),n+4}function F(t,e,n,r,o){return o||L(t,0,n,8),i.write(t,e,n,r,52,8),n+8}u.prototype.slice=function(t,e){var n,r=this.length;if((t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=void 0===e?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t),u.TYPED_ARRAY_SUPPORT)(n=this.subarray(t,e)).__proto__=u.prototype;else{var i=e-t;n=new u(i,void 0);for(var o=0;o<i;++o)n[o]=this[o+t]}return n},u.prototype.readUIntLE=function(t,e,n){t|=0,e|=0,n||R(t,e,this.length);for(var r=this[t],i=1,o=0;++o<e&&(i*=256);)r+=this[t+o]*i;return r},u.prototype.readUIntBE=function(t,e,n){t|=0,e|=0,n||R(t,e,this.length);for(var r=this[t+--e],i=1;e>0&&(i*=256);)r+=this[t+--e]*i;return r},u.prototype.readUInt8=function(t,e){return e||R(t,1,this.length),this[t]},u.prototype.readUInt16LE=function(t,e){return e||R(t,2,this.length),this[t]|this[t+1]<<8},u.prototype.readUInt16BE=function(t,e){return e||R(t,2,this.length),this[t]<<8|this[t+1]},u.prototype.readUInt32LE=function(t,e){return e||R(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},u.prototype.readUInt32BE=function(t,e){return e||R(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},u.prototype.readIntLE=function(t,e,n){t|=0,e|=0,n||R(t,e,this.length);for(var r=this[t],i=1,o=0;++o<e&&(i*=256);)r+=this[t+o]*i;return r>=(i*=128)&&(r-=Math.pow(2,8*e)),r},u.prototype.readIntBE=function(t,e,n){t|=0,e|=0,n||R(t,e,this.length);for(var r=e,i=1,o=this[t+--r];r>0&&(i*=256);)o+=this[t+--r]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*e)),o},u.prototype.readInt8=function(t,e){return e||R(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},u.prototype.readInt16LE=function(t,e){e||R(t,2,this.length);var n=this[t]|this[t+1]<<8;return 32768&n?4294901760|n:n},u.prototype.readInt16BE=function(t,e){e||R(t,2,this.length);var n=this[t+1]|this[t]<<8;return 32768&n?4294901760|n:n},u.prototype.readInt32LE=function(t,e){return e||R(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},u.prototype.readInt32BE=function(t,e){return e||R(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},u.prototype.readFloatLE=function(t,e){return e||R(t,4,this.length),i.read(this,t,!0,23,4)},u.prototype.readFloatBE=function(t,e){return e||R(t,4,this.length),i.read(this,t,!1,23,4)},u.prototype.readDoubleLE=function(t,e){return e||R(t,8,this.length),i.read(this,t,!0,52,8)},u.prototype.readDoubleBE=function(t,e){return e||R(t,8,this.length),i.read(this,t,!1,52,8)},u.prototype.writeUIntLE=function(t,e,n,r){(t=+t,e|=0,n|=0,r)||I(this,t,e,n,Math.pow(2,8*n)-1,0);var i=1,o=0;for(this[e]=255&t;++o<n&&(i*=256);)this[e+o]=t/i&255;return e+n},u.prototype.writeUIntBE=function(t,e,n,r){(t=+t,e|=0,n|=0,r)||I(this,t,e,n,Math.pow(2,8*n)-1,0);var i=n-1,o=1;for(this[e+i]=255&t;--i>=0&&(o*=256);)this[e+i]=t/o&255;return e+n},u.prototype.writeUInt8=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,1,255,0),u.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},u.prototype.writeUInt16LE=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):N(this,t,e,!0),e+2},u.prototype.writeUInt16BE=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):N(this,t,e,!1),e+2},u.prototype.writeUInt32LE=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):B(this,t,e,!0),e+4},u.prototype.writeUInt32BE=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):B(this,t,e,!1),e+4},u.prototype.writeIntLE=function(t,e,n,r){if(t=+t,e|=0,!r){var i=Math.pow(2,8*n-1);I(this,t,e,n,i-1,-i)}var o=0,a=1,s=0;for(this[e]=255&t;++o<n&&(a*=256);)t<0&&0===s&&0!==this[e+o-1]&&(s=1),this[e+o]=(t/a>>0)-s&255;return e+n},u.prototype.writeIntBE=function(t,e,n,r){if(t=+t,e|=0,!r){var i=Math.pow(2,8*n-1);I(this,t,e,n,i-1,-i)}var o=n-1,a=1,s=0;for(this[e+o]=255&t;--o>=0&&(a*=256);)t<0&&0===s&&0!==this[e+o+1]&&(s=1),this[e+o]=(t/a>>0)-s&255;return e+n},u.prototype.writeInt8=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,1,127,-128),u.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},u.prototype.writeInt16LE=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):N(this,t,e,!0),e+2},u.prototype.writeInt16BE=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):N(this,t,e,!1),e+2},u.prototype.writeInt32LE=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,4,2147483647,-2147483648),u.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):B(this,t,e,!0),e+4},u.prototype.writeInt32BE=function(t,e,n){return t=+t,e|=0,n||I(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):B(this,t,e,!1),e+4},u.prototype.writeFloatLE=function(t,e,n){return P(this,t,e,!0,n)},u.prototype.writeFloatBE=function(t,e,n){return P(this,t,e,!1,n)},u.prototype.writeDoubleLE=function(t,e,n){return F(this,t,e,!0,n)},u.prototype.writeDoubleBE=function(t,e,n){return F(this,t,e,!1,n)},u.prototype.copy=function(t,e,n,r){if(n||(n=0),r||0===r||(r=this.length),e>=t.length&&(e=t.length),e||(e=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),t.length-e<r-n&&(r=t.length-e+n);var i,o=r-n;if(this===t&&n<e&&e<r)for(i=o-1;i>=0;--i)t[i+e]=this[i+n];else if(o<1e3||!u.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)t[i+e]=this[i+n];else Uint8Array.prototype.set.call(t,this.subarray(n,n+o),e);return o},u.prototype.fill=function(t,e,n,r){if("string"==typeof t){if("string"==typeof e?(r=e,e=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===t.length){var i=t.charCodeAt(0);i<256&&(t=i)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!u.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<n)throw new RangeError("Out of range index");if(n<=e)return this;var o;if(e>>>=0,n=void 0===n?this.length:n>>>0,t||(t=0),"number"==typeof t)for(o=e;o<n;++o)this[o]=t;else{var a=u.isBuffer(t)?t:U(new u(t,r).toString()),s=a.length;for(o=0;o<n-e;++o)this[o+e]=a[o%s]}return this};var q=/[^+\/0-9A-Za-z-_]/g;function j(t){return t<16?"0"+t.toString(16):t.toString(16)}function U(t,e){var n;e=e||1/0;for(var r=t.length,i=null,o=[],a=0;a<r;++a){if((n=t.charCodeAt(a))>55295&&n<57344){if(!i){if(n>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(a+1===r){(e-=3)>-1&&o.push(239,191,189);continue}i=n;continue}if(n<56320){(e-=3)>-1&&o.push(239,191,189),i=n;continue}n=65536+(i-55296<<10|n-56320)}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,n<128){if((e-=1)<0)break;o.push(n)}else if(n<2048){if((e-=2)<0)break;o.push(n>>6|192,63&n|128)}else if(n<65536){if((e-=3)<0)break;o.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;o.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return o}function z(t){return r.toByteArray(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}(t).replace(q,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function Y(t,e,n,r){for(var i=0;i<r&&!(i+n>=e.length||i>=t.length);++i)e[i+n]=t[i];return i}}).call(this,n(11))},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},function(t,e,n){"use strict";var r=n(4),i=n(19).Graph;function o(t,e,n,i){var o;do{o=r.uniqueId(i)}while(t.hasNode(o));return n.dummy=e,t.setNode(o,n),o}function a(t){return r.max(r.map(t.nodes(),(function(e){var n=t.node(e).rank;if(!r.isUndefined(n))return n})))}t.exports={addDummyNode:o,simplify:function(t){var e=(new i).setGraph(t.graph());return r.forEach(t.nodes(),(function(n){e.setNode(n,t.node(n))})),r.forEach(t.edges(),(function(n){var r=e.edge(n.v,n.w)||{weight:0,minlen:1},i=t.edge(n);e.setEdge(n.v,n.w,{weight:r.weight+i.weight,minlen:Math.max(r.minlen,i.minlen)})})),e},asNonCompoundGraph:function(t){var e=new i({multigraph:t.isMultigraph()}).setGraph(t.graph());return r.forEach(t.nodes(),(function(n){t.children(n).length||e.setNode(n,t.node(n))})),r.forEach(t.edges(),(function(n){e.setEdge(n,t.edge(n))})),e},successorWeights:function(t){var e=r.map(t.nodes(),(function(e){var n={};return r.forEach(t.outEdges(e),(function(e){n[e.w]=(n[e.w]||0)+t.edge(e).weight})),n}));return r.zipObject(t.nodes(),e)},predecessorWeights:function(t){var e=r.map(t.nodes(),(function(e){var n={};return r.forEach(t.inEdges(e),(function(e){n[e.v]=(n[e.v]||0)+t.edge(e).weight})),n}));return r.zipObject(t.nodes(),e)},intersectRect:function(t,e){var n,r,i=t.x,o=t.y,a=e.x-i,s=e.y-o,u=t.width/2,c=t.height/2;if(!a&&!s)throw new Error("Not possible to find intersection inside of the rectangle");Math.abs(s)*u>Math.abs(a)*c?(s<0&&(c=-c),n=c*a/s,r=c):(a<0&&(u=-u),n=u,r=u*s/a);return{x:i+n,y:o+r}},buildLayerMatrix:function(t){var e=r.map(r.range(a(t)+1),(function(){return[]}));return r.forEach(t.nodes(),(function(n){var i=t.node(n),o=i.rank;r.isUndefined(o)||(e[o][i.order]=n)})),e},normalizeRanks:function(t){var e=r.min(r.map(t.nodes(),(function(e){return t.node(e).rank})));r.forEach(t.nodes(),(function(n){var i=t.node(n);r.has(i,"rank")&&(i.rank-=e)}))},removeEmptyRanks:function(t){var e=r.min(r.map(t.nodes(),(function(e){return t.node(e).rank}))),n=[];r.forEach(t.nodes(),(function(r){var i=t.node(r).rank-e;n[i]||(n[i]=[]),n[i].push(r)}));var i=0,o=t.graph().nodeRankFactor;r.forEach(n,(function(e,n){r.isUndefined(e)&&n%o!=0?--i:i&&r.forEach(e,(function(e){t.node(e).rank+=i}))}))},addBorderNode:function(t,e,n,r){var i={width:0,height:0};arguments.length>=4&&(i.rank=n,i.order=r);return o(t,"border",i,e)},maxRank:a,partition:function(t,e){var n={lhs:[],rhs:[]};return r.forEach(t,(function(t){e(t)?n.lhs.push(t):n.rhs.push(t)})),n},time:function(t,e){var n=r.now();try{return e()}finally{console.log(t+" time: "+(r.now()-n)+"ms")}},notime:function(t,e){return e()}}},function(t,e){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(t){"object"==typeof window&&(n=window)}t.exports=n},function(t,e,n){var r;try{r={clone:n(235),constant:n(99),each:n(100),filter:n(150),has:n(106),isArray:n(6),isEmpty:n(311),isFunction:n(37),isUndefined:n(161),keys:n(27),map:n(162),reduce:n(164),size:n(314),transform:n(320),union:n(321),values:n(169)}}catch(t){}r||(r=window._),t.exports=r},function(t,e){t.exports=function(t){var e=typeof t;return null!=t&&("object"==e||"function"==e)}},function(t,e,n){var r=n(43);t.exports={isSubgraph:function(t,e){return!!t.children(e).length},edgeToId:function(t){return o(t.v)+":"+o(t.w)+":"+o(t.name)},applyStyle:function(t,e){e&&t.attr("style",e)},applyClass:function(t,e,n){e&&t.attr("class",e).attr("class",n+" "+t.attr("class"))},applyTransition:function(t,e){var n=e.graph();if(r.isPlainObject(n)){var i=n.transition;if(r.isFunction(i))return i(t)}return t}};var i=/:/g;function o(t){return t?String(t).replace(i,"\\:"):""}},function(t,e){function n(t,e){if(!t)throw new Error(e||"Assertion failed")}t.exports=n,n.equal=function(t,e,n){if(t!=e)throw new Error(n||"Assertion failed: "+t+" != "+e)}},function(t,e,n){"use strict";var r=e,i=n(5),o=n(15),a=n(213);r.assert=o,r.toArray=a.toArray,r.zero2=a.zero2,r.toHex=a.toHex,r.encode=a.encode,r.getNAF=function(t,e){for(var n=[],r=1<<e+1,i=t.clone();i.cmpn(1)>=0;){var o;if(i.isOdd()){var a=i.andln(r-1);o=a>(r>>1)-1?(r>>1)-a:a,i.isubn(o)}else o=0;n.push(o);for(var s=0!==i.cmpn(0)&&0===i.andln(r-1)?e+1:1,u=1;u<s;u++)n.push(0);i.iushrn(s)}return n},r.getJSF=function(t,e){var n=[[],[]];t=t.clone(),e=e.clone();for(var r=0,i=0;t.cmpn(-r)>0||e.cmpn(-i)>0;){var o,a,s,u=t.andln(3)+r&3,c=e.andln(3)+i&3;if(3===u&&(u=-1),3===c&&(c=-1),0==(1&u))o=0;else o=3!==(s=t.andln(7)+r&7)&&5!==s||2!==c?u:-u;if(n[0].push(o),0==(1&c))a=0;else a=3!==(s=e.andln(7)+i&7)&&5!==s||2!==u?c:-c;n[1].push(a),2*r===o+1&&(r=1-r),2*i===a+1&&(i=1-i),t.iushrn(1),e.iushrn(1)}return n},r.cachedProperty=function(t,e,n){var r="_"+e;t.prototype[e]=function(){return void 0!==this[r]?this[r]:this[r]=n.call(this)}},r.parseBytes=function(t){return"string"==typeof t?r.toArray(t,"hex"):t},r.intFromLE=function(t){return new i(t,"hex","le")}},function(t,e,n){
+/**
+ * @license
+ * Copyright (c) 2012-2013 Chris Pettitt
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+t.exports={graphlib:n(346),dagre:n(175),intersect:n(403),render:n(405),util:n(14),version:n(417)}},function(t,e,n){var r=n(131),i="object"==typeof self&&self&&self.Object===Object&&self,o=r||i||Function("return this")();t.exports=o},function(t,e,n){var r;try{r=n(22)}catch(t){}r||(r=window.graphlib),t.exports=r},function(t,e){t.exports=function(t){return null!=t&&"object"==typeof t}},function(t,e,n){"use strict";var r=n(15),i=n(2);function o(t,e){return 55296==(64512&t.charCodeAt(e))&&(!(e<0||e+1>=t.length)&&56320==(64512&t.charCodeAt(e+1)))}function a(t){return(t>>>24|t>>>8&65280|t<<8&16711680|(255&t)<<24)>>>0}function s(t){return 1===t.length?"0"+t:t}function u(t){return 7===t.length?"0"+t:6===t.length?"00"+t:5===t.length?"000"+t:4===t.length?"0000"+t:3===t.length?"00000"+t:2===t.length?"000000"+t:1===t.length?"0000000"+t:t}e.inherits=i,e.toArray=function(t,e){if(Array.isArray(t))return t.slice();if(!t)return[];var n=[];if("string"==typeof t)if(e){if("hex"===e)for((t=t.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(t="0"+t),i=0;i<t.length;i+=2)n.push(parseInt(t[i]+t[i+1],16))}else for(var r=0,i=0;i<t.length;i++){var a=t.charCodeAt(i);a<128?n[r++]=a:a<2048?(n[r++]=a>>6|192,n[r++]=63&a|128):o(t,i)?(a=65536+((1023&a)<<10)+(1023&t.charCodeAt(++i)),n[r++]=a>>18|240,n[r++]=a>>12&63|128,n[r++]=a>>6&63|128,n[r++]=63&a|128):(n[r++]=a>>12|224,n[r++]=a>>6&63|128,n[r++]=63&a|128)}else for(i=0;i<t.length;i++)n[i]=0|t[i];return n},e.toHex=function(t){for(var e="",n=0;n<t.length;n++)e+=s(t[n].toString(16));return e},e.htonl=a,e.toHex32=function(t,e){for(var n="",r=0;r<t.length;r++){var i=t[r];"little"===e&&(i=a(i)),n+=u(i.toString(16))}return n},e.zero2=s,e.zero8=u,e.join32=function(t,e,n,i){var o=n-e;r(o%4==0);for(var a=new Array(o/4),s=0,u=e;s<a.length;s++,u+=4){var c;c="big"===i?t[u]<<24|t[u+1]<<16|t[u+2]<<8|t[u+3]:t[u+3]<<24|t[u+2]<<16|t[u+1]<<8|t[u],a[s]=c>>>0}return a},e.split32=function(t,e){for(var n=new Array(4*t.length),r=0,i=0;r<t.length;r++,i+=4){var o=t[r];"big"===e?(n[i]=o>>>24,n[i+1]=o>>>16&255,n[i+2]=o>>>8&255,n[i+3]=255&o):(n[i+3]=o>>>24,n[i+2]=o>>>16&255,n[i+1]=o>>>8&255,n[i]=255&o)}return n},e.rotr32=function(t,e){return t>>>e|t<<32-e},e.rotl32=function(t,e){return t<<e|t>>>32-e},e.sum32=function(t,e){return t+e>>>0},e.sum32_3=function(t,e,n){return t+e+n>>>0},e.sum32_4=function(t,e,n,r){return t+e+n+r>>>0},e.sum32_5=function(t,e,n,r,i){return t+e+n+r+i>>>0},e.sum64=function(t,e,n,r){var i=t[e],o=r+t[e+1]>>>0,a=(o<r?1:0)+n+i;t[e]=a>>>0,t[e+1]=o},e.sum64_hi=function(t,e,n,r){return(e+r>>>0<e?1:0)+t+n>>>0},e.sum64_lo=function(t,e,n,r){return e+r>>>0},e.sum64_4_hi=function(t,e,n,r,i,o,a,s){var u=0,c=e;return u+=(c=c+r>>>0)<e?1:0,u+=(c=c+o>>>0)<o?1:0,t+n+i+a+(u+=(c=c+s>>>0)<s?1:0)>>>0},e.sum64_4_lo=function(t,e,n,r,i,o,a,s){return e+r+o+s>>>0},e.sum64_5_hi=function(t,e,n,r,i,o,a,s,u,c){var f=0,l=e;return f+=(l=l+r>>>0)<e?1:0,f+=(l=l+o>>>0)<o?1:0,f+=(l=l+s>>>0)<s?1:0,t+n+i+a+u+(f+=(l=l+c>>>0)<c?1:0)>>>0},e.sum64_5_lo=function(t,e,n,r,i,o,a,s,u,c){return e+r+o+s+c>>>0},e.rotr64_hi=function(t,e,n){return(e<<32-n|t>>>n)>>>0},e.rotr64_lo=function(t,e,n){return(t<<32-n|e>>>n)>>>0},e.shr64_hi=function(t,e,n){return t>>>n},e.shr64_lo=function(t,e,n){return(t<<32-n|e>>>n)>>>0}},function(t,e,n){var r=n(234);t.exports={Graph:r.Graph,json:n(336),alg:n(337),version:r.version}},function(t,e,n){(function(t){t.exports=function(){"use strict";var e,r;function i(){return e.apply(null,arguments)}function o(t){return t instanceof Array||"[object Array]"===Object.prototype.toString.call(t)}function a(t){return null!=t&&"[object Object]"===Object.prototype.toString.call(t)}function s(t){return void 0===t}function u(t){return"number"==typeof t||"[object Number]"===Object.prototype.toString.call(t)}function c(t){return t instanceof Date||"[object Date]"===Object.prototype.toString.call(t)}function f(t,e){var n,r=[];for(n=0;n<t.length;++n)r.push(e(t[n],n));return r}function l(t,e){return Object.prototype.hasOwnProperty.call(t,e)}function h(t,e){for(var n in e)l(e,n)&&(t[n]=e[n]);return l(e,"toString")&&(t.toString=e.toString),l(e,"valueOf")&&(t.valueOf=e.valueOf),t}function d(t,e,n,r){return Te(t,e,n,r,!0).utc()}function p(t){return null==t._pf&&(t._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),t._pf}function g(t){if(null==t._isValid){var e=p(t),n=r.call(e.parsedDateParts,(function(t){return null!=t})),i=!isNaN(t._d.getTime())&&e.overflow<0&&!e.empty&&!e.invalidMonth&&!e.invalidWeekday&&!e.weekdayMismatch&&!e.nullInput&&!e.invalidFormat&&!e.userInvalidated&&(!e.meridiem||e.meridiem&&n);if(t._strict&&(i=i&&0===e.charsLeftOver&&0===e.unusedTokens.length&&void 0===e.bigHour),null!=Object.isFrozen&&Object.isFrozen(t))return i;t._isValid=i}return t._isValid}function y(t){var e=d(NaN);return null!=t?h(p(e),t):p(e).userInvalidated=!0,e}r=Array.prototype.some?Array.prototype.some:function(t){for(var e=Object(this),n=e.length>>>0,r=0;r<n;r++)if(r in e&&t.call(this,e[r],r,e))return!0;return!1};var b=i.momentProperties=[];function m(t,e){var n,r,i;if(s(e._isAMomentObject)||(t._isAMomentObject=e._isAMomentObject),s(e._i)||(t._i=e._i),s(e._f)||(t._f=e._f),s(e._l)||(t._l=e._l),s(e._strict)||(t._strict=e._strict),s(e._tzm)||(t._tzm=e._tzm),s(e._isUTC)||(t._isUTC=e._isUTC),s(e._offset)||(t._offset=e._offset),s(e._pf)||(t._pf=p(e)),s(e._locale)||(t._locale=e._locale),0<b.length)for(n=0;n<b.length;n++)s(i=e[r=b[n]])||(t[r]=i);return t}var v=!1;function _(t){m(this,t),this._d=new Date(null!=t._d?t._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===v&&(v=!0,i.updateOffset(this),v=!1)}function w(t){return t instanceof _||null!=t&&null!=t._isAMomentObject}function x(t){return t<0?Math.ceil(t)||0:Math.floor(t)}function k(t){var e=+t,n=0;return 0!==e&&isFinite(e)&&(n=x(e)),n}function E(t,e,n){var r,i=Math.min(t.length,e.length),o=Math.abs(t.length-e.length),a=0;for(r=0;r<i;r++)(n&&t[r]!==e[r]||!n&&k(t[r])!==k(e[r]))&&a++;return a+o}function A(t){!1===i.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+t)}function S(t,e){var n=!0;return h((function(){if(null!=i.deprecationHandler&&i.deprecationHandler(null,t),n){for(var r,o=[],a=0;a<arguments.length;a++){if(r="","object"==typeof arguments[a]){for(var s in r+="\n["+a+"] ",arguments[0])r+=s+": "+arguments[0][s]+", ";r=r.slice(0,-2)}else r=arguments[a];o.push(r)}A(t+"\nArguments: "+Array.prototype.slice.call(o).join("")+"\n"+(new Error).stack),n=!1}return e.apply(this,arguments)}),e)}var T,M={};function D(t,e){null!=i.deprecationHandler&&i.deprecationHandler(t,e),M[t]||(A(e),M[t]=!0)}function C(t){return t instanceof Function||"[object Function]"===Object.prototype.toString.call(t)}function O(t,e){var n,r=h({},t);for(n in e)l(e,n)&&(a(t[n])&&a(e[n])?(r[n]={},h(r[n],t[n]),h(r[n],e[n])):null!=e[n]?r[n]=e[n]:delete r[n]);for(n in t)l(t,n)&&!l(e,n)&&a(t[n])&&(r[n]=h({},r[n]));return r}function R(t){null!=t&&this.set(t)}i.suppressDeprecationWarnings=!1,i.deprecationHandler=null,T=Object.keys?Object.keys:function(t){var e,n=[];for(e in t)l(t,e)&&n.push(e);return n};var I={};function N(t,e){var n=t.toLowerCase();I[n]=I[n+"s"]=I[e]=t}function B(t){return"string"==typeof t?I[t]||I[t.toLowerCase()]:void 0}function L(t){var e,n,r={};for(n in t)l(t,n)&&(e=B(n))&&(r[e]=t[n]);return r}var P={};function F(t,e){P[t]=e}function q(t,e,n){var r=""+Math.abs(t),i=e-r.length;return(0<=t?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+r}var j=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,U=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,z={},Y={};function V(t,e,n,r){var i=r;"string"==typeof r&&(i=function(){return this[r]()}),t&&(Y[t]=i),e&&(Y[e[0]]=function(){return q(i.apply(this,arguments),e[1],e[2])}),n&&(Y[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),t)})}function H(t,e){return t.isValid()?(e=$(e,t.localeData()),z[e]=z[e]||function(t){var e,n,r,i=t.match(j);for(e=0,n=i.length;e<n;e++)Y[i[e]]?i[e]=Y[i[e]]:i[e]=(r=i[e]).match(/\[[\s\S]/)?r.replace(/^\[|\]$/g,""):r.replace(/\\/g,"");return function(e){var r,o="";for(r=0;r<n;r++)o+=C(i[r])?i[r].call(e,t):i[r];return o}}(e),z[e](t)):t.localeData().invalidDate()}function $(t,e){var n=5;function r(t){return e.longDateFormat(t)||t}for(U.lastIndex=0;0<=n&&U.test(t);)t=t.replace(U,r),U.lastIndex=0,n-=1;return t}var G=/\d/,W=/\d\d/,K=/\d{3}/,X=/\d{4}/,Z=/[+-]?\d{6}/,J=/\d\d?/,Q=/\d\d\d\d?/,tt=/\d\d\d\d\d\d?/,et=/\d{1,3}/,nt=/\d{1,4}/,rt=/[+-]?\d{1,6}/,it=/\d+/,ot=/[+-]?\d+/,at=/Z|[+-]\d\d:?\d\d/gi,st=/Z|[+-]\d\d(?::?\d\d)?/gi,ut=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,ct={};function ft(t,e,n){ct[t]=C(e)?e:function(t,r){return t&&n?n:e}}function lt(t,e){return l(ct,t)?ct[t](e._strict,e._locale):new RegExp(ht(t.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,(function(t,e,n,r,i){return e||n||r||i}))))}function ht(t){return t.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}var dt={};function pt(t,e){var n,r=e;for("string"==typeof t&&(t=[t]),u(e)&&(r=function(t,n){n[e]=k(t)}),n=0;n<t.length;n++)dt[t[n]]=r}function gt(t,e){pt(t,(function(t,n,r,i){r._w=r._w||{},e(t,r._w,r,i)}))}var yt=0,bt=1,mt=2,vt=3,_t=4,wt=5,xt=6,kt=7,Et=8;function At(t){return St(t)?366:365}function St(t){return t%4==0&&t%100!=0||t%400==0}V("Y",0,0,(function(){var t=this.year();return t<=9999?""+t:"+"+t})),V(0,["YY",2],0,(function(){return this.year()%100})),V(0,["YYYY",4],0,"year"),V(0,["YYYYY",5],0,"year"),V(0,["YYYYYY",6,!0],0,"year"),N("year","y"),F("year",1),ft("Y",ot),ft("YY",J,W),ft("YYYY",nt,X),ft("YYYYY",rt,Z),ft("YYYYYY",rt,Z),pt(["YYYYY","YYYYYY"],yt),pt("YYYY",(function(t,e){e[yt]=2===t.length?i.parseTwoDigitYear(t):k(t)})),pt("YY",(function(t,e){e[yt]=i.parseTwoDigitYear(t)})),pt("Y",(function(t,e){e[yt]=parseInt(t,10)})),i.parseTwoDigitYear=function(t){return k(t)+(68<k(t)?1900:2e3)};var Tt,Mt=Dt("FullYear",!0);function Dt(t,e){return function(n){return null!=n?(Ot(this,t,n),i.updateOffset(this,e),this):Ct(this,t)}}function Ct(t,e){return t.isValid()?t._d["get"+(t._isUTC?"UTC":"")+e]():NaN}function Ot(t,e,n){t.isValid()&&!isNaN(n)&&("FullYear"===e&&St(t.year())&&1===t.month()&&29===t.date()?t._d["set"+(t._isUTC?"UTC":"")+e](n,t.month(),Rt(n,t.month())):t._d["set"+(t._isUTC?"UTC":"")+e](n))}function Rt(t,e){if(isNaN(t)||isNaN(e))return NaN;var n=(e%12+12)%12;return t+=(e-n)/12,1===n?St(t)?29:28:31-n%7%2}Tt=Array.prototype.indexOf?Array.prototype.indexOf:function(t){var e;for(e=0;e<this.length;++e)if(this[e]===t)return e;return-1},V("M",["MM",2],"Mo",(function(){return this.month()+1})),V("MMM",0,0,(function(t){return this.localeData().monthsShort(this,t)})),V("MMMM",0,0,(function(t){return this.localeData().months(this,t)})),N("month","M"),F("month",8),ft("M",J),ft("MM",J,W),ft("MMM",(function(t,e){return e.monthsShortRegex(t)})),ft("MMMM",(function(t,e){return e.monthsRegex(t)})),pt(["M","MM"],(function(t,e){e[bt]=k(t)-1})),pt(["MMM","MMMM"],(function(t,e,n,r){var i=n._locale.monthsParse(t,r,n._strict);null!=i?e[bt]=i:p(n).invalidMonth=t}));var It=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Nt="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),Bt="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");function Lt(t,e){var n;if(!t.isValid())return t;if("string"==typeof e)if(/^\d+$/.test(e))e=k(e);else if(!u(e=t.localeData().monthsParse(e)))return t;return n=Math.min(t.date(),Rt(t.year(),e)),t._d["set"+(t._isUTC?"UTC":"")+"Month"](e,n),t}function Pt(t){return null!=t?(Lt(this,t),i.updateOffset(this,!0),this):Ct(this,"Month")}var Ft=ut,qt=ut;function jt(){function t(t,e){return e.length-t.length}var e,n,r=[],i=[],o=[];for(e=0;e<12;e++)n=d([2e3,e]),r.push(this.monthsShort(n,"")),i.push(this.months(n,"")),o.push(this.months(n,"")),o.push(this.monthsShort(n,""));for(r.sort(t),i.sort(t),o.sort(t),e=0;e<12;e++)r[e]=ht(r[e]),i[e]=ht(i[e]);for(e=0;e<24;e++)o[e]=ht(o[e]);this._monthsRegex=new RegExp("^("+o.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+r.join("|")+")","i")}function Ut(t){var e=new Date(Date.UTC.apply(null,arguments));return t<100&&0<=t&&isFinite(e.getUTCFullYear())&&e.setUTCFullYear(t),e}function zt(t,e,n){var r=7+e-n;return-(7+Ut(t,0,r).getUTCDay()-e)%7+r-1}function Yt(t,e,n,r,i){var o,a,s=1+7*(e-1)+(7+n-r)%7+zt(t,r,i);return s<=0?a=At(o=t-1)+s:s>At(t)?(o=t+1,a=s-At(t)):(o=t,a=s),{year:o,dayOfYear:a}}function Vt(t,e,n){var r,i,o=zt(t.year(),e,n),a=Math.floor((t.dayOfYear()-o-1)/7)+1;return a<1?r=a+Ht(i=t.year()-1,e,n):a>Ht(t.year(),e,n)?(r=a-Ht(t.year(),e,n),i=t.year()+1):(i=t.year(),r=a),{week:r,year:i}}function Ht(t,e,n){var r=zt(t,e,n),i=zt(t+1,e,n);return(At(t)-r+i)/7}V("w",["ww",2],"wo","week"),V("W",["WW",2],"Wo","isoWeek"),N("week","w"),N("isoWeek","W"),F("week",5),F("isoWeek",5),ft("w",J),ft("ww",J,W),ft("W",J),ft("WW",J,W),gt(["w","ww","W","WW"],(function(t,e,n,r){e[r.substr(0,1)]=k(t)})),V("d",0,"do","day"),V("dd",0,0,(function(t){return this.localeData().weekdaysMin(this,t)})),V("ddd",0,0,(function(t){return this.localeData().weekdaysShort(this,t)})),V("dddd",0,0,(function(t){return this.localeData().weekdays(this,t)})),V("e",0,0,"weekday"),V("E",0,0,"isoWeekday"),N("day","d"),N("weekday","e"),N("isoWeekday","E"),F("day",11),F("weekday",11),F("isoWeekday",11),ft("d",J),ft("e",J),ft("E",J),ft("dd",(function(t,e){return e.weekdaysMinRegex(t)})),ft("ddd",(function(t,e){return e.weekdaysShortRegex(t)})),ft("dddd",(function(t,e){return e.weekdaysRegex(t)})),gt(["dd","ddd","dddd"],(function(t,e,n,r){var i=n._locale.weekdaysParse(t,r,n._strict);null!=i?e.d=i:p(n).invalidWeekday=t})),gt(["d","e","E"],(function(t,e,n,r){e[r]=k(t)}));var $t="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),Gt="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),Wt="Su_Mo_Tu_We_Th_Fr_Sa".split("_"),Kt=ut,Xt=ut,Zt=ut;function Jt(){function t(t,e){return e.length-t.length}var e,n,r,i,o,a=[],s=[],u=[],c=[];for(e=0;e<7;e++)n=d([2e3,1]).day(e),r=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),o=this.weekdays(n,""),a.push(r),s.push(i),u.push(o),c.push(r),c.push(i),c.push(o);for(a.sort(t),s.sort(t),u.sort(t),c.sort(t),e=0;e<7;e++)s[e]=ht(s[e]),u[e]=ht(u[e]),c[e]=ht(c[e]);this._weekdaysRegex=new RegExp("^("+c.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+s.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function Qt(){return this.hours()%12||12}function te(t,e){V(t,0,0,(function(){return this.localeData().meridiem(this.hours(),this.minutes(),e)}))}function ee(t,e){return e._meridiemParse}V("H",["HH",2],0,"hour"),V("h",["hh",2],0,Qt),V("k",["kk",2],0,(function(){return this.hours()||24})),V("hmm",0,0,(function(){return""+Qt.apply(this)+q(this.minutes(),2)})),V("hmmss",0,0,(function(){return""+Qt.apply(this)+q(this.minutes(),2)+q(this.seconds(),2)})),V("Hmm",0,0,(function(){return""+this.hours()+q(this.minutes(),2)})),V("Hmmss",0,0,(function(){return""+this.hours()+q(this.minutes(),2)+q(this.seconds(),2)})),te("a",!0),te("A",!1),N("hour","h"),F("hour",13),ft("a",ee),ft("A",ee),ft("H",J),ft("h",J),ft("k",J),ft("HH",J,W),ft("hh",J,W),ft("kk",J,W),ft("hmm",Q),ft("hmmss",tt),ft("Hmm",Q),ft("Hmmss",tt),pt(["H","HH"],vt),pt(["k","kk"],(function(t,e,n){var r=k(t);e[vt]=24===r?0:r})),pt(["a","A"],(function(t,e,n){n._isPm=n._locale.isPM(t),n._meridiem=t})),pt(["h","hh"],(function(t,e,n){e[vt]=k(t),p(n).bigHour=!0})),pt("hmm",(function(t,e,n){var r=t.length-2;e[vt]=k(t.substr(0,r)),e[_t]=k(t.substr(r)),p(n).bigHour=!0})),pt("hmmss",(function(t,e,n){var r=t.length-4,i=t.length-2;e[vt]=k(t.substr(0,r)),e[_t]=k(t.substr(r,2)),e[wt]=k(t.substr(i)),p(n).bigHour=!0})),pt("Hmm",(function(t,e,n){var r=t.length-2;e[vt]=k(t.substr(0,r)),e[_t]=k(t.substr(r))})),pt("Hmmss",(function(t,e,n){var r=t.length-4,i=t.length-2;e[vt]=k(t.substr(0,r)),e[_t]=k(t.substr(r,2)),e[wt]=k(t.substr(i))}));var ne,re=Dt("Hours",!0),ie={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Nt,monthsShort:Bt,week:{dow:0,doy:6},weekdays:$t,weekdaysMin:Wt,weekdaysShort:Gt,meridiemParse:/[ap]\.?m?\.?/i},oe={},ae={};function se(t){return t?t.toLowerCase().replace("_","-"):t}function ue(e){var r=null;if(!oe[e]&&void 0!==t&&t&&t.exports)try{r=ne._abbr,n(233)("./"+e),ce(r)}catch(e){}return oe[e]}function ce(t,e){var n;return t&&((n=s(e)?le(t):fe(t,e))?ne=n:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+t+" not found. Did you forget to load it?")),ne._abbr}function fe(t,e){if(null!==e){var n,r=ie;if(e.abbr=t,null!=oe[t])D("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),r=oe[t]._config;else if(null!=e.parentLocale)if(null!=oe[e.parentLocale])r=oe[e.parentLocale]._config;else{if(null==(n=ue(e.parentLocale)))return ae[e.parentLocale]||(ae[e.parentLocale]=[]),ae[e.parentLocale].push({name:t,config:e}),null;r=n._config}return oe[t]=new R(O(r,e)),ae[t]&&ae[t].forEach((function(t){fe(t.name,t.config)})),ce(t),oe[t]}return delete oe[t],null}function le(t){var e;if(t&&t._locale&&t._locale._abbr&&(t=t._locale._abbr),!t)return ne;if(!o(t)){if(e=ue(t))return e;t=[t]}return function(t){for(var e,n,r,i,o=0;o<t.length;){for(e=(i=se(t[o]).split("-")).length,n=(n=se(t[o+1]))?n.split("-"):null;0<e;){if(r=ue(i.slice(0,e).join("-")))return r;if(n&&n.length>=e&&E(i,n,!0)>=e-1)break;e--}o++}return ne}(t)}function he(t){var e,n=t._a;return n&&-2===p(t).overflow&&(e=n[bt]<0||11<n[bt]?bt:n[mt]<1||n[mt]>Rt(n[yt],n[bt])?mt:n[vt]<0||24<n[vt]||24===n[vt]&&(0!==n[_t]||0!==n[wt]||0!==n[xt])?vt:n[_t]<0||59<n[_t]?_t:n[wt]<0||59<n[wt]?wt:n[xt]<0||999<n[xt]?xt:-1,p(t)._overflowDayOfYear&&(e<yt||mt<e)&&(e=mt),p(t)._overflowWeeks&&-1===e&&(e=kt),p(t)._overflowWeekday&&-1===e&&(e=Et),p(t).overflow=e),t}function de(t,e,n){return null!=t?t:null!=e?e:n}function pe(t){var e,n,r,o,a,s=[];if(!t._d){var u,c;for(u=t,c=new Date(i.now()),r=u._useUTC?[c.getUTCFullYear(),c.getUTCMonth(),c.getUTCDate()]:[c.getFullYear(),c.getMonth(),c.getDate()],t._w&&null==t._a[mt]&&null==t._a[bt]&&function(t){var e,n,r,i,o,a,s,u;if(null!=(e=t._w).GG||null!=e.W||null!=e.E)o=1,a=4,n=de(e.GG,t._a[yt],Vt(Me(),1,4).year),r=de(e.W,1),((i=de(e.E,1))<1||7<i)&&(u=!0);else{o=t._locale._week.dow,a=t._locale._week.doy;var c=Vt(Me(),o,a);n=de(e.gg,t._a[yt],c.year),r=de(e.w,c.week),null!=e.d?((i=e.d)<0||6<i)&&(u=!0):null!=e.e?(i=e.e+o,(e.e<0||6<e.e)&&(u=!0)):i=o}r<1||r>Ht(n,o,a)?p(t)._overflowWeeks=!0:null!=u?p(t)._overflowWeekday=!0:(s=Yt(n,r,i,o,a),t._a[yt]=s.year,t._dayOfYear=s.dayOfYear)}(t),null!=t._dayOfYear&&(a=de(t._a[yt],r[yt]),(t._dayOfYear>At(a)||0===t._dayOfYear)&&(p(t)._overflowDayOfYear=!0),n=Ut(a,0,t._dayOfYear),t._a[bt]=n.getUTCMonth(),t._a[mt]=n.getUTCDate()),e=0;e<3&&null==t._a[e];++e)t._a[e]=s[e]=r[e];for(;e<7;e++)t._a[e]=s[e]=null==t._a[e]?2===e?1:0:t._a[e];24===t._a[vt]&&0===t._a[_t]&&0===t._a[wt]&&0===t._a[xt]&&(t._nextDay=!0,t._a[vt]=0),t._d=(t._useUTC?Ut:function(t,e,n,r,i,o,a){var s=new Date(t,e,n,r,i,o,a);return t<100&&0<=t&&isFinite(s.getFullYear())&&s.setFullYear(t),s}).apply(null,s),o=t._useUTC?t._d.getUTCDay():t._d.getDay(),null!=t._tzm&&t._d.setUTCMinutes(t._d.getUTCMinutes()-t._tzm),t._nextDay&&(t._a[vt]=24),t._w&&void 0!==t._w.d&&t._w.d!==o&&(p(t).weekdayMismatch=!0)}}var ge=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,ye=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,be=/Z|[+-]\d\d(?::?\d\d)?/,me=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],ve=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],_e=/^\/?Date\((\-?\d+)/i;function we(t){var e,n,r,i,o,a,s=t._i,u=ge.exec(s)||ye.exec(s);if(u){for(p(t).iso=!0,e=0,n=me.length;e<n;e++)if(me[e][1].exec(u[1])){i=me[e][0],r=!1!==me[e][2];break}if(null==i)return void(t._isValid=!1);if(u[3]){for(e=0,n=ve.length;e<n;e++)if(ve[e][1].exec(u[3])){o=(u[2]||" ")+ve[e][0];break}if(null==o)return void(t._isValid=!1)}if(!r&&null!=o)return void(t._isValid=!1);if(u[4]){if(!be.exec(u[4]))return void(t._isValid=!1);a="Z"}t._f=i+(o||"")+(a||""),Ae(t)}else t._isValid=!1}var xe=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,ke={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};function Ee(t){var e,n,r,i=xe.exec(t._i.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim());if(i){var o=function(t,e,n,r,i,o){var a=[function(t){var e=parseInt(t,10);return e<=49?2e3+e:e<=999?1900+e:e}(t),Bt.indexOf(e),parseInt(n,10),parseInt(r,10),parseInt(i,10)];return o&&a.push(parseInt(o,10)),a}(i[4],i[3],i[2],i[5],i[6],i[7]);if(n=o,r=t,(e=i[1])&&Gt.indexOf(e)!==new Date(n[0],n[1],n[2]).getDay()&&(p(r).weekdayMismatch=!0,!(r._isValid=!1)))return;t._a=o,t._tzm=function(t,e,n){if(t)return ke[t];if(e)return 0;var r=parseInt(n,10),i=r%100;return(r-i)/100*60+i}(i[8],i[9],i[10]),t._d=Ut.apply(null,t._a),t._d.setUTCMinutes(t._d.getUTCMinutes()-t._tzm),p(t).rfc2822=!0}else t._isValid=!1}function Ae(t){if(t._f!==i.ISO_8601)if(t._f!==i.RFC_2822){t._a=[],p(t).empty=!0;var e,n,r,o,a,s,u,c,f=""+t._i,h=f.length,d=0;for(r=$(t._f,t._locale).match(j)||[],e=0;e<r.length;e++)o=r[e],(n=(f.match(lt(o,t))||[])[0])&&(0<(a=f.substr(0,f.indexOf(n))).length&&p(t).unusedInput.push(a),f=f.slice(f.indexOf(n)+n.length),d+=n.length),Y[o]?(n?p(t).empty=!1:p(t).unusedTokens.push(o),s=o,c=t,null!=(u=n)&&l(dt,s)&&dt[s](u,c._a,c,s)):t._strict&&!n&&p(t).unusedTokens.push(o);p(t).charsLeftOver=h-d,0<f.length&&p(t).unusedInput.push(f),t._a[vt]<=12&&!0===p(t).bigHour&&0<t._a[vt]&&(p(t).bigHour=void 0),p(t).parsedDateParts=t._a.slice(0),p(t).meridiem=t._meridiem,t._a[vt]=function(t,e,n){var r;return null==n?e:null!=t.meridiemHour?t.meridiemHour(e,n):(null!=t.isPM&&((r=t.isPM(n))&&e<12&&(e+=12),r||12!==e||(e=0)),e)}(t._locale,t._a[vt],t._meridiem),pe(t),he(t)}else Ee(t);else we(t)}function Se(t){var e,n,r,l,d=t._i,b=t._f;return t._locale=t._locale||le(t._l),null===d||void 0===b&&""===d?y({nullInput:!0}):("string"==typeof d&&(t._i=d=t._locale.preparse(d)),w(d)?new _(he(d)):(c(d)?t._d=d:o(b)?function(t){var e,n,r,i,o;if(0===t._f.length)return p(t).invalidFormat=!0,t._d=new Date(NaN);for(i=0;i<t._f.length;i++)o=0,e=m({},t),null!=t._useUTC&&(e._useUTC=t._useUTC),e._f=t._f[i],Ae(e),g(e)&&(o+=p(e).charsLeftOver,o+=10*p(e).unusedTokens.length,p(e).score=o,(null==r||o<r)&&(r=o,n=e));h(t,n||e)}(t):b?Ae(t):s(n=(e=t)._i)?e._d=new Date(i.now()):c(n)?e._d=new Date(n.valueOf()):"string"==typeof n?(r=e,null===(l=_e.exec(r._i))?(we(r),!1===r._isValid&&(delete r._isValid,Ee(r),!1===r._isValid&&(delete r._isValid,i.createFromInputFallback(r)))):r._d=new Date(+l[1])):o(n)?(e._a=f(n.slice(0),(function(t){return parseInt(t,10)})),pe(e)):a(n)?function(t){if(!t._d){var e=L(t._i);t._a=f([e.year,e.month,e.day||e.date,e.hour,e.minute,e.second,e.millisecond],(function(t){return t&&parseInt(t,10)})),pe(t)}}(e):u(n)?e._d=new Date(n):i.createFromInputFallback(e),g(t)||(t._d=null),t))}function Te(t,e,n,r,i){var s,u={};return!0!==n&&!1!==n||(r=n,n=void 0),(a(t)&&function(t){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(t).length;var e;for(e in t)if(t.hasOwnProperty(e))return!1;return!0}(t)||o(t)&&0===t.length)&&(t=void 0),u._isAMomentObject=!0,u._useUTC=u._isUTC=i,u._l=n,u._i=t,u._f=e,u._strict=r,(s=new _(he(Se(u))))._nextDay&&(s.add(1,"d"),s._nextDay=void 0),s}function Me(t,e,n,r){return Te(t,e,n,r,!1)}i.createFromInputFallback=S("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",(function(t){t._d=new Date(t._i+(t._useUTC?" UTC":""))})),i.ISO_8601=function(){},i.RFC_2822=function(){};var De=S("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",(function(){var t=Me.apply(null,arguments);return this.isValid()&&t.isValid()?t<this?this:t:y()})),Ce=S("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",(function(){var t=Me.apply(null,arguments);return this.isValid()&&t.isValid()?this<t?this:t:y()}));function Oe(t,e){var n,r;if(1===e.length&&o(e[0])&&(e=e[0]),!e.length)return Me();for(n=e[0],r=1;r<e.length;++r)e[r].isValid()&&!e[r][t](n)||(n=e[r]);return n}var Re=["year","quarter","month","week","day","hour","minute","second","millisecond"];function Ie(t){var e=L(t),n=e.year||0,r=e.quarter||0,i=e.month||0,o=e.week||0,a=e.day||0,s=e.hour||0,u=e.minute||0,c=e.second||0,f=e.millisecond||0;this._isValid=function(t){for(var e in t)if(-1===Tt.call(Re,e)||null!=t[e]&&isNaN(t[e]))return!1;for(var n=!1,r=0;r<Re.length;++r)if(t[Re[r]]){if(n)return!1;parseFloat(t[Re[r]])!==k(t[Re[r]])&&(n=!0)}return!0}(e),this._milliseconds=+f+1e3*c+6e4*u+1e3*s*60*60,this._days=+a+7*o,this._months=+i+3*r+12*n,this._data={},this._locale=le(),this._bubble()}function Ne(t){return t instanceof Ie}function Be(t){return t<0?-1*Math.round(-1*t):Math.round(t)}function Le(t,e){V(t,0,0,(function(){var t=this.utcOffset(),n="+";return t<0&&(t=-t,n="-"),n+q(~~(t/60),2)+e+q(~~t%60,2)}))}Le("Z",":"),Le("ZZ",""),ft("Z",st),ft("ZZ",st),pt(["Z","ZZ"],(function(t,e,n){n._useUTC=!0,n._tzm=Fe(st,t)}));var Pe=/([\+\-]|\d\d)/gi;function Fe(t,e){var n=(e||"").match(t);if(null===n)return null;var r=((n[n.length-1]||[])+"").match(Pe)||["-",0,0],i=60*r[1]+k(r[2]);return 0===i?0:"+"===r[0]?i:-i}function qe(t,e){var n,r;return e._isUTC?(n=e.clone(),r=(w(t)||c(t)?t.valueOf():Me(t).valueOf())-n.valueOf(),n._d.setTime(n._d.valueOf()+r),i.updateOffset(n,!1),n):Me(t).local()}function je(t){return 15*-Math.round(t._d.getTimezoneOffset()/15)}function Ue(){return!!this.isValid()&&this._isUTC&&0===this._offset}i.updateOffset=function(){};var ze=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,Ye=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;function Ve(t,e){var n,r,i,o=t,a=null;return Ne(t)?o={ms:t._milliseconds,d:t._days,M:t._months}:u(t)?(o={},e?o[e]=t:o.milliseconds=t):(a=ze.exec(t))?(n="-"===a[1]?-1:1,o={y:0,d:k(a[mt])*n,h:k(a[vt])*n,m:k(a[_t])*n,s:k(a[wt])*n,ms:k(Be(1e3*a[xt]))*n}):(a=Ye.exec(t))?(n="-"===a[1]?-1:(a[1],1),o={y:He(a[2],n),M:He(a[3],n),w:He(a[4],n),d:He(a[5],n),h:He(a[6],n),m:He(a[7],n),s:He(a[8],n)}):null==o?o={}:"object"==typeof o&&("from"in o||"to"in o)&&(i=function(t,e){var n;return t.isValid()&&e.isValid()?(e=qe(e,t),t.isBefore(e)?n=$e(t,e):((n=$e(e,t)).milliseconds=-n.milliseconds,n.months=-n.months),n):{milliseconds:0,months:0}}(Me(o.from),Me(o.to)),(o={}).ms=i.milliseconds,o.M=i.months),r=new Ie(o),Ne(t)&&l(t,"_locale")&&(r._locale=t._locale),r}function He(t,e){var n=t&&parseFloat(t.replace(",","."));return(isNaN(n)?0:n)*e}function $e(t,e){var n={milliseconds:0,months:0};return n.months=e.month()-t.month()+12*(e.year()-t.year()),t.clone().add(n.months,"M").isAfter(e)&&--n.months,n.milliseconds=+e-+t.clone().add(n.months,"M"),n}function Ge(t,e){return function(n,r){var i;return null===r||isNaN(+r)||(D(e,"moment()."+e+"(period, number) is deprecated. Please use moment()."+e+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),i=n,n=r,r=i),We(this,Ve(n="string"==typeof n?+n:n,r),t),this}}function We(t,e,n,r){var o=e._milliseconds,a=Be(e._days),s=Be(e._months);t.isValid()&&(r=null==r||r,s&&Lt(t,Ct(t,"Month")+s*n),a&&Ot(t,"Date",Ct(t,"Date")+a*n),o&&t._d.setTime(t._d.valueOf()+o*n),r&&i.updateOffset(t,a||s))}Ve.fn=Ie.prototype,Ve.invalid=function(){return Ve(NaN)};var Ke=Ge(1,"add"),Xe=Ge(-1,"subtract");function Ze(t,e){var n=12*(e.year()-t.year())+(e.month()-t.month()),r=t.clone().add(n,"months");return-(n+(e-r<0?(e-r)/(r-t.clone().add(n-1,"months")):(e-r)/(t.clone().add(n+1,"months")-r)))||0}function Je(t){var e;return void 0===t?this._locale._abbr:(null!=(e=le(t))&&(this._locale=e),this)}i.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",i.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var Qe=S("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",(function(t){return void 0===t?this.localeData():this.locale(t)}));function tn(){return this._locale}function en(t,e){V(0,[t,t.length],0,e)}function nn(t,e,n,r,i){var o;return null==t?Vt(this,r,i).year:((o=Ht(t,r,i))<e&&(e=o),function(t,e,n,r,i){var o=Yt(t,e,n,r,i),a=Ut(o.year,0,o.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,t,e,n,r,i))}V(0,["gg",2],0,(function(){return this.weekYear()%100})),V(0,["GG",2],0,(function(){return this.isoWeekYear()%100})),en("gggg","weekYear"),en("ggggg","weekYear"),en("GGGG","isoWeekYear"),en("GGGGG","isoWeekYear"),N("weekYear","gg"),N("isoWeekYear","GG"),F("weekYear",1),F("isoWeekYear",1),ft("G",ot),ft("g",ot),ft("GG",J,W),ft("gg",J,W),ft("GGGG",nt,X),ft("gggg",nt,X),ft("GGGGG",rt,Z),ft("ggggg",rt,Z),gt(["gggg","ggggg","GGGG","GGGGG"],(function(t,e,n,r){e[r.substr(0,2)]=k(t)})),gt(["gg","GG"],(function(t,e,n,r){e[r]=i.parseTwoDigitYear(t)})),V("Q",0,"Qo","quarter"),N("quarter","Q"),F("quarter",7),ft("Q",G),pt("Q",(function(t,e){e[bt]=3*(k(t)-1)})),V("D",["DD",2],"Do","date"),N("date","D"),F("date",9),ft("D",J),ft("DD",J,W),ft("Do",(function(t,e){return t?e._dayOfMonthOrdinalParse||e._ordinalParse:e._dayOfMonthOrdinalParseLenient})),pt(["D","DD"],mt),pt("Do",(function(t,e){e[mt]=k(t.match(J)[0])}));var rn=Dt("Date",!0);V("DDD",["DDDD",3],"DDDo","dayOfYear"),N("dayOfYear","DDD"),F("dayOfYear",4),ft("DDD",et),ft("DDDD",K),pt(["DDD","DDDD"],(function(t,e,n){n._dayOfYear=k(t)})),V("m",["mm",2],0,"minute"),N("minute","m"),F("minute",14),ft("m",J),ft("mm",J,W),pt(["m","mm"],_t);var on=Dt("Minutes",!1);V("s",["ss",2],0,"second"),N("second","s"),F("second",15),ft("s",J),ft("ss",J,W),pt(["s","ss"],wt);var an,sn=Dt("Seconds",!1);for(V("S",0,0,(function(){return~~(this.millisecond()/100)})),V(0,["SS",2],0,(function(){return~~(this.millisecond()/10)})),V(0,["SSS",3],0,"millisecond"),V(0,["SSSS",4],0,(function(){return 10*this.millisecond()})),V(0,["SSSSS",5],0,(function(){return 100*this.millisecond()})),V(0,["SSSSSS",6],0,(function(){return 1e3*this.millisecond()})),V(0,["SSSSSSS",7],0,(function(){return 1e4*this.millisecond()})),V(0,["SSSSSSSS",8],0,(function(){return 1e5*this.millisecond()})),V(0,["SSSSSSSSS",9],0,(function(){return 1e6*this.millisecond()})),N("millisecond","ms"),F("millisecond",16),ft("S",et,G),ft("SS",et,W),ft("SSS",et,K),an="SSSS";an.length<=9;an+="S")ft(an,it);function un(t,e){e[xt]=k(1e3*("0."+t))}for(an="S";an.length<=9;an+="S")pt(an,un);var cn=Dt("Milliseconds",!1);V("z",0,0,"zoneAbbr"),V("zz",0,0,"zoneName");var fn=_.prototype;function ln(t){return t}fn.add=Ke,fn.calendar=function(t,e){var n=t||Me(),r=qe(n,this).startOf("day"),o=i.calendarFormat(this,r)||"sameElse",a=e&&(C(e[o])?e[o].call(this,n):e[o]);return this.format(a||this.localeData().calendar(o,this,Me(n)))},fn.clone=function(){return new _(this)},fn.diff=function(t,e,n){var r,i,o;if(!this.isValid())return NaN;if(!(r=qe(t,this)).isValid())return NaN;switch(i=6e4*(r.utcOffset()-this.utcOffset()),e=B(e)){case"year":o=Ze(this,r)/12;break;case"month":o=Ze(this,r);break;case"quarter":o=Ze(this,r)/3;break;case"second":o=(this-r)/1e3;break;case"minute":o=(this-r)/6e4;break;case"hour":o=(this-r)/36e5;break;case"day":o=(this-r-i)/864e5;break;case"week":o=(this-r-i)/6048e5;break;default:o=this-r}return n?o:x(o)},fn.endOf=function(t){return void 0===(t=B(t))||"millisecond"===t?this:("date"===t&&(t="day"),this.startOf(t).add(1,"isoWeek"===t?"week":t).subtract(1,"ms"))},fn.format=function(t){t||(t=this.isUtc()?i.defaultFormatUtc:i.defaultFormat);var e=H(this,t);return this.localeData().postformat(e)},fn.from=function(t,e){return this.isValid()&&(w(t)&&t.isValid()||Me(t).isValid())?Ve({to:this,from:t}).locale(this.locale()).humanize(!e):this.localeData().invalidDate()},fn.fromNow=function(t){return this.from(Me(),t)},fn.to=function(t,e){return this.isValid()&&(w(t)&&t.isValid()||Me(t).isValid())?Ve({from:this,to:t}).locale(this.locale()).humanize(!e):this.localeData().invalidDate()},fn.toNow=function(t){return this.to(Me(),t)},fn.get=function(t){return C(this[t=B(t)])?this[t]():this},fn.invalidAt=function(){return p(this).overflow},fn.isAfter=function(t,e){var n=w(t)?t:Me(t);return!(!this.isValid()||!n.isValid())&&("millisecond"===(e=B(s(e)?"millisecond":e))?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(e).valueOf())},fn.isBefore=function(t,e){var n=w(t)?t:Me(t);return!(!this.isValid()||!n.isValid())&&("millisecond"===(e=B(s(e)?"millisecond":e))?this.valueOf()<n.valueOf():this.clone().endOf(e).valueOf()<n.valueOf())},fn.isBetween=function(t,e,n,r){return("("===(r=r||"()")[0]?this.isAfter(t,n):!this.isBefore(t,n))&&(")"===r[1]?this.isBefore(e,n):!this.isAfter(e,n))},fn.isSame=function(t,e){var n,r=w(t)?t:Me(t);return!(!this.isValid()||!r.isValid())&&("millisecond"===(e=B(e||"millisecond"))?this.valueOf()===r.valueOf():(n=r.valueOf(),this.clone().startOf(e).valueOf()<=n&&n<=this.clone().endOf(e).valueOf()))},fn.isSameOrAfter=function(t,e){return this.isSame(t,e)||this.isAfter(t,e)},fn.isSameOrBefore=function(t,e){return this.isSame(t,e)||this.isBefore(t,e)},fn.isValid=function(){return g(this)},fn.lang=Qe,fn.locale=Je,fn.localeData=tn,fn.max=Ce,fn.min=De,fn.parsingFlags=function(){return h({},p(this))},fn.set=function(t,e){if("object"==typeof t)for(var n=function(t){var e=[];for(var n in t)e.push({unit:n,priority:P[n]});return e.sort((function(t,e){return t.priority-e.priority})),e}(t=L(t)),r=0;r<n.length;r++)this[n[r].unit](t[n[r].unit]);else if(C(this[t=B(t)]))return this[t](e);return this},fn.startOf=function(t){switch(t=B(t)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":case"date":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===t&&this.weekday(0),"isoWeek"===t&&this.isoWeekday(1),"quarter"===t&&this.month(3*Math.floor(this.month()/3)),this},fn.subtract=Xe,fn.toArray=function(){var t=this;return[t.year(),t.month(),t.date(),t.hour(),t.minute(),t.second(),t.millisecond()]},fn.toObject=function(){var t=this;return{years:t.year(),months:t.month(),date:t.date(),hours:t.hours(),minutes:t.minutes(),seconds:t.seconds(),milliseconds:t.milliseconds()}},fn.toDate=function(){return new Date(this.valueOf())},fn.toISOString=function(t){if(!this.isValid())return null;var e=!0!==t,n=e?this.clone().utc():this;return n.year()<0||9999<n.year()?H(n,e?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):C(Date.prototype.toISOString)?e?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",H(n,"Z")):H(n,e?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},fn.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var t="moment",e="";this.isLocal()||(t=0===this.utcOffset()?"moment.utc":"moment.parseZone",e="Z");var n="["+t+'("]',r=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=e+'[")]';return this.format(n+r+"-MM-DD[T]HH:mm:ss.SSS"+i)},fn.toJSON=function(){return this.isValid()?this.toISOString():null},fn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},fn.unix=function(){return Math.floor(this.valueOf()/1e3)},fn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},fn.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},fn.year=Mt,fn.isLeapYear=function(){return St(this.year())},fn.weekYear=function(t){return nn.call(this,t,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},fn.isoWeekYear=function(t){return nn.call(this,t,this.isoWeek(),this.isoWeekday(),1,4)},fn.quarter=fn.quarters=function(t){return null==t?Math.ceil((this.month()+1)/3):this.month(3*(t-1)+this.month()%3)},fn.month=Pt,fn.daysInMonth=function(){return Rt(this.year(),this.month())},fn.week=fn.weeks=function(t){var e=this.localeData().week(this);return null==t?e:this.add(7*(t-e),"d")},fn.isoWeek=fn.isoWeeks=function(t){var e=Vt(this,1,4).week;return null==t?e:this.add(7*(t-e),"d")},fn.weeksInYear=function(){var t=this.localeData()._week;return Ht(this.year(),t.dow,t.doy)},fn.isoWeeksInYear=function(){return Ht(this.year(),1,4)},fn.date=rn,fn.day=fn.days=function(t){if(!this.isValid())return null!=t?this:NaN;var e,n,r=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=t?(e=t,n=this.localeData(),t="string"!=typeof e?e:isNaN(e)?"number"==typeof(e=n.weekdaysParse(e))?e:null:parseInt(e,10),this.add(t-r,"d")):r},fn.weekday=function(t){if(!this.isValid())return null!=t?this:NaN;var e=(this.day()+7-this.localeData()._week.dow)%7;return null==t?e:this.add(t-e,"d")},fn.isoWeekday=function(t){if(!this.isValid())return null!=t?this:NaN;if(null!=t){var e=(n=t,r=this.localeData(),"string"==typeof n?r.weekdaysParse(n)%7||7:isNaN(n)?null:n);return this.day(this.day()%7?e:e-7)}return this.day()||7;var n,r},fn.dayOfYear=function(t){var e=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==t?e:this.add(t-e,"d")},fn.hour=fn.hours=re,fn.minute=fn.minutes=on,fn.second=fn.seconds=sn,fn.millisecond=fn.milliseconds=cn,fn.utcOffset=function(t,e,n){var r,o=this._offset||0;if(!this.isValid())return null!=t?this:NaN;if(null!=t){if("string"==typeof t){if(null===(t=Fe(st,t)))return this}else Math.abs(t)<16&&!n&&(t*=60);return!this._isUTC&&e&&(r=je(this)),this._offset=t,this._isUTC=!0,null!=r&&this.add(r,"m"),o!==t&&(!e||this._changeInProgress?We(this,Ve(t-o,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,i.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?o:je(this)},fn.utc=function(t){return this.utcOffset(0,t)},fn.local=function(t){return this._isUTC&&(this.utcOffset(0,t),this._isUTC=!1,t&&this.subtract(je(this),"m")),this},fn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var t=Fe(at,this._i);null!=t?this.utcOffset(t):this.utcOffset(0,!0)}return this},fn.hasAlignedHourOffset=function(t){return!!this.isValid()&&(t=t?Me(t).utcOffset():0,(this.utcOffset()-t)%60==0)},fn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},fn.isLocal=function(){return!!this.isValid()&&!this._isUTC},fn.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},fn.isUtc=Ue,fn.isUTC=Ue,fn.zoneAbbr=function(){return this._isUTC?"UTC":""},fn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},fn.dates=S("dates accessor is deprecated. Use date instead.",rn),fn.months=S("months accessor is deprecated. Use month instead",Pt),fn.years=S("years accessor is deprecated. Use year instead",Mt),fn.zone=S("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",(function(t,e){return null!=t?("string"!=typeof t&&(t=-t),this.utcOffset(t,e),this):-this.utcOffset()})),fn.isDSTShifted=S("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",(function(){if(!s(this._isDSTShifted))return this._isDSTShifted;var t={};if(m(t,this),(t=Se(t))._a){var e=t._isUTC?d(t._a):Me(t._a);this._isDSTShifted=this.isValid()&&0<E(t._a,e.toArray())}else this._isDSTShifted=!1;return this._isDSTShifted}));var hn=R.prototype;function dn(t,e,n,r){var i=le(),o=d().set(r,e);return i[n](o,t)}function pn(t,e,n){if(u(t)&&(e=t,t=void 0),t=t||"",null!=e)return dn(t,e,n,"month");var r,i=[];for(r=0;r<12;r++)i[r]=dn(t,r,n,"month");return i}function gn(t,e,n,r){"boolean"==typeof t?u(e)&&(n=e,e=void 0):(e=t,t=!1,u(n=e)&&(n=e,e=void 0)),e=e||"";var i,o=le(),a=t?o._week.dow:0;if(null!=n)return dn(e,(n+a)%7,r,"day");var s=[];for(i=0;i<7;i++)s[i]=dn(e,(i+a)%7,r,"day");return s}hn.calendar=function(t,e,n){var r=this._calendar[t]||this._calendar.sameElse;return C(r)?r.call(e,n):r},hn.longDateFormat=function(t){var e=this._longDateFormat[t],n=this._longDateFormat[t.toUpperCase()];return e||!n?e:(this._longDateFormat[t]=n.replace(/MMMM|MM|DD|dddd/g,(function(t){return t.slice(1)})),this._longDateFormat[t])},hn.invalidDate=function(){return this._invalidDate},hn.ordinal=function(t){return this._ordinal.replace("%d",t)},hn.preparse=ln,hn.postformat=ln,hn.relativeTime=function(t,e,n,r){var i=this._relativeTime[n];return C(i)?i(t,e,n,r):i.replace(/%d/i,t)},hn.pastFuture=function(t,e){var n=this._relativeTime[0<t?"future":"past"];return C(n)?n(e):n.replace(/%s/i,e)},hn.set=function(t){var e,n;for(n in t)C(e=t[n])?this[n]=e:this["_"+n]=e;this._config=t,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},hn.months=function(t,e){return t?o(this._months)?this._months[t.month()]:this._months[(this._months.isFormat||It).test(e)?"format":"standalone"][t.month()]:o(this._months)?this._months:this._months.standalone},hn.monthsShort=function(t,e){return t?o(this._monthsShort)?this._monthsShort[t.month()]:this._monthsShort[It.test(e)?"format":"standalone"][t.month()]:o(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},hn.monthsParse=function(t,e,n){var r,i,o;if(this._monthsParseExact)return function(t,e,n){var r,i,o,a=t.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],r=0;r<12;++r)o=d([2e3,r]),this._shortMonthsParse[r]=this.monthsShort(o,"").toLocaleLowerCase(),this._longMonthsParse[r]=this.months(o,"").toLocaleLowerCase();return n?"MMM"===e?-1!==(i=Tt.call(this._shortMonthsParse,a))?i:null:-1!==(i=Tt.call(this._longMonthsParse,a))?i:null:"MMM"===e?-1!==(i=Tt.call(this._shortMonthsParse,a))?i:-1!==(i=Tt.call(this._longMonthsParse,a))?i:null:-1!==(i=Tt.call(this._longMonthsParse,a))?i:-1!==(i=Tt.call(this._shortMonthsParse,a))?i:null}.call(this,t,e,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),r=0;r<12;r++){if(i=d([2e3,r]),n&&!this._longMonthsParse[r]&&(this._longMonthsParse[r]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[r]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[r]||(o="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[r]=new RegExp(o.replace(".",""),"i")),n&&"MMMM"===e&&this._longMonthsParse[r].test(t))return r;if(n&&"MMM"===e&&this._shortMonthsParse[r].test(t))return r;if(!n&&this._monthsParse[r].test(t))return r}},hn.monthsRegex=function(t){return this._monthsParseExact?(l(this,"_monthsRegex")||jt.call(this),t?this._monthsStrictRegex:this._monthsRegex):(l(this,"_monthsRegex")||(this._monthsRegex=qt),this._monthsStrictRegex&&t?this._monthsStrictRegex:this._monthsRegex)},hn.monthsShortRegex=function(t){return this._monthsParseExact?(l(this,"_monthsRegex")||jt.call(this),t?this._monthsShortStrictRegex:this._monthsShortRegex):(l(this,"_monthsShortRegex")||(this._monthsShortRegex=Ft),this._monthsShortStrictRegex&&t?this._monthsShortStrictRegex:this._monthsShortRegex)},hn.week=function(t){return Vt(t,this._week.dow,this._week.doy).week},hn.firstDayOfYear=function(){return this._week.doy},hn.firstDayOfWeek=function(){return this._week.dow},hn.weekdays=function(t,e){return t?o(this._weekdays)?this._weekdays[t.day()]:this._weekdays[this._weekdays.isFormat.test(e)?"format":"standalone"][t.day()]:o(this._weekdays)?this._weekdays:this._weekdays.standalone},hn.weekdaysMin=function(t){return t?this._weekdaysMin[t.day()]:this._weekdaysMin},hn.weekdaysShort=function(t){return t?this._weekdaysShort[t.day()]:this._weekdaysShort},hn.weekdaysParse=function(t,e,n){var r,i,o;if(this._weekdaysParseExact)return function(t,e,n){var r,i,o,a=t.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],r=0;r<7;++r)o=d([2e3,1]).day(r),this._minWeekdaysParse[r]=this.weekdaysMin(o,"").toLocaleLowerCase(),this._shortWeekdaysParse[r]=this.weekdaysShort(o,"").toLocaleLowerCase(),this._weekdaysParse[r]=this.weekdays(o,"").toLocaleLowerCase();return n?"dddd"===e?-1!==(i=Tt.call(this._weekdaysParse,a))?i:null:"ddd"===e?-1!==(i=Tt.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Tt.call(this._minWeekdaysParse,a))?i:null:"dddd"===e?-1!==(i=Tt.call(this._weekdaysParse,a))?i:-1!==(i=Tt.call(this._shortWeekdaysParse,a))?i:-1!==(i=Tt.call(this._minWeekdaysParse,a))?i:null:"ddd"===e?-1!==(i=Tt.call(this._shortWeekdaysParse,a))?i:-1!==(i=Tt.call(this._weekdaysParse,a))?i:-1!==(i=Tt.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Tt.call(this._minWeekdaysParse,a))?i:-1!==(i=Tt.call(this._weekdaysParse,a))?i:-1!==(i=Tt.call(this._shortWeekdaysParse,a))?i:null}.call(this,t,e,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),r=0;r<7;r++){if(i=d([2e3,1]).day(r),n&&!this._fullWeekdaysParse[r]&&(this._fullWeekdaysParse[r]=new RegExp("^"+this.weekdays(i,"").replace(".",".?")+"$","i"),this._shortWeekdaysParse[r]=new RegExp("^"+this.weekdaysShort(i,"").replace(".",".?")+"$","i"),this._minWeekdaysParse[r]=new RegExp("^"+this.weekdaysMin(i,"").replace(".",".?")+"$","i")),this._weekdaysParse[r]||(o="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[r]=new RegExp(o.replace(".",""),"i")),n&&"dddd"===e&&this._fullWeekdaysParse[r].test(t))return r;if(n&&"ddd"===e&&this._shortWeekdaysParse[r].test(t))return r;if(n&&"dd"===e&&this._minWeekdaysParse[r].test(t))return r;if(!n&&this._weekdaysParse[r].test(t))return r}},hn.weekdaysRegex=function(t){return this._weekdaysParseExact?(l(this,"_weekdaysRegex")||Jt.call(this),t?this._weekdaysStrictRegex:this._weekdaysRegex):(l(this,"_weekdaysRegex")||(this._weekdaysRegex=Kt),this._weekdaysStrictRegex&&t?this._weekdaysStrictRegex:this._weekdaysRegex)},hn.weekdaysShortRegex=function(t){return this._weekdaysParseExact?(l(this,"_weekdaysRegex")||Jt.call(this),t?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(l(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Xt),this._weekdaysShortStrictRegex&&t?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},hn.weekdaysMinRegex=function(t){return this._weekdaysParseExact?(l(this,"_weekdaysRegex")||Jt.call(this),t?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(l(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Zt),this._weekdaysMinStrictRegex&&t?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},hn.isPM=function(t){return"p"===(t+"").toLowerCase().charAt(0)},hn.meridiem=function(t,e,n){return 11<t?n?"pm":"PM":n?"am":"AM"},ce("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(t){var e=t%10;return t+(1===k(t%100/10)?"th":1===e?"st":2===e?"nd":3===e?"rd":"th")}}),i.lang=S("moment.lang is deprecated. Use moment.locale instead.",ce),i.langData=S("moment.langData is deprecated. Use moment.localeData instead.",le);var yn=Math.abs;function bn(t,e,n,r){var i=Ve(e,n);return t._milliseconds+=r*i._milliseconds,t._days+=r*i._days,t._months+=r*i._months,t._bubble()}function mn(t){return t<0?Math.floor(t):Math.ceil(t)}function vn(t){return 4800*t/146097}function _n(t){return 146097*t/4800}function wn(t){return function(){return this.as(t)}}var xn=wn("ms"),kn=wn("s"),En=wn("m"),An=wn("h"),Sn=wn("d"),Tn=wn("w"),Mn=wn("M"),Dn=wn("y");function Cn(t){return function(){return this.isValid()?this._data[t]:NaN}}var On=Cn("milliseconds"),Rn=Cn("seconds"),In=Cn("minutes"),Nn=Cn("hours"),Bn=Cn("days"),Ln=Cn("months"),Pn=Cn("years"),Fn=Math.round,qn={ss:44,s:45,m:45,h:22,d:26,M:11},jn=Math.abs;function Un(t){return(0<t)-(t<0)||+t}function zn(){if(!this.isValid())return this.localeData().invalidDate();var t,e,n=jn(this._milliseconds)/1e3,r=jn(this._days),i=jn(this._months);e=x((t=x(n/60))/60),n%=60,t%=60;var o=x(i/12),a=i%=12,s=r,u=e,c=t,f=n?n.toFixed(3).replace(/\.?0+$/,""):"",l=this.asSeconds();if(!l)return"P0D";var h=l<0?"-":"",d=Un(this._months)!==Un(l)?"-":"",p=Un(this._days)!==Un(l)?"-":"",g=Un(this._milliseconds)!==Un(l)?"-":"";return h+"P"+(o?d+o+"Y":"")+(a?d+a+"M":"")+(s?p+s+"D":"")+(u||c||f?"T":"")+(u?g+u+"H":"")+(c?g+c+"M":"")+(f?g+f+"S":"")}var Yn=Ie.prototype;return Yn.isValid=function(){return this._isValid},Yn.abs=function(){var t=this._data;return this._milliseconds=yn(this._milliseconds),this._days=yn(this._days),this._months=yn(this._months),t.milliseconds=yn(t.milliseconds),t.seconds=yn(t.seconds),t.minutes=yn(t.minutes),t.hours=yn(t.hours),t.months=yn(t.months),t.years=yn(t.years),this},Yn.add=function(t,e){return bn(this,t,e,1)},Yn.subtract=function(t,e){return bn(this,t,e,-1)},Yn.as=function(t){if(!this.isValid())return NaN;var e,n,r=this._milliseconds;if("month"===(t=B(t))||"year"===t)return e=this._days+r/864e5,n=this._months+vn(e),"month"===t?n:n/12;switch(e=this._days+Math.round(_n(this._months)),t){case"week":return e/7+r/6048e5;case"day":return e+r/864e5;case"hour":return 24*e+r/36e5;case"minute":return 1440*e+r/6e4;case"second":return 86400*e+r/1e3;case"millisecond":return Math.floor(864e5*e)+r;default:throw new Error("Unknown unit "+t)}},Yn.asMilliseconds=xn,Yn.asSeconds=kn,Yn.asMinutes=En,Yn.asHours=An,Yn.asDays=Sn,Yn.asWeeks=Tn,Yn.asMonths=Mn,Yn.asYears=Dn,Yn.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*k(this._months/12):NaN},Yn._bubble=function(){var t,e,n,r,i,o=this._milliseconds,a=this._days,s=this._months,u=this._data;return 0<=o&&0<=a&&0<=s||o<=0&&a<=0&&s<=0||(o+=864e5*mn(_n(s)+a),s=a=0),u.milliseconds=o%1e3,t=x(o/1e3),u.seconds=t%60,e=x(t/60),u.minutes=e%60,n=x(e/60),u.hours=n%24,s+=i=x(vn(a+=x(n/24))),a-=mn(_n(i)),r=x(s/12),s%=12,u.days=a,u.months=s,u.years=r,this},Yn.clone=function(){return Ve(this)},Yn.get=function(t){return t=B(t),this.isValid()?this[t+"s"]():NaN},Yn.milliseconds=On,Yn.seconds=Rn,Yn.minutes=In,Yn.hours=Nn,Yn.days=Bn,Yn.weeks=function(){return x(this.days()/7)},Yn.months=Ln,Yn.years=Pn,Yn.humanize=function(t){if(!this.isValid())return this.localeData().invalidDate();var e,n,r,i,o,a,s,u,c,f,l=this.localeData(),h=(e=!t,n=l,r=Ve(this).abs(),i=Fn(r.as("s")),o=Fn(r.as("m")),a=Fn(r.as("h")),s=Fn(r.as("d")),u=Fn(r.as("M")),c=Fn(r.as("y")),(f=i<=qn.ss&&["s",i]||i<qn.s&&["ss",i]||o<=1&&["m"]||o<qn.m&&["mm",o]||a<=1&&["h"]||a<qn.h&&["hh",a]||s<=1&&["d"]||s<qn.d&&["dd",s]||u<=1&&["M"]||u<qn.M&&["MM",u]||c<=1&&["y"]||["yy",c])[2]=e,f[3]=0<+this,f[4]=n,function(t,e,n,r,i){return i.relativeTime(e||1,!!n,t,r)}.apply(null,f));return t&&(h=l.pastFuture(+this,h)),l.postformat(h)},Yn.toISOString=zn,Yn.toString=zn,Yn.toJSON=zn,Yn.locale=Je,Yn.localeData=tn,Yn.toIsoString=S("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",zn),Yn.lang=Qe,V("X",0,0,"unix"),V("x",0,0,"valueOf"),ft("x",ot),ft("X",/[+-]?\d+(\.\d{1,3})?/),pt("X",(function(t,e,n){n._d=new Date(1e3*parseFloat(t,10))})),pt("x",(function(t,e,n){n._d=new Date(k(t))})),i.version="2.22.1",e=Me,i.fn=fn,i.min=function(){return Oe("isBefore",[].slice.call(arguments,0))},i.max=function(){return Oe("isAfter",[].slice.call(arguments,0))},i.now=function(){return Date.now?Date.now():+new Date},i.utc=d,i.unix=function(t){return Me(1e3*t)},i.months=function(t,e){return pn(t,e,"months")},i.isDate=c,i.locale=ce,i.invalid=y,i.duration=Ve,i.isMoment=w,i.weekdays=function(t,e,n){return gn(t,e,n,"weekdays")},i.parseZone=function(){return Me.apply(null,arguments).parseZone()},i.localeData=le,i.isDuration=Ne,i.monthsShort=function(t,e){return pn(t,e,"monthsShort")},i.weekdaysMin=function(t,e,n){return gn(t,e,n,"weekdaysMin")},i.defineLocale=fe,i.updateLocale=function(t,e){if(null!=e){var n,r,i=ie;null!=(r=ue(t))&&(i=r._config),(n=new R(e=O(i,e))).parentLocale=oe[t],oe[t]=n,ce(t)}else null!=oe[t]&&(null!=oe[t].parentLocale?oe[t]=oe[t].parentLocale:null!=oe[t]&&delete oe[t]);return oe[t]},i.locales=function(){return T(oe)},i.weekdaysShort=function(t,e,n){return gn(t,e,n,"weekdaysShort")},i.normalizeUnits=B,i.relativeTimeRounding=function(t){return void 0===t?Fn:"function"==typeof t&&(Fn=t,!0)},i.relativeTimeThreshold=function(t,e){return void 0!==qn[t]&&(void 0===e?qn[t]:(qn[t]=e,"s"===t&&(qn.ss=e-1),!0))},i.calendarFormat=function(t,e){var n=t.diff(e,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},i.prototype=fn,i.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"YYYY-[W]WW",MONTH:"YYYY-MM"},i}()}).call(this,n(9)(t))},function(t,e,n){var r=n(37),i=n(93);t.exports=function(t){return null!=t&&i(t.length)&&!r(t)}},function(t,e,n){var r=n(291),i=n(301),o=n(34),a=n(6),s=n(308);t.exports=function(t){return"function"==typeof t?t:null==t?o:"object"==typeof t?a(t)?i(t[0],t[1]):r(t):s(t)}},function(t,e,n){(function(t,r){var i=function(){var t=function(t,e,n,r){for(n=n||{},r=t.length;r--;n[t[r]]=e);return n},e=[6,8,10,11,12,13,14,15,16,18,20],n=[1,9],r=[1,10],i=[1,11],o=[1,12],a=[1,13],s=[1,14],u=[1,16],c=[1,17],f={trace:function(){},yy:{},symbols_:{error:2,start:3,gantt:4,document:5,EOF:6,line:7,SPACE:8,statement:9,NL:10,dateFormat:11,inclusiveEndDates:12,axisFormat:13,excludes:14,title:15,section:16,clickStatement:17,taskTxt:18,taskData:19,click:20,callbackname:21,callbackargs:22,href:23,clickStatementDebug:24,$accept:0,$end:1},terminals_:{2:"error",4:"gantt",6:"EOF",8:"SPACE",10:"NL",11:"dateFormat",12:"inclusiveEndDates",13:"axisFormat",14:"excludes",15:"title",16:"section",18:"taskTxt",19:"taskData",20:"click",21:"callbackname",22:"callbackargs",23:"href"},productions_:[0,[3,3],[5,0],[5,2],[7,2],[7,1],[7,1],[7,1],[9,1],[9,1],[9,1],[9,1],[9,1],[9,1],[9,1],[9,2],[17,2],[17,3],[17,3],[17,4],[17,3],[17,4],[17,2],[24,2],[24,3],[24,3],[24,4],[24,3],[24,4],[24,2]],performAction:function(t,e,n,r,i,o,a){var s=o.length-1;switch(i){case 1:return o[s-1];case 2:this.$=[];break;case 3:o[s-1].push(o[s]),this.$=o[s-1];break;case 4:case 5:this.$=o[s];break;case 6:case 7:this.$=[];break;case 8:r.setDateFormat(o[s].substr(11)),this.$=o[s].substr(11);break;case 9:r.enableInclusiveEndDates(),this.$=o[s].substr(18);break;case 10:r.setAxisFormat(o[s].substr(11)),this.$=o[s].substr(11);break;case 11:r.setExcludes(o[s].substr(9)),this.$=o[s].substr(9);break;case 12:r.setTitle(o[s].substr(6)),this.$=o[s].substr(6);break;case 13:r.addSection(o[s].substr(8)),this.$=o[s].substr(8);break;case 15:r.addTask(o[s-1],o[s]),this.$="task";break;case 16:this.$=o[s-1],r.setClickEvent(o[s-1],o[s],null);break;case 17:this.$=o[s-2],r.setClickEvent(o[s-2],o[s-1],o[s]);break;case 18:this.$=o[s-2],r.setClickEvent(o[s-2],o[s-1],null),r.setLink(o[s-2],o[s]);break;case 19:this.$=o[s-3],r.setClickEvent(o[s-3],o[s-2],o[s-1]),r.setLink(o[s-3],o[s]);break;case 20:this.$=o[s-2],r.setClickEvent(o[s-2],o[s],null),r.setLink(o[s-2],o[s-1]);break;case 21:this.$=o[s-3],r.setClickEvent(o[s-3],o[s-1],o[s]),r.setLink(o[s-3],o[s-2]);break;case 22:this.$=o[s-1],r.setLink(o[s-1],o[s]);break;case 23:case 29:this.$=o[s-1]+" "+o[s];break;case 24:case 25:case 27:this.$=o[s-2]+" "+o[s-1]+" "+o[s];break;case 26:case 28:this.$=o[s-3]+" "+o[s-2]+" "+o[s-1]+" "+o[s]}},table:[{3:1,4:[1,2]},{1:[3]},t(e,[2,2],{5:3}),{6:[1,4],7:5,8:[1,6],9:7,10:[1,8],11:n,12:r,13:i,14:o,15:a,16:s,17:15,18:u,20:c},t(e,[2,7],{1:[2,1]}),t(e,[2,3]),{9:18,11:n,12:r,13:i,14:o,15:a,16:s,17:15,18:u,20:c},t(e,[2,5]),t(e,[2,6]),t(e,[2,8]),t(e,[2,9]),t(e,[2,10]),t(e,[2,11]),t(e,[2,12]),t(e,[2,13]),t(e,[2,14]),{19:[1,19]},{21:[1,20],23:[1,21]},t(e,[2,4]),t(e,[2,15]),t(e,[2,16],{22:[1,22],23:[1,23]}),t(e,[2,22],{21:[1,24]}),t(e,[2,17],{23:[1,25]}),t(e,[2,18]),t(e,[2,20],{22:[1,26]}),t(e,[2,19]),t(e,[2,21])],defaultActions:{},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],r=[],i=[null],o=[],a=this.table,s="",u=0,c=0,f=0,l=2,h=1,d=o.slice.call(arguments,1),p=Object.create(this.lexer),g={yy:{}};for(var y in this.yy)Object.prototype.hasOwnProperty.call(this.yy,y)&&(g.yy[y]=this.yy[y]);p.setInput(t,g.yy),g.yy.lexer=p,g.yy.parser=this,void 0===p.yylloc&&(p.yylloc={});var b=p.yylloc;o.push(b);var m=p.options&&p.options.ranges;function v(){var t;return"number"!=typeof(t=r.pop()||p.lex()||h)&&(t instanceof Array&&(t=(r=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof g.yy.parseError?this.parseError=g.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var _,w,x,k,E,A,S,T,M,D={};;){if(x=n[n.length-1],this.defaultActions[x]?k=this.defaultActions[x]:(null==_&&(_=v()),k=a[x]&&a[x][_]),void 0===k||!k.length||!k[0]){var C="";for(A in M=[],a[x])this.terminals_[A]&&A>l&&M.push("'"+this.terminals_[A]+"'");C=p.showPosition?"Parse error on line "+(u+1)+":\n"+p.showPosition()+"\nExpecting "+M.join(", ")+", got '"+(this.terminals_[_]||_)+"'":"Parse error on line "+(u+1)+": Unexpected "+(_==h?"end of input":"'"+(this.terminals_[_]||_)+"'"),this.parseError(C,{text:p.match,token:this.terminals_[_]||_,line:p.yylineno,loc:b,expected:M})}if(k[0]instanceof Array&&k.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+_);switch(k[0]){case 1:n.push(_),i.push(p.yytext),o.push(p.yylloc),n.push(k[1]),_=null,w?(_=w,w=null):(c=p.yyleng,s=p.yytext,u=p.yylineno,b=p.yylloc,f>0&&f--);break;case 2:if(S=this.productions_[k[1]][1],D.$=i[i.length-S],D._$={first_line:o[o.length-(S||1)].first_line,last_line:o[o.length-1].last_line,first_column:o[o.length-(S||1)].first_column,last_column:o[o.length-1].last_column},m&&(D._$.range=[o[o.length-(S||1)].range[0],o[o.length-1].range[1]]),void 0!==(E=this.performAction.apply(D,[s,c,u,g.yy,k[1],i,o].concat(d))))return E;S&&(n=n.slice(0,-1*S*2),i=i.slice(0,-1*S),o=o.slice(0,-1*S)),n.push(this.productions_[k[1]][0]),i.push(D.$),o.push(D._$),T=a[n[n.length-2]][n[n.length-1]],n.push(T);break;case 3:return!0}}return!0}},l={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var r=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var i=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===r.length?this.yylloc.first_column:0)+r[r.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[i[0],i[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,r,i;if(this.options.backtrack_lexer&&(i={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(i.yylloc.range=this.yylloc.range.slice(0))),(r=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=r.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:r?r[r.length-1].length-r[r.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var o in i)this[o]=i[o];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,r;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var i=this._currentRules(),o=0;o<i.length;o++)if((n=this._input.match(this.rules[i[o]]))&&(!e||n[0].length>e[0].length)){if(e=n,r=o,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,i[o])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,i[r]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(t,e,n,r){switch(n){case 0:return 10;case 1:case 2:case 3:break;case 4:this.begin("href");break;case 5:this.popState();break;case 6:return 23;case 7:this.begin("callbackname");break;case 8:this.popState();break;case 9:this.popState(),this.begin("callbackargs");break;case 10:return 21;case 11:this.popState();break;case 12:return 22;case 13:this.begin("click");break;case 14:this.popState();break;case 15:return 20;case 16:return 4;case 17:return 11;case 18:return 12;case 19:return 13;case 20:return 14;case 21:return"date";case 22:return 15;case 23:return 16;case 24:return 18;case 25:return 19;case 26:return":";case 27:return 6;case 28:return"INVALID"}},rules:[/^(?:[\n]+)/i,/^(?:\s+)/i,/^(?:#[^\n]*)/i,/^(?:%[^\n]*)/i,/^(?:href[\s]+["])/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:call[\s]+)/i,/^(?:\([\s]*\))/i,/^(?:\()/i,/^(?:[^(]*)/i,/^(?:\))/i,/^(?:[^)]*)/i,/^(?:click[\s]+)/i,/^(?:[\s\n])/i,/^(?:[^\s\n]*)/i,/^(?:gantt\b)/i,/^(?:dateFormat\s[^#\n;]+)/i,/^(?:inclusiveEndDates\b)/i,/^(?:axisFormat\s[^#\n;]+)/i,/^(?:excludes\s[^#\n;]+)/i,/^(?:\d\d\d\d-\d\d-\d\d\b)/i,/^(?:title\s[^#\n;]+)/i,/^(?:section\s[^#:\n;]+)/i,/^(?:[^#:\n;]+)/i,/^(?::[^#\n;]+)/i,/^(?::)/i,/^(?:$)/i,/^(?:.)/i],conditions:{callbackargs:{rules:[11,12],inclusive:!1},callbackname:{rules:[8,9,10],inclusive:!1},href:{rules:[5,6],inclusive:!1},click:{rules:[14,15],inclusive:!1},INITIAL:{rules:[0,1,2,3,4,7,13,16,17,18,19,20,21,22,23,24,25,26,27,28],inclusive:!0}}};function h(){this.yy={}}return f.lexer=l,h.prototype=f,f.Parser=h,new h}();e.parser=i,e.Parser=i.Parser,e.parse=function(){return i.parse.apply(i,arguments)},e.main=function(r){r[1]||(console.log("Usage: "+r[0]+" FILE"),t.exit(1));var i=n(28).readFileSync(n(29).normalize(r[1]),"utf8");return e.parser.parse(i)},n.c[n.s]===r&&e.main(t.argv.slice(1))}).call(this,n(7),n(9)(t))},function(t,e,n){var r=n(134),i=n(95),o=n(24);t.exports=function(t){return o(t)?r(t):i(t)}},function(t,e){},function(t,e,n){(function(t){function n(t,e){for(var n=0,r=t.length-1;r>=0;r--){var i=t[r];"."===i?t.splice(r,1):".."===i?(t.splice(r,1),n++):n&&(t.splice(r,1),n--)}if(e)for(;n--;n)t.unshift("..");return t}function r(t,e){if(t.filter)return t.filter(e);for(var n=[],r=0;r<t.length;r++)e(t[r],r,t)&&n.push(t[r]);return n}e.resolve=function(){for(var e="",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var a=o>=0?arguments[o]:t.cwd();if("string"!=typeof a)throw new TypeError("Arguments to path.resolve must be strings");a&&(e=a+"/"+e,i="/"===a.charAt(0))}return(i?"/":"")+(e=n(r(e.split("/"),(function(t){return!!t})),!i).join("/"))||"."},e.normalize=function(t){var o=e.isAbsolute(t),a="/"===i(t,-1);return(t=n(r(t.split("/"),(function(t){return!!t})),!o).join("/"))||o||(t="."),t&&a&&(t+="/"),(o?"/":"")+t},e.isAbsolute=function(t){return"/"===t.charAt(0)},e.join=function(){var t=Array.prototype.slice.call(arguments,0);return e.normalize(r(t,(function(t,e){if("string"!=typeof t)throw new TypeError("Arguments to path.join must be strings");return t})).join("/"))},e.relative=function(t,n){function r(t){for(var e=0;e<t.length&&""===t[e];e++);for(var n=t.length-1;n>=0&&""===t[n];n--);return e>n?[]:t.slice(e,n-e+1)}t=e.resolve(t).substr(1),n=e.resolve(n).substr(1);for(var i=r(t.split("/")),o=r(n.split("/")),a=Math.min(i.length,o.length),s=a,u=0;u<a;u++)if(i[u]!==o[u]){s=u;break}var c=[];for(u=s;u<i.length;u++)c.push("..");return(c=c.concat(o.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(t){if("string"!=typeof t&&(t+=""),0===t.length)return".";for(var e=t.charCodeAt(0),n=47===e,r=-1,i=!0,o=t.length-1;o>=1;--o)if(47===(e=t.charCodeAt(o))){if(!i){r=o;break}}else i=!1;return-1===r?n?"/":".":n&&1===r?"/":t.slice(0,r)},e.basename=function(t,e){var n=function(t){"string"!=typeof t&&(t+="");var e,n=0,r=-1,i=!0;for(e=t.length-1;e>=0;--e)if(47===t.charCodeAt(e)){if(!i){n=e+1;break}}else-1===r&&(i=!1,r=e+1);return-1===r?"":t.slice(n,r)}(t);return e&&n.substr(-1*e.length)===e&&(n=n.substr(0,n.length-e.length)),n},e.extname=function(t){"string"!=typeof t&&(t+="");for(var e=-1,n=0,r=-1,i=!0,o=0,a=t.length-1;a>=0;--a){var s=t.charCodeAt(a);if(47!==s)-1===r&&(i=!1,r=a+1),46===s?-1===e?e=a:1!==o&&(o=1):-1!==e&&(o=-1);else if(!i){n=a+1;break}}return-1===e||-1===r||0===o||1===o&&e===r-1&&e===n+1?"":t.slice(e,r)};var i="b"==="ab".substr(-1)?function(t,e,n){return t.substr(e,n)}:function(t,e,n){return e<0&&(e=t.length+e),t.substr(e,n)}}).call(this,n(7))},function(t,e,n){var r;if(!r)try{r=n(0)}catch(t){}r||(r=window.d3),t.exports=r},function(t,e,n){var r=n(3).Buffer,i=n(112).Transform,o=n(117).StringDecoder;function a(t){i.call(this),this.hashMode="string"==typeof t,this.hashMode?this[t]=this._finalOrDigest:this.final=this._finalOrDigest,this._final&&(this.__final=this._final,this._final=null),this._decoder=null,this._encoding=null}n(2)(a,i),a.prototype.update=function(t,e,n){"string"==typeof t&&(t=r.from(t,e));var i=this._update(t);return this.hashMode?this:(n&&(i=this._toString(i,n)),i)},a.prototype.setAutoPadding=function(){},a.prototype.getAuthTag=function(){throw new Error("trying to get auth tag in unsupported state")},a.prototype.setAuthTag=function(){throw new Error("trying to set auth tag in unsupported state")},a.prototype.setAAD=function(){throw new Error("trying to set aad in unsupported state")},a.prototype._transform=function(t,e,n){var r;try{this.hashMode?this._update(t):this.push(this._update(t))}catch(t){r=t}finally{n(r)}},a.prototype._flush=function(t){var e;try{this.push(this.__final())}catch(t){e=t}t(e)},a.prototype._finalOrDigest=function(t){var e=this.__final()||r.alloc(0);return t&&(e=this._toString(e,t,!0)),e},a.prototype._toString=function(t,e,n){if(this._decoder||(this._decoder=new o(e),this._encoding=e),this._encoding!==e)throw new Error("can't switch encodings");var r=this._decoder.write(t);return n&&(r+=this._decoder.end()),r},t.exports=a},function(t,e,n){var r=n(246),i=n(251);t.exports=function(t,e){var n=i(t,e);return r(n)?n:void 0}},function(t,e,n){var r=n(38),i=n(247),o=n(248),a="[object Null]",s="[object Undefined]",u=r?r.toStringTag:void 0;t.exports=function(t){return null==t?void 0===t?s:a:u&&u in Object(t)?i(t):o(t)}},function(t,e){t.exports=function(t){return t}},function(t,e,n){"use strict";var r=n(78),i=Object.keys||function(t){var e=[];for(var n in t)e.push(n);return e};t.exports=l;var o=n(54);o.inherits=n(2);var a=n(193),s=n(116);o.inherits(l,a);for(var u=i(s.prototype),c=0;c<u.length;c++){var f=u[c];l.prototype[f]||(l.prototype[f]=s.prototype[f])}function l(t){if(!(this instanceof l))return new l(t);a.call(this,t),s.call(this,t),t&&!1===t.readable&&(this.readable=!1),t&&!1===t.writable&&(this.writable=!1),this.allowHalfOpen=!0,t&&!1===t.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",h)}function h(){this.allowHalfOpen||this._writableState.ended||r.nextTick(d,this)}function d(t){t.end()}Object.defineProperty(l.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(l.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(t){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=t,this._writableState.destroyed=t)}}),l.prototype._destroy=function(t,e){this.push(null),this.end(),r.nextTick(e,t)}},function(t,e){t.exports=function(t,e){return t===e||t!=t&&e!=e}},function(t,e,n){var r=n(33),i=n(13),o="[object AsyncFunction]",a="[object Function]",s="[object GeneratorFunction]",u="[object Proxy]";t.exports=function(t){if(!i(t))return!1;var e=r(t);return e==a||e==s||e==o||e==u}},function(t,e,n){var r=n(18).Symbol;t.exports=r},function(t,e,n){(function(t){var r=n(18),i=n(267),o=e&&!e.nodeType&&e,a=o&&"object"==typeof t&&t&&!t.nodeType&&t,s=a&&a.exports===o?r.Buffer:void 0,u=(s?s.isBuffer:void 0)||i;t.exports=u}).call(this,n(9)(t))},function(t,e,n){var r=n(134),i=n(271),o=n(24);t.exports=function(t){return o(t)?r(t,!0):i(t)}},function(t,e,n){var r=n(276),i=n(90),o=n(277),a=n(143),s=n(278),u=n(33),c=n(132),f=c(r),l=c(i),h=c(o),d=c(a),p=c(s),g=u;(r&&"[object DataView]"!=g(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=g(new i)||o&&"[object Promise]"!=g(o.resolve())||a&&"[object Set]"!=g(new a)||s&&"[object WeakMap]"!=g(new s))&&(g=function(t){var e=u(t),n="[object Object]"==e?t.constructor:void 0,r=n?c(n):"";if(r)switch(r){case f:return"[object DataView]";case l:return"[object Map]";case h:return"[object Promise]";case d:return"[object Set]";case p:return"[object WeakMap]"}return e}),t.exports=g},function(t,e,n){var r=n(33),i=n(20),o="[object Symbol]";t.exports=function(t){return"symbol"==typeof t||i(t)&&r(t)==o}},function(t,e,n){var r;try{r={defaults:n(176),each:n(100),isFunction:n(37),isPlainObject:n(180),pick:n(183),has:n(106),range:n(184),uniqueId:n(185)}}catch(t){}r||(r=window._),t.exports=r},function(t,e,n){"use strict";(function(e,r){var i=65536,o=4294967295;var a=n(3).Buffer,s=e.crypto||e.msCrypto;s&&s.getRandomValues?t.exports=function(t,e){if(t>o)throw new RangeError("requested too many random bytes");var n=a.allocUnsafe(t);if(t>0)if(t>i)for(var u=0;u<t;u+=i)s.getRandomValues(n.slice(u,u+i));else s.getRandomValues(n);if("function"==typeof e)return r.nextTick((function(){e(null,n)}));return n}:t.exports=function(){throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11")}}).call(this,n(11),n(7))},function(t,e,n){var r=n(3).Buffer;function i(t,e){this._block=r.alloc(t),this._finalSize=e,this._blockSize=t,this._len=0}i.prototype.update=function(t,e){"string"==typeof t&&(e=e||"utf8",t=r.from(t,e));for(var n=this._block,i=this._blockSize,o=t.length,a=this._len,s=0;s<o;){for(var u=a%i,c=Math.min(o-s,i-u),f=0;f<c;f++)n[u+f]=t[s+f];s+=c,(a+=c)%i==0&&this._update(n)}return this._len+=o,this},i.prototype.digest=function(t){var e=this._len%this._blockSize;this._block[e]=128,this._block.fill(0,e+1),e>=this._finalSize&&(this._update(this._block),this._block.fill(0));var n=8*this._len;if(n<=4294967295)this._block.writeUInt32BE(n,this._blockSize-4);else{var r=(4294967295&n)>>>0,i=(n-r)/4294967296;this._block.writeUInt32BE(i,this._blockSize-8),this._block.writeUInt32BE(r,this._blockSize-4)}this._update(this._block);var o=this._hash();return t?o.toString(t):o},i.prototype._update=function(){throw new Error("_update must be implemented by subclass")},t.exports=i},function(t,e,n){(function(t,r){var i=function(){var t=function(t,e,n,r){for(n=n||{},r=t.length;r--;n[t[r]]=e);return n},e=[1,12],n=[1,15],r=[1,13],i=[1,14],o=[1,17],a=[1,18],s=[1,19],u=[6,8],c=[1,28],f=[1,29],l=[1,30],h=[1,31],d=[1,32],p=[1,33],g=[6,8,13,18,26,29,30,31,32,33,34],y=[6,8,13,18,22,26,29,30,31,32,33,34,48,49,50],b=[26,48,49,50],m=[26,33,34,48,49,50],v=[26,29,30,31,32,48,49,50],_=[6,8,13],w=[1,50],x={trace:function(){},yy:{},symbols_:{error:2,mermaidDoc:3,graphConfig:4,CLASS_DIAGRAM:5,NEWLINE:6,statements:7,EOF:8,statement:9,className:10,alphaNumToken:11,relationStatement:12,LABEL:13,classStatement:14,methodStatement:15,annotationStatement:16,CLASS:17,STRUCT_START:18,members:19,STRUCT_STOP:20,ANNOTATION_START:21,ANNOTATION_END:22,MEMBER:23,SEPARATOR:24,relation:25,STR:26,relationType:27,lineType:28,AGGREGATION:29,EXTENSION:30,COMPOSITION:31,DEPENDENCY:32,LINE:33,DOTTED_LINE:34,commentToken:35,textToken:36,graphCodeTokens:37,textNoTagsToken:38,TAGSTART:39,TAGEND:40,"==":41,"--":42,PCT:43,DEFAULT:44,SPACE:45,MINUS:46,keywords:47,UNICODE_TEXT:48,NUM:49,ALPHA:50,$accept:0,$end:1},terminals_:{2:"error",5:"CLASS_DIAGRAM",6:"NEWLINE",8:"EOF",13:"LABEL",17:"CLASS",18:"STRUCT_START",20:"STRUCT_STOP",21:"ANNOTATION_START",22:"ANNOTATION_END",23:"MEMBER",24:"SEPARATOR",26:"STR",29:"AGGREGATION",30:"EXTENSION",31:"COMPOSITION",32:"DEPENDENCY",33:"LINE",34:"DOTTED_LINE",37:"graphCodeTokens",39:"TAGSTART",40:"TAGEND",41:"==",42:"--",43:"PCT",44:"DEFAULT",45:"SPACE",46:"MINUS",47:"keywords",48:"UNICODE_TEXT",49:"NUM",50:"ALPHA"},productions_:[0,[3,1],[4,4],[7,1],[7,2],[7,3],[10,2],[10,1],[9,1],[9,2],[9,1],[9,1],[9,1],[14,2],[14,5],[16,4],[19,1],[19,2],[15,1],[15,2],[15,1],[15,1],[12,3],[12,4],[12,4],[12,5],[25,3],[25,2],[25,2],[25,1],[27,1],[27,1],[27,1],[27,1],[28,1],[28,1],[35,1],[35,1],[36,1],[36,1],[36,1],[36,1],[36,1],[36,1],[36,1],[38,1],[38,1],[38,1],[38,1],[11,1],[11,1],[11,1]],performAction:function(t,e,n,r,i,o,a){var s=o.length-1;switch(i){case 6:this.$=o[s-1]+o[s];break;case 7:this.$=o[s];break;case 8:r.addRelation(o[s]);break;case 9:o[s-1].title=r.cleanupLabel(o[s]),r.addRelation(o[s-1]);break;case 13:r.addClass(o[s]);break;case 14:r.addClass(o[s-3]),r.addMembers(o[s-3],o[s-1]);break;case 15:r.addAnnotation(o[s],o[s-2]);break;case 16:this.$=[o[s]];break;case 17:o[s].push(o[s-1]),this.$=o[s];break;case 18:break;case 19:r.addMember(o[s-1],r.cleanupLabel(o[s]));break;case 20:case 21:break;case 22:this.$={id1:o[s-2],id2:o[s],relation:o[s-1],relationTitle1:"none",relationTitle2:"none"};break;case 23:this.$={id1:o[s-3],id2:o[s],relation:o[s-1],relationTitle1:o[s-2],relationTitle2:"none"};break;case 24:this.$={id1:o[s-3],id2:o[s],relation:o[s-2],relationTitle1:"none",relationTitle2:o[s-1]};break;case 25:this.$={id1:o[s-4],id2:o[s],relation:o[s-2],relationTitle1:o[s-3],relationTitle2:o[s-1]};break;case 26:this.$={type1:o[s-2],type2:o[s],lineType:o[s-1]};break;case 27:this.$={type1:"none",type2:o[s],lineType:o[s-1]};break;case 28:this.$={type1:o[s-1],type2:"none",lineType:o[s]};break;case 29:this.$={type1:"none",type2:"none",lineType:o[s]};break;case 30:this.$=r.relationType.AGGREGATION;break;case 31:this.$=r.relationType.EXTENSION;break;case 32:this.$=r.relationType.COMPOSITION;break;case 33:this.$=r.relationType.DEPENDENCY;break;case 34:this.$=r.lineType.LINE;break;case 35:this.$=r.lineType.DOTTED_LINE}},table:[{3:1,4:2,5:[1,3]},{1:[3]},{1:[2,1]},{6:[1,4]},{7:5,9:6,10:11,11:16,12:7,14:8,15:9,16:10,17:e,21:n,23:r,24:i,48:o,49:a,50:s},{8:[1,20]},{6:[1,21],8:[2,3]},t(u,[2,8],{13:[1,22]}),t(u,[2,10]),t(u,[2,11]),t(u,[2,12]),t(u,[2,18],{25:23,27:26,28:27,13:[1,25],26:[1,24],29:c,30:f,31:l,32:h,33:d,34:p}),{10:34,11:16,48:o,49:a,50:s},t(u,[2,20]),t(u,[2,21]),{11:35,48:o,49:a,50:s},t(g,[2,7],{11:16,10:36,48:o,49:a,50:s}),t(y,[2,49]),t(y,[2,50]),t(y,[2,51]),{1:[2,2]},{7:37,8:[2,4],9:6,10:11,11:16,12:7,14:8,15:9,16:10,17:e,21:n,23:r,24:i,48:o,49:a,50:s},t(u,[2,9]),{10:38,11:16,26:[1,39],48:o,49:a,50:s},{25:40,27:26,28:27,29:c,30:f,31:l,32:h,33:d,34:p},t(u,[2,19]),{28:41,33:d,34:p},t(b,[2,29],{27:42,29:c,30:f,31:l,32:h}),t(m,[2,30]),t(m,[2,31]),t(m,[2,32]),t(m,[2,33]),t(v,[2,34]),t(v,[2,35]),t(u,[2,13],{18:[1,43]}),{22:[1,44]},t(g,[2,6]),{8:[2,5]},t(_,[2,22]),{10:45,11:16,48:o,49:a,50:s},{10:46,11:16,26:[1,47],48:o,49:a,50:s},t(b,[2,28],{27:48,29:c,30:f,31:l,32:h}),t(b,[2,27]),{19:49,23:w},{10:51,11:16,48:o,49:a,50:s},t(_,[2,24]),t(_,[2,23]),{10:52,11:16,48:o,49:a,50:s},t(b,[2,26]),{20:[1,53]},{19:54,20:[2,16],23:w},t(u,[2,15]),t(_,[2,25]),t(u,[2,14]),{20:[2,17]}],defaultActions:{2:[2,1],20:[2,2],37:[2,5],54:[2,17]},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],r=[],i=[null],o=[],a=this.table,s="",u=0,c=0,f=0,l=2,h=1,d=o.slice.call(arguments,1),p=Object.create(this.lexer),g={yy:{}};for(var y in this.yy)Object.prototype.hasOwnProperty.call(this.yy,y)&&(g.yy[y]=this.yy[y]);p.setInput(t,g.yy),g.yy.lexer=p,g.yy.parser=this,void 0===p.yylloc&&(p.yylloc={});var b=p.yylloc;o.push(b);var m=p.options&&p.options.ranges;function v(){var t;return"number"!=typeof(t=r.pop()||p.lex()||h)&&(t instanceof Array&&(t=(r=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof g.yy.parseError?this.parseError=g.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var _,w,x,k,E,A,S,T,M,D={};;){if(x=n[n.length-1],this.defaultActions[x]?k=this.defaultActions[x]:(null==_&&(_=v()),k=a[x]&&a[x][_]),void 0===k||!k.length||!k[0]){var C="";for(A in M=[],a[x])this.terminals_[A]&&A>l&&M.push("'"+this.terminals_[A]+"'");C=p.showPosition?"Parse error on line "+(u+1)+":\n"+p.showPosition()+"\nExpecting "+M.join(", ")+", got '"+(this.terminals_[_]||_)+"'":"Parse error on line "+(u+1)+": Unexpected "+(_==h?"end of input":"'"+(this.terminals_[_]||_)+"'"),this.parseError(C,{text:p.match,token:this.terminals_[_]||_,line:p.yylineno,loc:b,expected:M})}if(k[0]instanceof Array&&k.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+_);switch(k[0]){case 1:n.push(_),i.push(p.yytext),o.push(p.yylloc),n.push(k[1]),_=null,w?(_=w,w=null):(c=p.yyleng,s=p.yytext,u=p.yylineno,b=p.yylloc,f>0&&f--);break;case 2:if(S=this.productions_[k[1]][1],D.$=i[i.length-S],D._$={first_line:o[o.length-(S||1)].first_line,last_line:o[o.length-1].last_line,first_column:o[o.length-(S||1)].first_column,last_column:o[o.length-1].last_column},m&&(D._$.range=[o[o.length-(S||1)].range[0],o[o.length-1].range[1]]),void 0!==(E=this.performAction.apply(D,[s,c,u,g.yy,k[1],i,o].concat(d))))return E;S&&(n=n.slice(0,-1*S*2),i=i.slice(0,-1*S),o=o.slice(0,-1*S)),n.push(this.productions_[k[1]][0]),i.push(D.$),o.push(D._$),T=a[n[n.length-2]][n[n.length-1]],n.push(T);break;case 3:return!0}}return!0}},k={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var r=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var i=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===r.length?this.yylloc.first_column:0)+r[r.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[i[0],i[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,r,i;if(this.options.backtrack_lexer&&(i={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(i.yylloc.range=this.yylloc.range.slice(0))),(r=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=r.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:r?r[r.length-1].length-r[r.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var o in i)this[o]=i[o];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,r;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var i=this._currentRules(),o=0;o<i.length;o++)if((n=this._input.match(this.rules[i[o]]))&&(!e||n[0].length>e[0].length)){if(e=n,r=o,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,i[o])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,i[r]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{},performAction:function(t,e,n,r){switch(n){case 0:break;case 1:return 6;case 2:break;case 3:return 5;case 4:return this.begin("struct"),18;case 5:return this.popState(),20;case 6:break;case 7:return"MEMBER";case 8:return 17;case 9:return 21;case 10:return 22;case 11:this.begin("string");break;case 12:this.popState();break;case 13:return"STR";case 14:case 15:return 30;case 16:case 17:return 32;case 18:return 31;case 19:return 29;case 20:return 33;case 21:return 34;case 22:return 13;case 23:return 46;case 24:return"DOT";case 25:return"PLUS";case 26:return 43;case 27:case 28:return"EQUALS";case 29:return 50;case 30:return"PUNCTUATION";case 31:return 49;case 32:return 48;case 33:return 45;case 34:return 8}},rules:[/^(?:%%[^\n]*)/,/^(?:\n+)/,/^(?:\s+)/,/^(?:classDiagram\b)/,/^(?:[\{])/,/^(?:\})/,/^(?:[\n])/,/^(?:[^\{\}\n]*)/,/^(?:class\b)/,/^(?:<<)/,/^(?:>>)/,/^(?:["])/,/^(?:["])/,/^(?:[^"]*)/,/^(?:\s*<\|)/,/^(?:\s*\|>)/,/^(?:\s*>)/,/^(?:\s*<)/,/^(?:\s*\*)/,/^(?:\s*o\b)/,/^(?:--)/,/^(?:\.\.)/,/^(?::[^\n;]+)/,/^(?:-)/,/^(?:\.)/,/^(?:\+)/,/^(?:%)/,/^(?:=)/,/^(?:=)/,/^(?:\w+)/,/^(?:[!"#$%&'*+,-.`?\\\/])/,/^(?:[0-9]+)/,/^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,/^(?:\s)/,/^(?:$)/],conditions:{string:{rules:[12,13],inclusive:!1},struct:{rules:[5,6,7],inclusive:!1},INITIAL:{rules:[0,1,2,3,4,8,9,10,11,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34],inclusive:!0}}};function E(){this.yy={}}return x.lexer=k,E.prototype=x,x.Parser=E,new E}();e.parser=i,e.Parser=i.Parser,e.parse=function(){return i.parse.apply(i,arguments)},e.main=function(r){r[1]||(console.log("Usage: "+r[0]+" FILE"),t.exit(1));var i=n(28).readFileSync(n(29).normalize(r[1]),"utf8");return e.parser.parse(i)},n.c[n.s]===r&&e.main(t.argv.slice(1))}).call(this,n(7),n(9)(t))},function(t,e,n){(function(t,r){var i=function(){var t=function(t,e,n,r){for(n=n||{},r=t.length;r--;n[t[r]]=e);return n},e=[1,2],n=[1,3],r=[1,4],i=[2,4],o=[1,9],a=[1,11],s=[1,13],u=[1,14],c=[1,15],f=[1,16],l=[1,21],h=[1,17],d=[1,18],p=[1,19],g=[1,20],y=[1,22],b=[1,4,5,13,14,16,18,19,21,22,23,24,25,28],m=[1,4,5,11,12,13,14,16,18,19,21,22,23,24,25,28],v=[4,5,13,14,16,18,19,21,22,23,24,25,28],_={trace:function(){},yy:{},symbols_:{error:2,start:3,SPACE:4,NL:5,SD:6,document:7,line:8,statement:9,idStatement:10,DESCR:11,"--\x3e":12,HIDE_EMPTY:13,scale:14,WIDTH:15,COMPOSIT_STATE:16,STRUCT_START:17,STRUCT_STOP:18,STATE_DESCR:19,AS:20,ID:21,FORK:22,JOIN:23,CONCURRENT:24,note:25,notePosition:26,NOTE_TEXT:27,EDGE_STATE:28,left_of:29,right_of:30,$accept:0,$end:1},terminals_:{2:"error",4:"SPACE",5:"NL",6:"SD",11:"DESCR",12:"--\x3e",13:"HIDE_EMPTY",14:"scale",15:"WIDTH",16:"COMPOSIT_STATE",17:"STRUCT_START",18:"STRUCT_STOP",19:"STATE_DESCR",20:"AS",21:"ID",22:"FORK",23:"JOIN",24:"CONCURRENT",25:"note",27:"NOTE_TEXT",28:"EDGE_STATE",29:"left_of",30:"right_of"},productions_:[0,[3,2],[3,2],[3,2],[7,0],[7,2],[8,2],[8,1],[8,1],[9,1],[9,2],[9,3],[9,4],[9,1],[9,2],[9,1],[9,4],[9,3],[9,6],[9,1],[9,1],[9,1],[9,4],[9,4],[10,1],[10,1],[26,1],[26,1]],performAction:function(t,e,n,r,i,o,a){var s=o.length-1;switch(i){case 3:return r.setRootDoc(o[s]),o[s];case 4:this.$=[];break;case 5:"nl"!=o[s]&&(o[s-1].push(o[s]),this.$=o[s-1]);break;case 6:case 7:this.$=o[s];break;case 8:this.$="nl";break;case 9:this.$={stmt:"state",id:o[s],type:"default",description:""};break;case 10:this.$={stmt:"state",id:o[s-1],type:"default",description:o[s].trim()};break;case 11:this.$={stmt:"relation",state1:{stmt:"state",id:o[s-2],type:"default",description:""},state2:{stmt:"state",id:o[s],type:"default",description:""}};break;case 12:this.$={stmt:"relation",state1:{stmt:"state",id:o[s-3],type:"default",description:""},state2:{stmt:"state",id:o[s-1],type:"default",description:""},description:o[s].substr(1).trim()};break;case 16:this.$={stmt:"state",id:o[s-3],type:"default",description:"",doc:o[s-1]};break;case 17:var u=o[s],c=o[s-2].trim();if(o[s].match(":")){var f=o[s].split(":");u=f[0],c=[c,f[1]]}this.$={stmt:"state",id:u,type:"default",description:c};break;case 18:this.$={stmt:"state",id:o[s-3],type:"default",description:o[s-5],doc:o[s-1]};break;case 19:this.$={stmt:"state",id:o[s],type:"fork"};break;case 20:this.$={stmt:"state",id:o[s],type:"join"};break;case 21:this.$={stmt:"state",id:r.getDividerId(),type:"divider"};break;case 22:this.$={stmt:"state",id:o[s-1].trim(),note:{position:o[s-2].trim(),text:o[s].trim()}};break;case 24:case 25:this.$=o[s]}},table:[{3:1,4:e,5:n,6:r},{1:[3]},{3:5,4:e,5:n,6:r},{3:6,4:e,5:n,6:r},t([1,4,5,13,14,16,19,21,22,23,24,25,28],i,{7:7}),{1:[2,1]},{1:[2,2]},{1:[2,3],4:o,5:a,8:8,9:10,10:12,13:s,14:u,16:c,19:f,21:l,22:h,23:d,24:p,25:g,28:y},t(b,[2,5]),{9:23,10:12,13:s,14:u,16:c,19:f,21:l,22:h,23:d,24:p,25:g,28:y},t(b,[2,7]),t(b,[2,8]),t(b,[2,9],{11:[1,24],12:[1,25]}),t(b,[2,13]),{15:[1,26]},t(b,[2,15],{17:[1,27]}),{20:[1,28]},t(b,[2,19]),t(b,[2,20]),t(b,[2,21]),{26:29,27:[1,30],29:[1,31],30:[1,32]},t(m,[2,24]),t(m,[2,25]),t(b,[2,6]),t(b,[2,10]),{10:33,21:l,28:y},t(b,[2,14]),t(v,i,{7:34}),{21:[1,35]},{21:[1,36]},{20:[1,37]},{21:[2,26]},{21:[2,27]},t(b,[2,11],{11:[1,38]}),{4:o,5:a,8:8,9:10,10:12,13:s,14:u,16:c,18:[1,39],19:f,21:l,22:h,23:d,24:p,25:g,28:y},t(b,[2,17],{17:[1,40]}),{27:[1,41]},{21:[1,42]},t(b,[2,12]),t(b,[2,16]),t(v,i,{7:43}),t(b,[2,22]),t(b,[2,23]),{4:o,5:a,8:8,9:10,10:12,13:s,14:u,16:c,18:[1,44],19:f,21:l,22:h,23:d,24:p,25:g,28:y},t(b,[2,18])],defaultActions:{5:[2,1],6:[2,2],31:[2,26],32:[2,27]},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],r=[],i=[null],o=[],a=this.table,s="",u=0,c=0,f=0,l=2,h=1,d=o.slice.call(arguments,1),p=Object.create(this.lexer),g={yy:{}};for(var y in this.yy)Object.prototype.hasOwnProperty.call(this.yy,y)&&(g.yy[y]=this.yy[y]);p.setInput(t,g.yy),g.yy.lexer=p,g.yy.parser=this,void 0===p.yylloc&&(p.yylloc={});var b=p.yylloc;o.push(b);var m=p.options&&p.options.ranges;function v(){var t;return"number"!=typeof(t=r.pop()||p.lex()||h)&&(t instanceof Array&&(t=(r=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof g.yy.parseError?this.parseError=g.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var _,w,x,k,E,A,S,T,M,D={};;){if(x=n[n.length-1],this.defaultActions[x]?k=this.defaultActions[x]:(null==_&&(_=v()),k=a[x]&&a[x][_]),void 0===k||!k.length||!k[0]){var C="";for(A in M=[],a[x])this.terminals_[A]&&A>l&&M.push("'"+this.terminals_[A]+"'");C=p.showPosition?"Parse error on line "+(u+1)+":\n"+p.showPosition()+"\nExpecting "+M.join(", ")+", got '"+(this.terminals_[_]||_)+"'":"Parse error on line "+(u+1)+": Unexpected "+(_==h?"end of input":"'"+(this.terminals_[_]||_)+"'"),this.parseError(C,{text:p.match,token:this.terminals_[_]||_,line:p.yylineno,loc:b,expected:M})}if(k[0]instanceof Array&&k.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+_);switch(k[0]){case 1:n.push(_),i.push(p.yytext),o.push(p.yylloc),n.push(k[1]),_=null,w?(_=w,w=null):(c=p.yyleng,s=p.yytext,u=p.yylineno,b=p.yylloc,f>0&&f--);break;case 2:if(S=this.productions_[k[1]][1],D.$=i[i.length-S],D._$={first_line:o[o.length-(S||1)].first_line,last_line:o[o.length-1].last_line,first_column:o[o.length-(S||1)].first_column,last_column:o[o.length-1].last_column},m&&(D._$.range=[o[o.length-(S||1)].range[0],o[o.length-1].range[1]]),void 0!==(E=this.performAction.apply(D,[s,c,u,g.yy,k[1],i,o].concat(d))))return E;S&&(n=n.slice(0,-1*S*2),i=i.slice(0,-1*S),o=o.slice(0,-1*S)),n.push(this.productions_[k[1]][0]),i.push(D.$),o.push(D._$),T=a[n[n.length-2]][n[n.length-1]],n.push(T);break;case 3:return!0}}return!0}},w={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var r=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var i=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===r.length?this.yylloc.first_column:0)+r[r.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[i[0],i[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,r,i;if(this.options.backtrack_lexer&&(i={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(i.yylloc.range=this.yylloc.range.slice(0))),(r=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=r.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:r?r[r.length-1].length-r[r.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var o in i)this[o]=i[o];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,r;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var i=this._currentRules(),o=0;o<i.length;o++)if((n=this._input.match(this.rules[i[o]]))&&(!e||n[0].length>e[0].length)){if(e=n,r=o,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,i[o])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,i[r]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(t,e,n,r){switch(n){case 0:return 5;case 1:case 2:case 3:case 4:break;case 5:return this.pushState("SCALE"),14;case 6:return 15;case 7:this.popState();break;case 8:this.pushState("STATE");break;case 9:return this.popState(),e.yytext=e.yytext.slice(0,-8).trim(),22;case 10:return this.popState(),e.yytext=e.yytext.slice(0,-8).trim(),23;case 11:return this.popState(),e.yytext=e.yytext.slice(0,-8).trim(),22;case 12:return this.popState(),e.yytext=e.yytext.slice(0,-8).trim(),23;case 13:this.begin("STATE_STRING");break;case 14:return this.popState(),this.pushState("STATE_ID"),"AS";case 15:return this.popState(),"ID";case 16:this.popState();break;case 17:return"STATE_DESCR";case 18:return 16;case 19:this.popState();break;case 20:return this.popState(),this.pushState("struct"),17;case 21:return this.popState(),18;case 22:break;case 23:return this.begin("NOTE"),25;case 24:return this.popState(),this.pushState("NOTE_ID"),29;case 25:return this.popState(),this.pushState("NOTE_ID"),30;case 26:this.popState(),this.pushState("FLOATING_NOTE");break;case 27:return this.popState(),this.pushState("FLOATING_NOTE_ID"),"AS";case 28:break;case 29:return"NOTE_TEXT";case 30:return this.popState(),"ID";case 31:return this.popState(),this.pushState("NOTE_TEXT"),21;case 32:return this.popState(),e.yytext=e.yytext.substr(2).trim(),27;case 33:return this.popState(),e.yytext=e.yytext.slice(0,-8).trim(),27;case 34:return 6;case 35:return 13;case 36:return 28;case 37:return 21;case 38:return e.yytext=e.yytext.trim(),11;case 39:return 12;case 40:return 24;case 41:return 5;case 42:return"INVALID"}},rules:[/^(?:[\n]+)/i,/^(?:\s+)/i,/^(?:((?!\n)\s)+)/i,/^(?:#[^\n]*)/i,/^(?:%[^\n]*)/i,/^(?:scale\s+)/i,/^(?:\d+)/i,/^(?:\s+width\b)/i,/^(?:state\s+)/i,/^(?:.*<<fork>>)/i,/^(?:.*<<join>>)/i,/^(?:.*\[\[fork\]\])/i,/^(?:.*\[\[join\]\])/i,/^(?:["])/i,/^(?:as\s*)/i,/^(?:[^\n\{]*)/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:[^\n\s\{]+)/i,/^(?:\n)/i,/^(?:\{)/i,/^(?:\})/i,/^(?:[\n])/i,/^(?:note\s+)/i,/^(?:left of\b)/i,/^(?:right of\b)/i,/^(?:")/i,/^(?:\s*as\s*)/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:[^\n]*)/i,/^(?:\s*[^:\n\s\-]+)/i,/^(?:\s*:[^:\n;]+)/i,/^(?:\s*[^:;]+end note\b)/i,/^(?:stateDiagram\s+)/i,/^(?:hide empty description\b)/i,/^(?:\[\*\])/i,/^(?:[^:\n\s\-\{]+)/i,/^(?:\s*:[^:\n;]+)/i,/^(?:-->)/i,/^(?:--)/i,/^(?:$)/i,/^(?:.)/i],conditions:{LINE:{rules:[2,3],inclusive:!1},struct:{rules:[2,3,8,21,22,23,36,37,38,39,40],inclusive:!1},FLOATING_NOTE_ID:{rules:[30],inclusive:!1},FLOATING_NOTE:{rules:[27,28,29],inclusive:!1},NOTE_TEXT:{rules:[32,33],inclusive:!1},NOTE_ID:{rules:[31],inclusive:!1},NOTE:{rules:[24,25,26],inclusive:!1},SCALE:{rules:[6,7],inclusive:!1},ALIAS:{rules:[],inclusive:!1},STATE_ID:{rules:[15],inclusive:!1},STATE_STRING:{rules:[16,17],inclusive:!1},FORK_STATE:{rules:[],inclusive:!1},STATE:{rules:[2,3,9,10,11,12,13,14,18,19,20],inclusive:!1},ID:{rules:[2,3],inclusive:!1},INITIAL:{rules:[0,1,3,4,5,8,20,23,34,35,36,37,38,39,41,42],inclusive:!0}}};function x(){this.yy={}}return _.lexer=w,x.prototype=_,_.Parser=x,new x}();e.parser=i,e.Parser=i.Parser,e.parse=function(){return i.parse.apply(i,arguments)},e.main=function(r){r[1]||(console.log("Usage: "+r[0]+" FILE"),t.exit(1));var i=n(28).readFileSync(n(29).normalize(r[1]),"utf8");return e.parser.parse(i)},n.c[n.s]===r&&e.main(t.argv.slice(1))}).call(this,n(7),n(9)(t))},function(t,e,n){(function(t,n){(function(){var r,i=200,o="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",a="Expected a function",s="__lodash_hash_undefined__",u=500,c="__lodash_placeholder__",f=1,l=2,h=4,d=1,p=2,g=1,y=2,b=4,m=8,v=16,_=32,w=64,x=128,k=256,E=512,A=30,S="...",T=800,M=16,D=1,C=2,O=1/0,R=9007199254740991,I=17976931348623157e292,N=NaN,B=4294967295,L=B-1,P=B>>>1,F=[["ary",x],["bind",g],["bindKey",y],["curry",m],["curryRight",v],["flip",E],["partial",_],["partialRight",w],["rearg",k]],q="[object Arguments]",j="[object Array]",U="[object AsyncFunction]",z="[object Boolean]",Y="[object Date]",V="[object DOMException]",H="[object Error]",$="[object Function]",G="[object GeneratorFunction]",W="[object Map]",K="[object Number]",X="[object Null]",Z="[object Object]",J="[object Proxy]",Q="[object RegExp]",tt="[object Set]",et="[object String]",nt="[object Symbol]",rt="[object Undefined]",it="[object WeakMap]",ot="[object WeakSet]",at="[object ArrayBuffer]",st="[object DataView]",ut="[object Float32Array]",ct="[object Float64Array]",ft="[object Int8Array]",lt="[object Int16Array]",ht="[object Int32Array]",dt="[object Uint8Array]",pt="[object Uint8ClampedArray]",gt="[object Uint16Array]",yt="[object Uint32Array]",bt=/\b__p \+= '';/g,mt=/\b(__p \+=) '' \+/g,vt=/(__e\(.*?\)|\b__t\)) \+\n'';/g,_t=/&(?:amp|lt|gt|quot|#39);/g,wt=/[&<>"']/g,xt=RegExp(_t.source),kt=RegExp(wt.source),Et=/<%-([\s\S]+?)%>/g,At=/<%([\s\S]+?)%>/g,St=/<%=([\s\S]+?)%>/g,Tt=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Mt=/^\w*$/,Dt=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Ct=/[\\^$.*+?()[\]{}|]/g,Ot=RegExp(Ct.source),Rt=/^\s+|\s+$/g,It=/^\s+/,Nt=/\s+$/,Bt=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Lt=/\{\n\/\* \[wrapped with (.+)\] \*/,Pt=/,? & /,Ft=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,qt=/\\(\\)?/g,jt=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Ut=/\w*$/,zt=/^[-+]0x[0-9a-f]+$/i,Yt=/^0b[01]+$/i,Vt=/^\[object .+?Constructor\]$/,Ht=/^0o[0-7]+$/i,$t=/^(?:0|[1-9]\d*)$/,Gt=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Wt=/($^)/,Kt=/['\n\r\u2028\u2029\\]/g,Xt="\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",Zt="\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",Jt="[\\ud800-\\udfff]",Qt="["+Zt+"]",te="["+Xt+"]",ee="\\d+",ne="[\\u2700-\\u27bf]",re="[a-z\\xdf-\\xf6\\xf8-\\xff]",ie="[^\\ud800-\\udfff"+Zt+ee+"\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]",oe="\\ud83c[\\udffb-\\udfff]",ae="[^\\ud800-\\udfff]",se="(?:\\ud83c[\\udde6-\\uddff]){2}",ue="[\\ud800-\\udbff][\\udc00-\\udfff]",ce="[A-Z\\xc0-\\xd6\\xd8-\\xde]",fe="(?:"+re+"|"+ie+")",le="(?:"+ce+"|"+ie+")",he="(?:"+te+"|"+oe+")"+"?",de="[\\ufe0e\\ufe0f]?"+he+("(?:\\u200d(?:"+[ae,se,ue].join("|")+")[\\ufe0e\\ufe0f]?"+he+")*"),pe="(?:"+[ne,se,ue].join("|")+")"+de,ge="(?:"+[ae+te+"?",te,se,ue,Jt].join("|")+")",ye=RegExp("[']","g"),be=RegExp(te,"g"),me=RegExp(oe+"(?="+oe+")|"+ge+de,"g"),ve=RegExp([ce+"?"+re+"+(?:['](?:d|ll|m|re|s|t|ve))?(?="+[Qt,ce,"$"].join("|")+")",le+"+(?:['](?:D|LL|M|RE|S|T|VE))?(?="+[Qt,ce+fe,"$"].join("|")+")",ce+"?"+fe+"+(?:['](?:d|ll|m|re|s|t|ve))?",ce+"+(?:['](?:D|LL|M|RE|S|T|VE))?","\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])","\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",ee,pe].join("|"),"g"),_e=RegExp("[\\u200d\\ud800-\\udfff"+Xt+"\\ufe0e\\ufe0f]"),we=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,xe=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],ke=-1,Ee={};Ee[ut]=Ee[ct]=Ee[ft]=Ee[lt]=Ee[ht]=Ee[dt]=Ee[pt]=Ee[gt]=Ee[yt]=!0,Ee[q]=Ee[j]=Ee[at]=Ee[z]=Ee[st]=Ee[Y]=Ee[H]=Ee[$]=Ee[W]=Ee[K]=Ee[Z]=Ee[Q]=Ee[tt]=Ee[et]=Ee[it]=!1;var Ae={};Ae[q]=Ae[j]=Ae[at]=Ae[st]=Ae[z]=Ae[Y]=Ae[ut]=Ae[ct]=Ae[ft]=Ae[lt]=Ae[ht]=Ae[W]=Ae[K]=Ae[Z]=Ae[Q]=Ae[tt]=Ae[et]=Ae[nt]=Ae[dt]=Ae[pt]=Ae[gt]=Ae[yt]=!0,Ae[H]=Ae[$]=Ae[it]=!1;var Se={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Te=parseFloat,Me=parseInt,De="object"==typeof t&&t&&t.Object===Object&&t,Ce="object"==typeof self&&self&&self.Object===Object&&self,Oe=De||Ce||Function("return this")(),Re=e&&!e.nodeType&&e,Ie=Re&&"object"==typeof n&&n&&!n.nodeType&&n,Ne=Ie&&Ie.exports===Re,Be=Ne&&De.process,Le=function(){try{var t=Ie&&Ie.require&&Ie.require("util").types;return t||Be&&Be.binding&&Be.binding("util")}catch(t){}}(),Pe=Le&&Le.isArrayBuffer,Fe=Le&&Le.isDate,qe=Le&&Le.isMap,je=Le&&Le.isRegExp,Ue=Le&&Le.isSet,ze=Le&&Le.isTypedArray;function Ye(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)}function Ve(t,e,n,r){for(var i=-1,o=null==t?0:t.length;++i<o;){var a=t[i];e(r,a,n(a),t)}return r}function He(t,e){for(var n=-1,r=null==t?0:t.length;++n<r&&!1!==e(t[n],n,t););return t}function $e(t,e){for(var n=null==t?0:t.length;n--&&!1!==e(t[n],n,t););return t}function Ge(t,e){for(var n=-1,r=null==t?0:t.length;++n<r;)if(!e(t[n],n,t))return!1;return!0}function We(t,e){for(var n=-1,r=null==t?0:t.length,i=0,o=[];++n<r;){var a=t[n];e(a,n,t)&&(o[i++]=a)}return o}function Ke(t,e){return!!(null==t?0:t.length)&&an(t,e,0)>-1}function Xe(t,e,n){for(var r=-1,i=null==t?0:t.length;++r<i;)if(n(e,t[r]))return!0;return!1}function Ze(t,e){for(var n=-1,r=null==t?0:t.length,i=Array(r);++n<r;)i[n]=e(t[n],n,t);return i}function Je(t,e){for(var n=-1,r=e.length,i=t.length;++n<r;)t[i+n]=e[n];return t}function Qe(t,e,n,r){var i=-1,o=null==t?0:t.length;for(r&&o&&(n=t[++i]);++i<o;)n=e(n,t[i],i,t);return n}function tn(t,e,n,r){var i=null==t?0:t.length;for(r&&i&&(n=t[--i]);i--;)n=e(n,t[i],i,t);return n}function en(t,e){for(var n=-1,r=null==t?0:t.length;++n<r;)if(e(t[n],n,t))return!0;return!1}var nn=fn("length");function rn(t,e,n){var r;return n(t,(function(t,n,i){if(e(t,n,i))return r=n,!1})),r}function on(t,e,n,r){for(var i=t.length,o=n+(r?1:-1);r?o--:++o<i;)if(e(t[o],o,t))return o;return-1}function an(t,e,n){return e==e?function(t,e,n){var r=n-1,i=t.length;for(;++r<i;)if(t[r]===e)return r;return-1}(t,e,n):on(t,un,n)}function sn(t,e,n,r){for(var i=n-1,o=t.length;++i<o;)if(r(t[i],e))return i;return-1}function un(t){return t!=t}function cn(t,e){var n=null==t?0:t.length;return n?dn(t,e)/n:N}function fn(t){return function(e){return null==e?r:e[t]}}function ln(t){return function(e){return null==t?r:t[e]}}function hn(t,e,n,r,i){return i(t,(function(t,i,o){n=r?(r=!1,t):e(n,t,i,o)})),n}function dn(t,e){for(var n,i=-1,o=t.length;++i<o;){var a=e(t[i]);a!==r&&(n=n===r?a:n+a)}return n}function pn(t,e){for(var n=-1,r=Array(t);++n<t;)r[n]=e(n);return r}function gn(t){return function(e){return t(e)}}function yn(t,e){return Ze(e,(function(e){return t[e]}))}function bn(t,e){return t.has(e)}function mn(t,e){for(var n=-1,r=t.length;++n<r&&an(e,t[n],0)>-1;);return n}function vn(t,e){for(var n=t.length;n--&&an(e,t[n],0)>-1;);return n}var _n=ln({"":"A","":"A","":"A","":"A","":"A","":"A","":"a","":"a","":"a","":"a","":"a","":"a","":"C","":"c","":"D","":"d","":"E","":"E","":"E","":"E","":"e","":"e","":"e","":"e","":"I","":"I","":"I","":"I","":"i","":"i","":"i","":"i","":"N","":"n","":"O","":"O","":"O","":"O","":"O","":"O","":"o","":"o","":"o","":"o","":"o","":"o","":"U","":"U","":"U","":"U","":"u","":"u","":"u","":"u","":"Y","":"y","":"y","":"Ae","":"ae","":"Th","":"th","":"ss","":"A","":"A","":"A","":"a","":"a","":"a","":"C","":"C","":"C","":"C","":"c","":"c","":"c","":"c","":"D","":"D","":"d","":"d","":"E","":"E","":"E","":"E","":"E","":"e","":"e","":"e","":"e","":"e","":"G","":"G","":"G","":"G","":"g","":"g","":"g","":"g","":"H","":"H","":"h","":"h","":"I","":"I","":"I","":"I","":"I","":"i","":"i","":"i","":"i","":"i","":"J","":"j","":"K","":"k","":"k","":"L","":"L","":"L","":"L","":"L","":"l","":"l","":"l","":"l","":"l","":"N","":"N","":"N","":"N","":"n","":"n","":"n","":"n","":"O","":"O","":"O","":"o","":"o","":"o","":"R","":"R","":"R","":"r","":"r","":"r","":"S","":"S","":"S","":"S","":"s","":"s","":"s","":"s","":"T","":"T","":"T","":"t","":"t","":"t","":"U","":"U","":"U","":"U","":"U","":"U","":"u","":"u","":"u","":"u","":"u","":"u","":"W","":"w","":"Y","":"y","":"Y","":"Z","":"Z","":"Z","":"z","":"z","":"z","":"IJ","":"ij","":"Oe","":"oe","":"'n","":"s"}),wn=ln({"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"});function xn(t){return"\\"+Se[t]}function kn(t){return _e.test(t)}function En(t){var e=-1,n=Array(t.size);return t.forEach((function(t,r){n[++e]=[r,t]})),n}function An(t,e){return function(n){return t(e(n))}}function Sn(t,e){for(var n=-1,r=t.length,i=0,o=[];++n<r;){var a=t[n];a!==e&&a!==c||(t[n]=c,o[i++]=n)}return o}function Tn(t){var e=-1,n=Array(t.size);return t.forEach((function(t){n[++e]=t})),n}function Mn(t){var e=-1,n=Array(t.size);return t.forEach((function(t){n[++e]=[t,t]})),n}function Dn(t){return kn(t)?function(t){var e=me.lastIndex=0;for(;me.test(t);)++e;return e}(t):nn(t)}function Cn(t){return kn(t)?function(t){return t.match(me)||[]}(t):function(t){return t.split("")}(t)}var On=ln({"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"});var Rn=function t(e){var n,Xt=(e=null==e?Oe:Rn.defaults(Oe.Object(),e,Rn.pick(Oe,xe))).Array,Zt=e.Date,Jt=e.Error,Qt=e.Function,te=e.Math,ee=e.Object,ne=e.RegExp,re=e.String,ie=e.TypeError,oe=Xt.prototype,ae=Qt.prototype,se=ee.prototype,ue=e["__core-js_shared__"],ce=ae.toString,fe=se.hasOwnProperty,le=0,he=(n=/[^.]+$/.exec(ue&&ue.keys&&ue.keys.IE_PROTO||""))?"Symbol(src)_1."+n:"",de=se.toString,pe=ce.call(ee),ge=Oe._,me=ne("^"+ce.call(fe).replace(Ct,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),_e=Ne?e.Buffer:r,Se=e.Symbol,De=e.Uint8Array,Ce=_e?_e.allocUnsafe:r,Re=An(ee.getPrototypeOf,ee),Ie=ee.create,Be=se.propertyIsEnumerable,Le=oe.splice,nn=Se?Se.isConcatSpreadable:r,ln=Se?Se.iterator:r,In=Se?Se.toStringTag:r,Nn=function(){try{var t=qo(ee,"defineProperty");return t({},"",{}),t}catch(t){}}(),Bn=e.clearTimeout!==Oe.clearTimeout&&e.clearTimeout,Ln=Zt&&Zt.now!==Oe.Date.now&&Zt.now,Pn=e.setTimeout!==Oe.setTimeout&&e.setTimeout,Fn=te.ceil,qn=te.floor,jn=ee.getOwnPropertySymbols,Un=_e?_e.isBuffer:r,zn=e.isFinite,Yn=oe.join,Vn=An(ee.keys,ee),Hn=te.max,$n=te.min,Gn=Zt.now,Wn=e.parseInt,Kn=te.random,Xn=oe.reverse,Zn=qo(e,"DataView"),Jn=qo(e,"Map"),Qn=qo(e,"Promise"),tr=qo(e,"Set"),er=qo(e,"WeakMap"),nr=qo(ee,"create"),rr=er&&new er,ir={},or=la(Zn),ar=la(Jn),sr=la(Qn),ur=la(tr),cr=la(er),fr=Se?Se.prototype:r,lr=fr?fr.valueOf:r,hr=fr?fr.toString:r;function dr(t){if(Ms(t)&&!bs(t)&&!(t instanceof br)){if(t instanceof yr)return t;if(fe.call(t,"__wrapped__"))return ha(t)}return new yr(t)}var pr=function(){function t(){}return function(e){if(!Ts(e))return{};if(Ie)return Ie(e);t.prototype=e;var n=new t;return t.prototype=r,n}}();function gr(){}function yr(t,e){this.__wrapped__=t,this.__actions__=[],this.__chain__=!!e,this.__index__=0,this.__values__=r}function br(t){this.__wrapped__=t,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=B,this.__views__=[]}function mr(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function vr(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function _r(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}function wr(t){var e=-1,n=null==t?0:t.length;for(this.__data__=new _r;++e<n;)this.add(t[e])}function xr(t){var e=this.__data__=new vr(t);this.size=e.size}function kr(t,e){var n=bs(t),r=!n&&ys(t),i=!n&&!r&&ws(t),o=!n&&!r&&!i&&Ls(t),a=n||r||i||o,s=a?pn(t.length,re):[],u=s.length;for(var c in t)!e&&!fe.call(t,c)||a&&("length"==c||i&&("offset"==c||"parent"==c)||o&&("buffer"==c||"byteLength"==c||"byteOffset"==c)||$o(c,u))||s.push(c);return s}function Er(t){var e=t.length;return e?t[wi(0,e-1)]:r}function Ar(t,e){return ua(no(t),Nr(e,0,t.length))}function Sr(t){return ua(no(t))}function Tr(t,e,n){(n===r||ds(t[e],n))&&(n!==r||e in t)||Rr(t,e,n)}function Mr(t,e,n){var i=t[e];fe.call(t,e)&&ds(i,n)&&(n!==r||e in t)||Rr(t,e,n)}function Dr(t,e){for(var n=t.length;n--;)if(ds(t[n][0],e))return n;return-1}function Cr(t,e,n,r){return qr(t,(function(t,i,o){e(r,t,n(t),o)})),r}function Or(t,e){return t&&ro(e,iu(e),t)}function Rr(t,e,n){"__proto__"==e&&Nn?Nn(t,e,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[e]=n}function Ir(t,e){for(var n=-1,i=e.length,o=Xt(i),a=null==t;++n<i;)o[n]=a?r:Qs(t,e[n]);return o}function Nr(t,e,n){return t==t&&(n!==r&&(t=t<=n?t:n),e!==r&&(t=t>=e?t:e)),t}function Br(t,e,n,i,o,a){var s,u=e&f,c=e&l,d=e&h;if(n&&(s=o?n(t,i,o,a):n(t)),s!==r)return s;if(!Ts(t))return t;var p=bs(t);if(p){if(s=function(t){var e=t.length,n=new t.constructor(e);e&&"string"==typeof t[0]&&fe.call(t,"index")&&(n.index=t.index,n.input=t.input);return n}(t),!u)return no(t,s)}else{var g=zo(t),y=g==$||g==G;if(ws(t))return Xi(t,u);if(g==Z||g==q||y&&!o){if(s=c||y?{}:Vo(t),!u)return c?function(t,e){return ro(t,Uo(t),e)}(t,function(t,e){return t&&ro(e,ou(e),t)}(s,t)):function(t,e){return ro(t,jo(t),e)}(t,Or(s,t))}else{if(!Ae[g])return o?t:{};s=function(t,e,n){var r=t.constructor;switch(e){case at:return Zi(t);case z:case Y:return new r(+t);case st:return function(t,e){var n=e?Zi(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.byteLength)}(t,n);case ut:case ct:case ft:case lt:case ht:case dt:case pt:case gt:case yt:return Ji(t,n);case W:return new r;case K:case et:return new r(t);case Q:return function(t){var e=new t.constructor(t.source,Ut.exec(t));return e.lastIndex=t.lastIndex,e}(t);case tt:return new r;case nt:return i=t,lr?ee(lr.call(i)):{}}var i}(t,g,u)}}a||(a=new xr);var b=a.get(t);if(b)return b;a.set(t,s),Is(t)?t.forEach((function(r){s.add(Br(r,e,n,r,t,a))})):Ds(t)&&t.forEach((function(r,i){s.set(i,Br(r,e,n,i,t,a))}));var m=p?r:(d?c?Ro:Oo:c?ou:iu)(t);return He(m||t,(function(r,i){m&&(r=t[i=r]),Mr(s,i,Br(r,e,n,i,t,a))})),s}function Lr(t,e,n){var i=n.length;if(null==t)return!i;for(t=ee(t);i--;){var o=n[i],a=e[o],s=t[o];if(s===r&&!(o in t)||!a(s))return!1}return!0}function Pr(t,e,n){if("function"!=typeof t)throw new ie(a);return ia((function(){t.apply(r,n)}),e)}function Fr(t,e,n,r){var o=-1,a=Ke,s=!0,u=t.length,c=[],f=e.length;if(!u)return c;n&&(e=Ze(e,gn(n))),r?(a=Xe,s=!1):e.length>=i&&(a=bn,s=!1,e=new wr(e));t:for(;++o<u;){var l=t[o],h=null==n?l:n(l);if(l=r||0!==l?l:0,s&&h==h){for(var d=f;d--;)if(e[d]===h)continue t;c.push(l)}else a(e,h,r)||c.push(l)}return c}dr.templateSettings={escape:Et,evaluate:At,interpolate:St,variable:"",imports:{_:dr}},dr.prototype=gr.prototype,dr.prototype.constructor=dr,yr.prototype=pr(gr.prototype),yr.prototype.constructor=yr,br.prototype=pr(gr.prototype),br.prototype.constructor=br,mr.prototype.clear=function(){this.__data__=nr?nr(null):{},this.size=0},mr.prototype.delete=function(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e},mr.prototype.get=function(t){var e=this.__data__;if(nr){var n=e[t];return n===s?r:n}return fe.call(e,t)?e[t]:r},mr.prototype.has=function(t){var e=this.__data__;return nr?e[t]!==r:fe.call(e,t)},mr.prototype.set=function(t,e){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=nr&&e===r?s:e,this},vr.prototype.clear=function(){this.__data__=[],this.size=0},vr.prototype.delete=function(t){var e=this.__data__,n=Dr(e,t);return!(n<0)&&(n==e.length-1?e.pop():Le.call(e,n,1),--this.size,!0)},vr.prototype.get=function(t){var e=this.__data__,n=Dr(e,t);return n<0?r:e[n][1]},vr.prototype.has=function(t){return Dr(this.__data__,t)>-1},vr.prototype.set=function(t,e){var n=this.__data__,r=Dr(n,t);return r<0?(++this.size,n.push([t,e])):n[r][1]=e,this},_r.prototype.clear=function(){this.size=0,this.__data__={hash:new mr,map:new(Jn||vr),string:new mr}},_r.prototype.delete=function(t){var e=Po(this,t).delete(t);return this.size-=e?1:0,e},_r.prototype.get=function(t){return Po(this,t).get(t)},_r.prototype.has=function(t){return Po(this,t).has(t)},_r.prototype.set=function(t,e){var n=Po(this,t),r=n.size;return n.set(t,e),this.size+=n.size==r?0:1,this},wr.prototype.add=wr.prototype.push=function(t){return this.__data__.set(t,s),this},wr.prototype.has=function(t){return this.__data__.has(t)},xr.prototype.clear=function(){this.__data__=new vr,this.size=0},xr.prototype.delete=function(t){var e=this.__data__,n=e.delete(t);return this.size=e.size,n},xr.prototype.get=function(t){return this.__data__.get(t)},xr.prototype.has=function(t){return this.__data__.has(t)},xr.prototype.set=function(t,e){var n=this.__data__;if(n instanceof vr){var r=n.__data__;if(!Jn||r.length<i-1)return r.push([t,e]),this.size=++n.size,this;n=this.__data__=new _r(r)}return n.set(t,e),this.size=n.size,this};var qr=ao(Gr),jr=ao(Wr,!0);function Ur(t,e){var n=!0;return qr(t,(function(t,r,i){return n=!!e(t,r,i)})),n}function zr(t,e,n){for(var i=-1,o=t.length;++i<o;){var a=t[i],s=e(a);if(null!=s&&(u===r?s==s&&!Bs(s):n(s,u)))var u=s,c=a}return c}function Yr(t,e){var n=[];return qr(t,(function(t,r,i){e(t,r,i)&&n.push(t)})),n}function Vr(t,e,n,r,i){var o=-1,a=t.length;for(n||(n=Ho),i||(i=[]);++o<a;){var s=t[o];e>0&&n(s)?e>1?Vr(s,e-1,n,r,i):Je(i,s):r||(i[i.length]=s)}return i}var Hr=so(),$r=so(!0);function Gr(t,e){return t&&Hr(t,e,iu)}function Wr(t,e){return t&&$r(t,e,iu)}function Kr(t,e){return We(e,(function(e){return Es(t[e])}))}function Xr(t,e){for(var n=0,i=(e=$i(e,t)).length;null!=t&&n<i;)t=t[fa(e[n++])];return n&&n==i?t:r}function Zr(t,e,n){var r=e(t);return bs(t)?r:Je(r,n(t))}function Jr(t){return null==t?t===r?rt:X:In&&In in ee(t)?function(t){var e=fe.call(t,In),n=t[In];try{t[In]=r;var i=!0}catch(t){}var o=de.call(t);i&&(e?t[In]=n:delete t[In]);return o}(t):function(t){return de.call(t)}(t)}function Qr(t,e){return t>e}function ti(t,e){return null!=t&&fe.call(t,e)}function ei(t,e){return null!=t&&e in ee(t)}function ni(t,e,n){for(var i=n?Xe:Ke,o=t[0].length,a=t.length,s=a,u=Xt(a),c=1/0,f=[];s--;){var l=t[s];s&&e&&(l=Ze(l,gn(e))),c=$n(l.length,c),u[s]=!n&&(e||o>=120&&l.length>=120)?new wr(s&&l):r}l=t[0];var h=-1,d=u[0];t:for(;++h<o&&f.length<c;){var p=l[h],g=e?e(p):p;if(p=n||0!==p?p:0,!(d?bn(d,g):i(f,g,n))){for(s=a;--s;){var y=u[s];if(!(y?bn(y,g):i(t[s],g,n)))continue t}d&&d.push(g),f.push(p)}}return f}function ri(t,e,n){var i=null==(t=ea(t,e=$i(e,t)))?t:t[fa(ka(e))];return null==i?r:Ye(i,t,n)}function ii(t){return Ms(t)&&Jr(t)==q}function oi(t,e,n,i,o){return t===e||(null==t||null==e||!Ms(t)&&!Ms(e)?t!=t&&e!=e:function(t,e,n,i,o,a){var s=bs(t),u=bs(e),c=s?j:zo(t),f=u?j:zo(e),l=(c=c==q?Z:c)==Z,h=(f=f==q?Z:f)==Z,g=c==f;if(g&&ws(t)){if(!ws(e))return!1;s=!0,l=!1}if(g&&!l)return a||(a=new xr),s||Ls(t)?Do(t,e,n,i,o,a):function(t,e,n,r,i,o,a){switch(n){case st:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case at:return!(t.byteLength!=e.byteLength||!o(new De(t),new De(e)));case z:case Y:case K:return ds(+t,+e);case H:return t.name==e.name&&t.message==e.message;case Q:case et:return t==e+"";case W:var s=En;case tt:var u=r&d;if(s||(s=Tn),t.size!=e.size&&!u)return!1;var c=a.get(t);if(c)return c==e;r|=p,a.set(t,e);var f=Do(s(t),s(e),r,i,o,a);return a.delete(t),f;case nt:if(lr)return lr.call(t)==lr.call(e)}return!1}(t,e,c,n,i,o,a);if(!(n&d)){var y=l&&fe.call(t,"__wrapped__"),b=h&&fe.call(e,"__wrapped__");if(y||b){var m=y?t.value():t,v=b?e.value():e;return a||(a=new xr),o(m,v,n,i,a)}}if(!g)return!1;return a||(a=new xr),function(t,e,n,i,o,a){var s=n&d,u=Oo(t),c=u.length,f=Oo(e).length;if(c!=f&&!s)return!1;var l=c;for(;l--;){var h=u[l];if(!(s?h in e:fe.call(e,h)))return!1}var p=a.get(t);if(p&&a.get(e))return p==e;var g=!0;a.set(t,e),a.set(e,t);var y=s;for(;++l<c;){h=u[l];var b=t[h],m=e[h];if(i)var v=s?i(m,b,h,e,t,a):i(b,m,h,t,e,a);if(!(v===r?b===m||o(b,m,n,i,a):v)){g=!1;break}y||(y="constructor"==h)}if(g&&!y){var _=t.constructor,w=e.constructor;_!=w&&"constructor"in t&&"constructor"in e&&!("function"==typeof _&&_ instanceof _&&"function"==typeof w&&w instanceof w)&&(g=!1)}return a.delete(t),a.delete(e),g}(t,e,n,i,o,a)}(t,e,n,i,oi,o))}function ai(t,e,n,i){var o=n.length,a=o,s=!i;if(null==t)return!a;for(t=ee(t);o--;){var u=n[o];if(s&&u[2]?u[1]!==t[u[0]]:!(u[0]in t))return!1}for(;++o<a;){var c=(u=n[o])[0],f=t[c],l=u[1];if(s&&u[2]){if(f===r&&!(c in t))return!1}else{var h=new xr;if(i)var g=i(f,l,c,t,e,h);if(!(g===r?oi(l,f,d|p,i,h):g))return!1}}return!0}function si(t){return!(!Ts(t)||(e=t,he&&he in e))&&(Es(t)?me:Vt).test(la(t));var e}function ui(t){return"function"==typeof t?t:null==t?Cu:"object"==typeof t?bs(t)?pi(t[0],t[1]):di(t):qu(t)}function ci(t){if(!Zo(t))return Vn(t);var e=[];for(var n in ee(t))fe.call(t,n)&&"constructor"!=n&&e.push(n);return e}function fi(t){if(!Ts(t))return function(t){var e=[];if(null!=t)for(var n in ee(t))e.push(n);return e}(t);var e=Zo(t),n=[];for(var r in t)("constructor"!=r||!e&&fe.call(t,r))&&n.push(r);return n}function li(t,e){return t<e}function hi(t,e){var n=-1,r=vs(t)?Xt(t.length):[];return qr(t,(function(t,i,o){r[++n]=e(t,i,o)})),r}function di(t){var e=Fo(t);return 1==e.length&&e[0][2]?Qo(e[0][0],e[0][1]):function(n){return n===t||ai(n,t,e)}}function pi(t,e){return Wo(t)&&Jo(e)?Qo(fa(t),e):function(n){var i=Qs(n,t);return i===r&&i===e?tu(n,t):oi(e,i,d|p)}}function gi(t,e,n,i,o){t!==e&&Hr(e,(function(a,s){if(o||(o=new xr),Ts(a))!function(t,e,n,i,o,a,s){var u=na(t,n),c=na(e,n),f=s.get(c);if(f)return void Tr(t,n,f);var l=a?a(u,c,n+"",t,e,s):r,h=l===r;if(h){var d=bs(c),p=!d&&ws(c),g=!d&&!p&&Ls(c);l=c,d||p||g?bs(u)?l=u:_s(u)?l=no(u):p?(h=!1,l=Xi(c,!0)):g?(h=!1,l=Ji(c,!0)):l=[]:Os(c)||ys(c)?(l=u,ys(u)?l=Vs(u):Ts(u)&&!Es(u)||(l=Vo(c))):h=!1}h&&(s.set(c,l),o(l,c,i,a,s),s.delete(c));Tr(t,n,l)}(t,e,s,n,gi,i,o);else{var u=i?i(na(t,s),a,s+"",t,e,o):r;u===r&&(u=a),Tr(t,s,u)}}),ou)}function yi(t,e){var n=t.length;if(n)return $o(e+=e<0?n:0,n)?t[e]:r}function bi(t,e,n){var r=-1;return e=Ze(e.length?e:[Cu],gn(Lo())),function(t,e){var n=t.length;for(t.sort(e);n--;)t[n]=t[n].value;return t}(hi(t,(function(t,n,i){return{criteria:Ze(e,(function(e){return e(t)})),index:++r,value:t}})),(function(t,e){return function(t,e,n){var r=-1,i=t.criteria,o=e.criteria,a=i.length,s=n.length;for(;++r<a;){var u=Qi(i[r],o[r]);if(u){if(r>=s)return u;var c=n[r];return u*("desc"==c?-1:1)}}return t.index-e.index}(t,e,n)}))}function mi(t,e,n){for(var r=-1,i=e.length,o={};++r<i;){var a=e[r],s=Xr(t,a);n(s,a)&&Si(o,$i(a,t),s)}return o}function vi(t,e,n,r){var i=r?sn:an,o=-1,a=e.length,s=t;for(t===e&&(e=no(e)),n&&(s=Ze(t,gn(n)));++o<a;)for(var u=0,c=e[o],f=n?n(c):c;(u=i(s,f,u,r))>-1;)s!==t&&Le.call(s,u,1),Le.call(t,u,1);return t}function _i(t,e){for(var n=t?e.length:0,r=n-1;n--;){var i=e[n];if(n==r||i!==o){var o=i;$o(i)?Le.call(t,i,1):Fi(t,i)}}return t}function wi(t,e){return t+qn(Kn()*(e-t+1))}function xi(t,e){var n="";if(!t||e<1||e>R)return n;do{e%2&&(n+=t),(e=qn(e/2))&&(t+=t)}while(e);return n}function ki(t,e){return oa(ta(t,e,Cu),t+"")}function Ei(t){return Er(du(t))}function Ai(t,e){var n=du(t);return ua(n,Nr(e,0,n.length))}function Si(t,e,n,i){if(!Ts(t))return t;for(var o=-1,a=(e=$i(e,t)).length,s=a-1,u=t;null!=u&&++o<a;){var c=fa(e[o]),f=n;if(o!=s){var l=u[c];(f=i?i(l,c,u):r)===r&&(f=Ts(l)?l:$o(e[o+1])?[]:{})}Mr(u,c,f),u=u[c]}return t}var Ti=rr?function(t,e){return rr.set(t,e),t}:Cu,Mi=Nn?function(t,e){return Nn(t,"toString",{configurable:!0,enumerable:!1,value:Tu(e),writable:!0})}:Cu;function Di(t){return ua(du(t))}function Ci(t,e,n){var r=-1,i=t.length;e<0&&(e=-e>i?0:i+e),(n=n>i?i:n)<0&&(n+=i),i=e>n?0:n-e>>>0,e>>>=0;for(var o=Xt(i);++r<i;)o[r]=t[r+e];return o}function Oi(t,e){var n;return qr(t,(function(t,r,i){return!(n=e(t,r,i))})),!!n}function Ri(t,e,n){var r=0,i=null==t?r:t.length;if("number"==typeof e&&e==e&&i<=P){for(;r<i;){var o=r+i>>>1,a=t[o];null!==a&&!Bs(a)&&(n?a<=e:a<e)?r=o+1:i=o}return i}return Ii(t,e,Cu,n)}function Ii(t,e,n,i){e=n(e);for(var o=0,a=null==t?0:t.length,s=e!=e,u=null===e,c=Bs(e),f=e===r;o<a;){var l=qn((o+a)/2),h=n(t[l]),d=h!==r,p=null===h,g=h==h,y=Bs(h);if(s)var b=i||g;else b=f?g&&(i||d):u?g&&d&&(i||!p):c?g&&d&&!p&&(i||!y):!p&&!y&&(i?h<=e:h<e);b?o=l+1:a=l}return $n(a,L)}function Ni(t,e){for(var n=-1,r=t.length,i=0,o=[];++n<r;){var a=t[n],s=e?e(a):a;if(!n||!ds(s,u)){var u=s;o[i++]=0===a?0:a}}return o}function Bi(t){return"number"==typeof t?t:Bs(t)?N:+t}function Li(t){if("string"==typeof t)return t;if(bs(t))return Ze(t,Li)+"";if(Bs(t))return hr?hr.call(t):"";var e=t+"";return"0"==e&&1/t==-O?"-0":e}function Pi(t,e,n){var r=-1,o=Ke,a=t.length,s=!0,u=[],c=u;if(n)s=!1,o=Xe;else if(a>=i){var f=e?null:ko(t);if(f)return Tn(f);s=!1,o=bn,c=new wr}else c=e?[]:u;t:for(;++r<a;){var l=t[r],h=e?e(l):l;if(l=n||0!==l?l:0,s&&h==h){for(var d=c.length;d--;)if(c[d]===h)continue t;e&&c.push(h),u.push(l)}else o(c,h,n)||(c!==u&&c.push(h),u.push(l))}return u}function Fi(t,e){return null==(t=ea(t,e=$i(e,t)))||delete t[fa(ka(e))]}function qi(t,e,n,r){return Si(t,e,n(Xr(t,e)),r)}function ji(t,e,n,r){for(var i=t.length,o=r?i:-1;(r?o--:++o<i)&&e(t[o],o,t););return n?Ci(t,r?0:o,r?o+1:i):Ci(t,r?o+1:0,r?i:o)}function Ui(t,e){var n=t;return n instanceof br&&(n=n.value()),Qe(e,(function(t,e){return e.func.apply(e.thisArg,Je([t],e.args))}),n)}function zi(t,e,n){var r=t.length;if(r<2)return r?Pi(t[0]):[];for(var i=-1,o=Xt(r);++i<r;)for(var a=t[i],s=-1;++s<r;)s!=i&&(o[i]=Fr(o[i]||a,t[s],e,n));return Pi(Vr(o,1),e,n)}function Yi(t,e,n){for(var i=-1,o=t.length,a=e.length,s={};++i<o;){var u=i<a?e[i]:r;n(s,t[i],u)}return s}function Vi(t){return _s(t)?t:[]}function Hi(t){return"function"==typeof t?t:Cu}function $i(t,e){return bs(t)?t:Wo(t,e)?[t]:ca(Hs(t))}var Gi=ki;function Wi(t,e,n){var i=t.length;return n=n===r?i:n,!e&&n>=i?t:Ci(t,e,n)}var Ki=Bn||function(t){return Oe.clearTimeout(t)};function Xi(t,e){if(e)return t.slice();var n=t.length,r=Ce?Ce(n):new t.constructor(n);return t.copy(r),r}function Zi(t){var e=new t.constructor(t.byteLength);return new De(e).set(new De(t)),e}function Ji(t,e){var n=e?Zi(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.length)}function Qi(t,e){if(t!==e){var n=t!==r,i=null===t,o=t==t,a=Bs(t),s=e!==r,u=null===e,c=e==e,f=Bs(e);if(!u&&!f&&!a&&t>e||a&&s&&c&&!u&&!f||i&&s&&c||!n&&c||!o)return 1;if(!i&&!a&&!f&&t<e||f&&n&&o&&!i&&!a||u&&n&&o||!s&&o||!c)return-1}return 0}function to(t,e,n,r){for(var i=-1,o=t.length,a=n.length,s=-1,u=e.length,c=Hn(o-a,0),f=Xt(u+c),l=!r;++s<u;)f[s]=e[s];for(;++i<a;)(l||i<o)&&(f[n[i]]=t[i]);for(;c--;)f[s++]=t[i++];return f}function eo(t,e,n,r){for(var i=-1,o=t.length,a=-1,s=n.length,u=-1,c=e.length,f=Hn(o-s,0),l=Xt(f+c),h=!r;++i<f;)l[i]=t[i];for(var d=i;++u<c;)l[d+u]=e[u];for(;++a<s;)(h||i<o)&&(l[d+n[a]]=t[i++]);return l}function no(t,e){var n=-1,r=t.length;for(e||(e=Xt(r));++n<r;)e[n]=t[n];return e}function ro(t,e,n,i){var o=!n;n||(n={});for(var a=-1,s=e.length;++a<s;){var u=e[a],c=i?i(n[u],t[u],u,n,t):r;c===r&&(c=t[u]),o?Rr(n,u,c):Mr(n,u,c)}return n}function io(t,e){return function(n,r){var i=bs(n)?Ve:Cr,o=e?e():{};return i(n,t,Lo(r,2),o)}}function oo(t){return ki((function(e,n){var i=-1,o=n.length,a=o>1?n[o-1]:r,s=o>2?n[2]:r;for(a=t.length>3&&"function"==typeof a?(o--,a):r,s&&Go(n[0],n[1],s)&&(a=o<3?r:a,o=1),e=ee(e);++i<o;){var u=n[i];u&&t(e,u,i,a)}return e}))}function ao(t,e){return function(n,r){if(null==n)return n;if(!vs(n))return t(n,r);for(var i=n.length,o=e?i:-1,a=ee(n);(e?o--:++o<i)&&!1!==r(a[o],o,a););return n}}function so(t){return function(e,n,r){for(var i=-1,o=ee(e),a=r(e),s=a.length;s--;){var u=a[t?s:++i];if(!1===n(o[u],u,o))break}return e}}function uo(t){return function(e){var n=kn(e=Hs(e))?Cn(e):r,i=n?n[0]:e.charAt(0),o=n?Wi(n,1).join(""):e.slice(1);return i[t]()+o}}function co(t){return function(e){return Qe(Eu(yu(e).replace(ye,"")),t,"")}}function fo(t){return function(){var e=arguments;switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3]);case 5:return new t(e[0],e[1],e[2],e[3],e[4]);case 6:return new t(e[0],e[1],e[2],e[3],e[4],e[5]);case 7:return new t(e[0],e[1],e[2],e[3],e[4],e[5],e[6])}var n=pr(t.prototype),r=t.apply(n,e);return Ts(r)?r:n}}function lo(t){return function(e,n,i){var o=ee(e);if(!vs(e)){var a=Lo(n,3);e=iu(e),n=function(t){return a(o[t],t,o)}}var s=t(e,n,i);return s>-1?o[a?e[s]:s]:r}}function ho(t){return Co((function(e){var n=e.length,i=n,o=yr.prototype.thru;for(t&&e.reverse();i--;){var s=e[i];if("function"!=typeof s)throw new ie(a);if(o&&!u&&"wrapper"==No(s))var u=new yr([],!0)}for(i=u?i:n;++i<n;){var c=No(s=e[i]),f="wrapper"==c?Io(s):r;u=f&&Ko(f[0])&&f[1]==(x|m|_|k)&&!f[4].length&&1==f[9]?u[No(f[0])].apply(u,f[3]):1==s.length&&Ko(s)?u[c]():u.thru(s)}return function(){var t=arguments,r=t[0];if(u&&1==t.length&&bs(r))return u.plant(r).value();for(var i=0,o=n?e[i].apply(this,t):r;++i<n;)o=e[i].call(this,o);return o}}))}function po(t,e,n,i,o,a,s,u,c,f){var l=e&x,h=e&g,d=e&y,p=e&(m|v),b=e&E,_=d?r:fo(t);return function g(){for(var y=arguments.length,m=Xt(y),v=y;v--;)m[v]=arguments[v];if(p)var w=Bo(g),x=function(t,e){for(var n=t.length,r=0;n--;)t[n]===e&&++r;return r}(m,w);if(i&&(m=to(m,i,o,p)),a&&(m=eo(m,a,s,p)),y-=x,p&&y<f){var k=Sn(m,w);return wo(t,e,po,g.placeholder,n,m,k,u,c,f-y)}var E=h?n:this,A=d?E[t]:t;return y=m.length,u?m=function(t,e){var n=t.length,i=$n(e.length,n),o=no(t);for(;i--;){var a=e[i];t[i]=$o(a,n)?o[a]:r}return t}(m,u):b&&y>1&&m.reverse(),l&&c<y&&(m.length=c),this&&this!==Oe&&this instanceof g&&(A=_||fo(A)),A.apply(E,m)}}function go(t,e){return function(n,r){return function(t,e,n,r){return Gr(t,(function(t,i,o){e(r,n(t),i,o)})),r}(n,t,e(r),{})}}function yo(t,e){return function(n,i){var o;if(n===r&&i===r)return e;if(n!==r&&(o=n),i!==r){if(o===r)return i;"string"==typeof n||"string"==typeof i?(n=Li(n),i=Li(i)):(n=Bi(n),i=Bi(i)),o=t(n,i)}return o}}function bo(t){return Co((function(e){return e=Ze(e,gn(Lo())),ki((function(n){var r=this;return t(e,(function(t){return Ye(t,r,n)}))}))}))}function mo(t,e){var n=(e=e===r?" ":Li(e)).length;if(n<2)return n?xi(e,t):e;var i=xi(e,Fn(t/Dn(e)));return kn(e)?Wi(Cn(i),0,t).join(""):i.slice(0,t)}function vo(t){return function(e,n,i){return i&&"number"!=typeof i&&Go(e,n,i)&&(n=i=r),e=js(e),n===r?(n=e,e=0):n=js(n),function(t,e,n,r){for(var i=-1,o=Hn(Fn((e-t)/(n||1)),0),a=Xt(o);o--;)a[r?o:++i]=t,t+=n;return a}(e,n,i=i===r?e<n?1:-1:js(i),t)}}function _o(t){return function(e,n){return"string"==typeof e&&"string"==typeof n||(e=Ys(e),n=Ys(n)),t(e,n)}}function wo(t,e,n,i,o,a,s,u,c,f){var l=e&m;e|=l?_:w,(e&=~(l?w:_))&b||(e&=~(g|y));var h=[t,e,o,l?a:r,l?s:r,l?r:a,l?r:s,u,c,f],d=n.apply(r,h);return Ko(t)&&ra(d,h),d.placeholder=i,aa(d,t,e)}function xo(t){var e=te[t];return function(t,n){if(t=Ys(t),(n=null==n?0:$n(Us(n),292))&&zn(t)){var r=(Hs(t)+"e").split("e");return+((r=(Hs(e(r[0]+"e"+(+r[1]+n)))+"e").split("e"))[0]+"e"+(+r[1]-n))}return e(t)}}var ko=tr&&1/Tn(new tr([,-0]))[1]==O?function(t){return new tr(t)}:Bu;function Eo(t){return function(e){var n=zo(e);return n==W?En(e):n==tt?Mn(e):function(t,e){return Ze(e,(function(e){return[e,t[e]]}))}(e,t(e))}}function Ao(t,e,n,i,o,s,u,f){var l=e&y;if(!l&&"function"!=typeof t)throw new ie(a);var h=i?i.length:0;if(h||(e&=~(_|w),i=o=r),u=u===r?u:Hn(Us(u),0),f=f===r?f:Us(f),h-=o?o.length:0,e&w){var d=i,p=o;i=o=r}var E=l?r:Io(t),A=[t,e,n,i,o,d,p,s,u,f];if(E&&function(t,e){var n=t[1],r=e[1],i=n|r,o=i<(g|y|x),a=r==x&&n==m||r==x&&n==k&&t[7].length<=e[8]||r==(x|k)&&e[7].length<=e[8]&&n==m;if(!o&&!a)return t;r&g&&(t[2]=e[2],i|=n&g?0:b);var s=e[3];if(s){var u=t[3];t[3]=u?to(u,s,e[4]):s,t[4]=u?Sn(t[3],c):e[4]}(s=e[5])&&(u=t[5],t[5]=u?eo(u,s,e[6]):s,t[6]=u?Sn(t[5],c):e[6]);(s=e[7])&&(t[7]=s);r&x&&(t[8]=null==t[8]?e[8]:$n(t[8],e[8]));null==t[9]&&(t[9]=e[9]);t[0]=e[0],t[1]=i}(A,E),t=A[0],e=A[1],n=A[2],i=A[3],o=A[4],!(f=A[9]=A[9]===r?l?0:t.length:Hn(A[9]-h,0))&&e&(m|v)&&(e&=~(m|v)),e&&e!=g)S=e==m||e==v?function(t,e,n){var i=fo(t);return function o(){for(var a=arguments.length,s=Xt(a),u=a,c=Bo(o);u--;)s[u]=arguments[u];var f=a<3&&s[0]!==c&&s[a-1]!==c?[]:Sn(s,c);return(a-=f.length)<n?wo(t,e,po,o.placeholder,r,s,f,r,r,n-a):Ye(this&&this!==Oe&&this instanceof o?i:t,this,s)}}(t,e,f):e!=_&&e!=(g|_)||o.length?po.apply(r,A):function(t,e,n,r){var i=e&g,o=fo(t);return function e(){for(var a=-1,s=arguments.length,u=-1,c=r.length,f=Xt(c+s),l=this&&this!==Oe&&this instanceof e?o:t;++u<c;)f[u]=r[u];for(;s--;)f[u++]=arguments[++a];return Ye(l,i?n:this,f)}}(t,e,n,i);else var S=function(t,e,n){var r=e&g,i=fo(t);return function e(){return(this&&this!==Oe&&this instanceof e?i:t).apply(r?n:this,arguments)}}(t,e,n);return aa((E?Ti:ra)(S,A),t,e)}function So(t,e,n,i){return t===r||ds(t,se[n])&&!fe.call(i,n)?e:t}function To(t,e,n,i,o,a){return Ts(t)&&Ts(e)&&(a.set(e,t),gi(t,e,r,To,a),a.delete(e)),t}function Mo(t){return Os(t)?r:t}function Do(t,e,n,i,o,a){var s=n&d,u=t.length,c=e.length;if(u!=c&&!(s&&c>u))return!1;var f=a.get(t);if(f&&a.get(e))return f==e;var l=-1,h=!0,g=n&p?new wr:r;for(a.set(t,e),a.set(e,t);++l<u;){var y=t[l],b=e[l];if(i)var m=s?i(b,y,l,e,t,a):i(y,b,l,t,e,a);if(m!==r){if(m)continue;h=!1;break}if(g){if(!en(e,(function(t,e){if(!bn(g,e)&&(y===t||o(y,t,n,i,a)))return g.push(e)}))){h=!1;break}}else if(y!==b&&!o(y,b,n,i,a)){h=!1;break}}return a.delete(t),a.delete(e),h}function Co(t){return oa(ta(t,r,ma),t+"")}function Oo(t){return Zr(t,iu,jo)}function Ro(t){return Zr(t,ou,Uo)}var Io=rr?function(t){return rr.get(t)}:Bu;function No(t){for(var e=t.name+"",n=ir[e],r=fe.call(ir,e)?n.length:0;r--;){var i=n[r],o=i.func;if(null==o||o==t)return i.name}return e}function Bo(t){return(fe.call(dr,"placeholder")?dr:t).placeholder}function Lo(){var t=dr.iteratee||Ou;return t=t===Ou?ui:t,arguments.length?t(arguments[0],arguments[1]):t}function Po(t,e){var n,r,i=t.__data__;return("string"==(r=typeof(n=e))||"number"==r||"symbol"==r||"boolean"==r?"__proto__"!==n:null===n)?i["string"==typeof e?"string":"hash"]:i.map}function Fo(t){for(var e=iu(t),n=e.length;n--;){var r=e[n],i=t[r];e[n]=[r,i,Jo(i)]}return e}function qo(t,e){var n=function(t,e){return null==t?r:t[e]}(t,e);return si(n)?n:r}var jo=jn?function(t){return null==t?[]:(t=ee(t),We(jn(t),(function(e){return Be.call(t,e)})))}:zu,Uo=jn?function(t){for(var e=[];t;)Je(e,jo(t)),t=Re(t);return e}:zu,zo=Jr;function Yo(t,e,n){for(var r=-1,i=(e=$i(e,t)).length,o=!1;++r<i;){var a=fa(e[r]);if(!(o=null!=t&&n(t,a)))break;t=t[a]}return o||++r!=i?o:!!(i=null==t?0:t.length)&&Ss(i)&&$o(a,i)&&(bs(t)||ys(t))}function Vo(t){return"function"!=typeof t.constructor||Zo(t)?{}:pr(Re(t))}function Ho(t){return bs(t)||ys(t)||!!(nn&&t&&t[nn])}function $o(t,e){var n=typeof t;return!!(e=null==e?R:e)&&("number"==n||"symbol"!=n&&$t.test(t))&&t>-1&&t%1==0&&t<e}function Go(t,e,n){if(!Ts(n))return!1;var r=typeof e;return!!("number"==r?vs(n)&&$o(e,n.length):"string"==r&&e in n)&&ds(n[e],t)}function Wo(t,e){if(bs(t))return!1;var n=typeof t;return!("number"!=n&&"symbol"!=n&&"boolean"!=n&&null!=t&&!Bs(t))||(Mt.test(t)||!Tt.test(t)||null!=e&&t in ee(e))}function Ko(t){var e=No(t),n=dr[e];if("function"!=typeof n||!(e in br.prototype))return!1;if(t===n)return!0;var r=Io(n);return!!r&&t===r[0]}(Zn&&zo(new Zn(new ArrayBuffer(1)))!=st||Jn&&zo(new Jn)!=W||Qn&&"[object Promise]"!=zo(Qn.resolve())||tr&&zo(new tr)!=tt||er&&zo(new er)!=it)&&(zo=function(t){var e=Jr(t),n=e==Z?t.constructor:r,i=n?la(n):"";if(i)switch(i){case or:return st;case ar:return W;case sr:return"[object Promise]";case ur:return tt;case cr:return it}return e});var Xo=ue?Es:Yu;function Zo(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||se)}function Jo(t){return t==t&&!Ts(t)}function Qo(t,e){return function(n){return null!=n&&(n[t]===e&&(e!==r||t in ee(n)))}}function ta(t,e,n){return e=Hn(e===r?t.length-1:e,0),function(){for(var r=arguments,i=-1,o=Hn(r.length-e,0),a=Xt(o);++i<o;)a[i]=r[e+i];i=-1;for(var s=Xt(e+1);++i<e;)s[i]=r[i];return s[e]=n(a),Ye(t,this,s)}}function ea(t,e){return e.length<2?t:Xr(t,Ci(e,0,-1))}function na(t,e){if(("constructor"!==e||"function"!=typeof t[e])&&"__proto__"!=e)return t[e]}var ra=sa(Ti),ia=Pn||function(t,e){return Oe.setTimeout(t,e)},oa=sa(Mi);function aa(t,e,n){var r=e+"";return oa(t,function(t,e){var n=e.length;if(!n)return t;var r=n-1;return e[r]=(n>1?"& ":"")+e[r],e=e.join(n>2?", ":" "),t.replace(Bt,"{\n/* [wrapped with "+e+"] */\n")}(r,function(t,e){return He(F,(function(n){var r="_."+n[0];e&n[1]&&!Ke(t,r)&&t.push(r)})),t.sort()}(function(t){var e=t.match(Lt);return e?e[1].split(Pt):[]}(r),n)))}function sa(t){var e=0,n=0;return function(){var i=Gn(),o=M-(i-n);if(n=i,o>0){if(++e>=T)return arguments[0]}else e=0;return t.apply(r,arguments)}}function ua(t,e){var n=-1,i=t.length,o=i-1;for(e=e===r?i:e;++n<e;){var a=wi(n,o),s=t[a];t[a]=t[n],t[n]=s}return t.length=e,t}var ca=function(t){var e=ss(t,(function(t){return n.size===u&&n.clear(),t})),n=e.cache;return e}((function(t){var e=[];return 46===t.charCodeAt(0)&&e.push(""),t.replace(Dt,(function(t,n,r,i){e.push(r?i.replace(qt,"$1"):n||t)})),e}));function fa(t){if("string"==typeof t||Bs(t))return t;var e=t+"";return"0"==e&&1/t==-O?"-0":e}function la(t){if(null!=t){try{return ce.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function ha(t){if(t instanceof br)return t.clone();var e=new yr(t.__wrapped__,t.__chain__);return e.__actions__=no(t.__actions__),e.__index__=t.__index__,e.__values__=t.__values__,e}var da=ki((function(t,e){return _s(t)?Fr(t,Vr(e,1,_s,!0)):[]})),pa=ki((function(t,e){var n=ka(e);return _s(n)&&(n=r),_s(t)?Fr(t,Vr(e,1,_s,!0),Lo(n,2)):[]})),ga=ki((function(t,e){var n=ka(e);return _s(n)&&(n=r),_s(t)?Fr(t,Vr(e,1,_s,!0),r,n):[]}));function ya(t,e,n){var r=null==t?0:t.length;if(!r)return-1;var i=null==n?0:Us(n);return i<0&&(i=Hn(r+i,0)),on(t,Lo(e,3),i)}function ba(t,e,n){var i=null==t?0:t.length;if(!i)return-1;var o=i-1;return n!==r&&(o=Us(n),o=n<0?Hn(i+o,0):$n(o,i-1)),on(t,Lo(e,3),o,!0)}function ma(t){return(null==t?0:t.length)?Vr(t,1):[]}function va(t){return t&&t.length?t[0]:r}var _a=ki((function(t){var e=Ze(t,Vi);return e.length&&e[0]===t[0]?ni(e):[]})),wa=ki((function(t){var e=ka(t),n=Ze(t,Vi);return e===ka(n)?e=r:n.pop(),n.length&&n[0]===t[0]?ni(n,Lo(e,2)):[]})),xa=ki((function(t){var e=ka(t),n=Ze(t,Vi);return(e="function"==typeof e?e:r)&&n.pop(),n.length&&n[0]===t[0]?ni(n,r,e):[]}));function ka(t){var e=null==t?0:t.length;return e?t[e-1]:r}var Ea=ki(Aa);function Aa(t,e){return t&&t.length&&e&&e.length?vi(t,e):t}var Sa=Co((function(t,e){var n=null==t?0:t.length,r=Ir(t,e);return _i(t,Ze(e,(function(t){return $o(t,n)?+t:t})).sort(Qi)),r}));function Ta(t){return null==t?t:Xn.call(t)}var Ma=ki((function(t){return Pi(Vr(t,1,_s,!0))})),Da=ki((function(t){var e=ka(t);return _s(e)&&(e=r),Pi(Vr(t,1,_s,!0),Lo(e,2))})),Ca=ki((function(t){var e=ka(t);return e="function"==typeof e?e:r,Pi(Vr(t,1,_s,!0),r,e)}));function Oa(t){if(!t||!t.length)return[];var e=0;return t=We(t,(function(t){if(_s(t))return e=Hn(t.length,e),!0})),pn(e,(function(e){return Ze(t,fn(e))}))}function Ra(t,e){if(!t||!t.length)return[];var n=Oa(t);return null==e?n:Ze(n,(function(t){return Ye(e,r,t)}))}var Ia=ki((function(t,e){return _s(t)?Fr(t,e):[]})),Na=ki((function(t){return zi(We(t,_s))})),Ba=ki((function(t){var e=ka(t);return _s(e)&&(e=r),zi(We(t,_s),Lo(e,2))})),La=ki((function(t){var e=ka(t);return e="function"==typeof e?e:r,zi(We(t,_s),r,e)})),Pa=ki(Oa);var Fa=ki((function(t){var e=t.length,n=e>1?t[e-1]:r;return n="function"==typeof n?(t.pop(),n):r,Ra(t,n)}));function qa(t){var e=dr(t);return e.__chain__=!0,e}function ja(t,e){return e(t)}var Ua=Co((function(t){var e=t.length,n=e?t[0]:0,i=this.__wrapped__,o=function(e){return Ir(e,t)};return!(e>1||this.__actions__.length)&&i instanceof br&&$o(n)?((i=i.slice(n,+n+(e?1:0))).__actions__.push({func:ja,args:[o],thisArg:r}),new yr(i,this.__chain__).thru((function(t){return e&&!t.length&&t.push(r),t}))):this.thru(o)}));var za=io((function(t,e,n){fe.call(t,n)?++t[n]:Rr(t,n,1)}));var Ya=lo(ya),Va=lo(ba);function Ha(t,e){return(bs(t)?He:qr)(t,Lo(e,3))}function $a(t,e){return(bs(t)?$e:jr)(t,Lo(e,3))}var Ga=io((function(t,e,n){fe.call(t,n)?t[n].push(e):Rr(t,n,[e])}));var Wa=ki((function(t,e,n){var r=-1,i="function"==typeof e,o=vs(t)?Xt(t.length):[];return qr(t,(function(t){o[++r]=i?Ye(e,t,n):ri(t,e,n)})),o})),Ka=io((function(t,e,n){Rr(t,n,e)}));function Xa(t,e){return(bs(t)?Ze:hi)(t,Lo(e,3))}var Za=io((function(t,e,n){t[n?0:1].push(e)}),(function(){return[[],[]]}));var Ja=ki((function(t,e){if(null==t)return[];var n=e.length;return n>1&&Go(t,e[0],e[1])?e=[]:n>2&&Go(e[0],e[1],e[2])&&(e=[e[0]]),bi(t,Vr(e,1),[])})),Qa=Ln||function(){return Oe.Date.now()};function ts(t,e,n){return e=n?r:e,e=t&&null==e?t.length:e,Ao(t,x,r,r,r,r,e)}function es(t,e){var n;if("function"!=typeof e)throw new ie(a);return t=Us(t),function(){return--t>0&&(n=e.apply(this,arguments)),t<=1&&(e=r),n}}var ns=ki((function(t,e,n){var r=g;if(n.length){var i=Sn(n,Bo(ns));r|=_}return Ao(t,r,e,n,i)})),rs=ki((function(t,e,n){var r=g|y;if(n.length){var i=Sn(n,Bo(rs));r|=_}return Ao(e,r,t,n,i)}));function is(t,e,n){var i,o,s,u,c,f,l=0,h=!1,d=!1,p=!0;if("function"!=typeof t)throw new ie(a);function g(e){var n=i,a=o;return i=o=r,l=e,u=t.apply(a,n)}function y(t){var n=t-f;return f===r||n>=e||n<0||d&&t-l>=s}function b(){var t=Qa();if(y(t))return m(t);c=ia(b,function(t){var n=e-(t-f);return d?$n(n,s-(t-l)):n}(t))}function m(t){return c=r,p&&i?g(t):(i=o=r,u)}function v(){var t=Qa(),n=y(t);if(i=arguments,o=this,f=t,n){if(c===r)return function(t){return l=t,c=ia(b,e),h?g(t):u}(f);if(d)return Ki(c),c=ia(b,e),g(f)}return c===r&&(c=ia(b,e)),u}return e=Ys(e)||0,Ts(n)&&(h=!!n.leading,s=(d="maxWait"in n)?Hn(Ys(n.maxWait)||0,e):s,p="trailing"in n?!!n.trailing:p),v.cancel=function(){c!==r&&Ki(c),l=0,i=f=o=c=r},v.flush=function(){return c===r?u:m(Qa())},v}var os=ki((function(t,e){return Pr(t,1,e)})),as=ki((function(t,e,n){return Pr(t,Ys(e)||0,n)}));function ss(t,e){if("function"!=typeof t||null!=e&&"function"!=typeof e)throw new ie(a);var n=function(){var r=arguments,i=e?e.apply(this,r):r[0],o=n.cache;if(o.has(i))return o.get(i);var a=t.apply(this,r);return n.cache=o.set(i,a)||o,a};return n.cache=new(ss.Cache||_r),n}function us(t){if("function"!=typeof t)throw new ie(a);return function(){var e=arguments;switch(e.length){case 0:return!t.call(this);case 1:return!t.call(this,e[0]);case 2:return!t.call(this,e[0],e[1]);case 3:return!t.call(this,e[0],e[1],e[2])}return!t.apply(this,e)}}ss.Cache=_r;var cs=Gi((function(t,e){var n=(e=1==e.length&&bs(e[0])?Ze(e[0],gn(Lo())):Ze(Vr(e,1),gn(Lo()))).length;return ki((function(r){for(var i=-1,o=$n(r.length,n);++i<o;)r[i]=e[i].call(this,r[i]);return Ye(t,this,r)}))})),fs=ki((function(t,e){var n=Sn(e,Bo(fs));return Ao(t,_,r,e,n)})),ls=ki((function(t,e){var n=Sn(e,Bo(ls));return Ao(t,w,r,e,n)})),hs=Co((function(t,e){return Ao(t,k,r,r,r,e)}));function ds(t,e){return t===e||t!=t&&e!=e}var ps=_o(Qr),gs=_o((function(t,e){return t>=e})),ys=ii(function(){return arguments}())?ii:function(t){return Ms(t)&&fe.call(t,"callee")&&!Be.call(t,"callee")},bs=Xt.isArray,ms=Pe?gn(Pe):function(t){return Ms(t)&&Jr(t)==at};function vs(t){return null!=t&&Ss(t.length)&&!Es(t)}function _s(t){return Ms(t)&&vs(t)}var ws=Un||Yu,xs=Fe?gn(Fe):function(t){return Ms(t)&&Jr(t)==Y};function ks(t){if(!Ms(t))return!1;var e=Jr(t);return e==H||e==V||"string"==typeof t.message&&"string"==typeof t.name&&!Os(t)}function Es(t){if(!Ts(t))return!1;var e=Jr(t);return e==$||e==G||e==U||e==J}function As(t){return"number"==typeof t&&t==Us(t)}function Ss(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=R}function Ts(t){var e=typeof t;return null!=t&&("object"==e||"function"==e)}function Ms(t){return null!=t&&"object"==typeof t}var Ds=qe?gn(qe):function(t){return Ms(t)&&zo(t)==W};function Cs(t){return"number"==typeof t||Ms(t)&&Jr(t)==K}function Os(t){if(!Ms(t)||Jr(t)!=Z)return!1;var e=Re(t);if(null===e)return!0;var n=fe.call(e,"constructor")&&e.constructor;return"function"==typeof n&&n instanceof n&&ce.call(n)==pe}var Rs=je?gn(je):function(t){return Ms(t)&&Jr(t)==Q};var Is=Ue?gn(Ue):function(t){return Ms(t)&&zo(t)==tt};function Ns(t){return"string"==typeof t||!bs(t)&&Ms(t)&&Jr(t)==et}function Bs(t){return"symbol"==typeof t||Ms(t)&&Jr(t)==nt}var Ls=ze?gn(ze):function(t){return Ms(t)&&Ss(t.length)&&!!Ee[Jr(t)]};var Ps=_o(li),Fs=_o((function(t,e){return t<=e}));function qs(t){if(!t)return[];if(vs(t))return Ns(t)?Cn(t):no(t);if(ln&&t[ln])return function(t){for(var e,n=[];!(e=t.next()).done;)n.push(e.value);return n}(t[ln]());var e=zo(t);return(e==W?En:e==tt?Tn:du)(t)}function js(t){return t?(t=Ys(t))===O||t===-O?(t<0?-1:1)*I:t==t?t:0:0===t?t:0}function Us(t){var e=js(t),n=e%1;return e==e?n?e-n:e:0}function zs(t){return t?Nr(Us(t),0,B):0}function Ys(t){if("number"==typeof t)return t;if(Bs(t))return N;if(Ts(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=Ts(e)?e+"":e}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(Rt,"");var n=Yt.test(t);return n||Ht.test(t)?Me(t.slice(2),n?2:8):zt.test(t)?N:+t}function Vs(t){return ro(t,ou(t))}function Hs(t){return null==t?"":Li(t)}var $s=oo((function(t,e){if(Zo(e)||vs(e))ro(e,iu(e),t);else for(var n in e)fe.call(e,n)&&Mr(t,n,e[n])})),Gs=oo((function(t,e){ro(e,ou(e),t)})),Ws=oo((function(t,e,n,r){ro(e,ou(e),t,r)})),Ks=oo((function(t,e,n,r){ro(e,iu(e),t,r)})),Xs=Co(Ir);var Zs=ki((function(t,e){t=ee(t);var n=-1,i=e.length,o=i>2?e[2]:r;for(o&&Go(e[0],e[1],o)&&(i=1);++n<i;)for(var a=e[n],s=ou(a),u=-1,c=s.length;++u<c;){var f=s[u],l=t[f];(l===r||ds(l,se[f])&&!fe.call(t,f))&&(t[f]=a[f])}return t})),Js=ki((function(t){return t.push(r,To),Ye(su,r,t)}));function Qs(t,e,n){var i=null==t?r:Xr(t,e);return i===r?n:i}function tu(t,e){return null!=t&&Yo(t,e,ei)}var eu=go((function(t,e,n){null!=e&&"function"!=typeof e.toString&&(e=de.call(e)),t[e]=n}),Tu(Cu)),nu=go((function(t,e,n){null!=e&&"function"!=typeof e.toString&&(e=de.call(e)),fe.call(t,e)?t[e].push(n):t[e]=[n]}),Lo),ru=ki(ri);function iu(t){return vs(t)?kr(t):ci(t)}function ou(t){return vs(t)?kr(t,!0):fi(t)}var au=oo((function(t,e,n){gi(t,e,n)})),su=oo((function(t,e,n,r){gi(t,e,n,r)})),uu=Co((function(t,e){var n={};if(null==t)return n;var r=!1;e=Ze(e,(function(e){return e=$i(e,t),r||(r=e.length>1),e})),ro(t,Ro(t),n),r&&(n=Br(n,f|l|h,Mo));for(var i=e.length;i--;)Fi(n,e[i]);return n}));var cu=Co((function(t,e){return null==t?{}:function(t,e){return mi(t,e,(function(e,n){return tu(t,n)}))}(t,e)}));function fu(t,e){if(null==t)return{};var n=Ze(Ro(t),(function(t){return[t]}));return e=Lo(e),mi(t,n,(function(t,n){return e(t,n[0])}))}var lu=Eo(iu),hu=Eo(ou);function du(t){return null==t?[]:yn(t,iu(t))}var pu=co((function(t,e,n){return e=e.toLowerCase(),t+(n?gu(e):e)}));function gu(t){return ku(Hs(t).toLowerCase())}function yu(t){return(t=Hs(t))&&t.replace(Gt,_n).replace(be,"")}var bu=co((function(t,e,n){return t+(n?"-":"")+e.toLowerCase()})),mu=co((function(t,e,n){return t+(n?" ":"")+e.toLowerCase()})),vu=uo("toLowerCase");var _u=co((function(t,e,n){return t+(n?"_":"")+e.toLowerCase()}));var wu=co((function(t,e,n){return t+(n?" ":"")+ku(e)}));var xu=co((function(t,e,n){return t+(n?" ":"")+e.toUpperCase()})),ku=uo("toUpperCase");function Eu(t,e,n){return t=Hs(t),(e=n?r:e)===r?function(t){return we.test(t)}(t)?function(t){return t.match(ve)||[]}(t):function(t){return t.match(Ft)||[]}(t):t.match(e)||[]}var Au=ki((function(t,e){try{return Ye(t,r,e)}catch(t){return ks(t)?t:new Jt(t)}})),Su=Co((function(t,e){return He(e,(function(e){e=fa(e),Rr(t,e,ns(t[e],t))})),t}));function Tu(t){return function(){return t}}var Mu=ho(),Du=ho(!0);function Cu(t){return t}function Ou(t){return ui("function"==typeof t?t:Br(t,f))}var Ru=ki((function(t,e){return function(n){return ri(n,t,e)}})),Iu=ki((function(t,e){return function(n){return ri(t,n,e)}}));function Nu(t,e,n){var r=iu(e),i=Kr(e,r);null!=n||Ts(e)&&(i.length||!r.length)||(n=e,e=t,t=this,i=Kr(e,iu(e)));var o=!(Ts(n)&&"chain"in n&&!n.chain),a=Es(t);return He(i,(function(n){var r=e[n];t[n]=r,a&&(t.prototype[n]=function(){var e=this.__chain__;if(o||e){var n=t(this.__wrapped__),i=n.__actions__=no(this.__actions__);return i.push({func:r,args:arguments,thisArg:t}),n.__chain__=e,n}return r.apply(t,Je([this.value()],arguments))})})),t}function Bu(){}var Lu=bo(Ze),Pu=bo(Ge),Fu=bo(en);function qu(t){return Wo(t)?fn(fa(t)):function(t){return function(e){return Xr(e,t)}}(t)}var ju=vo(),Uu=vo(!0);function zu(){return[]}function Yu(){return!1}var Vu=yo((function(t,e){return t+e}),0),Hu=xo("ceil"),$u=yo((function(t,e){return t/e}),1),Gu=xo("floor");var Wu,Ku=yo((function(t,e){return t*e}),1),Xu=xo("round"),Zu=yo((function(t,e){return t-e}),0);return dr.after=function(t,e){if("function"!=typeof e)throw new ie(a);return t=Us(t),function(){if(--t<1)return e.apply(this,arguments)}},dr.ary=ts,dr.assign=$s,dr.assignIn=Gs,dr.assignInWith=Ws,dr.assignWith=Ks,dr.at=Xs,dr.before=es,dr.bind=ns,dr.bindAll=Su,dr.bindKey=rs,dr.castArray=function(){if(!arguments.length)return[];var t=arguments[0];return bs(t)?t:[t]},dr.chain=qa,dr.chunk=function(t,e,n){e=(n?Go(t,e,n):e===r)?1:Hn(Us(e),0);var i=null==t?0:t.length;if(!i||e<1)return[];for(var o=0,a=0,s=Xt(Fn(i/e));o<i;)s[a++]=Ci(t,o,o+=e);return s},dr.compact=function(t){for(var e=-1,n=null==t?0:t.length,r=0,i=[];++e<n;){var o=t[e];o&&(i[r++]=o)}return i},dr.concat=function(){var t=arguments.length;if(!t)return[];for(var e=Xt(t-1),n=arguments[0],r=t;r--;)e[r-1]=arguments[r];return Je(bs(n)?no(n):[n],Vr(e,1))},dr.cond=function(t){var e=null==t?0:t.length,n=Lo();return t=e?Ze(t,(function(t){if("function"!=typeof t[1])throw new ie(a);return[n(t[0]),t[1]]})):[],ki((function(n){for(var r=-1;++r<e;){var i=t[r];if(Ye(i[0],this,n))return Ye(i[1],this,n)}}))},dr.conforms=function(t){return function(t){var e=iu(t);return function(n){return Lr(n,t,e)}}(Br(t,f))},dr.constant=Tu,dr.countBy=za,dr.create=function(t,e){var n=pr(t);return null==e?n:Or(n,e)},dr.curry=function t(e,n,i){var o=Ao(e,m,r,r,r,r,r,n=i?r:n);return o.placeholder=t.placeholder,o},dr.curryRight=function t(e,n,i){var o=Ao(e,v,r,r,r,r,r,n=i?r:n);return o.placeholder=t.placeholder,o},dr.debounce=is,dr.defaults=Zs,dr.defaultsDeep=Js,dr.defer=os,dr.delay=as,dr.difference=da,dr.differenceBy=pa,dr.differenceWith=ga,dr.drop=function(t,e,n){var i=null==t?0:t.length;return i?Ci(t,(e=n||e===r?1:Us(e))<0?0:e,i):[]},dr.dropRight=function(t,e,n){var i=null==t?0:t.length;return i?Ci(t,0,(e=i-(e=n||e===r?1:Us(e)))<0?0:e):[]},dr.dropRightWhile=function(t,e){return t&&t.length?ji(t,Lo(e,3),!0,!0):[]},dr.dropWhile=function(t,e){return t&&t.length?ji(t,Lo(e,3),!0):[]},dr.fill=function(t,e,n,i){var o=null==t?0:t.length;return o?(n&&"number"!=typeof n&&Go(t,e,n)&&(n=0,i=o),function(t,e,n,i){var o=t.length;for((n=Us(n))<0&&(n=-n>o?0:o+n),(i=i===r||i>o?o:Us(i))<0&&(i+=o),i=n>i?0:zs(i);n<i;)t[n++]=e;return t}(t,e,n,i)):[]},dr.filter=function(t,e){return(bs(t)?We:Yr)(t,Lo(e,3))},dr.flatMap=function(t,e){return Vr(Xa(t,e),1)},dr.flatMapDeep=function(t,e){return Vr(Xa(t,e),O)},dr.flatMapDepth=function(t,e,n){return n=n===r?1:Us(n),Vr(Xa(t,e),n)},dr.flatten=ma,dr.flattenDeep=function(t){return(null==t?0:t.length)?Vr(t,O):[]},dr.flattenDepth=function(t,e){return(null==t?0:t.length)?Vr(t,e=e===r?1:Us(e)):[]},dr.flip=function(t){return Ao(t,E)},dr.flow=Mu,dr.flowRight=Du,dr.fromPairs=function(t){for(var e=-1,n=null==t?0:t.length,r={};++e<n;){var i=t[e];r[i[0]]=i[1]}return r},dr.functions=function(t){return null==t?[]:Kr(t,iu(t))},dr.functionsIn=function(t){return null==t?[]:Kr(t,ou(t))},dr.groupBy=Ga,dr.initial=function(t){return(null==t?0:t.length)?Ci(t,0,-1):[]},dr.intersection=_a,dr.intersectionBy=wa,dr.intersectionWith=xa,dr.invert=eu,dr.invertBy=nu,dr.invokeMap=Wa,dr.iteratee=Ou,dr.keyBy=Ka,dr.keys=iu,dr.keysIn=ou,dr.map=Xa,dr.mapKeys=function(t,e){var n={};return e=Lo(e,3),Gr(t,(function(t,r,i){Rr(n,e(t,r,i),t)})),n},dr.mapValues=function(t,e){var n={};return e=Lo(e,3),Gr(t,(function(t,r,i){Rr(n,r,e(t,r,i))})),n},dr.matches=function(t){return di(Br(t,f))},dr.matchesProperty=function(t,e){return pi(t,Br(e,f))},dr.memoize=ss,dr.merge=au,dr.mergeWith=su,dr.method=Ru,dr.methodOf=Iu,dr.mixin=Nu,dr.negate=us,dr.nthArg=function(t){return t=Us(t),ki((function(e){return yi(e,t)}))},dr.omit=uu,dr.omitBy=function(t,e){return fu(t,us(Lo(e)))},dr.once=function(t){return es(2,t)},dr.orderBy=function(t,e,n,i){return null==t?[]:(bs(e)||(e=null==e?[]:[e]),bs(n=i?r:n)||(n=null==n?[]:[n]),bi(t,e,n))},dr.over=Lu,dr.overArgs=cs,dr.overEvery=Pu,dr.overSome=Fu,dr.partial=fs,dr.partialRight=ls,dr.partition=Za,dr.pick=cu,dr.pickBy=fu,dr.property=qu,dr.propertyOf=function(t){return function(e){return null==t?r:Xr(t,e)}},dr.pull=Ea,dr.pullAll=Aa,dr.pullAllBy=function(t,e,n){return t&&t.length&&e&&e.length?vi(t,e,Lo(n,2)):t},dr.pullAllWith=function(t,e,n){return t&&t.length&&e&&e.length?vi(t,e,r,n):t},dr.pullAt=Sa,dr.range=ju,dr.rangeRight=Uu,dr.rearg=hs,dr.reject=function(t,e){return(bs(t)?We:Yr)(t,us(Lo(e,3)))},dr.remove=function(t,e){var n=[];if(!t||!t.length)return n;var r=-1,i=[],o=t.length;for(e=Lo(e,3);++r<o;){var a=t[r];e(a,r,t)&&(n.push(a),i.push(r))}return _i(t,i),n},dr.rest=function(t,e){if("function"!=typeof t)throw new ie(a);return ki(t,e=e===r?e:Us(e))},dr.reverse=Ta,dr.sampleSize=function(t,e,n){return e=(n?Go(t,e,n):e===r)?1:Us(e),(bs(t)?Ar:Ai)(t,e)},dr.set=function(t,e,n){return null==t?t:Si(t,e,n)},dr.setWith=function(t,e,n,i){return i="function"==typeof i?i:r,null==t?t:Si(t,e,n,i)},dr.shuffle=function(t){return(bs(t)?Sr:Di)(t)},dr.slice=function(t,e,n){var i=null==t?0:t.length;return i?(n&&"number"!=typeof n&&Go(t,e,n)?(e=0,n=i):(e=null==e?0:Us(e),n=n===r?i:Us(n)),Ci(t,e,n)):[]},dr.sortBy=Ja,dr.sortedUniq=function(t){return t&&t.length?Ni(t):[]},dr.sortedUniqBy=function(t,e){return t&&t.length?Ni(t,Lo(e,2)):[]},dr.split=function(t,e,n){return n&&"number"!=typeof n&&Go(t,e,n)&&(e=n=r),(n=n===r?B:n>>>0)?(t=Hs(t))&&("string"==typeof e||null!=e&&!Rs(e))&&!(e=Li(e))&&kn(t)?Wi(Cn(t),0,n):t.split(e,n):[]},dr.spread=function(t,e){if("function"!=typeof t)throw new ie(a);return e=null==e?0:Hn(Us(e),0),ki((function(n){var r=n[e],i=Wi(n,0,e);return r&&Je(i,r),Ye(t,this,i)}))},dr.tail=function(t){var e=null==t?0:t.length;return e?Ci(t,1,e):[]},dr.take=function(t,e,n){return t&&t.length?Ci(t,0,(e=n||e===r?1:Us(e))<0?0:e):[]},dr.takeRight=function(t,e,n){var i=null==t?0:t.length;return i?Ci(t,(e=i-(e=n||e===r?1:Us(e)))<0?0:e,i):[]},dr.takeRightWhile=function(t,e){return t&&t.length?ji(t,Lo(e,3),!1,!0):[]},dr.takeWhile=function(t,e){return t&&t.length?ji(t,Lo(e,3)):[]},dr.tap=function(t,e){return e(t),t},dr.throttle=function(t,e,n){var r=!0,i=!0;if("function"!=typeof t)throw new ie(a);return Ts(n)&&(r="leading"in n?!!n.leading:r,i="trailing"in n?!!n.trailing:i),is(t,e,{leading:r,maxWait:e,trailing:i})},dr.thru=ja,dr.toArray=qs,dr.toPairs=lu,dr.toPairsIn=hu,dr.toPath=function(t){return bs(t)?Ze(t,fa):Bs(t)?[t]:no(ca(Hs(t)))},dr.toPlainObject=Vs,dr.transform=function(t,e,n){var r=bs(t),i=r||ws(t)||Ls(t);if(e=Lo(e,4),null==n){var o=t&&t.constructor;n=i?r?new o:[]:Ts(t)&&Es(o)?pr(Re(t)):{}}return(i?He:Gr)(t,(function(t,r,i){return e(n,t,r,i)})),n},dr.unary=function(t){return ts(t,1)},dr.union=Ma,dr.unionBy=Da,dr.unionWith=Ca,dr.uniq=function(t){return t&&t.length?Pi(t):[]},dr.uniqBy=function(t,e){return t&&t.length?Pi(t,Lo(e,2)):[]},dr.uniqWith=function(t,e){return e="function"==typeof e?e:r,t&&t.length?Pi(t,r,e):[]},dr.unset=function(t,e){return null==t||Fi(t,e)},dr.unzip=Oa,dr.unzipWith=Ra,dr.update=function(t,e,n){return null==t?t:qi(t,e,Hi(n))},dr.updateWith=function(t,e,n,i){return i="function"==typeof i?i:r,null==t?t:qi(t,e,Hi(n),i)},dr.values=du,dr.valuesIn=function(t){return null==t?[]:yn(t,ou(t))},dr.without=Ia,dr.words=Eu,dr.wrap=function(t,e){return fs(Hi(e),t)},dr.xor=Na,dr.xorBy=Ba,dr.xorWith=La,dr.zip=Pa,dr.zipObject=function(t,e){return Yi(t||[],e||[],Mr)},dr.zipObjectDeep=function(t,e){return Yi(t||[],e||[],Si)},dr.zipWith=Fa,dr.entries=lu,dr.entriesIn=hu,dr.extend=Gs,dr.extendWith=Ws,Nu(dr,dr),dr.add=Vu,dr.attempt=Au,dr.camelCase=pu,dr.capitalize=gu,dr.ceil=Hu,dr.clamp=function(t,e,n){return n===r&&(n=e,e=r),n!==r&&(n=(n=Ys(n))==n?n:0),e!==r&&(e=(e=Ys(e))==e?e:0),Nr(Ys(t),e,n)},dr.clone=function(t){return Br(t,h)},dr.cloneDeep=function(t){return Br(t,f|h)},dr.cloneDeepWith=function(t,e){return Br(t,f|h,e="function"==typeof e?e:r)},dr.cloneWith=function(t,e){return Br(t,h,e="function"==typeof e?e:r)},dr.conformsTo=function(t,e){return null==e||Lr(t,e,iu(e))},dr.deburr=yu,dr.defaultTo=function(t,e){return null==t||t!=t?e:t},dr.divide=$u,dr.endsWith=function(t,e,n){t=Hs(t),e=Li(e);var i=t.length,o=n=n===r?i:Nr(Us(n),0,i);return(n-=e.length)>=0&&t.slice(n,o)==e},dr.eq=ds,dr.escape=function(t){return(t=Hs(t))&&kt.test(t)?t.replace(wt,wn):t},dr.escapeRegExp=function(t){return(t=Hs(t))&&Ot.test(t)?t.replace(Ct,"\\$&"):t},dr.every=function(t,e,n){var i=bs(t)?Ge:Ur;return n&&Go(t,e,n)&&(e=r),i(t,Lo(e,3))},dr.find=Ya,dr.findIndex=ya,dr.findKey=function(t,e){return rn(t,Lo(e,3),Gr)},dr.findLast=Va,dr.findLastIndex=ba,dr.findLastKey=function(t,e){return rn(t,Lo(e,3),Wr)},dr.floor=Gu,dr.forEach=Ha,dr.forEachRight=$a,dr.forIn=function(t,e){return null==t?t:Hr(t,Lo(e,3),ou)},dr.forInRight=function(t,e){return null==t?t:$r(t,Lo(e,3),ou)},dr.forOwn=function(t,e){return t&&Gr(t,Lo(e,3))},dr.forOwnRight=function(t,e){return t&&Wr(t,Lo(e,3))},dr.get=Qs,dr.gt=ps,dr.gte=gs,dr.has=function(t,e){return null!=t&&Yo(t,e,ti)},dr.hasIn=tu,dr.head=va,dr.identity=Cu,dr.includes=function(t,e,n,r){t=vs(t)?t:du(t),n=n&&!r?Us(n):0;var i=t.length;return n<0&&(n=Hn(i+n,0)),Ns(t)?n<=i&&t.indexOf(e,n)>-1:!!i&&an(t,e,n)>-1},dr.indexOf=function(t,e,n){var r=null==t?0:t.length;if(!r)return-1;var i=null==n?0:Us(n);return i<0&&(i=Hn(r+i,0)),an(t,e,i)},dr.inRange=function(t,e,n){return e=js(e),n===r?(n=e,e=0):n=js(n),function(t,e,n){return t>=$n(e,n)&&t<Hn(e,n)}(t=Ys(t),e,n)},dr.invoke=ru,dr.isArguments=ys,dr.isArray=bs,dr.isArrayBuffer=ms,dr.isArrayLike=vs,dr.isArrayLikeObject=_s,dr.isBoolean=function(t){return!0===t||!1===t||Ms(t)&&Jr(t)==z},dr.isBuffer=ws,dr.isDate=xs,dr.isElement=function(t){return Ms(t)&&1===t.nodeType&&!Os(t)},dr.isEmpty=function(t){if(null==t)return!0;if(vs(t)&&(bs(t)||"string"==typeof t||"function"==typeof t.splice||ws(t)||Ls(t)||ys(t)))return!t.length;var e=zo(t);if(e==W||e==tt)return!t.size;if(Zo(t))return!ci(t).length;for(var n in t)if(fe.call(t,n))return!1;return!0},dr.isEqual=function(t,e){return oi(t,e)},dr.isEqualWith=function(t,e,n){var i=(n="function"==typeof n?n:r)?n(t,e):r;return i===r?oi(t,e,r,n):!!i},dr.isError=ks,dr.isFinite=function(t){return"number"==typeof t&&zn(t)},dr.isFunction=Es,dr.isInteger=As,dr.isLength=Ss,dr.isMap=Ds,dr.isMatch=function(t,e){return t===e||ai(t,e,Fo(e))},dr.isMatchWith=function(t,e,n){return n="function"==typeof n?n:r,ai(t,e,Fo(e),n)},dr.isNaN=function(t){return Cs(t)&&t!=+t},dr.isNative=function(t){if(Xo(t))throw new Jt(o);return si(t)},dr.isNil=function(t){return null==t},dr.isNull=function(t){return null===t},dr.isNumber=Cs,dr.isObject=Ts,dr.isObjectLike=Ms,dr.isPlainObject=Os,dr.isRegExp=Rs,dr.isSafeInteger=function(t){return As(t)&&t>=-R&&t<=R},dr.isSet=Is,dr.isString=Ns,dr.isSymbol=Bs,dr.isTypedArray=Ls,dr.isUndefined=function(t){return t===r},dr.isWeakMap=function(t){return Ms(t)&&zo(t)==it},dr.isWeakSet=function(t){return Ms(t)&&Jr(t)==ot},dr.join=function(t,e){return null==t?"":Yn.call(t,e)},dr.kebabCase=bu,dr.last=ka,dr.lastIndexOf=function(t,e,n){var i=null==t?0:t.length;if(!i)return-1;var o=i;return n!==r&&(o=(o=Us(n))<0?Hn(i+o,0):$n(o,i-1)),e==e?function(t,e,n){for(var r=n+1;r--;)if(t[r]===e)return r;return r}(t,e,o):on(t,un,o,!0)},dr.lowerCase=mu,dr.lowerFirst=vu,dr.lt=Ps,dr.lte=Fs,dr.max=function(t){return t&&t.length?zr(t,Cu,Qr):r},dr.maxBy=function(t,e){return t&&t.length?zr(t,Lo(e,2),Qr):r},dr.mean=function(t){return cn(t,Cu)},dr.meanBy=function(t,e){return cn(t,Lo(e,2))},dr.min=function(t){return t&&t.length?zr(t,Cu,li):r},dr.minBy=function(t,e){return t&&t.length?zr(t,Lo(e,2),li):r},dr.stubArray=zu,dr.stubFalse=Yu,dr.stubObject=function(){return{}},dr.stubString=function(){return""},dr.stubTrue=function(){return!0},dr.multiply=Ku,dr.nth=function(t,e){return t&&t.length?yi(t,Us(e)):r},dr.noConflict=function(){return Oe._===this&&(Oe._=ge),this},dr.noop=Bu,dr.now=Qa,dr.pad=function(t,e,n){t=Hs(t);var r=(e=Us(e))?Dn(t):0;if(!e||r>=e)return t;var i=(e-r)/2;return mo(qn(i),n)+t+mo(Fn(i),n)},dr.padEnd=function(t,e,n){t=Hs(t);var r=(e=Us(e))?Dn(t):0;return e&&r<e?t+mo(e-r,n):t},dr.padStart=function(t,e,n){t=Hs(t);var r=(e=Us(e))?Dn(t):0;return e&&r<e?mo(e-r,n)+t:t},dr.parseInt=function(t,e,n){return n||null==e?e=0:e&&(e=+e),Wn(Hs(t).replace(It,""),e||0)},dr.random=function(t,e,n){if(n&&"boolean"!=typeof n&&Go(t,e,n)&&(e=n=r),n===r&&("boolean"==typeof e?(n=e,e=r):"boolean"==typeof t&&(n=t,t=r)),t===r&&e===r?(t=0,e=1):(t=js(t),e===r?(e=t,t=0):e=js(e)),t>e){var i=t;t=e,e=i}if(n||t%1||e%1){var o=Kn();return $n(t+o*(e-t+Te("1e-"+((o+"").length-1))),e)}return wi(t,e)},dr.reduce=function(t,e,n){var r=bs(t)?Qe:hn,i=arguments.length<3;return r(t,Lo(e,4),n,i,qr)},dr.reduceRight=function(t,e,n){var r=bs(t)?tn:hn,i=arguments.length<3;return r(t,Lo(e,4),n,i,jr)},dr.repeat=function(t,e,n){return e=(n?Go(t,e,n):e===r)?1:Us(e),xi(Hs(t),e)},dr.replace=function(){var t=arguments,e=Hs(t[0]);return t.length<3?e:e.replace(t[1],t[2])},dr.result=function(t,e,n){var i=-1,o=(e=$i(e,t)).length;for(o||(o=1,t=r);++i<o;){var a=null==t?r:t[fa(e[i])];a===r&&(i=o,a=n),t=Es(a)?a.call(t):a}return t},dr.round=Xu,dr.runInContext=t,dr.sample=function(t){return(bs(t)?Er:Ei)(t)},dr.size=function(t){if(null==t)return 0;if(vs(t))return Ns(t)?Dn(t):t.length;var e=zo(t);return e==W||e==tt?t.size:ci(t).length},dr.snakeCase=_u,dr.some=function(t,e,n){var i=bs(t)?en:Oi;return n&&Go(t,e,n)&&(e=r),i(t,Lo(e,3))},dr.sortedIndex=function(t,e){return Ri(t,e)},dr.sortedIndexBy=function(t,e,n){return Ii(t,e,Lo(n,2))},dr.sortedIndexOf=function(t,e){var n=null==t?0:t.length;if(n){var r=Ri(t,e);if(r<n&&ds(t[r],e))return r}return-1},dr.sortedLastIndex=function(t,e){return Ri(t,e,!0)},dr.sortedLastIndexBy=function(t,e,n){return Ii(t,e,Lo(n,2),!0)},dr.sortedLastIndexOf=function(t,e){if(null==t?0:t.length){var n=Ri(t,e,!0)-1;if(ds(t[n],e))return n}return-1},dr.startCase=wu,dr.startsWith=function(t,e,n){return t=Hs(t),n=null==n?0:Nr(Us(n),0,t.length),e=Li(e),t.slice(n,n+e.length)==e},dr.subtract=Zu,dr.sum=function(t){return t&&t.length?dn(t,Cu):0},dr.sumBy=function(t,e){return t&&t.length?dn(t,Lo(e,2)):0},dr.template=function(t,e,n){var i=dr.templateSettings;n&&Go(t,e,n)&&(e=r),t=Hs(t),e=Ws({},e,i,So);var o,a,s=Ws({},e.imports,i.imports,So),u=iu(s),c=yn(s,u),f=0,l=e.interpolate||Wt,h="__p += '",d=ne((e.escape||Wt).source+"|"+l.source+"|"+(l===St?jt:Wt).source+"|"+(e.evaluate||Wt).source+"|$","g"),p="//# sourceURL="+(fe.call(e,"sourceURL")?(e.sourceURL+"").replace(/[\r\n]/g," "):"lodash.templateSources["+ ++ke+"]")+"\n";t.replace(d,(function(e,n,r,i,s,u){return r||(r=i),h+=t.slice(f,u).replace(Kt,xn),n&&(o=!0,h+="' +\n__e("+n+") +\n'"),s&&(a=!0,h+="';\n"+s+";\n__p += '"),r&&(h+="' +\n((__t = ("+r+")) == null ? '' : __t) +\n'"),f=u+e.length,e})),h+="';\n";var g=fe.call(e,"variable")&&e.variable;g||(h="with (obj) {\n"+h+"\n}\n"),h=(a?h.replace(bt,""):h).replace(mt,"$1").replace(vt,"$1;"),h="function("+(g||"obj")+") {\n"+(g?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(o?", __e = _.escape":"")+(a?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+h+"return __p\n}";var y=Au((function(){return Qt(u,p+"return "+h).apply(r,c)}));if(y.source=h,ks(y))throw y;return y},dr.times=function(t,e){if((t=Us(t))<1||t>R)return[];var n=B,r=$n(t,B);e=Lo(e),t-=B;for(var i=pn(r,e);++n<t;)e(n);return i},dr.toFinite=js,dr.toInteger=Us,dr.toLength=zs,dr.toLower=function(t){return Hs(t).toLowerCase()},dr.toNumber=Ys,dr.toSafeInteger=function(t){return t?Nr(Us(t),-R,R):0===t?t:0},dr.toString=Hs,dr.toUpper=function(t){return Hs(t).toUpperCase()},dr.trim=function(t,e,n){if((t=Hs(t))&&(n||e===r))return t.replace(Rt,"");if(!t||!(e=Li(e)))return t;var i=Cn(t),o=Cn(e);return Wi(i,mn(i,o),vn(i,o)+1).join("")},dr.trimEnd=function(t,e,n){if((t=Hs(t))&&(n||e===r))return t.replace(Nt,"");if(!t||!(e=Li(e)))return t;var i=Cn(t);return Wi(i,0,vn(i,Cn(e))+1).join("")},dr.trimStart=function(t,e,n){if((t=Hs(t))&&(n||e===r))return t.replace(It,"");if(!t||!(e=Li(e)))return t;var i=Cn(t);return Wi(i,mn(i,Cn(e))).join("")},dr.truncate=function(t,e){var n=A,i=S;if(Ts(e)){var o="separator"in e?e.separator:o;n="length"in e?Us(e.length):n,i="omission"in e?Li(e.omission):i}var a=(t=Hs(t)).length;if(kn(t)){var s=Cn(t);a=s.length}if(n>=a)return t;var u=n-Dn(i);if(u<1)return i;var c=s?Wi(s,0,u).join(""):t.slice(0,u);if(o===r)return c+i;if(s&&(u+=c.length-u),Rs(o)){if(t.slice(u).search(o)){var f,l=c;for(o.global||(o=ne(o.source,Hs(Ut.exec(o))+"g")),o.lastIndex=0;f=o.exec(l);)var h=f.index;c=c.slice(0,h===r?u:h)}}else if(t.indexOf(Li(o),u)!=u){var d=c.lastIndexOf(o);d>-1&&(c=c.slice(0,d))}return c+i},dr.unescape=function(t){return(t=Hs(t))&&xt.test(t)?t.replace(_t,On):t},dr.uniqueId=function(t){var e=++le;return Hs(t)+e},dr.upperCase=xu,dr.upperFirst=ku,dr.each=Ha,dr.eachRight=$a,dr.first=va,Nu(dr,(Wu={},Gr(dr,(function(t,e){fe.call(dr.prototype,e)||(Wu[e]=t)})),Wu),{chain:!1}),dr.VERSION="4.17.15",He(["bind","bindKey","curry","curryRight","partial","partialRight"],(function(t){dr[t].placeholder=dr})),He(["drop","take"],(function(t,e){br.prototype[t]=function(n){n=n===r?1:Hn(Us(n),0);var i=this.__filtered__&&!e?new br(this):this.clone();return i.__filtered__?i.__takeCount__=$n(n,i.__takeCount__):i.__views__.push({size:$n(n,B),type:t+(i.__dir__<0?"Right":"")}),i},br.prototype[t+"Right"]=function(e){return this.reverse()[t](e).reverse()}})),He(["filter","map","takeWhile"],(function(t,e){var n=e+1,r=n==D||3==n;br.prototype[t]=function(t){var e=this.clone();return e.__iteratees__.push({iteratee:Lo(t,3),type:n}),e.__filtered__=e.__filtered__||r,e}})),He(["head","last"],(function(t,e){var n="take"+(e?"Right":"");br.prototype[t]=function(){return this[n](1).value()[0]}})),He(["initial","tail"],(function(t,e){var n="drop"+(e?"":"Right");br.prototype[t]=function(){return this.__filtered__?new br(this):this[n](1)}})),br.prototype.compact=function(){return this.filter(Cu)},br.prototype.find=function(t){return this.filter(t).head()},br.prototype.findLast=function(t){return this.reverse().find(t)},br.prototype.invokeMap=ki((function(t,e){return"function"==typeof t?new br(this):this.map((function(n){return ri(n,t,e)}))})),br.prototype.reject=function(t){return this.filter(us(Lo(t)))},br.prototype.slice=function(t,e){t=Us(t);var n=this;return n.__filtered__&&(t>0||e<0)?new br(n):(t<0?n=n.takeRight(-t):t&&(n=n.drop(t)),e!==r&&(n=(e=Us(e))<0?n.dropRight(-e):n.take(e-t)),n)},br.prototype.takeRightWhile=function(t){return this.reverse().takeWhile(t).reverse()},br.prototype.toArray=function(){return this.take(B)},Gr(br.prototype,(function(t,e){var n=/^(?:filter|find|map|reject)|While$/.test(e),i=/^(?:head|last)$/.test(e),o=dr[i?"take"+("last"==e?"Right":""):e],a=i||/^find/.test(e);o&&(dr.prototype[e]=function(){var e=this.__wrapped__,s=i?[1]:arguments,u=e instanceof br,c=s[0],f=u||bs(e),l=function(t){var e=o.apply(dr,Je([t],s));return i&&h?e[0]:e};f&&n&&"function"==typeof c&&1!=c.length&&(u=f=!1);var h=this.__chain__,d=!!this.__actions__.length,p=a&&!h,g=u&&!d;if(!a&&f){e=g?e:new br(this);var y=t.apply(e,s);return y.__actions__.push({func:ja,args:[l],thisArg:r}),new yr(y,h)}return p&&g?t.apply(this,s):(y=this.thru(l),p?i?y.value()[0]:y.value():y)})})),He(["pop","push","shift","sort","splice","unshift"],(function(t){var e=oe[t],n=/^(?:push|sort|unshift)$/.test(t)?"tap":"thru",r=/^(?:pop|shift)$/.test(t);dr.prototype[t]=function(){var t=arguments;if(r&&!this.__chain__){var i=this.value();return e.apply(bs(i)?i:[],t)}return this[n]((function(n){return e.apply(bs(n)?n:[],t)}))}})),Gr(br.prototype,(function(t,e){var n=dr[e];if(n){var r=n.name+"";fe.call(ir,r)||(ir[r]=[]),ir[r].push({name:e,func:n})}})),ir[po(r,y).name]=[{name:"wrapper",func:r}],br.prototype.clone=function(){var t=new br(this.__wrapped__);return t.__actions__=no(this.__actions__),t.__dir__=this.__dir__,t.__filtered__=this.__filtered__,t.__iteratees__=no(this.__iteratees__),t.__takeCount__=this.__takeCount__,t.__views__=no(this.__views__),t},br.prototype.reverse=function(){if(this.__filtered__){var t=new br(this);t.__dir__=-1,t.__filtered__=!0}else(t=this.clone()).__dir__*=-1;return t},br.prototype.value=function(){var t=this.__wrapped__.value(),e=this.__dir__,n=bs(t),r=e<0,i=n?t.length:0,o=function(t,e,n){var r=-1,i=n.length;for(;++r<i;){var o=n[r],a=o.size;switch(o.type){case"drop":t+=a;break;case"dropRight":e-=a;break;case"take":e=$n(e,t+a);break;case"takeRight":t=Hn(t,e-a)}}return{start:t,end:e}}(0,i,this.__views__),a=o.start,s=o.end,u=s-a,c=r?s:a-1,f=this.__iteratees__,l=f.length,h=0,d=$n(u,this.__takeCount__);if(!n||!r&&i==u&&d==u)return Ui(t,this.__actions__);var p=[];t:for(;u--&&h<d;){for(var g=-1,y=t[c+=e];++g<l;){var b=f[g],m=b.iteratee,v=b.type,_=m(y);if(v==C)y=_;else if(!_){if(v==D)continue t;break t}}p[h++]=y}return p},dr.prototype.at=Ua,dr.prototype.chain=function(){return qa(this)},dr.prototype.commit=function(){return new yr(this.value(),this.__chain__)},dr.prototype.next=function(){this.__values__===r&&(this.__values__=qs(this.value()));var t=this.__index__>=this.__values__.length;return{done:t,value:t?r:this.__values__[this.__index__++]}},dr.prototype.plant=function(t){for(var e,n=this;n instanceof gr;){var i=ha(n);i.__index__=0,i.__values__=r,e?o.__wrapped__=i:e=i;var o=i;n=n.__wrapped__}return o.__wrapped__=t,e},dr.prototype.reverse=function(){var t=this.__wrapped__;if(t instanceof br){var e=t;return this.__actions__.length&&(e=new br(this)),(e=e.reverse()).__actions__.push({func:ja,args:[Ta],thisArg:r}),new yr(e,this.__chain__)}return this.thru(Ta)},dr.prototype.toJSON=dr.prototype.valueOf=dr.prototype.value=function(){return Ui(this.__wrapped__,this.__actions__)},dr.prototype.first=dr.prototype.head,ln&&(dr.prototype[ln]=function(){return this}),dr}();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(Oe._=Rn,define((function(){return Rn}))):Ie?((Ie.exports=Rn)._=Rn,Re._=Rn):Oe._=Rn}).call(this)}).call(this,n(11),n(9)(t))},function(t,e,n){var r=n(66),i=n(67);t.exports=function(t,e,n,o){var a=!n;n||(n={});for(var s=-1,u=e.length;++s<u;){var c=e[s],f=o?o(n[c],t[c],c,n,t):void 0;void 0===f&&(f=t[c]),a?i(n,c,f):r(n,c,f)}return n}},function(t,e,n){var r=n(266),i=n(20),o=Object.prototype,a=o.hasOwnProperty,s=o.propertyIsEnumerable,u=r(function(){return arguments}())?r:function(t){return i(t)&&a.call(t,"callee")&&!s.call(t,"callee")};t.exports=u},function(t,e,n){var r=n(268),i=n(69),o=n(94),a=o&&o.isTypedArray,s=a?i(a):r;t.exports=s},function(t,e,n){var r=n(42),i=1/0;t.exports=function(t){if("string"==typeof t||r(t))return t;var e=t+"";return"0"==e&&1/t==-i?"-0":e}},function(t,e,n){"use strict";var r=n(2),i=n(111),o=n(118),a=n(119),s=n(31);function u(t){s.call(this,"digest"),this._hash=t}r(u,s),u.prototype._update=function(t){this._hash.update(t)},u.prototype._final=function(){return this._hash.digest()},t.exports=function(t){return"md5"===(t=t.toLowerCase())?new i:"rmd160"===t||"ripemd160"===t?new o:new u(a(t))}},function(t,e,n){(function(t){function n(t){return Object.prototype.toString.call(t)}e.isArray=function(t){return Array.isArray?Array.isArray(t):"[object Array]"===n(t)},e.isBoolean=function(t){return"boolean"==typeof t},e.isNull=function(t){return null===t},e.isNullOrUndefined=function(t){return null==t},e.isNumber=function(t){return"number"==typeof t},e.isString=function(t){return"string"==typeof t},e.isSymbol=function(t){return"symbol"==typeof t},e.isUndefined=function(t){return void 0===t},e.isRegExp=function(t){return"[object RegExp]"===n(t)},e.isObject=function(t){return"object"==typeof t&&null!==t},e.isDate=function(t){return"[object Date]"===n(t)},e.isError=function(t){return"[object Error]"===n(t)||t instanceof Error},e.isFunction=function(t){return"function"==typeof t},e.isPrimitive=function(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||void 0===t},e.isBuffer=t.isBuffer}).call(this,n(8).Buffer)},function(t,e,n){(function(e){t.exports=function(t,n){for(var r=Math.min(t.length,n.length),i=new e(r),o=0;o<r;++o)i[o]=t[o]^n[o];return i}}).call(this,n(8).Buffer)},function(t,e,n){"use strict";var r=n(21),i=n(15);function o(){this.pending=null,this.pendingTotal=0,this.blockSize=this.constructor.blockSize,this.outSize=this.constructor.outSize,this.hmacStrength=this.constructor.hmacStrength,this.padLength=this.constructor.padLength/8,this.endian="big",this._delta8=this.blockSize/8,this._delta32=this.blockSize/32}e.BlockHash=o,o.prototype.update=function(t,e){if(t=r.toArray(t,e),this.pending?this.pending=this.pending.concat(t):this.pending=t,this.pendingTotal+=t.length,this.pending.length>=this._delta8){var n=(t=this.pending).length%this._delta8;this.pending=t.slice(t.length-n,t.length),0===this.pending.length&&(this.pending=null),t=r.join32(t,0,t.length-n,this.endian);for(var i=0;i<t.length;i+=this._delta32)this._update(t,i,i+this._delta32)}return this},o.prototype.digest=function(t){return this.update(this._pad()),i(null===this.pending),this._digest(t)},o.prototype._pad=function(){var t=this.pendingTotal,e=this._delta8,n=e-(t+this.padLength)%e,r=new Array(n+this.padLength);r[0]=128;for(var i=1;i<n;i++)r[i]=0;if(t<<=3,"big"===this.endian){for(var o=8;o<this.padLength;o++)r[i++]=0;r[i++]=0,r[i++]=0,r[i++]=0,r[i++]=0,r[i++]=t>>>24&255,r[i++]=t>>>16&255,r[i++]=t>>>8&255,r[i++]=255&t}else for(r[i++]=255&t,r[i++]=t>>>8&255,r[i++]=t>>>16&255,r[i++]=t>>>24&255,r[i++]=0,r[i++]=0,r[i++]=0,r[i++]=0,o=8;o<this.padLength;o++)r[i++]=0;return r}},function(t,e,n){var r=e;r.bignum=n(5),r.define=n(482).define,r.base=n(58),r.constants=n(219),r.decoders=n(487),r.encoders=n(489)},function(t,e,n){var r=e;r.Reporter=n(484).Reporter,r.DecoderBuffer=n(218).DecoderBuffer,r.EncoderBuffer=n(218).EncoderBuffer,r.Node=n(485)},function(t,e,n){t.exports={graphlib:n(19),layout:n(347),debug:n(401),util:{time:n(10).time,notime:n(10).notime},version:n(402)}},function(t,e,n){(function(t,r){var i=function(){var t=function(t,e,n,r){for(n=n||{},r=t.length;r--;n[t[r]]=e);return n},e=[1,4],n=[1,3],r=[1,5],i=[1,8,9,10,11,26,89,90,91,92,93,94,106,107,110,111,112,114,115,121,122,123,124,125,126],o=[2,2],a=[1,12],s=[1,13],u=[1,14],c=[1,15],f=[1,22],l=[1,24],h=[1,25],d=[1,26],p=[1,27],g=[1,28],y=[1,40],b=[1,35],m=[1,37],v=[1,32],_=[1,36],w=[1,39],x=[1,43],k=[1,44],E=[1,45],A=[1,34],S=[1,38],T=[1,41],M=[1,42],D=[1,33],C=[1,50],O=[1,8,9,10,11,26,30,89,90,91,92,93,94,106,107,110,111,112,114,115,121,122,123,124,125,126],R=[1,54],I=[1,53],N=[1,55],B=[8,9,11,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82],L=[8,9,11,34,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82],P=[8,9,10,11,28,34,36,38,40,42,43,45,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,94,106,107,110,111,112,114,115,121,122,123,124,125,126],F=[94,106,107,110,111,112,114,115,121,122,123,124,125,126],q=[1,129],j=[1,149],U=[1,150],z=[1,151],Y=[1,152],V=[1,123],H=[1,125],$=[1,124],G=[1,120],W=[1,144],K=[1,145],X=[1,146],Z=[1,147],J=[1,148],Q=[1,153],tt=[1,154],et=[1,127],nt=[1,126],rt=[1,134],it=[1,137],ot=[1,135],at=[1,136],st=[1,130],ut=[1,142],ct=[1,141],ft=[1,122],lt=[1,132],ht=[1,133],dt=[1,138],pt=[1,139],gt=[1,140],yt=[1,143],bt=[49,83,94,106,107,110,111,112,114,115,121,122,123,124,125,126],mt=[8,9,10,11,26,30,89,90,91,92,93,94,106,107,110,111,112,114,115,121,122,123,124,125,126],vt=[1,171],_t=[1,173],wt=[1,174],xt=[8,9,10,11,12,13,26,28,29,30,37,39,41,42,44,46,50,51,53,55,57,59,61,63,65,66,67,69,71,73,83,89,90,91,92,93,94,95,98,105,106,107,110,111,112,114,115,117,121,122,123,124,125,126],kt=[8,9,10,11,13,94,106,107,110,111,112,114,115,121,122,123,124,125,126],Et=[10,107],At=[1,252],St=[1,256],Tt=[1,253],Mt=[1,257],Dt=[1,250],Ct=[1,247],Ot=[1,248],Rt=[1,249],It=[1,251],Nt=[1,254],Bt=[1,255],Lt=[8,9,11],Pt=[1,282],Ft=[8,9,11,107],qt=[8,9,10,11,89,101,105,106,107,110,111,112,113,114,115],jt={trace:function(){},yy:{},symbols_:{error:2,mermaidDoc:3,graphConfig:4,document:5,line:6,statement:7,SEMI:8,NEWLINE:9,SPACE:10,EOF:11,GRAPH:12,DIR:13,FirstStmtSeperator:14,ending:15,endToken:16,spaceList:17,spaceListNewline:18,verticeStatement:19,separator:20,styleStatement:21,linkStyleStatement:22,classDefStatement:23,classStatement:24,clickStatement:25,subgraph:26,text:27,SQS:28,SQE:29,end:30,link:31,node:32,vertex:33,STYLE_SEPARATOR:34,idString:35,PS:36,PE:37,"(-":38,"-)":39,DIAMOND_START:40,DIAMOND_STOP:41,TAGEND:42,TRAPSTART:43,TRAPEND:44,INVTRAPSTART:45,INVTRAPEND:46,linkStatement:47,arrowText:48,TESTSTR:49,"--":50,ARROW_POINT:51,START_DOUBLE_ARROW_POINT:52,ARROW_CIRCLE:53,START_DOUBLE_ARROW_CIRCLE:54,ARROW_CROSS:55,START_DOUBLE_ARROW_CROSS:56,ARROW_OPEN:57,"-.":58,DOTTED_ARROW_POINT:59,START_DOUBLE_DOTTED_ARROW_POINT:60,DOTTED_ARROW_CIRCLE:61,START_DOUBLE_DOTTED_ARROW_CIRCLE:62,DOTTED_ARROW_CROSS:63,START_DOUBLE_DOTTED_ARROW_CROSS:64,DOTTED_ARROW_OPEN:65,"==":66,THICK_ARROW_POINT:67,START_DOUBLE_THICK_ARROW_POINT:68,THICK_ARROW_CIRCLE:69,START_DOUBLE_THICK_ARROW_CIRCLE:70,THICK_ARROW_CROSS:71,START_DOUBLE_THICK_ARROW_CROSS:72,THICK_ARROW_OPEN:73,DOUBLE_ARROW_POINT:74,DOUBLE_ARROW_CIRCLE:75,DOUBLE_ARROW_CROSS:76,DOUBLE_DOTTED_ARROW_POINT:77,DOUBLE_DOTTED_ARROW_CIRCLE:78,DOUBLE_DOTTED_ARROW_CROSS:79,DOUBLE_THICK_ARROW_POINT:80,DOUBLE_THICK_ARROW_CIRCLE:81,DOUBLE_THICK_ARROW_CROSS:82,PIPE:83,textToken:84,STR:85,commentText:86,commentToken:87,keywords:88,STYLE:89,LINKSTYLE:90,CLASSDEF:91,CLASS:92,CLICK:93,DOWN:94,UP:95,textNoTags:96,textNoTagsToken:97,DEFAULT:98,stylesOpt:99,alphaNum:100,HEX:101,numList:102,INTERPOLATE:103,commentStatement:104,PCT:105,NUM:106,COMMA:107,style:108,styleComponent:109,ALPHA:110,COLON:111,MINUS:112,UNIT:113,BRKT:114,DOT:115,graphCodeTokens:116,TAGSTART:117,alphaNumToken:118,idStringToken:119,alphaNumStatement:120,PUNCTUATION:121,UNICODE_TEXT:122,PLUS:123,EQUALS:124,MULT:125,UNDERSCORE:126,QUOTE:127,$accept:0,$end:1},terminals_:{2:"error",8:"SEMI",9:"NEWLINE",10:"SPACE",11:"EOF",12:"GRAPH",13:"DIR",26:"subgraph",28:"SQS",29:"SQE",30:"end",34:"STYLE_SEPARATOR",36:"PS",37:"PE",38:"(-",39:"-)",40:"DIAMOND_START",41:"DIAMOND_STOP",42:"TAGEND",43:"TRAPSTART",44:"TRAPEND",45:"INVTRAPSTART",46:"INVTRAPEND",49:"TESTSTR",50:"--",51:"ARROW_POINT",52:"START_DOUBLE_ARROW_POINT",53:"ARROW_CIRCLE",54:"START_DOUBLE_ARROW_CIRCLE",55:"ARROW_CROSS",56:"START_DOUBLE_ARROW_CROSS",57:"ARROW_OPEN",58:"-.",59:"DOTTED_ARROW_POINT",60:"START_DOUBLE_DOTTED_ARROW_POINT",61:"DOTTED_ARROW_CIRCLE",62:"START_DOUBLE_DOTTED_ARROW_CIRCLE",63:"DOTTED_ARROW_CROSS",64:"START_DOUBLE_DOTTED_ARROW_CROSS",65:"DOTTED_ARROW_OPEN",66:"==",67:"THICK_ARROW_POINT",68:"START_DOUBLE_THICK_ARROW_POINT",69:"THICK_ARROW_CIRCLE",70:"START_DOUBLE_THICK_ARROW_CIRCLE",71:"THICK_ARROW_CROSS",72:"START_DOUBLE_THICK_ARROW_CROSS",73:"THICK_ARROW_OPEN",74:"DOUBLE_ARROW_POINT",75:"DOUBLE_ARROW_CIRCLE",76:"DOUBLE_ARROW_CROSS",77:"DOUBLE_DOTTED_ARROW_POINT",78:"DOUBLE_DOTTED_ARROW_CIRCLE",79:"DOUBLE_DOTTED_ARROW_CROSS",80:"DOUBLE_THICK_ARROW_POINT",81:"DOUBLE_THICK_ARROW_CIRCLE",82:"DOUBLE_THICK_ARROW_CROSS",83:"PIPE",85:"STR",89:"STYLE",90:"LINKSTYLE",91:"CLASSDEF",92:"CLASS",93:"CLICK",94:"DOWN",95:"UP",98:"DEFAULT",101:"HEX",103:"INTERPOLATE",105:"PCT",106:"NUM",107:"COMMA",110:"ALPHA",111:"COLON",112:"MINUS",113:"UNIT",114:"BRKT",115:"DOT",117:"TAGSTART",121:"PUNCTUATION",122:"UNICODE_TEXT",123:"PLUS",124:"EQUALS",125:"MULT",126:"UNDERSCORE",127:"QUOTE"},productions_:[0,[3,2],[5,0],[5,2],[6,1],[6,1],[6,1],[6,1],[6,1],[4,2],[4,2],[4,3],[15,2],[15,1],[16,1],[16,1],[16,1],[14,1],[14,1],[14,2],[18,2],[18,2],[18,1],[18,1],[17,2],[17,1],[7,2],[7,2],[7,2],[7,2],[7,2],[7,2],[7,9],[7,6],[7,4],[20,1],[20,1],[20,1],[19,3],[19,1],[32,1],[32,3],[33,4],[33,5],[33,6],[33,7],[33,4],[33,5],[33,4],[33,5],[33,4],[33,5],[33,6],[33,7],[33,4],[33,5],[33,4],[33,5],[33,4],[33,5],[33,4],[33,5],[33,4],[33,5],[33,1],[33,2],[31,2],[31,3],[31,3],[31,1],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[31,3],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[48,3],[27,1],[27,2],[27,1],[86,1],[86,2],[88,1],[88,1],[88,1],[88,1],[88,1],[88,1],[88,1],[88,1],[88,1],[88,1],[88,1],[96,1],[96,2],[23,5],[23,5],[24,5],[25,5],[25,7],[25,5],[25,7],[21,5],[21,5],[22,5],[22,5],[22,9],[22,9],[22,7],[22,7],[104,3],[102,1],[102,3],[99,1],[99,3],[108,1],[108,2],[109,1],[109,1],[109,1],[109,1],[109,1],[109,1],[109,1],[109,1],[109,1],[109,1],[109,1],[87,1],[87,1],[84,1],[84,1],[84,1],[84,1],[84,1],[84,1],[84,1],[97,1],[97,1],[97,1],[97,1],[35,1],[35,2],[100,1],[100,2],[120,1],[120,1],[120,1],[120,1],[118,1],[118,1],[118,1],[118,1],[118,1],[118,1],[118,1],[118,1],[118,1],[118,1],[118,1],[118,1],[119,1],[119,1],[119,1],[119,1],[119,1],[119,1],[119,1],[119,1],[119,1],[119,1],[119,1],[119,1],[119,1],[119,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1],[116,1]],performAction:function(t,e,n,r,i,o,a){var s=o.length-1;switch(i){case 2:this.$=[];break;case 3:o[s]!==[]&&o[s-1].push(o[s]),this.$=o[s-1];break;case 4:case 113:case 115:case 116:case 129:case 179:case 181:case 182:this.$=o[s];break;case 11:r.setDirection(o[s-1]),this.$=o[s-1];break;case 26:this.$=o[s-1];break;case 27:case 28:case 29:case 30:case 31:this.$=[];break;case 32:this.$=r.addSubGraph(o[s-6],o[s-1],o[s-4]);break;case 33:this.$=r.addSubGraph(o[s-3],o[s-1],o[s-3]);break;case 34:this.$=r.addSubGraph(void 0,o[s-1],void 0);break;case 38:r.addLink(o[s-2][0],o[s][0],o[s-1]),this.$=o[s].concat(o[s-2]);break;case 39:this.$=o[s];break;case 40:this.$=[o[s]];break;case 41:this.$=[o[s-2]],r.setClass(o[s-2],o[s]);break;case 42:this.$=o[s-3],r.addVertex(o[s-3],o[s-1],"square");break;case 43:this.$=o[s-4],r.addVertex(o[s-4],o[s-2],"square");break;case 44:this.$=o[s-5],r.addVertex(o[s-5],o[s-2],"circle");break;case 45:this.$=o[s-6],r.addVertex(o[s-6],o[s-3],"circle");break;case 46:this.$=o[s-3],r.addVertex(o[s-3],o[s-1],"ellipse");break;case 47:this.$=o[s-4],r.addVertex(o[s-4],o[s-2],"ellipse");break;case 48:this.$=o[s-3],r.addVertex(o[s-3],o[s-1],"round");break;case 49:this.$=o[s-4],r.addVertex(o[s-4],o[s-2],"round");break;case 50:this.$=o[s-3],r.addVertex(o[s-3],o[s-1],"diamond");break;case 51:this.$=o[s-4],r.addVertex(o[s-4],o[s-2],"diamond");break;case 52:this.$=o[s-5],r.addVertex(o[s-5],o[s-2],"hexagon");break;case 53:this.$=o[s-6],r.addVertex(o[s-6],o[s-3],"hexagon");break;case 54:this.$=o[s-3],r.addVertex(o[s-3],o[s-1],"odd");break;case 55:this.$=o[s-4],r.addVertex(o[s-4],o[s-2],"odd");break;case 56:this.$=o[s-3],r.addVertex(o[s-3],o[s-1],"trapezoid");break;case 57:this.$=o[s-4],r.addVertex(o[s-4],o[s-2],"trapezoid");break;case 58:this.$=o[s-3],r.addVertex(o[s-3],o[s-1],"inv_trapezoid");break;case 59:this.$=o[s-4],r.addVertex(o[s-4],o[s-2],"inv_trapezoid");break;case 60:this.$=o[s-3],r.addVertex(o[s-3],o[s-1],"lean_right");break;case 61:this.$=o[s-4],r.addVertex(o[s-4],o[s-2],"lean_right");break;case 62:this.$=o[s-3],r.addVertex(o[s-3],o[s-1],"lean_left");break;case 63:this.$=o[s-4],r.addVertex(o[s-4],o[s-2],"lean_left");break;case 64:this.$=o[s],r.addVertex(o[s]);break;case 65:this.$=o[s-1],r.addVertex(o[s-1]);break;case 66:o[s-1].text=o[s],this.$=o[s-1];break;case 67:case 68:o[s-2].text=o[s-1],this.$=o[s-2];break;case 69:this.$=o[s];break;case 70:this.$={type:"arrow",stroke:"normal",text:o[s-1]};break;case 71:this.$={type:"double_arrow_point",stroke:"normal",text:o[s-1]};break;case 72:this.$={type:"arrow_circle",stroke:"normal",text:o[s-1]};break;case 73:this.$={type:"double_arrow_circle",stroke:"normal",text:o[s-1]};break;case 74:this.$={type:"arrow_cross",stroke:"normal",text:o[s-1]};break;case 75:this.$={type:"double_arrow_cross",stroke:"normal",text:o[s-1]};break;case 76:this.$={type:"arrow_open",stroke:"normal",text:o[s-1]};break;case 77:this.$={type:"arrow",stroke:"dotted",text:o[s-1]};break;case 78:this.$={type:"double_arrow_point",stroke:"dotted",text:o[s-1]};break;case 79:this.$={type:"arrow_circle",stroke:"dotted",text:o[s-1]};break;case 80:this.$={type:"double_arrow_circle",stroke:"dotted",text:o[s-1]};break;case 81:this.$={type:"arrow_cross",stroke:"dotted",text:o[s-1]};break;case 82:this.$={type:"double_arrow_cross",stroke:"dotted",text:o[s-1]};break;case 83:this.$={type:"arrow_open",stroke:"dotted",text:o[s-1]};break;case 84:this.$={type:"arrow",stroke:"thick",text:o[s-1]};break;case 85:this.$={type:"double_arrow_point",stroke:"thick",text:o[s-1]};break;case 86:this.$={type:"arrow_circle",stroke:"thick",text:o[s-1]};break;case 87:this.$={type:"double_arrow_circle",stroke:"thick",text:o[s-1]};break;case 88:this.$={type:"arrow_cross",stroke:"thick",text:o[s-1]};break;case 89:this.$={type:"double_arrow_cross",stroke:"thick",text:o[s-1]};break;case 90:this.$={type:"arrow_open",stroke:"thick",text:o[s-1]};break;case 91:this.$={type:"arrow",stroke:"normal"};break;case 92:this.$={type:"double_arrow_point",stroke:"normal"};break;case 93:this.$={type:"arrow_circle",stroke:"normal"};break;case 94:this.$={type:"double_arrow_circle",stroke:"normal"};break;case 95:this.$={type:"arrow_cross",stroke:"normal"};break;case 96:this.$={type:"double_arrow_cross",stroke:"normal"};break;case 97:this.$={type:"arrow_open",stroke:"normal"};break;case 98:this.$={type:"arrow",stroke:"dotted"};break;case 99:this.$={type:"double_arrow_point",stroke:"dotted"};break;case 100:this.$={type:"arrow_circle",stroke:"dotted"};break;case 101:this.$={type:"double_arrow_circle",stroke:"dotted"};break;case 102:this.$={type:"arrow_cross",stroke:"dotted"};break;case 103:this.$={type:"double_arrow_cross",stroke:"dotted"};break;case 104:this.$={type:"arrow_open",stroke:"dotted"};break;case 105:this.$={type:"arrow",stroke:"thick"};break;case 106:this.$={type:"double_arrow_point",stroke:"thick"};break;case 107:this.$={type:"arrow_circle",stroke:"thick"};break;case 108:this.$={type:"double_arrow_circle",stroke:"thick"};break;case 109:this.$={type:"arrow_cross",stroke:"thick"};break;case 110:this.$={type:"double_arrow_cross",stroke:"thick"};break;case 111:this.$={type:"arrow_open",stroke:"thick"};break;case 112:this.$=o[s-1];break;case 114:case 117:case 130:case 180:this.$=o[s-1]+""+o[s];break;case 131:case 132:this.$=o[s-4],r.addClass(o[s-2],o[s]);break;case 133:this.$=o[s-4],r.setClass(o[s-2],o[s]);break;case 134:this.$=o[s-4],r.setClickEvent(o[s-2],o[s],void 0);break;case 135:this.$=o[s-6],r.setClickEvent(o[s-4],o[s-2],o[s]);break;case 136:this.$=o[s-4],r.setLink(o[s-2],o[s],void 0);break;case 137:this.$=o[s-6],r.setLink(o[s-4],o[s-2],o[s]);break;case 138:this.$=o[s-4],r.addVertex(o[s-2],void 0,void 0,o[s]);break;case 139:case 141:this.$=o[s-4],r.updateLink(o[s-2],o[s]);break;case 140:this.$=o[s-4],r.updateLink([o[s-2]],o[s]);break;case 142:this.$=o[s-8],r.updateLinkInterpolate([o[s-6]],o[s-2]),r.updateLink([o[s-6]],o[s]);break;case 143:this.$=o[s-8],r.updateLinkInterpolate(o[s-6],o[s-2]),r.updateLink(o[s-6],o[s]);break;case 144:this.$=o[s-6],r.updateLinkInterpolate([o[s-4]],o[s]);break;case 145:this.$=o[s-6],r.updateLinkInterpolate(o[s-4],o[s]);break;case 147:case 149:this.$=[o[s]];break;case 148:case 150:o[s-2].push(o[s]),this.$=o[s-2];break;case 152:this.$=o[s-1]+o[s];break;case 177:this.$=o[s];break;case 178:this.$=o[s-1]+""+o[s];break;case 183:this.$="v";break;case 184:this.$="-"}},table:[{3:1,4:2,9:e,10:n,12:r},{1:[3]},t(i,o,{5:6}),{4:7,9:e,10:n,12:r},{4:8,9:e,10:n,12:r},{13:[1,9]},{1:[2,1],6:10,7:11,8:a,9:s,10:u,11:c,19:16,21:17,22:18,23:19,24:20,25:21,26:f,32:23,33:29,35:30,89:l,90:h,91:d,92:p,93:g,94:y,106:b,107:m,110:v,111:_,112:w,114:x,115:k,119:31,121:E,122:A,123:S,124:T,125:M,126:D},t(i,[2,9]),t(i,[2,10]),{8:[1,47],9:[1,48],10:C,14:46,17:49},t(O,[2,3]),t(O,[2,4]),t(O,[2,5]),t(O,[2,6]),t(O,[2,7]),t(O,[2,8]),{8:R,9:I,11:N,20:51,31:52,47:56,50:[1,57],51:[1,69],52:[1,58],53:[1,71],54:[1,59],55:[1,73],56:[1,60],57:[1,75],58:[1,61],59:[1,76],60:[1,62],61:[1,78],62:[1,63],63:[1,80],64:[1,64],65:[1,82],66:[1,65],67:[1,83],68:[1,66],69:[1,85],70:[1,67],71:[1,87],72:[1,68],73:[1,89],74:[1,70],75:[1,72],76:[1,74],77:[1,77],78:[1,79],79:[1,81],80:[1,84],81:[1,86],82:[1,88]},{8:R,9:I,11:N,20:90},{8:R,9:I,11:N,20:91},{8:R,9:I,11:N,20:92},{8:R,9:I,11:N,20:93},{8:R,9:I,11:N,20:94},{8:R,9:I,10:[1,95],11:N,20:96},t(B,[2,39]),{10:[1,97]},{10:[1,98]},{10:[1,99]},{10:[1,100]},{10:[1,101]},t(B,[2,40],{34:[1,102]}),t(L,[2,64],{17:110,119:111,10:C,28:[1,103],36:[1,104],38:[1,105],40:[1,106],42:[1,107],43:[1,108],45:[1,109],94:y,106:b,107:m,110:v,111:_,112:w,114:x,115:k,121:E,122:A,123:S,124:T,125:M,126:D}),t(P,[2,177]),t(P,[2,197]),t(P,[2,198]),t(P,[2,199]),t(P,[2,200]),t(P,[2,201]),t(P,[2,202]),t(P,[2,203]),t(P,[2,204]),t(P,[2,205]),t(P,[2,206]),t(P,[2,207]),t(P,[2,208]),t(P,[2,209]),t(P,[2,210]),t(i,[2,11]),t(i,[2,17]),t(i,[2,18]),{9:[1,112]},t(L,[2,25],{17:113,10:C}),t(O,[2,26]),{32:114,33:29,35:30,94:y,106:b,107:m,110:v,111:_,112:w,114:x,115:k,119:31,121:E,122:A,123:S,124:T,125:M,126:D},t(O,[2,35]),t(O,[2,36]),t(O,[2,37]),t(F,[2,69],{48:115,49:[1,116],83:[1,117]}),{10:q,12:j,13:U,26:z,27:118,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:155,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:156,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:157,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:158,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:159,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:160,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:161,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:162,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:163,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:164,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:165,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(bt,[2,91]),t(bt,[2,92]),t(bt,[2,93]),t(bt,[2,94]),t(bt,[2,95]),t(bt,[2,96]),t(bt,[2,97]),t(bt,[2,98]),t(bt,[2,99]),t(bt,[2,100]),t(bt,[2,101]),t(bt,[2,102]),t(bt,[2,103]),t(bt,[2,104]),t(bt,[2,105]),t(bt,[2,106]),t(bt,[2,107]),t(bt,[2,108]),t(bt,[2,109]),t(bt,[2,110]),t(bt,[2,111]),t(O,[2,27]),t(O,[2,28]),t(O,[2,29]),t(O,[2,30]),t(O,[2,31]),{10:q,12:j,13:U,26:z,27:166,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(mt,o,{5:167}),{13:vt,94:_t,100:168,101:[1,169],106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:170,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{98:[1,175],102:176,106:[1,177]},{13:vt,94:_t,98:[1,178],100:179,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:170,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{13:vt,94:_t,100:180,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:170,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{13:vt,94:_t,100:181,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:170,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{35:182,94:y,106:b,107:m,110:v,111:_,112:w,114:x,115:k,119:31,121:E,122:A,123:S,124:T,125:M,126:D},{10:q,12:j,13:U,26:z,27:183,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:185,30:Y,36:[1,184],42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:186,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:187,30:Y,40:[1,188],42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:189,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:190,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:191,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(L,[2,65]),t(P,[2,178]),t(i,[2,19]),t(L,[2,24]),t(B,[2,38]),t(F,[2,66],{10:[1,192]}),{10:[1,193]},{10:q,12:j,13:U,26:z,27:194,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,51:[1,195],53:[1,196],55:[1,197],57:[1,198],66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(xt,[2,113]),t(xt,[2,115]),t(xt,[2,166]),t(xt,[2,167]),t(xt,[2,168]),t(xt,[2,169]),t(xt,[2,170]),t(xt,[2,171]),t(xt,[2,172]),t(xt,[2,173]),t(xt,[2,174]),t(xt,[2,175]),t(xt,[2,176]),t(xt,[2,185]),t(xt,[2,186]),t(xt,[2,187]),t(xt,[2,188]),t(xt,[2,189]),t(xt,[2,190]),t(xt,[2,191]),t(xt,[2,192]),t(xt,[2,193]),t(xt,[2,194]),t(xt,[2,195]),t(xt,[2,196]),t(xt,[2,118]),t(xt,[2,119]),t(xt,[2,120]),t(xt,[2,121]),t(xt,[2,122]),t(xt,[2,123]),t(xt,[2,124]),t(xt,[2,125]),t(xt,[2,126]),t(xt,[2,127]),t(xt,[2,128]),{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,51:[1,200],66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,53:[1,201],66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,55:[1,202],66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,59:[1,203],61:[1,204],63:[1,205],65:[1,206],66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,59:[1,207],66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,61:[1,208],66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,63:[1,209],66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,66:$,67:[1,210],69:[1,211],71:[1,212],73:[1,213],84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,66:$,67:[1,214],84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,66:$,69:[1,215],84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,66:$,71:[1,216],84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{8:R,9:I,10:q,11:N,12:j,13:U,20:218,26:z,28:[1,217],30:Y,42:V,50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{6:10,7:11,8:a,9:s,10:u,11:c,19:16,21:17,22:18,23:19,24:20,25:21,26:f,30:[1,219],32:23,33:29,35:30,89:l,90:h,91:d,92:p,93:g,94:y,106:b,107:m,110:v,111:_,112:w,114:x,115:k,119:31,121:E,122:A,123:S,124:T,125:M,126:D},{10:[1,220],13:vt,94:_t,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:221,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:[1,222]},t(kt,[2,179]),t(kt,[2,181]),t(kt,[2,182]),t(kt,[2,183]),t(kt,[2,184]),{10:[1,223]},{10:[1,224],107:[1,225]},t(Et,[2,147]),{10:[1,226]},{10:[1,227],13:vt,94:_t,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:221,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:[1,228],13:vt,94:_t,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:221,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:[1,229],13:vt,94:_t,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:221,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(B,[2,41],{119:111,94:y,106:b,107:m,110:v,111:_,112:w,114:x,115:k,121:E,122:A,123:S,124:T,125:M,126:D}),{10:q,12:j,13:U,26:z,29:[1,230],30:Y,42:V,50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:231,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,37:[1,232],42:V,50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,39:[1,233],42:V,50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,41:[1,234],42:V,50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,27:235,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,29:[1,236],30:Y,42:V,50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,44:[1,237],46:[1,238],50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{10:q,12:j,13:U,26:z,30:Y,42:V,44:[1,240],46:[1,239],50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(F,[2,68]),t(F,[2,67]),{10:q,12:j,13:U,26:z,30:Y,42:V,50:H,66:$,83:[1,241],84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(F,[2,70]),t(F,[2,72]),t(F,[2,74]),t(F,[2,76]),t(xt,[2,114]),t(F,[2,71]),t(F,[2,73]),t(F,[2,75]),t(F,[2,77]),t(F,[2,79]),t(F,[2,81]),t(F,[2,83]),t(F,[2,78]),t(F,[2,80]),t(F,[2,82]),t(F,[2,84]),t(F,[2,86]),t(F,[2,88]),t(F,[2,90]),t(F,[2,85]),t(F,[2,87]),t(F,[2,89]),{10:q,12:j,13:U,26:z,27:242,30:Y,42:V,50:H,66:$,84:119,85:G,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(mt,o,{5:243}),t(O,[2,34]),{10:At,89:St,99:244,101:Tt,105:Mt,106:Dt,108:245,109:246,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt},t(kt,[2,180]),{10:At,89:St,99:258,101:Tt,105:Mt,106:Dt,108:245,109:246,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt},{10:At,89:St,99:259,101:Tt,103:[1,260],105:Mt,106:Dt,108:245,109:246,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt},{10:At,89:St,99:261,101:Tt,103:[1,262],105:Mt,106:Dt,108:245,109:246,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt},{106:[1,263]},{10:At,89:St,99:264,101:Tt,105:Mt,106:Dt,108:245,109:246,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt},{10:At,89:St,99:265,101:Tt,105:Mt,106:Dt,108:245,109:246,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt},{13:vt,94:_t,100:266,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:170,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{13:vt,85:[1,268],94:_t,100:267,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:170,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(L,[2,42],{17:269,10:C}),{10:q,12:j,13:U,26:z,30:Y,37:[1,270],42:V,50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(L,[2,48],{17:271,10:C}),t(L,[2,46],{17:272,10:C}),t(L,[2,50],{17:273,10:C}),{10:q,12:j,13:U,26:z,30:Y,41:[1,274],42:V,50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},t(L,[2,54],{17:275,10:C}),t(L,[2,56],{17:276,10:C}),t(L,[2,60],{17:277,10:C}),t(L,[2,58],{17:278,10:C}),t(L,[2,62],{17:279,10:C}),t([10,94,106,107,110,111,112,114,115,121,122,123,124,125,126],[2,112]),{10:q,12:j,13:U,26:z,29:[1,280],30:Y,42:V,50:H,66:$,84:199,88:131,89:W,90:K,91:X,92:Z,93:J,94:Q,95:tt,97:121,98:et,105:nt,106:rt,107:it,110:ot,111:at,112:st,114:ut,115:ct,117:ft,118:128,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{6:10,7:11,8:a,9:s,10:u,11:c,19:16,21:17,22:18,23:19,24:20,25:21,26:f,30:[1,281],32:23,33:29,35:30,89:l,90:h,91:d,92:p,93:g,94:y,106:b,107:m,110:v,111:_,112:w,114:x,115:k,119:31,121:E,122:A,123:S,124:T,125:M,126:D},t(Lt,[2,138],{107:Pt}),t(Ft,[2,149],{109:283,10:At,89:St,101:Tt,105:Mt,106:Dt,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt}),t(qt,[2,151]),t(qt,[2,153]),t(qt,[2,154]),t(qt,[2,155]),t(qt,[2,156]),t(qt,[2,157]),t(qt,[2,158]),t(qt,[2,159]),t(qt,[2,160]),t(qt,[2,161]),t(qt,[2,162]),t(qt,[2,163]),t(Lt,[2,139],{107:Pt}),t(Lt,[2,140],{107:Pt}),{10:[1,284]},t(Lt,[2,141],{107:Pt}),{10:[1,285]},t(Et,[2,148]),t(Lt,[2,131],{107:Pt}),t(Lt,[2,132],{107:Pt}),t(Lt,[2,133],{118:172,120:221,13:vt,94:_t,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt}),t(Lt,[2,134],{118:172,120:221,10:[1,286],13:vt,94:_t,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt}),t(Lt,[2,136],{10:[1,287]}),t(L,[2,43]),{37:[1,288]},t(L,[2,49]),t(L,[2,47]),t(L,[2,51]),{41:[1,289]},t(L,[2,55]),t(L,[2,57]),t(L,[2,61]),t(L,[2,59]),t(L,[2,63]),{8:R,9:I,11:N,20:290},t(O,[2,33]),{10:At,89:St,101:Tt,105:Mt,106:Dt,108:291,109:246,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt},t(qt,[2,152]),{13:vt,94:_t,100:292,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:170,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{13:vt,94:_t,100:293,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,118:172,120:170,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt},{85:[1,294]},{85:[1,295]},t(L,[2,44],{17:296,10:C}),t(L,[2,52],{17:297,10:C}),t(mt,o,{5:298}),t(Ft,[2,150],{109:283,10:At,89:St,101:Tt,105:Mt,106:Dt,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt}),t(Lt,[2,144],{118:172,120:221,10:[1,299],13:vt,94:_t,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt}),t(Lt,[2,145],{118:172,120:221,10:[1,300],13:vt,94:_t,106:rt,107:it,110:ot,111:at,112:wt,114:ut,115:ct,121:lt,122:ht,123:dt,124:pt,125:gt,126:yt}),t(Lt,[2,135]),t(Lt,[2,137]),t(L,[2,45]),t(L,[2,53]),{6:10,7:11,8:a,9:s,10:u,11:c,19:16,21:17,22:18,23:19,24:20,25:21,26:f,30:[1,301],32:23,33:29,35:30,89:l,90:h,91:d,92:p,93:g,94:y,106:b,107:m,110:v,111:_,112:w,114:x,115:k,119:31,121:E,122:A,123:S,124:T,125:M,126:D},{10:At,89:St,99:302,101:Tt,105:Mt,106:Dt,108:245,109:246,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt},{10:At,89:St,99:303,101:Tt,105:Mt,106:Dt,108:245,109:246,110:Ct,111:Ot,112:Rt,113:It,114:Nt,115:Bt},t(O,[2,32]),t(Lt,[2,142],{107:Pt}),t(Lt,[2,143],{107:Pt})],defaultActions:{},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],r=[],i=[null],o=[],a=this.table,s="",u=0,c=0,f=0,l=2,h=1,d=o.slice.call(arguments,1),p=Object.create(this.lexer),g={yy:{}};for(var y in this.yy)Object.prototype.hasOwnProperty.call(this.yy,y)&&(g.yy[y]=this.yy[y]);p.setInput(t,g.yy),g.yy.lexer=p,g.yy.parser=this,void 0===p.yylloc&&(p.yylloc={});var b=p.yylloc;o.push(b);var m=p.options&&p.options.ranges;function v(){var t;return"number"!=typeof(t=r.pop()||p.lex()||h)&&(t instanceof Array&&(t=(r=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof g.yy.parseError?this.parseError=g.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var _,w,x,k,E,A,S,T,M,D={};;){if(x=n[n.length-1],this.defaultActions[x]?k=this.defaultActions[x]:(null==_&&(_=v()),k=a[x]&&a[x][_]),void 0===k||!k.length||!k[0]){var C="";for(A in M=[],a[x])this.terminals_[A]&&A>l&&M.push("'"+this.terminals_[A]+"'");C=p.showPosition?"Parse error on line "+(u+1)+":\n"+p.showPosition()+"\nExpecting "+M.join(", ")+", got '"+(this.terminals_[_]||_)+"'":"Parse error on line "+(u+1)+": Unexpected "+(_==h?"end of input":"'"+(this.terminals_[_]||_)+"'"),this.parseError(C,{text:p.match,token:this.terminals_[_]||_,line:p.yylineno,loc:b,expected:M})}if(k[0]instanceof Array&&k.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+_);switch(k[0]){case 1:n.push(_),i.push(p.yytext),o.push(p.yylloc),n.push(k[1]),_=null,w?(_=w,w=null):(c=p.yyleng,s=p.yytext,u=p.yylineno,b=p.yylloc,f>0&&f--);break;case 2:if(S=this.productions_[k[1]][1],D.$=i[i.length-S],D._$={first_line:o[o.length-(S||1)].first_line,last_line:o[o.length-1].last_line,first_column:o[o.length-(S||1)].first_column,last_column:o[o.length-1].last_column},m&&(D._$.range=[o[o.length-(S||1)].range[0],o[o.length-1].range[1]]),void 0!==(E=this.performAction.apply(D,[s,c,u,g.yy,k[1],i,o].concat(d))))return E;S&&(n=n.slice(0,-1*S*2),i=i.slice(0,-1*S),o=o.slice(0,-1*S)),n.push(this.productions_[k[1]][0]),i.push(D.$),o.push(D._$),T=a[n[n.length-2]][n[n.length-1]],n.push(T);break;case 3:return!0}}return!0}},Ut={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var r=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var i=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===r.length?this.yylloc.first_column:0)+r[r.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[i[0],i[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,r,i;if(this.options.backtrack_lexer&&(i={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(i.yylloc.range=this.yylloc.range.slice(0))),(r=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=r.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:r?r[r.length-1].length-r[r.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var o in i)this[o]=i[o];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,r;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var i=this._currentRules(),o=0;o<i.length;o++)if((n=this._input.match(this.rules[i[o]]))&&(!e||n[0].length>e[0].length)){if(e=n,r=o,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,i[o])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,i[r]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{},performAction:function(t,e,n,r){switch(n){case 0:break;case 1:this.begin("string");break;case 2:this.popState();break;case 3:return"STR";case 4:return 89;case 5:return 98;case 6:return 90;case 7:return 103;case 8:return 91;case 9:return 92;case 10:return 93;case 11:return t.lex.firstGraph()&&this.begin("dir"),12;case 12:return 26;case 13:return 30;case 14:case 15:case 16:case 17:case 18:case 19:case 20:case 21:case 22:case 23:return this.popState(),13;case 24:return 106;case 25:return 114;case 26:return 34;case 27:return 111;case 28:return 8;case 29:return 107;case 30:return 125;case 31:return 55;case 32:return 51;case 33:return 74;case 34:return 76;case 35:return 75;case 36:return 78;case 37:return 80;case 38:return 81;case 39:return 82;case 40:case 41:return 79;case 42:case 43:return 77;case 44:return 78;case 45:return 53;case 46:return 57;case 47:return 63;case 48:return 59;case 49:return 61;case 50:return 65;case 51:return 63;case 52:return 59;case 53:return 61;case 54:return 65;case 55:return 71;case 56:return 67;case 57:return 69;case 58:return 73;case 59:return 52;case 60:return 56;case 61:return 54;case 62:return 60;case 63:return 64;case 64:return 62;case 65:return 68;case 66:return 72;case 67:return 70;case 68:return 50;case 69:return 58;case 70:return 66;case 71:return 38;case 72:return 39;case 73:return 112;case 74:return 115;case 75:return 126;case 76:return 123;case 77:return 105;case 78:case 79:return 124;case 80:return 117;case 81:return 42;case 82:return 95;case 83:return 94;case 84:return 110;case 85:return 44;case 86:return 43;case 87:return 46;case 88:return 45;case 89:return 121;case 90:return 122;case 91:return 83;case 92:return 36;case 93:return 37;case 94:return 28;case 95:return 29;case 96:return 40;case 97:return 41;case 98:return 127;case 99:return 9;case 100:return 10;case 101:return 11}},rules:[/^(?:%%[^\n]*)/,/^(?:["])/,/^(?:["])/,/^(?:[^"]*)/,/^(?:style\b)/,/^(?:default\b)/,/^(?:linkStyle\b)/,/^(?:interpolate\b)/,/^(?:classDef\b)/,/^(?:class\b)/,/^(?:click\b)/,/^(?:graph\b)/,/^(?:subgraph\b)/,/^(?:end\b\s*)/,/^(?:\s*LR\b)/,/^(?:\s*RL\b)/,/^(?:\s*TB\b)/,/^(?:\s*BT\b)/,/^(?:\s*TD\b)/,/^(?:\s*BR\b)/,/^(?:\s*<)/,/^(?:\s*>)/,/^(?:\s*\^)/,/^(?:\s*v\b)/,/^(?:[0-9]+)/,/^(?:#)/,/^(?::::)/,/^(?::)/,/^(?:;)/,/^(?:,)/,/^(?:\*)/,/^(?:\s*--[x]\s*)/,/^(?:\s*-->\s*)/,/^(?:\s*<-->\s*)/,/^(?:\s*[x]--[x]\s*)/,/^(?:\s*[o]--[o]\s*)/,/^(?:\s*[o]\.-[o]\s*)/,/^(?:\s*<==>\s*)/,/^(?:\s*[o]==[o]\s*)/,/^(?:\s*[x]==[x]\s*)/,/^(?:\s*[x].-[x]\s*)/,/^(?:\s*[x]-\.-[x]\s*)/,/^(?:\s*<\.->\s*)/,/^(?:\s*<-\.->\s*)/,/^(?:\s*[o]-\.-[o]\s*)/,/^(?:\s*--[o]\s*)/,/^(?:\s*---\s*)/,/^(?:\s*-\.-[x]\s*)/,/^(?:\s*-\.->\s*)/,/^(?:\s*-\.-[o]\s*)/,/^(?:\s*-\.-\s*)/,/^(?:\s*.-[x]\s*)/,/^(?:\s*\.->\s*)/,/^(?:\s*\.-[o]\s*)/,/^(?:\s*\.-\s*)/,/^(?:\s*==[x]\s*)/,/^(?:\s*==>\s*)/,/^(?:\s*==[o]\s*)/,/^(?:\s*==[\=]\s*)/,/^(?:\s*<--\s*)/,/^(?:\s*[x]--\s*)/,/^(?:\s*[o]--\s*)/,/^(?:\s*<-\.\s*)/,/^(?:\s*[x]-\.\s*)/,/^(?:\s*[o]-\.\s*)/,/^(?:\s*<==\s*)/,/^(?:\s*[x]==\s*)/,/^(?:\s*[o]==\s*)/,/^(?:\s*--\s*)/,/^(?:\s*-\.\s*)/,/^(?:\s*==\s*)/,/^(?:\(-)/,/^(?:-\))/,/^(?:-)/,/^(?:\.)/,/^(?:[\_])/,/^(?:\+)/,/^(?:%)/,/^(?:=)/,/^(?:=)/,/^(?:<)/,/^(?:>)/,/^(?:\^)/,/^(?:v\b)/,/^(?:[A-Za-z]+)/,/^(?:\\\])/,/^(?:\[\/)/,/^(?:\/\])/,/^(?:\[\\)/,/^(?:[!"#$%&'*+,-.`?\\_\/])/,/^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,/^(?:\|)/,/^(?:\()/,/^(?:\))/,/^(?:\[)/,/^(?:\])/,/^(?:\{)/,/^(?:\})/,/^(?:")/,/^(?:(\r|\n|\r\n)+)/,/^(?:\s)/,/^(?:$)/],conditions:{dir:{rules:[14,15,16,17,18,19,20,21,22,23],inclusive:!1},string:{rules:[2,3],inclusive:!1},INITIAL:{rules:[0,1,4,5,6,7,8,9,10,11,12,13,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101],inclusive:!0}}};function zt(){this.yy={}}return jt.lexer=Ut,zt.prototype=jt,jt.Parser=zt,new zt}();e.parser=i,e.Parser=i.Parser,e.parse=function(){return i.parse.apply(i,arguments)},e.main=function(r){r[1]||(console.log("Usage: "+r[0]+" FILE"),t.exit(1));var i=n(28).readFileSync(n(29).normalize(r[1]),"utf8");return e.parser.parse(i)},n.c[n.s]===r&&e.main(t.argv.slice(1))}).call(this,n(7),n(9)(t))},function(t,e,n){var r=n(62),i=n(241),o=n(242),a=n(243),s=n(244),u=n(245);function c(t){var e=this.__data__=new r(t);this.size=e.size}c.prototype.clear=i,c.prototype.delete=o,c.prototype.get=a,c.prototype.has=s,c.prototype.set=u,t.exports=c},function(t,e,n){var r=n(236),i=n(237),o=n(238),a=n(239),s=n(240);function u(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}u.prototype.clear=r,u.prototype.delete=i,u.prototype.get=o,u.prototype.has=a,u.prototype.set=s,t.exports=u},function(t,e,n){var r=n(36);t.exports=function(t,e){for(var n=t.length;n--;)if(r(t[n][0],e))return n;return-1}},function(t,e,n){var r=n(32)(Object,"create");t.exports=r},function(t,e,n){var r=n(260);t.exports=function(t,e){var n=t.__data__;return r(e)?n["string"==typeof e?"string":"hash"]:n.map}},function(t,e,n){var r=n(67),i=n(36),o=Object.prototype.hasOwnProperty;t.exports=function(t,e,n){var a=t[e];o.call(t,e)&&i(a,n)&&(void 0!==n||e in t)||r(t,e,n)}},function(t,e,n){var r=n(133);t.exports=function(t,e,n){"__proto__"==e&&r?r(t,e,{configurable:!0,enumerable:!0,value:n,writable:!0}):t[e]=n}},function(t,e){var n=9007199254740991,r=/^(?:0|[1-9]\d*)$/;t.exports=function(t,e){var i=typeof t;return!!(e=null==e?n:e)&&("number"==i||"symbol"!=i&&r.test(t))&&t>-1&&t%1==0&&t<e}},function(t,e){t.exports=function(t){return function(e){return t(e)}}},function(t,e){var n=Object.prototype;t.exports=function(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||n)}},function(t,e,n){var r=n(135)(Object.getPrototypeOf,Object);t.exports=r},function(t,e,n){var r=n(101),i=n(289)(r);t.exports=i},function(t,e,n){var r=n(6),i=n(105),o=n(303),a=n(157);t.exports=function(t,e){return r(t)?t:i(t,e)?[t]:o(a(t))}},function(t,e){t.exports=function(t,e){for(var n=-1,r=null==t?0:t.length,i=Array(r);++n<r;)i[n]=e(t[n],n,t);return i}},function(t,e,n){var r=n(34),i=n(165),o=n(166);t.exports=function(t,e){return o(i(t,e,r),t+"")}},function(t,e,n){var r=n(36),i=n(24),o=n(68),a=n(13);t.exports=function(t,e,n){if(!a(n))return!1;var s=typeof e;return!!("number"==s?i(n)&&o(e,n.length):"string"==s&&e in n)&&r(n[e],t)}},function(t,e,n){"use strict";var r=n(4);t.exports={longestPath:function(t){var e={};r.forEach(t.sources(),(function n(i){var o=t.node(i);if(r.has(e,i))return o.rank;e[i]=!0;var a=r.min(r.map(t.outEdges(i),(function(e){return n(e.w)-t.edge(e).minlen})));return a!==Number.POSITIVE_INFINITY&&null!=a||(a=0),o.rank=a}))},slack:function(t,e){return t.node(e.w).rank-t.node(e.v).rank-t.edge(e).minlen}}},function(t,e,n){"use strict";(function(e){void 0===e||!e.version||0===e.version.indexOf("v0.")||0===e.version.indexOf("v1.")&&0!==e.version.indexOf("v1.8.")?t.exports={nextTick:function(t,n,r,i){if("function"!=typeof t)throw new TypeError('"callback" argument must be a function');var o,a,s=arguments.length;switch(s){case 0:case 1:return e.nextTick(t);case 2:return e.nextTick((function(){t.call(null,n)}));case 3:return e.nextTick((function(){t.call(null,n,r)}));case 4:return e.nextTick((function(){t.call(null,n,r,i)}));default:for(o=new Array(s-1),a=0;a<o.length;)o[a++]=arguments[a];return e.nextTick((function(){t.apply(null,o)}))}}}:t.exports=e}).call(this,n(7))},function(t,e,n){var r=n(3).Buffer;function i(t){r.isBuffer(t)||(t=r.from(t));for(var e=t.length/4|0,n=new Array(e),i=0;i<e;i++)n[i]=t.readUInt32BE(4*i);return n}function o(t){for(;0<t.length;t++)t[0]=0}function a(t,e,n,r,i){for(var o,a,s,u,c=n[0],f=n[1],l=n[2],h=n[3],d=t[0]^e[0],p=t[1]^e[1],g=t[2]^e[2],y=t[3]^e[3],b=4,m=1;m<i;m++)o=c[d>>>24]^f[p>>>16&255]^l[g>>>8&255]^h[255&y]^e[b++],a=c[p>>>24]^f[g>>>16&255]^l[y>>>8&255]^h[255&d]^e[b++],s=c[g>>>24]^f[y>>>16&255]^l[d>>>8&255]^h[255&p]^e[b++],u=c[y>>>24]^f[d>>>16&255]^l[p>>>8&255]^h[255&g]^e[b++],d=o,p=a,g=s,y=u;return o=(r[d>>>24]<<24|r[p>>>16&255]<<16|r[g>>>8&255]<<8|r[255&y])^e[b++],a=(r[p>>>24]<<24|r[g>>>16&255]<<16|r[y>>>8&255]<<8|r[255&d])^e[b++],s=(r[g>>>24]<<24|r[y>>>16&255]<<16|r[d>>>8&255]<<8|r[255&p])^e[b++],u=(r[y>>>24]<<24|r[d>>>16&255]<<16|r[p>>>8&255]<<8|r[255&g])^e[b++],[o>>>=0,a>>>=0,s>>>=0,u>>>=0]}var s=[0,1,2,4,8,16,32,64,128,27,54],u=function(){for(var t=new Array(256),e=0;e<256;e++)t[e]=e<128?e<<1:e<<1^283;for(var n=[],r=[],i=[[],[],[],[]],o=[[],[],[],[]],a=0,s=0,u=0;u<256;++u){var c=s^s<<1^s<<2^s<<3^s<<4;c=c>>>8^255&c^99,n[a]=c,r[c]=a;var f=t[a],l=t[f],h=t[l],d=257*t[c]^16843008*c;i[0][a]=d<<24|d>>>8,i[1][a]=d<<16|d>>>16,i[2][a]=d<<8|d>>>24,i[3][a]=d,d=16843009*h^65537*l^257*f^16843008*a,o[0][c]=d<<24|d>>>8,o[1][c]=d<<16|d>>>16,o[2][c]=d<<8|d>>>24,o[3][c]=d,0===a?a=s=1:(a=f^t[t[t[h^f]]],s^=t[t[s]])}return{SBOX:n,INV_SBOX:r,SUB_MIX:i,INV_SUB_MIX:o}}();function c(t){this._key=i(t),this._reset()}c.blockSize=16,c.keySize=32,c.prototype.blockSize=c.blockSize,c.prototype.keySize=c.keySize,c.prototype._reset=function(){for(var t=this._key,e=t.length,n=e+6,r=4*(n+1),i=[],o=0;o<e;o++)i[o]=t[o];for(o=e;o<r;o++){var a=i[o-1];o%e==0?(a=a<<8|a>>>24,a=u.SBOX[a>>>24]<<24|u.SBOX[a>>>16&255]<<16|u.SBOX[a>>>8&255]<<8|u.SBOX[255&a],a^=s[o/e|0]<<24):e>6&&o%e==4&&(a=u.SBOX[a>>>24]<<24|u.SBOX[a>>>16&255]<<16|u.SBOX[a>>>8&255]<<8|u.SBOX[255&a]),i[o]=i[o-e]^a}for(var c=[],f=0;f<r;f++){var l=r-f,h=i[l-(f%4?0:4)];c[f]=f<4||l<=4?h:u.INV_SUB_MIX[0][u.SBOX[h>>>24]]^u.INV_SUB_MIX[1][u.SBOX[h>>>16&255]]^u.INV_SUB_MIX[2][u.SBOX[h>>>8&255]]^u.INV_SUB_MIX[3][u.SBOX[255&h]]}this._nRounds=n,this._keySchedule=i,this._invKeySchedule=c},c.prototype.encryptBlockRaw=function(t){return a(t=i(t),this._keySchedule,u.SUB_MIX,u.SBOX,this._nRounds)},c.prototype.encryptBlock=function(t){var e=this.encryptBlockRaw(t),n=r.allocUnsafe(16);return n.writeUInt32BE(e[0],0),n.writeUInt32BE(e[1],4),n.writeUInt32BE(e[2],8),n.writeUInt32BE(e[3],12),n},c.prototype.decryptBlock=function(t){var e=(t=i(t))[1];t[1]=t[3],t[3]=e;var n=a(t,this._invKeySchedule,u.INV_SUB_MIX,u.INV_SBOX,this._nRounds),o=r.allocUnsafe(16);return o.writeUInt32BE(n[0],0),o.writeUInt32BE(n[3],4),o.writeUInt32BE(n[2],8),o.writeUInt32BE(n[1],12),o},c.prototype.scrub=function(){o(this._keySchedule),o(this._invKeySchedule),o(this._key)},t.exports.AES=c},function(t,e,n){var r=n(3).Buffer,i=n(111);t.exports=function(t,e,n,o){if(r.isBuffer(t)||(t=r.from(t,"binary")),e&&(r.isBuffer(e)||(e=r.from(e,"binary")),8!==e.length))throw new RangeError("salt should be Buffer with 8 byte length");for(var a=n/8,s=r.alloc(a),u=r.alloc(o||0),c=r.alloc(0);a>0||o>0;){var f=new i;f.update(c),f.update(t),e&&f.update(e),c=f.digest();var l=0;if(a>0){var h=s.length-a;l=Math.min(a,c.length),c.copy(s,h,0,l),a-=l}if(l<c.length&&o>0){var d=u.length-o,p=Math.min(o,c.length-l);c.copy(u,d,l,l+p),o-=p}}return c.fill(0),{key:s,iv:u}}},function(t,e,n){"use strict";var r=n(5),i=n(16),o=i.getNAF,a=i.getJSF,s=i.assert;function u(t,e){this.type=t,this.p=new r(e.p,16),this.red=e.prime?r.red(e.prime):r.mont(this.p),this.zero=new r(0).toRed(this.red),this.one=new r(1).toRed(this.red),this.two=new r(2).toRed(this.red),this.n=e.n&&new r(e.n,16),this.g=e.g&&this.pointFromJSON(e.g,e.gRed),this._wnafT1=new Array(4),this._wnafT2=new Array(4),this._wnafT3=new Array(4),this._wnafT4=new Array(4);var n=this.n&&this.p.div(this.n);!n||n.cmpn(100)>0?this.redN=null:(this._maxwellTrick=!0,this.redN=this.n.toRed(this.red))}function c(t,e){this.curve=t,this.type=e,this.precomputed=null}t.exports=u,u.prototype.point=function(){throw new Error("Not implemented")},u.prototype.validate=function(){throw new Error("Not implemented")},u.prototype._fixedNafMul=function(t,e){s(t.precomputed);var n=t._getDoubles(),r=o(e,1),i=(1<<n.step+1)-(n.step%2==0?2:1);i/=3;for(var a=[],u=0;u<r.length;u+=n.step){var c=0;for(e=u+n.step-1;e>=u;e--)c=(c<<1)+r[e];a.push(c)}for(var f=this.jpoint(null,null,null),l=this.jpoint(null,null,null),h=i;h>0;h--){for(u=0;u<a.length;u++){(c=a[u])===h?l=l.mixedAdd(n.points[u]):c===-h&&(l=l.mixedAdd(n.points[u].neg()))}f=f.add(l)}return f.toP()},u.prototype._wnafMul=function(t,e){var n=4,r=t._getNAFPoints(n);n=r.wnd;for(var i=r.points,a=o(e,n),u=this.jpoint(null,null,null),c=a.length-1;c>=0;c--){for(e=0;c>=0&&0===a[c];c--)e++;if(c>=0&&e++,u=u.dblp(e),c<0)break;var f=a[c];s(0!==f),u="affine"===t.type?f>0?u.mixedAdd(i[f-1>>1]):u.mixedAdd(i[-f-1>>1].neg()):f>0?u.add(i[f-1>>1]):u.add(i[-f-1>>1].neg())}return"affine"===t.type?u.toP():u},u.prototype._wnafMulAdd=function(t,e,n,r,i){for(var s=this._wnafT1,u=this._wnafT2,c=this._wnafT3,f=0,l=0;l<r;l++){var h=(A=e[l])._getNAFPoints(t);s[l]=h.wnd,u[l]=h.points}for(l=r-1;l>=1;l-=2){var d=l-1,p=l;if(1===s[d]&&1===s[p]){var g=[e[d],null,null,e[p]];0===e[d].y.cmp(e[p].y)?(g[1]=e[d].add(e[p]),g[2]=e[d].toJ().mixedAdd(e[p].neg())):0===e[d].y.cmp(e[p].y.redNeg())?(g[1]=e[d].toJ().mixedAdd(e[p]),g[2]=e[d].add(e[p].neg())):(g[1]=e[d].toJ().mixedAdd(e[p]),g[2]=e[d].toJ().mixedAdd(e[p].neg()));var y=[-3,-1,-5,-7,0,7,5,1,3],b=a(n[d],n[p]);f=Math.max(b[0].length,f),c[d]=new Array(f),c[p]=new Array(f);for(var m=0;m<f;m++){var v=0|b[0][m],_=0|b[1][m];c[d][m]=y[3*(v+1)+(_+1)],c[p][m]=0,u[d]=g}}else c[d]=o(n[d],s[d]),c[p]=o(n[p],s[p]),f=Math.max(c[d].length,f),f=Math.max(c[p].length,f)}var w=this.jpoint(null,null,null),x=this._wnafT4;for(l=f;l>=0;l--){for(var k=0;l>=0;){var E=!0;for(m=0;m<r;m++)x[m]=0|c[m][l],0!==x[m]&&(E=!1);if(!E)break;k++,l--}if(l>=0&&k++,w=w.dblp(k),l<0)break;for(m=0;m<r;m++){var A,S=x[m];0!==S&&(S>0?A=u[m][S-1>>1]:S<0&&(A=u[m][-S-1>>1].neg()),w="affine"===A.type?w.mixedAdd(A):w.add(A))}}for(l=0;l<r;l++)u[l]=null;return i?w:w.toP()},u.BasePoint=c,c.prototype.eq=function(){throw new Error("Not implemented")},c.prototype.validate=function(){return this.curve.validate(this)},u.prototype.decodePoint=function(t,e){t=i.toArray(t,e);var n=this.p.byteLength();if((4===t[0]||6===t[0]||7===t[0])&&t.length-1==2*n)return 6===t[0]?s(t[t.length-1]%2==0):7===t[0]&&s(t[t.length-1]%2==1),this.point(t.slice(1,1+n),t.slice(1+n,1+2*n));if((2===t[0]||3===t[0])&&t.length-1===n)return this.pointFromX(t.slice(1,1+n),3===t[0]);throw new Error("Unknown point format")},c.prototype.encodeCompressed=function(t){return this.encode(t,!0)},c.prototype._encode=function(t){var e=this.curve.p.byteLength(),n=this.getX().toArray("be",e);return t?[this.getY().isEven()?2:3].concat(n):[4].concat(n,this.getY().toArray("be",e))},c.prototype.encode=function(t,e){return i.encode(this._encode(e),t)},c.prototype.precompute=function(t){if(this.precomputed)return this;var e={doubles:null,naf:null,beta:null};return e.naf=this._getNAFPoints(8),e.doubles=this._getDoubles(4,t),e.beta=this._getBeta(),this.precomputed=e,this},c.prototype._hasDoubles=function(t){if(!this.precomputed)return!1;var e=this.precomputed.doubles;return!!e&&e.points.length>=Math.ceil((t.bitLength()+1)/e.step)},c.prototype._getDoubles=function(t,e){if(this.precomputed&&this.precomputed.doubles)return this.precomputed.doubles;for(var n=[this],r=this,i=0;i<e;i+=t){for(var o=0;o<t;o++)r=r.dbl();n.push(r)}return{step:t,points:n}},c.prototype._getNAFPoints=function(t){if(this.precomputed&&this.precomputed.naf)return this.precomputed.naf;for(var e=[this],n=(1<<t)-1,r=1===n?null:this.dbl(),i=1;i<n;i++)e[i]=e[i-1].add(r);return{wnd:t,points:e}},c.prototype._getBeta=function(){return null},c.prototype.dblp=function(t){for(var e=this,n=0;n<t;n++)e=e.dbl();return e}},function(t,e,n){var r=n(481),i=n(492),o=n(493),a=n(121),s=n(202),u=n(3).Buffer;function c(t){var e;"object"!=typeof t||u.isBuffer(t)||(e=t.passphrase,t=t.key),"string"==typeof t&&(t=u.from(t));var n,c,f=o(t,e),l=f.tag,h=f.data;switch(l){case"CERTIFICATE":c=r.certificate.decode(h,"der").tbsCertificate.subjectPublicKeyInfo;case"PUBLIC KEY":switch(c||(c=r.PublicKey.decode(h,"der")),n=c.algorithm.algorithm.join(".")){case"1.2.840.113549.1.1.1":return r.RSAPublicKey.decode(c.subjectPublicKey.data,"der");case"1.2.840.10045.2.1":return c.subjectPrivateKey=c.subjectPublicKey,{type:"ec",data:c};case"1.2.840.10040.4.1":return c.algorithm.params.pub_key=r.DSAparam.decode(c.subjectPublicKey.data,"der"),{type:"dsa",data:c.algorithm.params};default:throw new Error("unknown key id "+n)}throw new Error("unknown key type "+l);case"ENCRYPTED PRIVATE KEY":h=function(t,e){var n=t.algorithm.decrypt.kde.kdeparams.salt,r=parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(),10),o=i[t.algorithm.decrypt.cipher.algo.join(".")],c=t.algorithm.decrypt.cipher.iv,f=t.subjectPrivateKey,l=parseInt(o.split("-")[1],10)/8,h=s.pbkdf2Sync(e,n,r,l,"sha1"),d=a.createDecipheriv(o,h,c),p=[];return p.push(d.update(f)),p.push(d.final()),u.concat(p)}(h=r.EncryptedPrivateKey.decode(h,"der"),e);case"PRIVATE KEY":switch(n=(c=r.PrivateKey.decode(h,"der")).algorithm.algorithm.join(".")){case"1.2.840.113549.1.1.1":return r.RSAPrivateKey.decode(c.subjectPrivateKey,"der");case"1.2.840.10045.2.1":return{curve:c.algorithm.curve,privateKey:r.ECPrivateKey.decode(c.subjectPrivateKey,"der").privateKey};case"1.2.840.10040.4.1":return c.algorithm.params.priv_key=r.DSAparam.decode(c.subjectPrivateKey,"der"),{type:"dsa",params:c.algorithm.params};default:throw new Error("unknown key id "+n)}throw new Error("unknown key type "+l);case"RSA PUBLIC KEY":return r.RSAPublicKey.decode(h,"der");case"RSA PRIVATE KEY":return r.RSAPrivateKey.decode(h,"der");case"DSA PRIVATE KEY":return{type:"dsa",params:r.DSAPrivateKey.decode(h,"der")};case"EC PRIVATE KEY":return{curve:(h=r.ECPrivateKey.decode(h,"der")).parameters.value,privateKey:h.privateKey};default:throw new Error("unknown key type "+l)}}t.exports=c,c.signature=r.signature},function(t,e,n){"use strict";t.exports=function(t){var e=[];return e.toString=function(){return this.map((function(e){var n=function(t,e){var n=t[1]||"",r=t[3];if(!r)return n;if(e&&"function"==typeof btoa){var i=(a=r,"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+" */"),o=r.sources.map((function(t){return"/*# sourceURL="+r.sourceRoot+t+" */"}));return[n].concat(o).concat([i]).join("\n")}var a;return[n].join("\n")}(e,t);return e[2]?"@media "+e[2]+"{"+n+"}":n})).join("")},e.i=function(t,n){"string"==typeof t&&(t=[[null,t,""]]);for(var r={},i=0;i<this.length;i++){var o=this[i][0];null!=o&&(r[o]=!0)}for(i=0;i<t.length;i++){var a=t[i];null!=a[0]&&r[a[0]]||(n&&!a[2]?a[2]=n:n&&(a[2]="("+a[2]+") and ("+n+")"),e.push(a))}},e}},function(t,e,n){"use strict";var r=/^(%20|\s)*(javascript|data)/im,i=/[^\x20-\x7E]/gim,o=/^([^:]+):/gm,a=[".","/"];t.exports={sanitizeUrl:function(t){if(!t)return"about:blank";var e,n,s=t.replace(i,"").trim();return function(t){return a.indexOf(t[0])>-1}(s)?s:(n=s.match(o))?(e=n[0],r.test(e)?"about:blank":s):"about:blank"}}},function(t,e,n){(function(t,r){var i=function(){var t=function(t,e,n,r){for(n=n||{},r=t.length;r--;n[t[r]]=e);return n},e=[2,3],n=[1,7],r=[7,12,15,17,19,20,21],i=[7,11,12,15,17,19,20,21],o=[2,20],a=[1,32],s={trace:function(){},yy:{},symbols_:{error:2,start:3,GG:4,":":5,document:6,EOF:7,DIR:8,options:9,body:10,OPT:11,NL:12,line:13,statement:14,COMMIT:15,commit_arg:16,BRANCH:17,ID:18,CHECKOUT:19,MERGE:20,RESET:21,reset_arg:22,STR:23,HEAD:24,reset_parents:25,CARET:26,$accept:0,$end:1},terminals_:{2:"error",4:"GG",5:":",7:"EOF",8:"DIR",11:"OPT",12:"NL",15:"COMMIT",17:"BRANCH",18:"ID",19:"CHECKOUT",20:"MERGE",21:"RESET",23:"STR",24:"HEAD",26:"CARET"},productions_:[0,[3,4],[3,5],[6,0],[6,2],[9,2],[9,1],[10,0],[10,2],[13,2],[13,1],[14,2],[14,2],[14,2],[14,2],[14,2],[16,0],[16,1],[22,2],[22,2],[25,0],[25,2]],performAction:function(t,e,n,r,i,o,a){var s=o.length-1;switch(i){case 1:return o[s-1];case 2:return r.setDirection(o[s-3]),o[s-1];case 4:r.setOptions(o[s-1]),this.$=o[s];break;case 5:o[s-1]+=o[s],this.$=o[s-1];break;case 7:this.$=[];break;case 8:o[s-1].push(o[s]),this.$=o[s-1];break;case 9:this.$=o[s-1];break;case 11:r.commit(o[s]);break;case 12:r.branch(o[s]);break;case 13:r.checkout(o[s]);break;case 14:r.merge(o[s]);break;case 15:r.reset(o[s]);break;case 16:this.$="";break;case 17:this.$=o[s];break;case 18:this.$=o[s-1]+":"+o[s];break;case 19:this.$=o[s-1]+":"+r.count,r.count=0;break;case 20:r.count=0;break;case 21:r.count+=1}},table:[{3:1,4:[1,2]},{1:[3]},{5:[1,3],8:[1,4]},{6:5,7:e,9:6,12:n},{5:[1,8]},{7:[1,9]},t(r,[2,7],{10:10,11:[1,11]}),t(i,[2,6]),{6:12,7:e,9:6,12:n},{1:[2,1]},{7:[2,4],12:[1,15],13:13,14:14,15:[1,16],17:[1,17],19:[1,18],20:[1,19],21:[1,20]},t(i,[2,5]),{7:[1,21]},t(r,[2,8]),{12:[1,22]},t(r,[2,10]),{12:[2,16],16:23,23:[1,24]},{18:[1,25]},{18:[1,26]},{18:[1,27]},{18:[1,30],22:28,24:[1,29]},{1:[2,2]},t(r,[2,9]),{12:[2,11]},{12:[2,17]},{12:[2,12]},{12:[2,13]},{12:[2,14]},{12:[2,15]},{12:o,25:31,26:a},{12:o,25:33,26:a},{12:[2,18]},{12:o,25:34,26:a},{12:[2,19]},{12:[2,21]}],defaultActions:{9:[2,1],21:[2,2],23:[2,11],24:[2,17],25:[2,12],26:[2,13],27:[2,14],28:[2,15],31:[2,18],33:[2,19],34:[2,21]},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],r=[],i=[null],o=[],a=this.table,s="",u=0,c=0,f=0,l=2,h=1,d=o.slice.call(arguments,1),p=Object.create(this.lexer),g={yy:{}};for(var y in this.yy)Object.prototype.hasOwnProperty.call(this.yy,y)&&(g.yy[y]=this.yy[y]);p.setInput(t,g.yy),g.yy.lexer=p,g.yy.parser=this,void 0===p.yylloc&&(p.yylloc={});var b=p.yylloc;o.push(b);var m=p.options&&p.options.ranges;function v(){var t;return"number"!=typeof(t=r.pop()||p.lex()||h)&&(t instanceof Array&&(t=(r=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof g.yy.parseError?this.parseError=g.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var _,w,x,k,E,A,S,T,M,D={};;){if(x=n[n.length-1],this.defaultActions[x]?k=this.defaultActions[x]:(null==_&&(_=v()),k=a[x]&&a[x][_]),void 0===k||!k.length||!k[0]){var C="";for(A in M=[],a[x])this.terminals_[A]&&A>l&&M.push("'"+this.terminals_[A]+"'");C=p.showPosition?"Parse error on line "+(u+1)+":\n"+p.showPosition()+"\nExpecting "+M.join(", ")+", got '"+(this.terminals_[_]||_)+"'":"Parse error on line "+(u+1)+": Unexpected "+(_==h?"end of input":"'"+(this.terminals_[_]||_)+"'"),this.parseError(C,{text:p.match,token:this.terminals_[_]||_,line:p.yylineno,loc:b,expected:M})}if(k[0]instanceof Array&&k.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+_);switch(k[0]){case 1:n.push(_),i.push(p.yytext),o.push(p.yylloc),n.push(k[1]),_=null,w?(_=w,w=null):(c=p.yyleng,s=p.yytext,u=p.yylineno,b=p.yylloc,f>0&&f--);break;case 2:if(S=this.productions_[k[1]][1],D.$=i[i.length-S],D._$={first_line:o[o.length-(S||1)].first_line,last_line:o[o.length-1].last_line,first_column:o[o.length-(S||1)].first_column,last_column:o[o.length-1].last_column},m&&(D._$.range=[o[o.length-(S||1)].range[0],o[o.length-1].range[1]]),void 0!==(E=this.performAction.apply(D,[s,c,u,g.yy,k[1],i,o].concat(d))))return E;S&&(n=n.slice(0,-1*S*2),i=i.slice(0,-1*S),o=o.slice(0,-1*S)),n.push(this.productions_[k[1]][0]),i.push(D.$),o.push(D._$),T=a[n[n.length-2]][n[n.length-1]],n.push(T);break;case 3:return!0}}return!0}},u={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var r=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var i=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===r.length?this.yylloc.first_column:0)+r[r.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[i[0],i[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,r,i;if(this.options.backtrack_lexer&&(i={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(i.yylloc.range=this.yylloc.range.slice(0))),(r=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=r.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:r?r[r.length-1].length-r[r.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var o in i)this[o]=i[o];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,r;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var i=this._currentRules(),o=0;o<i.length;o++)if((n=this._input.match(this.rules[i[o]]))&&(!e||n[0].length>e[0].length)){if(e=n,r=o,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,i[o])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,i[r]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(t,e,n,r){switch(n){case 0:return 12;case 1:case 2:case 3:break;case 4:return 4;case 5:return 15;case 6:return 17;case 7:return 20;case 8:return 21;case 9:return 19;case 10:case 11:return 8;case 12:return 5;case 13:return 26;case 14:this.begin("options");break;case 15:this.popState();break;case 16:return 11;case 17:this.begin("string");break;case 18:this.popState();break;case 19:return 23;case 20:return 18;case 21:return 7}},rules:[/^(?:(\r?\n)+)/i,/^(?:\s+)/i,/^(?:#[^\n]*)/i,/^(?:%[^\n]*)/i,/^(?:gitGraph\b)/i,/^(?:commit\b)/i,/^(?:branch\b)/i,/^(?:merge\b)/i,/^(?:reset\b)/i,/^(?:checkout\b)/i,/^(?:LR\b)/i,/^(?:BT\b)/i,/^(?::)/i,/^(?:\^)/i,/^(?:options\r?\n)/i,/^(?:end\r?\n)/i,/^(?:[^\n]+\r?\n)/i,/^(?:["])/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?:[a-zA-Z][a-zA-Z0-9_]+)/i,/^(?:$)/i],conditions:{options:{rules:[15,16],inclusive:!1},string:{rules:[18,19],inclusive:!1},INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,17,20,21],inclusive:!0}}};function c(){this.yy={}}return s.lexer=u,c.prototype=s,s.Parser=c,new c}();e.parser=i,e.Parser=i.Parser,e.parse=function(){return i.parse.apply(i,arguments)},e.main=function(r){r[1]||(console.log("Usage: "+r[0]+" FILE"),t.exit(1));var i=n(28).readFileSync(n(29).normalize(r[1]),"utf8");return e.parser.parse(i)},n.c[n.s]===r&&e.main(t.argv.slice(1))}).call(this,n(7),n(9)(t))},function(t,e,n){(function(t,r){var i=function(){var t=function(t,e,n,r){for(n=n||{},r=t.length;r--;n[t[r]]=e);return n},e=[6,9,10],n={trace:function(){},yy:{},symbols_:{error:2,start:3,info:4,document:5,EOF:6,line:7,statement:8,NL:9,showInfo:10,$accept:0,$end:1},terminals_:{2:"error",4:"info",6:"EOF",9:"NL",10:"showInfo"},productions_:[0,[3,3],[5,0],[5,2],[7,1],[7,1],[8,1]],performAction:function(t,e,n,r,i,o,a){o.length;switch(i){case 1:return r;case 4:break;case 6:r.setInfo(!0)}},table:[{3:1,4:[1,2]},{1:[3]},t(e,[2,2],{5:3}),{6:[1,4],7:5,8:6,9:[1,7],10:[1,8]},{1:[2,1]},t(e,[2,3]),t(e,[2,4]),t(e,[2,5]),t(e,[2,6])],defaultActions:{4:[2,1]},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],r=[],i=[null],o=[],a=this.table,s="",u=0,c=0,f=0,l=2,h=1,d=o.slice.call(arguments,1),p=Object.create(this.lexer),g={yy:{}};for(var y in this.yy)Object.prototype.hasOwnProperty.call(this.yy,y)&&(g.yy[y]=this.yy[y]);p.setInput(t,g.yy),g.yy.lexer=p,g.yy.parser=this,void 0===p.yylloc&&(p.yylloc={});var b=p.yylloc;o.push(b);var m=p.options&&p.options.ranges;function v(){var t;return"number"!=typeof(t=r.pop()||p.lex()||h)&&(t instanceof Array&&(t=(r=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof g.yy.parseError?this.parseError=g.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var _,w,x,k,E,A,S,T,M,D={};;){if(x=n[n.length-1],this.defaultActions[x]?k=this.defaultActions[x]:(null==_&&(_=v()),k=a[x]&&a[x][_]),void 0===k||!k.length||!k[0]){var C="";for(A in M=[],a[x])this.terminals_[A]&&A>l&&M.push("'"+this.terminals_[A]+"'");C=p.showPosition?"Parse error on line "+(u+1)+":\n"+p.showPosition()+"\nExpecting "+M.join(", ")+", got '"+(this.terminals_[_]||_)+"'":"Parse error on line "+(u+1)+": Unexpected "+(_==h?"end of input":"'"+(this.terminals_[_]||_)+"'"),this.parseError(C,{text:p.match,token:this.terminals_[_]||_,line:p.yylineno,loc:b,expected:M})}if(k[0]instanceof Array&&k.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+_);switch(k[0]){case 1:n.push(_),i.push(p.yytext),o.push(p.yylloc),n.push(k[1]),_=null,w?(_=w,w=null):(c=p.yyleng,s=p.yytext,u=p.yylineno,b=p.yylloc,f>0&&f--);break;case 2:if(S=this.productions_[k[1]][1],D.$=i[i.length-S],D._$={first_line:o[o.length-(S||1)].first_line,last_line:o[o.length-1].last_line,first_column:o[o.length-(S||1)].first_column,last_column:o[o.length-1].last_column},m&&(D._$.range=[o[o.length-(S||1)].range[0],o[o.length-1].range[1]]),void 0!==(E=this.performAction.apply(D,[s,c,u,g.yy,k[1],i,o].concat(d))))return E;S&&(n=n.slice(0,-1*S*2),i=i.slice(0,-1*S),o=o.slice(0,-1*S)),n.push(this.productions_[k[1]][0]),i.push(D.$),o.push(D._$),T=a[n[n.length-2]][n[n.length-1]],n.push(T);break;case 3:return!0}}return!0}},r={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var r=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var i=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===r.length?this.yylloc.first_column:0)+r[r.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[i[0],i[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,r,i;if(this.options.backtrack_lexer&&(i={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(i.yylloc.range=this.yylloc.range.slice(0))),(r=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=r.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:r?r[r.length-1].length-r[r.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var o in i)this[o]=i[o];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,r;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var i=this._currentRules(),o=0;o<i.length;o++)if((n=this._input.match(this.rules[i[o]]))&&(!e||n[0].length>e[0].length)){if(e=n,r=o,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,i[o])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,i[r]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(t,e,n,r){switch(n){case 0:return 4;case 1:return 9;case 2:return"space";case 3:return 10;case 4:return 6;case 5:return"TXT"}},rules:[/^(?:info\b)/i,/^(?:[\s\n\r]+)/i,/^(?:[\s]+)/i,/^(?:showInfo\b)/i,/^(?:$)/i,/^(?:.)/i],conditions:{INITIAL:{rules:[0,1,2,3,4,5],inclusive:!0}}};function i(){this.yy={}}return n.lexer=r,i.prototype=n,n.Parser=i,new i}();e.parser=i,e.Parser=i.Parser,e.parse=function(){return i.parse.apply(i,arguments)},e.main=function(r){r[1]||(console.log("Usage: "+r[0]+" FILE"),t.exit(1));var i=n(28).readFileSync(n(29).normalize(r[1]),"utf8");return e.parser.parse(i)},n.c[n.s]===r&&e.main(t.argv.slice(1))}).call(this,n(7),n(9)(t))},function(t,e,n){(function(t,r){var i=function(){var t=function(t,e,n,r){for(n=n||{},r=t.length;r--;n[t[r]]=e);return n},e=[6,9,10,12],n={trace:function(){},yy:{},symbols_:{error:2,start:3,pie:4,document:5,EOF:6,line:7,statement:8,NL:9,STR:10,VALUE:11,title:12,$accept:0,$end:1},terminals_:{2:"error",4:"pie",6:"EOF",9:"NL",10:"STR",11:"VALUE",12:"title"},productions_:[0,[3,3],[5,0],[5,2],[7,1],[7,1],[8,2],[8,1]],performAction:function(t,e,n,r,i,o,a){var s=o.length-1;switch(i){case 4:break;case 6:console.log("str:"+o[s-1]+" value: "+o[s]),r.addSection(o[s-1],r.cleanupValue(o[s]));break;case 7:r.setTitle(o[s].substr(6)),this.$=o[s].substr(6)}},table:[{3:1,4:[1,2]},{1:[3]},t(e,[2,2],{5:3}),{6:[1,4],7:5,8:6,9:[1,7],10:[1,8],12:[1,9]},{1:[2,1]},t(e,[2,3]),t(e,[2,4]),t(e,[2,5]),{11:[1,10]},t(e,[2,7]),t(e,[2,6])],defaultActions:{4:[2,1]},parseError:function(t,e){if(!e.recoverable){var n=new Error(t);throw n.hash=e,n}this.trace(t)},parse:function(t){var e=this,n=[0],r=[],i=[null],o=[],a=this.table,s="",u=0,c=0,f=0,l=2,h=1,d=o.slice.call(arguments,1),p=Object.create(this.lexer),g={yy:{}};for(var y in this.yy)Object.prototype.hasOwnProperty.call(this.yy,y)&&(g.yy[y]=this.yy[y]);p.setInput(t,g.yy),g.yy.lexer=p,g.yy.parser=this,void 0===p.yylloc&&(p.yylloc={});var b=p.yylloc;o.push(b);var m=p.options&&p.options.ranges;function v(){var t;return"number"!=typeof(t=r.pop()||p.lex()||h)&&(t instanceof Array&&(t=(r=t).pop()),t=e.symbols_[t]||t),t}"function"==typeof g.yy.parseError?this.parseError=g.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;for(var _,w,x,k,E,A,S,T,M,D={};;){if(x=n[n.length-1],this.defaultActions[x]?k=this.defaultActions[x]:(null==_&&(_=v()),k=a[x]&&a[x][_]),void 0===k||!k.length||!k[0]){var C="";for(A in M=[],a[x])this.terminals_[A]&&A>l&&M.push("'"+this.terminals_[A]+"'");C=p.showPosition?"Parse error on line "+(u+1)+":\n"+p.showPosition()+"\nExpecting "+M.join(", ")+", got '"+(this.terminals_[_]||_)+"'":"Parse error on line "+(u+1)+": Unexpected "+(_==h?"end of input":"'"+(this.terminals_[_]||_)+"'"),this.parseError(C,{text:p.match,token:this.terminals_[_]||_,line:p.yylineno,loc:b,expected:M})}if(k[0]instanceof Array&&k.length>1)throw new Error("Parse Error: multiple actions possible at state: "+x+", token: "+_);switch(k[0]){case 1:n.push(_),i.push(p.yytext),o.push(p.yylloc),n.push(k[1]),_=null,w?(_=w,w=null):(c=p.yyleng,s=p.yytext,u=p.yylineno,b=p.yylloc,f>0&&f--);break;case 2:if(S=this.productions_[k[1]][1],D.$=i[i.length-S],D._$={first_line:o[o.length-(S||1)].first_line,last_line:o[o.length-1].last_line,first_column:o[o.length-(S||1)].first_column,last_column:o[o.length-1].last_column},m&&(D._$.range=[o[o.length-(S||1)].range[0],o[o.length-1].range[1]]),void 0!==(E=this.performAction.apply(D,[s,c,u,g.yy,k[1],i,o].concat(d))))return E;S&&(n=n.slice(0,-1*S*2),i=i.slice(0,-1*S),o=o.slice(0,-1*S)),n.push(this.productions_[k[1]][0]),i.push(D.$),o.push(D._$),T=a[n[n.length-2]][n[n.length-1]],n.push(T);break;case 3:return!0}}return!0}},r={EOF:1,parseError:function(t,e){if(!this.yy.parser)throw new Error(t);this.yy.parser.parseError(t,e)},setInput:function(t,e){return this.yy=e||this.yy||{},this._input=t,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var t=this._input[0];return this.yytext+=t,this.yyleng++,this.offset++,this.match+=t,this.matched+=t,t.match(/(?:\r\n?|\n).*/g)?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),t},unput:function(t){var e=t.length,n=t.split(/(?:\r\n?|\n)/g);this._input=t+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-e),this.offset-=e;var r=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),n.length-1&&(this.yylineno-=n.length-1);var i=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:n?(n.length===r.length?this.yylloc.first_column:0)+r[r.length-n.length].length-n[0].length:this.yylloc.first_column-e},this.options.ranges&&(this.yylloc.range=[i[0],i[0]+this.yyleng-e]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){return this.options.backtrack_lexer?(this._backtrack=!0,this):this.parseError("Lexical error on line "+(this.yylineno+1)+". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},less:function(t){this.unput(this.match.slice(t))},pastInput:function(){var t=this.matched.substr(0,this.matched.length-this.match.length);return(t.length>20?"...":"")+t.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var t=this.match;return t.length<20&&(t+=this._input.substr(0,20-t.length)),(t.substr(0,20)+(t.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var t=this.pastInput(),e=new Array(t.length+1).join("-");return t+this.upcomingInput()+"\n"+e+"^"},test_match:function(t,e){var n,r,i;if(this.options.backtrack_lexer&&(i={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(i.yylloc.range=this.yylloc.range.slice(0))),(r=t[0].match(/(?:\r\n?|\n).*/g))&&(this.yylineno+=r.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:r?r[r.length-1].length-r[r.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+t[0].length},this.yytext+=t[0],this.match+=t[0],this.matches=t,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(t[0].length),this.matched+=t[0],n=this.performAction.call(this,this.yy,this,e,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),n)return n;if(this._backtrack){for(var o in i)this[o]=i[o];return!1}return!1},next:function(){if(this.done)return this.EOF;var t,e,n,r;this._input||(this.done=!0),this._more||(this.yytext="",this.match="");for(var i=this._currentRules(),o=0;o<i.length;o++)if((n=this._input.match(this.rules[i[o]]))&&(!e||n[0].length>e[0].length)){if(e=n,r=o,this.options.backtrack_lexer){if(!1!==(t=this.test_match(n,i[o])))return t;if(this._backtrack){e=!1;continue}return!1}if(!this.options.flex)break}return e?!1!==(t=this.test_match(e,i[r]))&&t:""===this._input?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var t=this.next();return t||this.lex()},begin:function(t){this.conditionStack.push(t)},popState:function(){return this.conditionStack.length-1>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(t){return(t=this.conditionStack.length-1-Math.abs(t||0))>=0?this.conditionStack[t]:"INITIAL"},pushState:function(t){this.begin(t)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(t,e,n,r){switch(n){case 0:case 1:break;case 2:return 4;case 3:return 9;case 4:return"space";case 5:return 12;case 6:this.begin("string");break;case 7:this.popState();break;case 8:return"STR";case 9:return"VALUE";case 10:return 6}},rules:[/^(?:%%[^\n]*)/i,/^(?:\s+)/i,/^(?:pie\b)/i,/^(?:[\s\n\r]+)/i,/^(?:[\s]+)/i,/^(?:title\s[^#\n;]+)/i,/^(?:["])/i,/^(?:["])/i,/^(?:[^"]*)/i,/^(?::[\s]*[\d]+(?:\.[\d]+)?)/i,/^(?:$)/i],conditions:{string:{rules:[7,8],inclusive:!1},INITIAL:{rules:[0,1,2,3,4,5,6,9,10],inclusive:!0}}};function i(){this.yy={}}return n.lexer=r,i.prototype=n,n.Parser=i,new i}();e.parser=i,e.Parser=i.Parser,e.parse=function(){return i.parse.apply(i,arguments)},e.main=function(r){r[1]||(console.log("Usage: "+r[0]+" FILE"),t.exit(1));var i=n(28).readFileSync(n(29).normalize(r[1]),"utf8");return e.parser.parse(i)},n.c[n.s]===r&&e.main(t.argv.slice(1))}).call(this,n(7),n(9)(t))},function(t){t.exports=JSON.parse('{"name":"mermaid","version":"8.4.3","description":"Markdownish syntax for generating flowcharts, sequence diagrams, class diagrams, gantt charts and git graphs.","main":"dist/mermaid.core.js","keywords":["diagram","markdown","flowchart","sequence diagram","gantt","class diagram","git graph"],"scripts":{"build":"webpack --progress --colors","postbuild":"documentation build src/mermaidAPI.js --shallow -f md --markdown-toc false -o docs/mermaidAPI.md","build:watch":"yarn build --watch","minify":"minify ./dist/mermaid.js > ./dist/mermaid.min.js","release":"yarn build -p --config webpack.config.prod.babel.js","lint":"eslint src","e2e:depr":"yarn lint && jest e2e --config e2e/jest.config.js","cypress":"percy exec -- cypress run","e2e":"start-server-and-test dev http://localhost:9000/ cypress","e2e-upd":"yarn lint && jest e2e -u --config e2e/jest.config.js","dev":"webpack-dev-server --config webpack.config.e2e.js","test":"yarn lint && jest src/.*","test:watch":"jest --watch src","prepublishOnly":"yarn build && yarn release && yarn test && yarn e2e","prepush":"yarn test"},"repository":{"type":"git","url":"https://github.com/knsv/mermaid"},"author":"Knut Sveidqvist","license":"MIT","standard":{"ignore":["**/parser/*.js","dist/**/*.js","cypress/**/*.js"],"globals":["page"]},"dependencies":{"@braintree/sanitize-url":"^3.1.0","crypto-random-string":"^3.0.1","d3":"^5.7.0","dagre-d3-unofficial":"0.6.4","dagre":"^0.8.4","graphlib":"^2.1.7","he":"^1.2.0","lodash":"^4.17.11","minify":"^4.1.1","moment-mini":"^2.22.1","scope-css":"^1.2.1"},"devDependencies":{"documentation":"^12.0.1","prettier":"^1.18.2","eslint":"^6.3.0","eslint-config-prettier":"^6.3.0","eslint-plugin-prettier":"^3.1.0","@babel/core":"^7.2.2","@babel/preset-env":"^7.2.0","@babel/register":"^7.0.0","@percy/cypress":"^2.0.1","babel-core":"7.0.0-bridge.0","babel-jest":"^23.6.0","babel-loader":"^8.0.4","coveralls":"^3.0.2","css-loader":"^2.0.1","css-to-string-loader":"^0.1.3","cypress":"3.4.0","husky":"^1.2.1","identity-obj-proxy":"^3.0.0","jest":"^24.9.0","jison":"^0.4.18","moment":"^2.23.0","node-sass":"^4.12.0","puppeteer":"^1.17.0","sass-loader":"^7.1.0","start-server-and-test":"^1.10.0","webpack":"^4.27.1","webpack-cli":"^3.1.2","webpack-dev-server":"^3.4.1","webpack-node-externals":"^1.7.2","yarn-upgrade-all":"^0.5.0"},"files":["dist"],"yarn-upgrade-all":{"ignore":["babel-core"]}}')},function(t,e,n){"use strict";var r=n(12);t.exports=s;var i="\0",o="\0",a="";function s(t){this._isDirected=!r.has(t,"directed")||t.directed,this._isMultigraph=!!r.has(t,"multigraph")&&t.multigraph,this._isCompound=!!r.has(t,"compound")&&t.compound,this._label=void 0,this._defaultNodeLabelFn=r.constant(void 0),this._defaultEdgeLabelFn=r.constant(void 0),this._nodes={},this._isCompound&&(this._parent={},this._children={},this._children[o]={}),this._in={},this._preds={},this._out={},this._sucs={},this._edgeObjs={},this._edgeLabels={}}function u(t,e){t[e]?t[e]++:t[e]=1}function c(t,e){--t[e]||delete t[e]}function f(t,e,n,o){var s=""+e,u=""+n;if(!t&&s>u){var c=s;s=u,u=c}return s+a+u+a+(r.isUndefined(o)?i:o)}function l(t,e,n,r){var i=""+e,o=""+n;if(!t&&i>o){var a=i;i=o,o=a}var s={v:i,w:o};return r&&(s.name=r),s}function h(t,e){return f(t,e.v,e.w,e.name)}s.prototype._nodeCount=0,s.prototype._edgeCount=0,s.prototype.isDirected=function(){return this._isDirected},s.prototype.isMultigraph=function(){return this._isMultigraph},s.prototype.isCompound=function(){return this._isCompound},s.prototype.setGraph=function(t){return this._label=t,this},s.prototype.graph=function(){return this._label},s.prototype.setDefaultNodeLabel=function(t){return r.isFunction(t)||(t=r.constant(t)),this._defaultNodeLabelFn=t,this},s.prototype.nodeCount=function(){return this._nodeCount},s.prototype.nodes=function(){return r.keys(this._nodes)},s.prototype.sources=function(){var t=this;return r.filter(this.nodes(),(function(e){return r.isEmpty(t._in[e])}))},s.prototype.sinks=function(){var t=this;return r.filter(this.nodes(),(function(e){return r.isEmpty(t._out[e])}))},s.prototype.setNodes=function(t,e){var n=arguments,i=this;return r.each(t,(function(t){n.length>1?i.setNode(t,e):i.setNode(t)})),this},s.prototype.setNode=function(t,e){return r.has(this._nodes,t)?(arguments.length>1&&(this._nodes[t]=e),this):(this._nodes[t]=arguments.length>1?e:this._defaultNodeLabelFn(t),this._isCompound&&(this._parent[t]=o,this._children[t]={},this._children[o][t]=!0),this._in[t]={},this._preds[t]={},this._out[t]={},this._sucs[t]={},++this._nodeCount,this)},s.prototype.node=function(t){return this._nodes[t]},s.prototype.hasNode=function(t){return r.has(this._nodes,t)},s.prototype.removeNode=function(t){var e=this;if(r.has(this._nodes,t)){var n=function(t){e.removeEdge(e._edgeObjs[t])};delete this._nodes[t],this._isCompound&&(this._removeFromParentsChildList(t),delete this._parent[t],r.each(this.children(t),(function(t){e.setParent(t)})),delete this._children[t]),r.each(r.keys(this._in[t]),n),delete this._in[t],delete this._preds[t],r.each(r.keys(this._out[t]),n),delete this._out[t],delete this._sucs[t],--this._nodeCount}return this},s.prototype.setParent=function(t,e){if(!this._isCompound)throw new Error("Cannot set parent in a non-compound graph");if(r.isUndefined(e))e=o;else{for(var n=e+="";!r.isUndefined(n);n=this.parent(n))if(n===t)throw new Error("Setting "+e+" as parent of "+t+" would create a cycle");this.setNode(e)}return this.setNode(t),this._removeFromParentsChildList(t),this._parent[t]=e,this._children[e][t]=!0,this},s.prototype._removeFromParentsChildList=function(t){delete this._children[this._parent[t]][t]},s.prototype.parent=function(t){if(this._isCompound){var e=this._parent[t];if(e!==o)return e}},s.prototype.children=function(t){if(r.isUndefined(t)&&(t=o),this._isCompound){var e=this._children[t];if(e)return r.keys(e)}else{if(t===o)return this.nodes();if(this.hasNode(t))return[]}},s.prototype.predecessors=function(t){var e=this._preds[t];if(e)return r.keys(e)},s.prototype.successors=function(t){var e=this._sucs[t];if(e)return r.keys(e)},s.prototype.neighbors=function(t){var e=this.predecessors(t);if(e)return r.union(e,this.successors(t))},s.prototype.isLeaf=function(t){return 0===(this.isDirected()?this.successors(t):this.neighbors(t)).length},s.prototype.filterNodes=function(t){var e=new this.constructor({directed:this._isDirected,multigraph:this._isMultigraph,compound:this._isCompound});e.setGraph(this.graph());var n=this;r.each(this._nodes,(function(n,r){t(r)&&e.setNode(r,n)})),r.each(this._edgeObjs,(function(t){e.hasNode(t.v)&&e.hasNode(t.w)&&e.setEdge(t,n.edge(t))}));var i={};return this._isCompound&&r.each(e.nodes(),(function(t){e.setParent(t,function t(r){var o=n.parent(r);return void 0===o||e.hasNode(o)?(i[r]=o,o):o in i?i[o]:t(o)}(t))})),e},s.prototype.setDefaultEdgeLabel=function(t){return r.isFunction(t)||(t=r.constant(t)),this._defaultEdgeLabelFn=t,this},s.prototype.edgeCount=function(){return this._edgeCount},s.prototype.edges=function(){return r.values(this._edgeObjs)},s.prototype.setPath=function(t,e){var n=this,i=arguments;return r.reduce(t,(function(t,r){return i.length>1?n.setEdge(t,r,e):n.setEdge(t,r),r})),this},s.prototype.setEdge=function(){var t,e,n,i,o=!1,a=arguments[0];"object"==typeof a&&null!==a&&"v"in a?(t=a.v,e=a.w,n=a.name,2===arguments.length&&(i=arguments[1],o=!0)):(t=a,e=arguments[1],n=arguments[3],arguments.length>2&&(i=arguments[2],o=!0)),t=""+t,e=""+e,r.isUndefined(n)||(n=""+n);var s=f(this._isDirected,t,e,n);if(r.has(this._edgeLabels,s))return o&&(this._edgeLabels[s]=i),this;if(!r.isUndefined(n)&&!this._isMultigraph)throw new Error("Cannot set a named edge when isMultigraph = false");this.setNode(t),this.setNode(e),this._edgeLabels[s]=o?i:this._defaultEdgeLabelFn(t,e,n);var c=l(this._isDirected,t,e,n);return t=c.v,e=c.w,Object.freeze(c),this._edgeObjs[s]=c,u(this._preds[e],t),u(this._sucs[t],e),this._in[e][s]=c,this._out[t][s]=c,this._edgeCount++,this},s.prototype.edge=function(t,e,n){var r=1===arguments.length?h(this._isDirected,arguments[0]):f(this._isDirected,t,e,n);return this._edgeLabels[r]},s.prototype.hasEdge=function(t,e,n){var i=1===arguments.length?h(this._isDirected,arguments[0]):f(this._isDirected,t,e,n);return r.has(this._edgeLabels,i)},s.prototype.removeEdge=function(t,e,n){var r=1===arguments.length?h(this._isDirected,arguments[0]):f(this._isDirected,t,e,n),i=this._edgeObjs[r];return i&&(t=i.v,e=i.w,delete this._edgeLabels[r],delete this._edgeObjs[r],c(this._preds[e],t),c(this._sucs[t],e),delete this._in[e][r],delete this._out[t][r],this._edgeCount--),this},s.prototype.inEdges=function(t,e){var n=this._in[t];if(n){var i=r.values(n);return e?r.filter(i,(function(t){return t.v===e})):i}},s.prototype.outEdges=function(t,e){var n=this._out[t];if(n){var i=r.values(n);return e?r.filter(i,(function(t){return t.w===e})):i}},s.prototype.nodeEdges=function(t,e){var n=this.inEdges(t,e);if(n)return n.concat(this.outEdges(t,e))}},function(t,e,n){var r=n(32)(n(18),"Map");t.exports=r},function(t,e,n){var r=n(252),i=n(259),o=n(261),a=n(262),s=n(263);function u(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}u.prototype.clear=r,u.prototype.delete=i,u.prototype.get=o,u.prototype.has=a,u.prototype.set=s,t.exports=u},function(t,e){t.exports=function(t,e){for(var n=-1,r=null==t?0:t.length;++n<r&&!1!==e(t[n],n,t););return t}},function(t,e){var n=9007199254740991;t.exports=function(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=n}},function(t,e,n){(function(t){var r=n(131),i=e&&!e.nodeType&&e,o=i&&"object"==typeof t&&t&&!t.nodeType&&t,a=o&&o.exports===i&&r.process,s=function(){try{var t=o&&o.require&&o.require("util").types;return t||a&&a.binding&&a.binding("util")}catch(t){}}();t.exports=s}).call(this,n(9)(t))},function(t,e,n){var r=n(70),i=n(269),o=Object.prototype.hasOwnProperty;t.exports=function(t){if(!r(t))return i(t);var e=[];for(var n in Object(t))o.call(t,n)&&"constructor"!=n&&e.push(n);return e}},function(t,e,n){var r=n(138),i=n(139),o=Object.prototype.propertyIsEnumerable,a=Object.getOwnPropertySymbols,s=a?function(t){return null==t?[]:(t=Object(t),r(a(t),(function(e){return o.call(t,e)})))}:i;t.exports=s},function(t,e){t.exports=function(t,e){for(var n=-1,r=e.length,i=t.length;++n<r;)t[i+n]=e[n];return t}},function(t,e,n){var r=n(144);t.exports=function(t){var e=new t.constructor(t.byteLength);return new r(e).set(new r(t)),e}},function(t,e){t.exports=function(t){return function(){return t}}},function(t,e,n){t.exports=n(148)},function(t,e,n){var r=n(102),i=n(27);t.exports=function(t,e){return t&&r(t,e,i)}},function(t,e,n){var r=n(288)();t.exports=r},function(t,e){t.exports=function(t){var e=-1,n=Array(t.size);return t.forEach((function(t){n[++e]=t})),n}},function(t,e,n){var r=n(73),i=n(52);t.exports=function(t,e){for(var n=0,o=(e=r(e,t)).length;null!=t&&n<o;)t=t[i(e[n++])];return n&&n==o?t:void 0}},function(t,e,n){var r=n(6),i=n(42),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,a=/^\w*$/;t.exports=function(t,e){if(r(t))return!1;var n=typeof t;return!("number"!=n&&"symbol"!=n&&"boolean"!=n&&null!=t&&!i(t))||(a.test(t)||!o.test(t)||null!=e&&t in Object(e))}},function(t,e,n){var r=n(310),i=n(159);t.exports=function(t,e){return null!=t&&i(t,e,r)}},function(t,e,n){var r=n(97),i=n(322);t.exports=function t(e,n,o,a,s){var u=-1,c=e.length;for(o||(o=i),s||(s=[]);++u<c;){var f=e[u];n>0&&o(f)?n>1?t(f,n-1,o,a,s):r(s,f):a||(s[s.length]=f)}return s}},function(t,e,n){var r=n(42);t.exports=function(t,e,n){for(var i=-1,o=t.length;++i<o;){var a=t[i],s=e(a);if(null!=s&&(void 0===u?s==s&&!r(s):n(s,u)))var u=s,c=a}return c}},function(t,e){t.exports=function(t,e,n,r){var i=t.x,o=t.y,a=i-r.x,s=o-r.y,u=Math.sqrt(e*e*s*s+n*n*a*a),c=Math.abs(e*n*a/u);r.x<i&&(c=-c);var f=Math.abs(e*n*s/u);r.y<o&&(f=-f);return{x:i+c,y:o+f}}},function(t,e,n){var r=n(407),i=n(128),o=n(408);t.exports=function(t,e,n){var a=e.label,s=t.append("g");"svg"===e.labelType?o(s,e):"string"!=typeof a||"html"===e.labelType?i(s,e):r(s,e);var u,c=s.node().getBBox();switch(n){case"top":u=-e.height/2;break;case"bottom":u=e.height/2-c.height;break;default:u=-c.height/2}return s.attr("transform","translate("+-c.width/2+","+u+")"),s}},function(t,e,n){"use strict";var r=n(2),i=n(192),o=n(3).Buffer,a=new Array(16);function s(){i.call(this,64),this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878}function u(t,e){return t<<e|t>>>32-e}function c(t,e,n,r,i,o,a){return u(t+(e&n|~e&r)+i+o|0,a)+e|0}function f(t,e,n,r,i,o,a){return u(t+(e&r|n&~r)+i+o|0,a)+e|0}function l(t,e,n,r,i,o,a){return u(t+(e^n^r)+i+o|0,a)+e|0}function h(t,e,n,r,i,o,a){return u(t+(n^(e|~r))+i+o|0,a)+e|0}r(s,i),s.prototype._update=function(){for(var t=a,e=0;e<16;++e)t[e]=this._block.readInt32LE(4*e);var n=this._a,r=this._b,i=this._c,o=this._d;n=c(n,r,i,o,t[0],3614090360,7),o=c(o,n,r,i,t[1],3905402710,12),i=c(i,o,n,r,t[2],606105819,17),r=c(r,i,o,n,t[3],3250441966,22),n=c(n,r,i,o,t[4],4118548399,7),o=c(o,n,r,i,t[5],1200080426,12),i=c(i,o,n,r,t[6],2821735955,17),r=c(r,i,o,n,t[7],4249261313,22),n=c(n,r,i,o,t[8],1770035416,7),o=c(o,n,r,i,t[9],2336552879,12),i=c(i,o,n,r,t[10],4294925233,17),r=c(r,i,o,n,t[11],2304563134,22),n=c(n,r,i,o,t[12],1804603682,7),o=c(o,n,r,i,t[13],4254626195,12),i=c(i,o,n,r,t[14],2792965006,17),n=f(n,r=c(r,i,o,n,t[15],1236535329,22),i,o,t[1],4129170786,5),o=f(o,n,r,i,t[6],3225465664,9),i=f(i,o,n,r,t[11],643717713,14),r=f(r,i,o,n,t[0],3921069994,20),n=f(n,r,i,o,t[5],3593408605,5),o=f(o,n,r,i,t[10],38016083,9),i=f(i,o,n,r,t[15],3634488961,14),r=f(r,i,o,n,t[4],3889429448,20),n=f(n,r,i,o,t[9],568446438,5),o=f(o,n,r,i,t[14],3275163606,9),i=f(i,o,n,r,t[3],4107603335,14),r=f(r,i,o,n,t[8],1163531501,20),n=f(n,r,i,o,t[13],2850285829,5),o=f(o,n,r,i,t[2],4243563512,9),i=f(i,o,n,r,t[7],1735328473,14),n=l(n,r=f(r,i,o,n,t[12],2368359562,20),i,o,t[5],4294588738,4),o=l(o,n,r,i,t[8],2272392833,11),i=l(i,o,n,r,t[11],1839030562,16),r=l(r,i,o,n,t[14],4259657740,23),n=l(n,r,i,o,t[1],2763975236,4),o=l(o,n,r,i,t[4],1272893353,11),i=l(i,o,n,r,t[7],4139469664,16),r=l(r,i,o,n,t[10],3200236656,23),n=l(n,r,i,o,t[13],681279174,4),o=l(o,n,r,i,t[0],3936430074,11),i=l(i,o,n,r,t[3],3572445317,16),r=l(r,i,o,n,t[6],76029189,23),n=l(n,r,i,o,t[9],3654602809,4),o=l(o,n,r,i,t[12],3873151461,11),i=l(i,o,n,r,t[15],530742520,16),n=h(n,r=l(r,i,o,n,t[2],3299628645,23),i,o,t[0],4096336452,6),o=h(o,n,r,i,t[7],1126891415,10),i=h(i,o,n,r,t[14],2878612391,15),r=h(r,i,o,n,t[5],4237533241,21),n=h(n,r,i,o,t[12],1700485571,6),o=h(o,n,r,i,t[3],2399980690,10),i=h(i,o,n,r,t[10],4293915773,15),r=h(r,i,o,n,t[1],2240044497,21),n=h(n,r,i,o,t[8],1873313359,6),o=h(o,n,r,i,t[15],4264355552,10),i=h(i,o,n,r,t[6],2734768916,15),r=h(r,i,o,n,t[13],1309151649,21),n=h(n,r,i,o,t[4],4149444226,6),o=h(o,n,r,i,t[11],3174756917,10),i=h(i,o,n,r,t[2],718787259,15),r=h(r,i,o,n,t[9],3951481745,21),this._a=this._a+n|0,this._b=this._b+r|0,this._c=this._c+i|0,this._d=this._d+o|0},s.prototype._digest=function(){this._block[this._blockOffset++]=128,this._blockOffset>56&&(this._block.fill(0,this._blockOffset,64),this._update(),this._blockOffset=0),this._block.fill(0,this._blockOffset,56),this._block.writeUInt32LE(this._length[0],56),this._block.writeUInt32LE(this._length[1],60),this._update();var t=o.allocUnsafe(16);return t.writeInt32LE(this._a,0),t.writeInt32LE(this._b,4),t.writeInt32LE(this._c,8),t.writeInt32LE(this._d,12),t},t.exports=s},function(t,e,n){t.exports=i;var r=n(113).EventEmitter;function i(){r.call(this)}n(2)(i,r),i.Readable=n(114),i.Writable=n(428),i.Duplex=n(429),i.Transform=n(430),i.PassThrough=n(431),i.Stream=i,i.prototype.pipe=function(t,e){var n=this;function i(e){t.writable&&!1===t.write(e)&&n.pause&&n.pause()}function o(){n.readable&&n.resume&&n.resume()}n.on("data",i),t.on("drain",o),t._isStdio||e&&!1===e.end||(n.on("end",s),n.on("close",u));var a=!1;function s(){a||(a=!0,t.end())}function u(){a||(a=!0,"function"==typeof t.destroy&&t.destroy())}function c(t){if(f(),0===r.listenerCount(this,"error"))throw t}function f(){n.removeListener("data",i),t.removeListener("drain",o),n.removeListener("end",s),n.removeListener("close",u),n.removeListener("error",c),t.removeListener("error",c),n.removeListener("end",f),n.removeListener("close",f),t.removeListener("close",f)}return n.on("error",c),t.on("error",c),n.on("end",f),n.on("close",f),t.on("close",f),t.emit("pipe",n),t}},function(t,e,n){"use strict";var r,i="object"==typeof Reflect?Reflect:null,o=i&&"function"==typeof i.apply?i.apply:function(t,e,n){return Function.prototype.apply.call(t,e,n)};r=i&&"function"==typeof i.ownKeys?i.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var a=Number.isNaN||function(t){return t!=t};function s(){s.init.call(this)}t.exports=s,s.EventEmitter=s,s.prototype._events=void 0,s.prototype._eventsCount=0,s.prototype._maxListeners=void 0;var u=10;function c(t){return void 0===t._maxListeners?s.defaultMaxListeners:t._maxListeners}function f(t,e,n,r){var i,o,a,s;if("function"!=typeof n)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n);if(void 0===(o=t._events)?(o=t._events=Object.create(null),t._eventsCount=0):(void 0!==o.newListener&&(t.emit("newListener",e,n.listener?n.listener:n),o=t._events),a=o[e]),void 0===a)a=o[e]=n,++t._eventsCount;else if("function"==typeof a?a=o[e]=r?[n,a]:[a,n]:r?a.unshift(n):a.push(n),(i=c(t))>0&&a.length>i&&!a.warned){a.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=t,u.type=e,u.count=a.length,s=u,console&&console.warn&&console.warn(s)}return t}function l(){for(var t=[],e=0;e<arguments.length;e++)t.push(arguments[e]);this.fired||(this.target.removeListener(this.type,this.wrapFn),this.fired=!0,o(this.listener,this.target,t))}function h(t,e,n){var r={fired:!1,wrapFn:void 0,target:t,type:e,listener:n},i=l.bind(r);return i.listener=n,r.wrapFn=i,i}function d(t,e,n){var r=t._events;if(void 0===r)return[];var i=r[e];return void 0===i?[]:"function"==typeof i?n?[i.listener||i]:[i]:n?function(t){for(var e=new Array(t.length),n=0;n<e.length;++n)e[n]=t[n].listener||t[n];return e}(i):g(i,i.length)}function p(t){var e=this._events;if(void 0!==e){var n=e[t];if("function"==typeof n)return 1;if(void 0!==n)return n.length}return 0}function g(t,e){for(var n=new Array(e),r=0;r<e;++r)n[r]=t[r];return n}Object.defineProperty(s,"defaultMaxListeners",{enumerable:!0,get:function(){return u},set:function(t){if("number"!=typeof t||t<0||a(t))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+t+".");u=t}}),s.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},s.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||a(t))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+t+".");return this._maxListeners=t,this},s.prototype.getMaxListeners=function(){return c(this)},s.prototype.emit=function(t){for(var e=[],n=1;n<arguments.length;n++)e.push(arguments[n]);var r="error"===t,i=this._events;if(void 0!==i)r=r&&void 0===i.error;else if(!r)return!1;if(r){var a;if(e.length>0&&(a=e[0]),a instanceof Error)throw a;var s=new Error("Unhandled error."+(a?" ("+a.message+")":""));throw s.context=a,s}var u=i[t];if(void 0===u)return!1;if("function"==typeof u)o(u,this,e);else{var c=u.length,f=g(u,c);for(n=0;n<c;++n)o(f[n],this,e)}return!0},s.prototype.addListener=function(t,e){return f(this,t,e,!1)},s.prototype.on=s.prototype.addListener,s.prototype.prependListener=function(t,e){return f(this,t,e,!0)},s.prototype.once=function(t,e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e);return this.on(t,h(this,t,e)),this},s.prototype.prependOnceListener=function(t,e){if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e);return this.prependListener(t,h(this,t,e)),this},s.prototype.removeListener=function(t,e){var n,r,i,o,a;if("function"!=typeof e)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof e);if(void 0===(r=this._events))return this;if(void 0===(n=r[t]))return this;if(n===e||n.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete r[t],r.removeListener&&this.emit("removeListener",t,n.listener||e));else if("function"!=typeof n){for(i=-1,o=n.length-1;o>=0;o--)if(n[o]===e||n[o].listener===e){a=n[o].listener,i=o;break}if(i<0)return this;0===i?n.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(n,i),1===n.length&&(r[t]=n[0]),void 0!==r.removeListener&&this.emit("removeListener",t,a||e)}return this},s.prototype.off=s.prototype.removeListener,s.prototype.removeAllListeners=function(t){var e,n,r;if(void 0===(n=this._events))return this;if(void 0===n.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==n[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete n[t]),this;if(0===arguments.length){var i,o=Object.keys(n);for(r=0;r<o.length;++r)"removeListener"!==(i=o[r])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=n[t]))this.removeListener(t,e);else if(void 0!==e)for(r=e.length-1;r>=0;r--)this.removeListener(t,e[r]);return this},s.prototype.listeners=function(t){return d(this,t,!0)},s.prototype.rawListeners=function(t){return d(this,t,!1)},s.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):p.call(t,e)},s.prototype.listenerCount=p,s.prototype.eventNames=function(){return this._eventsCount>0?r(this._events):[]}},function(t,e,n){(e=t.exports=n(193)).Stream=e,e.Readable=e,e.Writable=n(116),e.Duplex=n(35),e.Transform=n(196),e.PassThrough=n(427)},function(t,e,n){var r=n(8),i=r.Buffer;function o(t,e){for(var n in t)e[n]=t[n]}function a(t,e,n){return i(t,e,n)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?t.exports=r:(o(r,e),e.Buffer=a),o(i,a),a.from=function(t,e,n){if("number"==typeof t)throw new TypeError("Argument must not be a number");return i(t,e,n)},a.alloc=function(t,e,n){if("number"!=typeof t)throw new TypeError("Argument must be a number");var r=i(t);return void 0!==e?"string"==typeof n?r.fill(e,n):r.fill(e):r.fill(0),r},a.allocUnsafe=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return i(t)},a.allocUnsafeSlow=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return r.SlowBuffer(t)}},function(t,e,n){"use strict";(function(e,r,i){var o=n(78);function a(t){var e=this;this.next=null,this.entry=null,this.finish=function(){!function(t,e,n){var r=t.entry;t.entry=null;for(;r;){var i=r.callback;e.pendingcb--,i(n),r=r.next}e.corkedRequestsFree?e.corkedRequestsFree.next=t:e.corkedRequestsFree=t}(e,t)}}t.exports=m;var s,u=!e.browser&&["v0.10","v0.9."].indexOf(e.version.slice(0,5))>-1?r:o.nextTick;m.WritableState=b;var c=n(54);c.inherits=n(2);var f={deprecate:n(426)},l=n(194),h=n(115).Buffer,d=i.Uint8Array||function(){};var p,g=n(195);function y(){}function b(t,e){s=s||n(35),t=t||{};var r=e instanceof s;this.objectMode=!!t.objectMode,r&&(this.objectMode=this.objectMode||!!t.writableObjectMode);var i=t.highWaterMark,c=t.writableHighWaterMark,f=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:r&&(c||0===c)?c:f,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var l=!1===t.decodeStrings;this.decodeStrings=!l,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(t){!function(t,e){var n=t._writableState,r=n.sync,i=n.writecb;if(function(t){t.writing=!1,t.writecb=null,t.length-=t.writelen,t.writelen=0}(n),e)!function(t,e,n,r,i){--e.pendingcb,n?(o.nextTick(i,r),o.nextTick(E,t,e),t._writableState.errorEmitted=!0,t.emit("error",r)):(i(r),t._writableState.errorEmitted=!0,t.emit("error",r),E(t,e))}(t,n,r,e,i);else{var a=x(n);a||n.corked||n.bufferProcessing||!n.bufferedRequest||w(t,n),r?u(_,t,n,a,i):_(t,n,a,i)}}(e,t)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new a(this)}function m(t){if(s=s||n(35),!(p.call(m,this)||this instanceof s))return new m(t);this._writableState=new b(t,this),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final)),l.call(this)}function v(t,e,n,r,i,o,a){e.writelen=r,e.writecb=a,e.writing=!0,e.sync=!0,n?t._writev(i,e.onwrite):t._write(i,o,e.onwrite),e.sync=!1}function _(t,e,n,r){n||function(t,e){0===e.length&&e.needDrain&&(e.needDrain=!1,t.emit("drain"))}(t,e),e.pendingcb--,r(),E(t,e)}function w(t,e){e.bufferProcessing=!0;var n=e.bufferedRequest;if(t._writev&&n&&n.next){var r=e.bufferedRequestCount,i=new Array(r),o=e.corkedRequestsFree;o.entry=n;for(var s=0,u=!0;n;)i[s]=n,n.isBuf||(u=!1),n=n.next,s+=1;i.allBuffers=u,v(t,e,!0,e.length,i,"",o.finish),e.pendingcb++,e.lastBufferedRequest=null,o.next?(e.corkedRequestsFree=o.next,o.next=null):e.corkedRequestsFree=new a(e),e.bufferedRequestCount=0}else{for(;n;){var c=n.chunk,f=n.encoding,l=n.callback;if(v(t,e,!1,e.objectMode?1:c.length,c,f,l),n=n.next,e.bufferedRequestCount--,e.writing)break}null===n&&(e.lastBufferedRequest=null)}e.bufferedRequest=n,e.bufferProcessing=!1}function x(t){return t.ending&&0===t.length&&null===t.bufferedRequest&&!t.finished&&!t.writing}function k(t,e){t._final((function(n){e.pendingcb--,n&&t.emit("error",n),e.prefinished=!0,t.emit("prefinish"),E(t,e)}))}function E(t,e){var n=x(e);return n&&(!function(t,e){e.prefinished||e.finalCalled||("function"==typeof t._final?(e.pendingcb++,e.finalCalled=!0,o.nextTick(k,t,e)):(e.prefinished=!0,t.emit("prefinish")))}(t,e),0===e.pendingcb&&(e.finished=!0,t.emit("finish"))),n}c.inherits(m,l),b.prototype.getBuffer=function(){for(var t=this.bufferedRequest,e=[];t;)e.push(t),t=t.next;return e},function(){try{Object.defineProperty(b.prototype,"buffer",{get:f.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(t){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(p=Function.prototype[Symbol.hasInstance],Object.defineProperty(m,Symbol.hasInstance,{value:function(t){return!!p.call(this,t)||this===m&&(t&&t._writableState instanceof b)}})):p=function(t){return t instanceof this},m.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},m.prototype.write=function(t,e,n){var r,i=this._writableState,a=!1,s=!i.objectMode&&(r=t,h.isBuffer(r)||r instanceof d);return s&&!h.isBuffer(t)&&(t=function(t){return h.from(t)}(t)),"function"==typeof e&&(n=e,e=null),s?e="buffer":e||(e=i.defaultEncoding),"function"!=typeof n&&(n=y),i.ended?function(t,e){var n=new Error("write after end");t.emit("error",n),o.nextTick(e,n)}(this,n):(s||function(t,e,n,r){var i=!0,a=!1;return null===n?a=new TypeError("May not write null values to stream"):"string"==typeof n||void 0===n||e.objectMode||(a=new TypeError("Invalid non-string/buffer chunk")),a&&(t.emit("error",a),o.nextTick(r,a),i=!1),i}(this,i,t,n))&&(i.pendingcb++,a=function(t,e,n,r,i,o){if(!n){var a=function(t,e,n){t.objectMode||!1===t.decodeStrings||"string"!=typeof e||(e=h.from(e,n));return e}(e,r,i);r!==a&&(n=!0,i="buffer",r=a)}var s=e.objectMode?1:r.length;e.length+=s;var u=e.length<e.highWaterMark;u||(e.needDrain=!0);if(e.writing||e.corked){var c=e.lastBufferedRequest;e.lastBufferedRequest={chunk:r,encoding:i,isBuf:n,callback:o,next:null},c?c.next=e.lastBufferedRequest:e.bufferedRequest=e.lastBufferedRequest,e.bufferedRequestCount+=1}else v(t,e,!1,s,r,i,o);return u}(this,i,s,t,e,n)),a},m.prototype.cork=function(){this._writableState.corked++},m.prototype.uncork=function(){var t=this._writableState;t.corked&&(t.corked--,t.writing||t.corked||t.finished||t.bufferProcessing||!t.bufferedRequest||w(this,t))},m.prototype.setDefaultEncoding=function(t){if("string"==typeof t&&(t=t.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((t+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+t);return this._writableState.defaultEncoding=t,this},Object.defineProperty(m.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),m.prototype._write=function(t,e,n){n(new Error("_write() is not implemented"))},m.prototype._writev=null,m.prototype.end=function(t,e,n){var r=this._writableState;"function"==typeof t?(n=t,t=null,e=null):"function"==typeof e&&(n=e,e=null),null!=t&&this.write(t,e),r.corked&&(r.corked=1,this.uncork()),r.ending||r.finished||function(t,e,n){e.ending=!0,E(t,e),n&&(e.finished?o.nextTick(n):t.once("finish",n));e.ended=!0,t.writable=!1}(this,r,n)},Object.defineProperty(m.prototype,"destroyed",{get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(t){this._writableState&&(this._writableState.destroyed=t)}}),m.prototype.destroy=g.destroy,m.prototype._undestroy=g.undestroy,m.prototype._destroy=function(t,e){this.end(),e(t)}}).call(this,n(7),n(424).setImmediate,n(11))},function(t,e,n){"use strict";var r=n(3).Buffer,i=r.isEncoding||function(t){switch((t=""+t)&&t.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function o(t){var e;switch(this.encoding=function(t){var e=function(t){if(!t)return"utf8";for(var e;;)switch(t){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return t;default:if(e)return;t=(""+t).toLowerCase(),e=!0}}(t);if("string"!=typeof e&&(r.isEncoding===i||!i(t)))throw new Error("Unknown encoding: "+t);return e||t}(t),this.encoding){case"utf16le":this.text=u,this.end=c,e=4;break;case"utf8":this.fillLast=s,e=4;break;case"base64":this.text=f,this.end=l,e=3;break;default:return this.write=h,void(this.end=d)}this.lastNeed=0,this.lastTotal=0,this.lastChar=r.allocUnsafe(e)}function a(t){return t<=127?0:t>>5==6?2:t>>4==14?3:t>>3==30?4:t>>6==2?-1:-2}function s(t){var e=this.lastTotal-this.lastNeed,n=function(t,e,n){if(128!=(192&e[0]))return t.lastNeed=0,"";if(t.lastNeed>1&&e.length>1){if(128!=(192&e[1]))return t.lastNeed=1,"";if(t.lastNeed>2&&e.length>2&&128!=(192&e[2]))return t.lastNeed=2,""}}(this,t);return void 0!==n?n:this.lastNeed<=t.length?(t.copy(this.lastChar,e,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(t.copy(this.lastChar,e,0,t.length),void(this.lastNeed-=t.length))}function u(t,e){if((t.length-e)%2==0){var n=t.toString("utf16le",e);if(n){var r=n.charCodeAt(n.length-1);if(r>=55296&&r<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1],n.slice(0,-1)}return n}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=t[t.length-1],t.toString("utf16le",e,t.length-1)}function c(t){var e=t&&t.length?this.write(t):"";if(this.lastNeed){var n=this.lastTotal-this.lastNeed;return e+this.lastChar.toString("utf16le",0,n)}return e}function f(t,e){var n=(t.length-e)%3;return 0===n?t.toString("base64",e):(this.lastNeed=3-n,this.lastTotal=3,1===n?this.lastChar[0]=t[t.length-1]:(this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1]),t.toString("base64",e,t.length-n))}function l(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+this.lastChar.toString("base64",0,3-this.lastNeed):e}function h(t){return t.toString(this.encoding)}function d(t){return t&&t.length?this.write(t):""}e.StringDecoder=o,o.prototype.write=function(t){if(0===t.length)return"";var e,n;if(this.lastNeed){if(void 0===(e=this.fillLast(t)))return"";n=this.lastNeed,this.lastNeed=0}else n=0;return n<t.length?e?e+this.text(t,n):this.text(t,n):e||""},o.prototype.end=function(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+"":e},o.prototype.text=function(t,e){var n=function(t,e,n){var r=e.length-1;if(r<n)return 0;var i=a(e[r]);if(i>=0)return i>0&&(t.lastNeed=i-1),i;if(--r<n||-2===i)return 0;if((i=a(e[r]))>=0)return i>0&&(t.lastNeed=i-2),i;if(--r<n||-2===i)return 0;if((i=a(e[r]))>=0)return i>0&&(2===i?i=0:t.lastNeed=i-3),i;return 0}(this,t,e);if(!this.lastNeed)return t.toString("utf8",e);this.lastTotal=n;var r=t.length-(n-this.lastNeed);return t.copy(this.lastChar,0,r),t.toString("utf8",e,r)},o.prototype.fillLast=function(t){if(this.lastNeed<=t.length)return t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,t.length),this.lastNeed-=t.length}},function(t,e,n){"use strict";var r=n(8).Buffer,i=n(2),o=n(192),a=new Array(16),s=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],u=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],c=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],f=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11],l=[0,1518500249,1859775393,2400959708,2840853838],h=[1352829926,1548603684,1836072691,2053994217,0];function d(){o.call(this,64),this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520}function p(t,e){return t<<e|t>>>32-e}function g(t,e,n,r,i,o,a,s){return p(t+(e^n^r)+o+a|0,s)+i|0}function y(t,e,n,r,i,o,a,s){return p(t+(e&n|~e&r)+o+a|0,s)+i|0}function b(t,e,n,r,i,o,a,s){return p(t+((e|~n)^r)+o+a|0,s)+i|0}function m(t,e,n,r,i,o,a,s){return p(t+(e&r|n&~r)+o+a|0,s)+i|0}function v(t,e,n,r,i,o,a,s){return p(t+(e^(n|~r))+o+a|0,s)+i|0}i(d,o),d.prototype._update=function(){for(var t=a,e=0;e<16;++e)t[e]=this._block.readInt32LE(4*e);for(var n=0|this._a,r=0|this._b,i=0|this._c,o=0|this._d,d=0|this._e,_=0|this._a,w=0|this._b,x=0|this._c,k=0|this._d,E=0|this._e,A=0;A<80;A+=1){var S,T;A<16?(S=g(n,r,i,o,d,t[s[A]],l[0],c[A]),T=v(_,w,x,k,E,t[u[A]],h[0],f[A])):A<32?(S=y(n,r,i,o,d,t[s[A]],l[1],c[A]),T=m(_,w,x,k,E,t[u[A]],h[1],f[A])):A<48?(S=b(n,r,i,o,d,t[s[A]],l[2],c[A]),T=b(_,w,x,k,E,t[u[A]],h[2],f[A])):A<64?(S=m(n,r,i,o,d,t[s[A]],l[3],c[A]),T=y(_,w,x,k,E,t[u[A]],h[3],f[A])):(S=v(n,r,i,o,d,t[s[A]],l[4],c[A]),T=g(_,w,x,k,E,t[u[A]],h[4],f[A])),n=d,d=o,o=p(i,10),i=r,r=S,_=E,E=k,k=p(x,10),x=w,w=T}var M=this._b+i+k|0;this._b=this._c+o+E|0,this._c=this._d+d+_|0,this._d=this._e+n+w|0,this._e=this._a+r+x|0,this._a=M},d.prototype._digest=function(){this._block[this._blockOffset++]=128,this._blockOffset>56&&(this._block.fill(0,this._blockOffset,64),this._update(),this._blockOffset=0),this._block.fill(0,this._blockOffset,56),this._block.writeUInt32LE(this._length[0],56),this._block.writeUInt32LE(this._length[1],60),this._update();var t=r.alloc?r.alloc(20):new r(20);return t.writeInt32LE(this._a,0),t.writeInt32LE(this._b,4),t.writeInt32LE(this._c,8),t.writeInt32LE(this._d,12),t.writeInt32LE(this._e,16),t},t.exports=d},function(t,e,n){(e=t.exports=function(t){t=t.toLowerCase();var n=e[t];if(!n)throw new Error(t+" is not supported (we accept pull requests)");return new n}).sha=n(432),e.sha1=n(433),e.sha224=n(434),e.sha256=n(197),e.sha384=n(435),e.sha512=n(198)},function(t,e,n){"use strict";e.utils=n(441),e.Cipher=n(442),e.DES=n(443),e.CBC=n(444),e.EDE=n(445)},function(t,e,n){var r=n(446),i=n(454),o=n(208);e.createCipher=e.Cipher=r.createCipher,e.createCipheriv=e.Cipheriv=r.createCipheriv,e.createDecipher=e.Decipher=i.createDecipher,e.createDecipheriv=e.Decipheriv=i.createDecipheriv,e.listCiphers=e.getCiphers=function(){return Object.keys(o)}},function(t,e,n){var r={ECB:n(447),CBC:n(448),CFB:n(449),CFB8:n(450),CFB1:n(451),OFB:n(452),CTR:n(206),GCM:n(206)},i=n(208);for(var o in i)i[o].module=r[i[o].mode];t.exports=i},function(t,e,n){var r;function i(t){this.rand=t}if(t.exports=function(t){return r||(r=new i(null)),r.generate(t)},t.exports.Rand=i,i.prototype.generate=function(t){return this._rand(t)},i.prototype._rand=function(t){if(this.rand.getBytes)return this.rand.getBytes(t);for(var e=new Uint8Array(t),n=0;n<e.length;n++)e[n]=this.rand.getByte();return e},"object"==typeof self)self.crypto&&self.crypto.getRandomValues?i.prototype._rand=function(t){var e=new Uint8Array(t);return self.crypto.getRandomValues(e),e}:self.msCrypto&&self.msCrypto.getRandomValues?i.prototype._rand=function(t){var e=new Uint8Array(t);return self.msCrypto.getRandomValues(e),e}:"object"==typeof window&&(i.prototype._rand=function(){throw new Error("Not implemented yet")});else try{var o=n(458);if("function"!=typeof o.randomBytes)throw new Error("Not supported");i.prototype._rand=function(t){return o.randomBytes(t)}}catch(t){}},function(t,e,n){(function(e){var r=n(5),i=n(44);function o(t,n){var i=function(t){var e=a(t);return{blinder:e.toRed(r.mont(t.modulus)).redPow(new r(t.publicExponent)).fromRed(),unblinder:e.invm(t.modulus)}}(n),o=n.modulus.byteLength(),s=(r.mont(n.modulus),new r(t).mul(i.blinder).umod(n.modulus)),u=s.toRed(r.mont(n.prime1)),c=s.toRed(r.mont(n.prime2)),f=n.coefficient,l=n.prime1,h=n.prime2,d=u.redPow(n.exponent1),p=c.redPow(n.exponent2);d=d.fromRed(),p=p.fromRed();var g=d.isub(p).imul(f).umod(l);return g.imul(h),p.iadd(g),new e(p.imul(i.unblinder).umod(n.modulus).toArray(!1,o))}function a(t){for(var e=t.modulus.byteLength(),n=new r(i(e));n.cmp(t.modulus)>=0||!n.umod(t.prime1)||!n.umod(t.prime2);)n=new r(i(e));return n}t.exports=o,o.getr=a}).call(this,n(8).Buffer)},function(t,e,n){"use strict";var r=e;r.version=n(463).version,r.utils=n(16),r.rand=n(123),r.curve=n(214),r.curves=n(126),r.ec=n(474),r.eddsa=n(478)},function(t,e,n){"use strict";var r,i=e,o=n(127),a=n(214),s=n(16).assert;function u(t){"short"===t.type?this.curve=new a.short(t):"edwards"===t.type?this.curve=new a.edwards(t):this.curve=new a.mont(t),this.g=this.curve.g,this.n=this.curve.n,this.hash=t.hash,s(this.g.validate(),"Invalid curve"),s(this.g.mul(this.n).isInfinity(),"Invalid curve, G*N != O")}function c(t,e){Object.defineProperty(i,t,{configurable:!0,enumerable:!0,get:function(){var n=new u(e);return Object.defineProperty(i,t,{configurable:!0,enumerable:!0,value:n}),n}})}i.PresetCurve=u,c("p192",{type:"short",prime:"p192",p:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",a:"ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",b:"64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",n:"ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",hash:o.sha256,gRed:!1,g:["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012","07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]}),c("p224",{type:"short",prime:"p224",p:"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",a:"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",b:"b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",n:"ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",hash:o.sha256,gRed:!1,g:["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21","bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]}),c("p256",{type:"short",prime:null,p:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",a:"ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",b:"5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",n:"ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",hash:o.sha256,gRed:!1,g:["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296","4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]}),c("p384",{type:"short",prime:null,p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",a:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",b:"b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",n:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",hash:o.sha384,gRed:!1,g:["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7","3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]}),c("p521",{type:"short",prime:null,p:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",a:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",b:"00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",n:"000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",hash:o.sha512,gRed:!1,g:["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66","00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]}),c("curve25519",{type:"mont",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"76d06",b:"1",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:o.sha256,gRed:!1,g:["9"]}),c("ed25519",{type:"edwards",prime:"p25519",p:"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",a:"-1",c:"1",d:"52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",n:"1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",hash:o.sha256,gRed:!1,g:["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a","6666666666666666666666666666666666666666666666666666666666666658"]});try{r=n(473)}catch(t){r=void 0}c("secp256k1",{type:"short",prime:"k256",p:"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",a:"0",b:"7",n:"ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",h:"1",hash:o.sha256,beta:"7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",lambda:"5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",basis:[{a:"3086d221a7d46bcde86c90e49284eb15",b:"-e4437ed6010e88286f547fa90abfe4c3"},{a:"114ca50f7a8e2f3f657c1108d9d44cfd8",b:"3086d221a7d46bcde86c90e49284eb15"}],gRed:!1,g:["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798","483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",r]})},function(t,e,n){var r=e;r.utils=n(21),r.common=n(56),r.sha=n(467),r.ripemd=n(471),r.hmac=n(472),r.sha1=r.sha.sha1,r.sha256=r.sha.sha256,r.sha224=r.sha.sha224,r.sha384=r.sha.sha384,r.sha512=r.sha.sha512,r.ripemd160=r.ripemd.ripemd160},function(t,e,n){var r=n(14);t.exports=function(t,e){var n=t.append("foreignObject").attr("width","100000"),i=n.append("xhtml:div");i.attr("xmlns","http://www.w3.org/1999/xhtml");var o=e.label;switch(typeof o){case"function":i.insert(o);break;case"object":i.insert((function(){return o}));break;default:i.html(o)}r.applyStyle(i,e.labelStyle),i.style("display","inline-block"),i.style("white-space","nowrap");var a=i.node().getBoundingClientRect();return n.attr("width",a.width).attr("height",a.height),n}},function(t,e){},function(t,e,n){var r=n(61),i=n(92),o=n(66),a=n(264),s=n(270),u=n(136),c=n(137),f=n(273),l=n(274),h=n(141),d=n(275),p=n(41),g=n(279),y=n(280),b=n(146),m=n(6),v=n(39),_=n(284),w=n(13),x=n(286),k=n(27),E=1,A=2,S=4,T="[object Arguments]",M="[object Function]",D="[object GeneratorFunction]",C="[object Object]",O={};O[T]=O["[object Array]"]=O["[object ArrayBuffer]"]=O["[object DataView]"]=O["[object Boolean]"]=O["[object Date]"]=O["[object Float32Array]"]=O["[object Float64Array]"]=O["[object Int8Array]"]=O["[object Int16Array]"]=O["[object Int32Array]"]=O["[object Map]"]=O["[object Number]"]=O[C]=O["[object RegExp]"]=O["[object Set]"]=O["[object String]"]=O["[object Symbol]"]=O["[object Uint8Array]"]=O["[object Uint8ClampedArray]"]=O["[object Uint16Array]"]=O["[object Uint32Array]"]=!0,O["[object Error]"]=O[M]=O["[object WeakMap]"]=!1,t.exports=function t(e,n,R,I,N,B){var L,P=n&E,F=n&A,q=n&S;if(R&&(L=N?R(e,I,N,B):R(e)),void 0!==L)return L;if(!w(e))return e;var j=m(e);if(j){if(L=g(e),!P)return c(e,L)}else{var U=p(e),z=U==M||U==D;if(v(e))return u(e,P);if(U==C||U==T||z&&!N){if(L=F||z?{}:b(e),!P)return F?l(e,s(L,e)):f(e,a(L,e))}else{if(!O[U])return N?e:{};L=y(e,U,P)}}B||(B=new r);var Y=B.get(e);if(Y)return Y;B.set(e,L),x(e)?e.forEach((function(r){L.add(t(r,n,R,r,e,B))})):_(e)&&e.forEach((function(r,i){L.set(i,t(r,n,R,i,e,B))}));var V=q?F?d:h:F?keysIn:k,H=j?void 0:V(e);return i(H||e,(function(r,i){H&&(r=e[i=r]),o(L,i,t(r,n,R,i,e,B))})),L}},function(t,e,n){(function(e){var n="object"==typeof e&&e&&e.Object===Object&&e;t.exports=n}).call(this,n(11))},function(t,e){var n=Function.prototype.toString;t.exports=function(t){if(null!=t){try{return n.call(t)}catch(t){}try{return t+""}catch(t){}}return""}},function(t,e,n){var r=n(32),i=function(){try{var t=r(Object,"defineProperty");return t({},"",{}),t}catch(t){}}();t.exports=i},function(t,e,n){var r=n(265),i=n(50),o=n(6),a=n(39),s=n(68),u=n(51),c=Object.prototype.hasOwnProperty;t.exports=function(t,e){var n=o(t),f=!n&&i(t),l=!n&&!f&&a(t),h=!n&&!f&&!l&&u(t),d=n||f||l||h,p=d?r(t.length,String):[],g=p.length;for(var y in t)!e&&!c.call(t,y)||d&&("length"==y||l&&("offset"==y||"parent"==y)||h&&("buffer"==y||"byteLength"==y||"byteOffset"==y)||s(y,g))||p.push(y);return p}},function(t,e){t.exports=function(t,e){return function(n){return t(e(n))}}},function(t,e,n){(function(t){var r=n(18),i=e&&!e.nodeType&&e,o=i&&"object"==typeof t&&t&&!t.nodeType&&t,a=o&&o.exports===i?r.Buffer:void 0,s=a?a.allocUnsafe:void 0;t.exports=function(t,e){if(e)return t.slice();var n=t.length,r=s?s(n):new t.constructor(n);return t.copy(r),r}}).call(this,n(9)(t))},function(t,e){t.exports=function(t,e){var n=-1,r=t.length;for(e||(e=Array(r));++n<r;)e[n]=t[n];return e}},function(t,e){t.exports=function(t,e){for(var n=-1,r=null==t?0:t.length,i=0,o=[];++n<r;){var a=t[n];e(a,n,t)&&(o[i++]=a)}return o}},function(t,e){t.exports=function(){return[]}},function(t,e,n){var r=n(97),i=n(71),o=n(96),a=n(139),s=Object.getOwnPropertySymbols?function(t){for(var e=[];t;)r(e,o(t)),t=i(t);return e}:a;t.exports=s},function(t,e,n){var r=n(142),i=n(96),o=n(27);t.exports=function(t){return r(t,o,i)}},function(t,e,n){var r=n(97),i=n(6);t.exports=function(t,e,n){var o=e(t);return i(t)?o:r(o,n(t))}},function(t,e,n){var r=n(32)(n(18),"Set");t.exports=r},function(t,e,n){var r=n(18).Uint8Array;t.exports=r},function(t,e,n){var r=n(98);t.exports=function(t,e){var n=e?r(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.length)}},function(t,e,n){var r=n(147),i=n(71),o=n(70);t.exports=function(t){return"function"!=typeof t.constructor||o(t)?{}:r(i(t))}},function(t,e,n){var r=n(13),i=Object.create,o=function(){function t(){}return function(e){if(!r(e))return{};if(i)return i(e);t.prototype=e;var n=new t;return t.prototype=void 0,n}}();t.exports=o},function(t,e,n){var r=n(92),i=n(72),o=n(149),a=n(6);t.exports=function(t,e){return(a(t)?r:i)(t,o(e))}},function(t,e,n){var r=n(34);t.exports=function(t){return"function"==typeof t?t:r}},function(t,e,n){var r=n(138),i=n(290),o=n(25),a=n(6);t.exports=function(t,e){return(a(t)?r:i)(t,o(e,3))}},function(t,e,n){var r=n(293),i=n(20);t.exports=function t(e,n,o,a,s){return e===n||(null==e||null==n||!i(e)&&!i(n)?e!=e&&n!=n:r(e,n,o,a,t,s))}},function(t,e,n){var r=n(153),i=n(296),o=n(154),a=1,s=2;t.exports=function(t,e,n,u,c,f){var l=n&a,h=t.length,d=e.length;if(h!=d&&!(l&&d>h))return!1;var p=f.get(t);if(p&&f.get(e))return p==e;var g=-1,y=!0,b=n&s?new r:void 0;for(f.set(t,e),f.set(e,t);++g<h;){var m=t[g],v=e[g];if(u)var _=l?u(v,m,g,e,t,f):u(m,v,g,t,e,f);if(void 0!==_){if(_)continue;y=!1;break}if(b){if(!i(e,(function(t,e){if(!o(b,e)&&(m===t||c(m,t,n,u,f)))return b.push(e)}))){y=!1;break}}else if(m!==v&&!c(m,v,n,u,f)){y=!1;break}}return f.delete(t),f.delete(e),y}},function(t,e,n){var r=n(91),i=n(294),o=n(295);function a(t){var e=-1,n=null==t?0:t.length;for(this.__data__=new r;++e<n;)this.add(t[e])}a.prototype.add=a.prototype.push=i,a.prototype.has=o,t.exports=a},function(t,e){t.exports=function(t,e){return t.has(e)}},function(t,e,n){var r=n(13);t.exports=function(t){return t==t&&!r(t)}},function(t,e){t.exports=function(t,e){return function(n){return null!=n&&(n[t]===e&&(void 0!==e||t in Object(n)))}}},function(t,e,n){var r=n(306);t.exports=function(t){return null==t?"":r(t)}},function(t,e,n){var r=n(307),i=n(159);t.exports=function(t,e){return null!=t&&i(t,e,r)}},function(t,e,n){var r=n(73),i=n(50),o=n(6),a=n(68),s=n(93),u=n(52);t.exports=function(t,e,n){for(var c=-1,f=(e=r(e,t)).length,l=!1;++c<f;){var h=u(e[c]);if(!(l=null!=t&&n(t,h)))break;t=t[h]}return l||++c!=f?l:!!(f=null==t?0:t.length)&&s(f)&&a(h,f)&&(o(t)||i(t))}},function(t,e){t.exports=function(t){return function(e){return null==e?void 0:e[t]}}},function(t,e){t.exports=function(t){return void 0===t}},function(t,e,n){var r=n(74),i=n(25),o=n(163),a=n(6);t.exports=function(t,e){return(a(t)?r:o)(t,i(e,3))}},function(t,e,n){var r=n(72),i=n(24);t.exports=function(t,e){var n=-1,o=i(t)?Array(t.length):[];return r(t,(function(t,r,i){o[++n]=e(t,r,i)})),o}},function(t,e,n){var r=n(312),i=n(72),o=n(25),a=n(313),s=n(6);t.exports=function(t,e,n){var u=s(t)?r:a,c=arguments.length<3;return u(t,o(e,4),n,c,i)}},function(t,e,n){var r=n(323),i=Math.max;t.exports=function(t,e,n){return e=i(void 0===e?t.length-1:e,0),function(){for(var o=arguments,a=-1,s=i(o.length-e,0),u=Array(s);++a<s;)u[a]=o[e+a];a=-1;for(var c=Array(e+1);++a<e;)c[a]=o[a];return c[e]=n(u),r(t,this,c)}}},function(t,e,n){var r=n(324),i=n(325)(r);t.exports=i},function(t,e){t.exports=function(t,e,n,r){for(var i=t.length,o=n+(r?1:-1);r?o--:++o<i;)if(e(t[o],o,t))return o;return-1}},function(t,e,n){var r=n(24),i=n(20);t.exports=function(t){return i(t)&&r(t)}},function(t,e,n){var r=n(334),i=n(27);t.exports=function(t){return null==t?[]:r(t,i(t))}},function(t,e,n){var r=n(12),i=n(171);t.exports=function(t,e,n,r){return function(t,e,n,r){var o,a,s={},u=new i,c=function(t){var e=t.v!==o?t.v:t.w,r=s[e],i=n(t),c=a.distance+i;if(i<0)throw new Error("dijkstra does not allow negative edge weights. Bad edge: "+t+" Weight: "+i);c<r.distance&&(r.distance=c,r.predecessor=o,u.decrease(e,c))};t.nodes().forEach((function(t){var n=t===e?0:Number.POSITIVE_INFINITY;s[t]={distance:n},u.add(t,n)}));for(;u.size()>0&&(o=u.removeMin(),(a=s[o]).distance!==Number.POSITIVE_INFINITY);)r(o).forEach(c);return s}(t,String(e),n||o,r||function(e){return t.outEdges(e)})};var o=r.constant(1)},function(t,e,n){var r=n(12);function i(){this._arr=[],this._keyIndices={}}t.exports=i,i.prototype.size=function(){return this._arr.length},i.prototype.keys=function(){return this._arr.map((function(t){return t.key}))},i.prototype.has=function(t){return r.has(this._keyIndices,t)},i.prototype.priority=function(t){var e=this._keyIndices[t];if(void 0!==e)return this._arr[e].priority},i.prototype.min=function(){if(0===this.size())throw new Error("Queue underflow");return this._arr[0].key},i.prototype.add=function(t,e){var n=this._keyIndices;if(t=String(t),!r.has(n,t)){var i=this._arr,o=i.length;return n[t]=o,i.push({key:t,priority:e}),this._decrease(o),!0}return!1},i.prototype.removeMin=function(){this._swap(0,this._arr.length-1);var t=this._arr.pop();return delete this._keyIndices[t.key],this._heapify(0),t.key},i.prototype.decrease=function(t,e){var n=this._keyIndices[t];if(e>this._arr[n].priority)throw new Error("New priority is greater than current priority. Key: "+t+" Old: "+this._arr[n].priority+" New: "+e);this._arr[n].priority=e,this._decrease(n)},i.prototype._heapify=function(t){var e=this._arr,n=2*t,r=n+1,i=t;n<e.length&&(i=e[n].priority<e[i].priority?n:i,r<e.length&&(i=e[r].priority<e[i].priority?r:i),i!==t&&(this._swap(t,i),this._heapify(i)))},i.prototype._decrease=function(t){for(var e,n=this._arr,r=n[t].priority;0!==t&&!(n[e=t>>1].priority<r);)this._swap(t,e),t=e},i.prototype._swap=function(t,e){var n=this._arr,r=this._keyIndices,i=n[t],o=n[e];n[t]=o,n[e]=i,r[o.key]=t,r[i.key]=e}},function(t,e,n){var r=n(12);t.exports=function(t){var e=0,n=[],i={},o=[];return t.nodes().forEach((function(a){r.has(i,a)||function a(s){var u=i[s]={onStack:!0,lowlink:e,index:e++};n.push(s);t.successors(s).forEach((function(t){r.has(i,t)?i[t].onStack&&(u.lowlink=Math.min(u.lowlink,i[t].index)):(a(t),u.lowlink=Math.min(u.lowlink,i[t].lowlink))}));if(u.lowlink===u.index){var c,f=[];do{c=n.pop(),i[c].onStack=!1,f.push(c)}while(s!==c);o.push(f)}}(a)})),o}},function(t,e,n){var r=n(12);function i(t){var e={},n={},i=[];if(r.each(t.sinks(),(function a(s){if(r.has(n,s))throw new o;r.has(e,s)||(n[s]=!0,e[s]=!0,r.each(t.predecessors(s),a),delete n[s],i.push(s))})),r.size(e)!==t.nodeCount())throw new o;return i}function o(){}t.exports=i,i.CycleException=o,o.prototype=new Error},function(t,e,n){var r=n(12);t.exports=function(t,e,n){r.isArray(e)||(e=[e]);var i=(t.isDirected()?t.successors:t.neighbors).bind(t),o=[],a={};return r.each(e,(function(e){if(!t.hasNode(e))throw new Error("Graph does not have node: "+e);!function t(e,n,i,o,a,s){r.has(o,n)||(o[n]=!0,i||s.push(n),r.each(a(n),(function(n){t(e,n,i,o,a,s)})),i&&s.push(n))}(t,e,"post"===n,a,i,o)})),o}},function(t,e,n){var r;try{r=n(59)}catch(t){}r||(r=window.dagre),t.exports=r},function(t,e,n){var r=n(75),i=n(36),o=n(76),a=n(40),s=Object.prototype,u=s.hasOwnProperty,c=r((function(t,e){t=Object(t);var n=-1,r=e.length,c=r>2?e[2]:void 0;for(c&&o(e[0],e[1],c)&&(r=1);++n<r;)for(var f=e[n],l=a(f),h=-1,d=l.length;++h<d;){var p=l[h],g=t[p];(void 0===g||i(g,s[p])&&!u.call(t,p))&&(t[p]=f[p])}return t}));t.exports=c},function(t,e,n){var r=n(353),i=1/0,o=17976931348623157e292;t.exports=function(t){return t?(t=r(t))===i||t===-i?(t<0?-1:1)*o:t==t?t:0:0===t?t:0}},function(t,e,n){var r=n(107);t.exports=function(t){return(null==t?0:t.length)?r(t,1):[]}},function(t,e,n){var r=n(67),i=n(36);t.exports=function(t,e,n){(void 0===n||i(t[e],n))&&(void 0!==n||e in t)||r(t,e,n)}},function(t,e,n){var r=n(33),i=n(71),o=n(20),a="[object Object]",s=Function.prototype,u=Object.prototype,c=s.toString,f=u.hasOwnProperty,l=c.call(Object);t.exports=function(t){if(!o(t)||r(t)!=a)return!1;var e=i(t);if(null===e)return!0;var n=f.call(e,"constructor")&&e.constructor;return"function"==typeof n&&n instanceof n&&c.call(n)==l}},function(t,e){t.exports=function(t,e){if(("constructor"!==e||"function"!=typeof t[e])&&"__proto__"!=e)return t[e]}},function(t,e){t.exports=function(t,e){return t<e}},function(t,e,n){var r=n(367),i=n(370)((function(t,e){return null==t?{}:r(t,e)}));t.exports=i},function(t,e,n){var r=n(371)();t.exports=r},function(t,e,n){var r=n(157),i=0;t.exports=function(t){var e=++i;return r(t)+e}},function(t,e,n){"use strict";var r=n(4),i=n(19).Graph,o=n(77).slack;function a(t,e){return r.forEach(t.nodes(),(function n(i){r.forEach(e.nodeEdges(i),(function(r){var a=r.v,s=i===a?r.w:a;t.hasNode(s)||o(e,r)||(t.setNode(s,{}),t.setEdge(i,s,{}),n(s))}))})),t.nodeCount()}function s(t,e){return r.minBy(e.edges(),(function(n){if(t.hasNode(n.v)!==t.hasNode(n.w))return o(e,n)}))}function u(t,e,n){r.forEach(t.nodes(),(function(t){e.node(t).rank+=n}))}t.exports=function(t){var e,n,r=new i({directed:!1}),c=t.nodes()[0],f=t.nodeCount();r.setNode(c,{});for(;a(r,t)<f;)e=s(r,t),n=r.hasNode(e.v)?o(t,e):-o(t,e),u(r,t,n);return r}},function(t,e){t.exports=function(t,e){return t.intersect(e)}},function(t,e,n){var r=n(109);t.exports=function(t,e,n){return r(t,e,e,n)}},function(t,e,n){var r=n(404);t.exports=function(t,e,n){var i=t.x,o=t.y,a=[],s=Number.POSITIVE_INFINITY,u=Number.POSITIVE_INFINITY;e.forEach((function(t){s=Math.min(s,t.x),u=Math.min(u,t.y)}));for(var c=i-t.width/2-s,f=o-t.height/2-u,l=0;l<e.length;l++){var h=e[l],d=e[l<e.length-1?l+1:0],p=r(t,n,{x:c+h.x,y:f+h.y},{x:c+d.x,y:f+d.y});p&&a.push(p)}if(!a.length)return console.log("NO INTERSECTION FOUND, RETURN NODE CENTER",t),t;a.length>1&&a.sort((function(t,e){var r=t.x-n.x,i=t.y-n.y,o=Math.sqrt(r*r+i*i),a=e.x-n.x,s=e.y-n.y,u=Math.sqrt(a*a+s*s);return o<u?-1:o===u?0:1}));return a[0]}},function(t,e){t.exports=function(t,e){var n,r,i=t.x,o=t.y,a=e.x-i,s=e.y-o,u=t.width/2,c=t.height/2;Math.abs(s)*u>Math.abs(a)*c?(s<0&&(c=-c),n=0===s?0:c*a/s,r=c):(a<0&&(u=-u),n=u,r=0===a?0:u*s/a);return{x:i+n,y:o+r}}},function(t,e){var n={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==n.call(t)}},function(t,e,n){"use strict";var r=n(3).Buffer,i=n(112).Transform;function o(t){i.call(this),this._block=r.allocUnsafe(t),this._blockSize=t,this._blockOffset=0,this._length=[0,0,0,0],this._finalized=!1}n(2)(o,i),o.prototype._transform=function(t,e,n){var r=null;try{this.update(t,e)}catch(t){r=t}n(r)},o.prototype._flush=function(t){var e=null;try{this.push(this.digest())}catch(t){e=t}t(e)},o.prototype.update=function(t,e){if(function(t,e){if(!r.isBuffer(t)&&"string"!=typeof t)throw new TypeError(e+" must be a string or a buffer")}(t,"Data"),this._finalized)throw new Error("Digest already called");r.isBuffer(t)||(t=r.from(t,e));for(var n=this._block,i=0;this._blockOffset+t.length-i>=this._blockSize;){for(var o=this._blockOffset;o<this._blockSize;)n[o++]=t[i++];this._update(),this._blockOffset=0}for(;i<t.length;)n[this._blockOffset++]=t[i++];for(var a=0,s=8*t.length;s>0;++a)this._length[a]+=s,(s=this._length[a]/4294967296|0)>0&&(this._length[a]-=4294967296*s);return this},o.prototype._update=function(){throw new Error("_update is not implemented")},o.prototype.digest=function(t){if(this._finalized)throw new Error("Digest already called");this._finalized=!0;var e=this._digest();void 0!==t&&(e=e.toString(t)),this._block.fill(0),this._blockOffset=0;for(var n=0;n<4;++n)this._length[n]=0;return e},o.prototype._digest=function(){throw new Error("_digest is not implemented")},t.exports=o},function(t,e,n){"use strict";(function(e,r){var i=n(78);t.exports=v;var o,a=n(191);v.ReadableState=m;n(113).EventEmitter;var s=function(t,e){return t.listeners(e).length},u=n(194),c=n(115).Buffer,f=e.Uint8Array||function(){};var l=n(54);l.inherits=n(2);var h=n(421),d=void 0;d=h&&h.debuglog?h.debuglog("stream"):function(){};var p,g=n(422),y=n(195);l.inherits(v,u);var b=["error","close","destroy","pause","resume"];function m(t,e){t=t||{};var r=e instanceof(o=o||n(35));this.objectMode=!!t.objectMode,r&&(this.objectMode=this.objectMode||!!t.readableObjectMode);var i=t.highWaterMark,a=t.readableHighWaterMark,s=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:r&&(a||0===a)?a:s,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new g,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(p||(p=n(117).StringDecoder),this.decoder=new p(t.encoding),this.encoding=t.encoding)}function v(t){if(o=o||n(35),!(this instanceof v))return new v(t);this._readableState=new m(t,this),this.readable=!0,t&&("function"==typeof t.read&&(this._read=t.read),"function"==typeof t.destroy&&(this._destroy=t.destroy)),u.call(this)}function _(t,e,n,r,i){var o,a=t._readableState;null===e?(a.reading=!1,function(t,e){if(e.ended)return;if(e.decoder){var n=e.decoder.end();n&&n.length&&(e.buffer.push(n),e.length+=e.objectMode?1:n.length)}e.ended=!0,E(t)}(t,a)):(i||(o=function(t,e){var n;r=e,c.isBuffer(r)||r instanceof f||"string"==typeof e||void 0===e||t.objectMode||(n=new TypeError("Invalid non-string/buffer chunk"));var r;return n}(a,e)),o?t.emit("error",o):a.objectMode||e&&e.length>0?("string"==typeof e||a.objectMode||Object.getPrototypeOf(e)===c.prototype||(e=function(t){return c.from(t)}(e)),r?a.endEmitted?t.emit("error",new Error("stream.unshift() after end event")):w(t,a,e,!0):a.ended?t.emit("error",new Error("stream.push() after EOF")):(a.reading=!1,a.decoder&&!n?(e=a.decoder.write(e),a.objectMode||0!==e.length?w(t,a,e,!1):S(t,a)):w(t,a,e,!1))):r||(a.reading=!1));return function(t){return!t.ended&&(t.needReadable||t.length<t.highWaterMark||0===t.length)}(a)}function w(t,e,n,r){e.flowing&&0===e.length&&!e.sync?(t.emit("data",n),t.read(0)):(e.length+=e.objectMode?1:n.length,r?e.buffer.unshift(n):e.buffer.push(n),e.needReadable&&E(t)),S(t,e)}Object.defineProperty(v.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(t){this._readableState&&(this._readableState.destroyed=t)}}),v.prototype.destroy=y.destroy,v.prototype._undestroy=y.undestroy,v.prototype._destroy=function(t,e){this.push(null),e(t)},v.prototype.push=function(t,e){var n,r=this._readableState;return r.objectMode?n=!0:"string"==typeof t&&((e=e||r.defaultEncoding)!==r.encoding&&(t=c.from(t,e),e=""),n=!0),_(this,t,e,!1,n)},v.prototype.unshift=function(t){return _(this,t,null,!0,!1)},v.prototype.isPaused=function(){return!1===this._readableState.flowing},v.prototype.setEncoding=function(t){return p||(p=n(117).StringDecoder),this._readableState.decoder=new p(t),this._readableState.encoding=t,this};var x=8388608;function k(t,e){return t<=0||0===e.length&&e.ended?0:e.objectMode?1:t!=t?e.flowing&&e.length?e.buffer.head.data.length:e.length:(t>e.highWaterMark&&(e.highWaterMark=function(t){return t>=x?t=x:(t--,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t++),t}(t)),t<=e.length?t:e.ended?e.length:(e.needReadable=!0,0))}function E(t){var e=t._readableState;e.needReadable=!1,e.emittedReadable||(d("emitReadable",e.flowing),e.emittedReadable=!0,e.sync?i.nextTick(A,t):A(t))}function A(t){d("emit readable"),t.emit("readable"),C(t)}function S(t,e){e.readingMore||(e.readingMore=!0,i.nextTick(T,t,e))}function T(t,e){for(var n=e.length;!e.reading&&!e.flowing&&!e.ended&&e.length<e.highWaterMark&&(d("maybeReadMore read 0"),t.read(0),n!==e.length);)n=e.length;e.readingMore=!1}function M(t){d("readable nexttick read 0"),t.read(0)}function D(t,e){e.reading||(d("resume read 0"),t.read(0)),e.resumeScheduled=!1,e.awaitDrain=0,t.emit("resume"),C(t),e.flowing&&!e.reading&&t.read(0)}function C(t){var e=t._readableState;for(d("flow",e.flowing);e.flowing&&null!==t.read(););}function O(t,e){return 0===e.length?null:(e.objectMode?n=e.buffer.shift():!t||t>=e.length?(n=e.decoder?e.buffer.join(""):1===e.buffer.length?e.buffer.head.data:e.buffer.concat(e.length),e.buffer.clear()):n=function(t,e,n){var r;t<e.head.data.length?(r=e.head.data.slice(0,t),e.head.data=e.head.data.slice(t)):r=t===e.head.data.length?e.shift():n?function(t,e){var n=e.head,r=1,i=n.data;t-=i.length;for(;n=n.next;){var o=n.data,a=t>o.length?o.length:t;if(a===o.length?i+=o:i+=o.slice(0,t),0===(t-=a)){a===o.length?(++r,n.next?e.head=n.next:e.head=e.tail=null):(e.head=n,n.data=o.slice(a));break}++r}return e.length-=r,i}(t,e):function(t,e){var n=c.allocUnsafe(t),r=e.head,i=1;r.data.copy(n),t-=r.data.length;for(;r=r.next;){var o=r.data,a=t>o.length?o.length:t;if(o.copy(n,n.length-t,0,a),0===(t-=a)){a===o.length?(++i,r.next?e.head=r.next:e.head=e.tail=null):(e.head=r,r.data=o.slice(a));break}++i}return e.length-=i,n}(t,e);return r}(t,e.buffer,e.decoder),n);var n}function R(t){var e=t._readableState;if(e.length>0)throw new Error('"endReadable()" called on non-empty stream');e.endEmitted||(e.ended=!0,i.nextTick(I,e,t))}function I(t,e){t.endEmitted||0!==t.length||(t.endEmitted=!0,e.readable=!1,e.emit("end"))}function N(t,e){for(var n=0,r=t.length;n<r;n++)if(t[n]===e)return n;return-1}v.prototype.read=function(t){d("read",t),t=parseInt(t,10);var e=this._readableState,n=t;if(0!==t&&(e.emittedReadable=!1),0===t&&e.needReadable&&(e.length>=e.highWaterMark||e.ended))return d("read: emitReadable",e.length,e.ended),0===e.length&&e.ended?R(this):E(this),null;if(0===(t=k(t,e))&&e.ended)return 0===e.length&&R(this),null;var r,i=e.needReadable;return d("need readable",i),(0===e.length||e.length-t<e.highWaterMark)&&d("length less than watermark",i=!0),e.ended||e.reading?d("reading or ended",i=!1):i&&(d("do read"),e.reading=!0,e.sync=!0,0===e.length&&(e.needReadable=!0),this._read(e.highWaterMark),e.sync=!1,e.reading||(t=k(n,e))),null===(r=t>0?O(t,e):null)?(e.needReadable=!0,t=0):e.length-=t,0===e.length&&(e.ended||(e.needReadable=!0),n!==t&&e.ended&&R(this)),null!==r&&this.emit("data",r),r},v.prototype._read=function(t){this.emit("error",new Error("_read() is not implemented"))},v.prototype.pipe=function(t,e){var n=this,o=this._readableState;switch(o.pipesCount){case 0:o.pipes=t;break;case 1:o.pipes=[o.pipes,t];break;default:o.pipes.push(t)}o.pipesCount+=1,d("pipe count=%d opts=%j",o.pipesCount,e);var u=(!e||!1!==e.end)&&t!==r.stdout&&t!==r.stderr?f:v;function c(e,r){d("onunpipe"),e===n&&r&&!1===r.hasUnpiped&&(r.hasUnpiped=!0,d("cleanup"),t.removeListener("close",b),t.removeListener("finish",m),t.removeListener("drain",l),t.removeListener("error",y),t.removeListener("unpipe",c),n.removeListener("end",f),n.removeListener("end",v),n.removeListener("data",g),h=!0,!o.awaitDrain||t._writableState&&!t._writableState.needDrain||l())}function f(){d("onend"),t.end()}o.endEmitted?i.nextTick(u):n.once("end",u),t.on("unpipe",c);var l=function(t){return function(){var e=t._readableState;d("pipeOnDrain",e.awaitDrain),e.awaitDrain&&e.awaitDrain--,0===e.awaitDrain&&s(t,"data")&&(e.flowing=!0,C(t))}}(n);t.on("drain",l);var h=!1;var p=!1;function g(e){d("ondata"),p=!1,!1!==t.write(e)||p||((1===o.pipesCount&&o.pipes===t||o.pipesCount>1&&-1!==N(o.pipes,t))&&!h&&(d("false write response, pause",n._readableState.awaitDrain),n._readableState.awaitDrain++,p=!0),n.pause())}function y(e){d("onerror",e),v(),t.removeListener("error",y),0===s(t,"error")&&t.emit("error",e)}function b(){t.removeListener("finish",m),v()}function m(){d("onfinish"),t.removeListener("close",b),v()}function v(){d("unpipe"),n.unpipe(t)}return n.on("data",g),function(t,e,n){if("function"==typeof t.prependListener)return t.prependListener(e,n);t._events&&t._events[e]?a(t._events[e])?t._events[e].unshift(n):t._events[e]=[n,t._events[e]]:t.on(e,n)}(t,"error",y),t.once("close",b),t.once("finish",m),t.emit("pipe",n),o.flowing||(d("pipe resume"),n.resume()),t},v.prototype.unpipe=function(t){var e=this._readableState,n={hasUnpiped:!1};if(0===e.pipesCount)return this;if(1===e.pipesCount)return t&&t!==e.pipes?this:(t||(t=e.pipes),e.pipes=null,e.pipesCount=0,e.flowing=!1,t&&t.emit("unpipe",this,n),this);if(!t){var r=e.pipes,i=e.pipesCount;e.pipes=null,e.pipesCount=0,e.flowing=!1;for(var o=0;o<i;o++)r[o].emit("unpipe",this,n);return this}var a=N(e.pipes,t);return-1===a?this:(e.pipes.splice(a,1),e.pipesCount-=1,1===e.pipesCount&&(e.pipes=e.pipes[0]),t.emit("unpipe",this,n),this)},v.prototype.on=function(t,e){var n=u.prototype.on.call(this,t,e);if("data"===t)!1!==this._readableState.flowing&&this.resume();else if("readable"===t){var r=this._readableState;r.endEmitted||r.readableListening||(r.readableListening=r.needReadable=!0,r.emittedReadable=!1,r.reading?r.length&&E(this):i.nextTick(M,this))}return n},v.prototype.addListener=v.prototype.on,v.prototype.resume=function(){var t=this._readableState;return t.flowing||(d("resume"),t.flowing=!0,function(t,e){e.resumeScheduled||(e.resumeScheduled=!0,i.nextTick(D,t,e))}(this,t)),this},v.prototype.pause=function(){return d("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(d("pause"),this._readableState.flowing=!1,this.emit("pause")),this},v.prototype.wrap=function(t){var e=this,n=this._readableState,r=!1;for(var i in t.on("end",(function(){if(d("wrapped end"),n.decoder&&!n.ended){var t=n.decoder.end();t&&t.length&&e.push(t)}e.push(null)})),t.on("data",(function(i){(d("wrapped data"),n.decoder&&(i=n.decoder.write(i)),n.objectMode&&null==i)||(n.objectMode||i&&i.length)&&(e.push(i)||(r=!0,t.pause()))})),t)void 0===this[i]&&"function"==typeof t[i]&&(this[i]=function(e){return function(){return t[e].apply(t,arguments)}}(i));for(var o=0;o<b.length;o++)t.on(b[o],this.emit.bind(this,b[o]));return this._read=function(e){d("wrapped _read",e),r&&(r=!1,t.resume())},this},Object.defineProperty(v.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),v._fromList=O}).call(this,n(11),n(7))},function(t,e,n){t.exports=n(113).EventEmitter},function(t,e,n){"use strict";var r=n(78);function i(t,e){t.emit("error",e)}t.exports={destroy:function(t,e){var n=this,o=this._readableState&&this._readableState.destroyed,a=this._writableState&&this._writableState.destroyed;return o||a?(e?e(t):!t||this._writableState&&this._writableState.errorEmitted||r.nextTick(i,this,t),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(t||null,(function(t){!e&&t?(r.nextTick(i,n,t),n._writableState&&(n._writableState.errorEmitted=!0)):e&&e(t)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}}},function(t,e,n){"use strict";t.exports=a;var r=n(35),i=n(54);function o(t,e){var n=this._transformState;n.transforming=!1;var r=n.writecb;if(!r)return this.emit("error",new Error("write callback called multiple times"));n.writechunk=null,n.writecb=null,null!=e&&this.push(e),r(t);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}function a(t){if(!(this instanceof a))return new a(t);r.call(this,t),this._transformState={afterTransform:o.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,t&&("function"==typeof t.transform&&(this._transform=t.transform),"function"==typeof t.flush&&(this._flush=t.flush)),this.on("prefinish",s)}function s(){var t=this;"function"==typeof this._flush?this._flush((function(e,n){u(t,e,n)})):u(this,null,null)}function u(t,e,n){if(e)return t.emit("error",e);if(null!=n&&t.push(n),t._writableState.length)throw new Error("Calling transform done when ws.length != 0");if(t._transformState.transforming)throw new Error("Calling transform done when still transforming");return t.push(null)}i.inherits=n(2),i.inherits(a,r),a.prototype.push=function(t,e){return this._transformState.needTransform=!1,r.prototype.push.call(this,t,e)},a.prototype._transform=function(t,e,n){throw new Error("_transform() is not implemented")},a.prototype._write=function(t,e,n){var r=this._transformState;if(r.writecb=n,r.writechunk=t,r.writeencoding=e,!r.transforming){var i=this._readableState;(r.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},a.prototype._read=function(t){var e=this._transformState;null!==e.writechunk&&e.writecb&&!e.transforming?(e.transforming=!0,this._transform(e.writechunk,e.writeencoding,e.afterTransform)):e.needTransform=!0},a.prototype._destroy=function(t,e){var n=this;r.prototype._destroy.call(this,t,(function(t){e(t),n.emit("close")}))}},function(t,e,n){var r=n(2),i=n(45),o=n(3).Buffer,a=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],s=new Array(64);function u(){this.init(),this._w=s,i.call(this,64,56)}function c(t,e,n){return n^t&(e^n)}function f(t,e,n){return t&e|n&(t|e)}function l(t){return(t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10)}function h(t){return(t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7)}function d(t){return(t>>>7|t<<25)^(t>>>18|t<<14)^t>>>3}r(u,i),u.prototype.init=function(){return this._a=1779033703,this._b=3144134277,this._c=1013904242,this._d=2773480762,this._e=1359893119,this._f=2600822924,this._g=528734635,this._h=1541459225,this},u.prototype._update=function(t){for(var e,n=this._w,r=0|this._a,i=0|this._b,o=0|this._c,s=0|this._d,u=0|this._e,p=0|this._f,g=0|this._g,y=0|this._h,b=0;b<16;++b)n[b]=t.readInt32BE(4*b);for(;b<64;++b)n[b]=0|(((e=n[b-2])>>>17|e<<15)^(e>>>19|e<<13)^e>>>10)+n[b-7]+d(n[b-15])+n[b-16];for(var m=0;m<64;++m){var v=y+h(u)+c(u,p,g)+a[m]+n[m]|0,_=l(r)+f(r,i,o)|0;y=g,g=p,p=u,u=s+v|0,s=o,o=i,i=r,r=v+_|0}this._a=r+this._a|0,this._b=i+this._b|0,this._c=o+this._c|0,this._d=s+this._d|0,this._e=u+this._e|0,this._f=p+this._f|0,this._g=g+this._g|0,this._h=y+this._h|0},u.prototype._hash=function(){var t=o.allocUnsafe(32);return t.writeInt32BE(this._a,0),t.writeInt32BE(this._b,4),t.writeInt32BE(this._c,8),t.writeInt32BE(this._d,12),t.writeInt32BE(this._e,16),t.writeInt32BE(this._f,20),t.writeInt32BE(this._g,24),t.writeInt32BE(this._h,28),t},t.exports=u},function(t,e,n){var r=n(2),i=n(45),o=n(3).Buffer,a=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591],s=new Array(160);function u(){this.init(),this._w=s,i.call(this,128,112)}function c(t,e,n){return n^t&(e^n)}function f(t,e,n){return t&e|n&(t|e)}function l(t,e){return(t>>>28|e<<4)^(e>>>2|t<<30)^(e>>>7|t<<25)}function h(t,e){return(t>>>14|e<<18)^(t>>>18|e<<14)^(e>>>9|t<<23)}function d(t,e){return(t>>>1|e<<31)^(t>>>8|e<<24)^t>>>7}function p(t,e){return(t>>>1|e<<31)^(t>>>8|e<<24)^(t>>>7|e<<25)}function g(t,e){return(t>>>19|e<<13)^(e>>>29|t<<3)^t>>>6}function y(t,e){return(t>>>19|e<<13)^(e>>>29|t<<3)^(t>>>6|e<<26)}function b(t,e){return t>>>0<e>>>0?1:0}r(u,i),u.prototype.init=function(){return this._ah=1779033703,this._bh=3144134277,this._ch=1013904242,this._dh=2773480762,this._eh=1359893119,this._fh=2600822924,this._gh=528734635,this._hh=1541459225,this._al=4089235720,this._bl=2227873595,this._cl=4271175723,this._dl=1595750129,this._el=2917565137,this._fl=725511199,this._gl=4215389547,this._hl=327033209,this},u.prototype._update=function(t){for(var e=this._w,n=0|this._ah,r=0|this._bh,i=0|this._ch,o=0|this._dh,s=0|this._eh,u=0|this._fh,m=0|this._gh,v=0|this._hh,_=0|this._al,w=0|this._bl,x=0|this._cl,k=0|this._dl,E=0|this._el,A=0|this._fl,S=0|this._gl,T=0|this._hl,M=0;M<32;M+=2)e[M]=t.readInt32BE(4*M),e[M+1]=t.readInt32BE(4*M+4);for(;M<160;M+=2){var D=e[M-30],C=e[M-30+1],O=d(D,C),R=p(C,D),I=g(D=e[M-4],C=e[M-4+1]),N=y(C,D),B=e[M-14],L=e[M-14+1],P=e[M-32],F=e[M-32+1],q=R+L|0,j=O+B+b(q,R)|0;j=(j=j+I+b(q=q+N|0,N)|0)+P+b(q=q+F|0,F)|0,e[M]=j,e[M+1]=q}for(var U=0;U<160;U+=2){j=e[U],q=e[U+1];var z=f(n,r,i),Y=f(_,w,x),V=l(n,_),H=l(_,n),$=h(s,E),G=h(E,s),W=a[U],K=a[U+1],X=c(s,u,m),Z=c(E,A,S),J=T+G|0,Q=v+$+b(J,T)|0;Q=(Q=(Q=Q+X+b(J=J+Z|0,Z)|0)+W+b(J=J+K|0,K)|0)+j+b(J=J+q|0,q)|0;var tt=H+Y|0,et=V+z+b(tt,H)|0;v=m,T=S,m=u,S=A,u=s,A=E,s=o+Q+b(E=k+J|0,k)|0,o=i,k=x,i=r,x=w,r=n,w=_,n=Q+et+b(_=J+tt|0,J)|0}this._al=this._al+_|0,this._bl=this._bl+w|0,this._cl=this._cl+x|0,this._dl=this._dl+k|0,this._el=this._el+E|0,this._fl=this._fl+A|0,this._gl=this._gl+S|0,this._hl=this._hl+T|0,this._ah=this._ah+n+b(this._al,_)|0,this._bh=this._bh+r+b(this._bl,w)|0,this._ch=this._ch+i+b(this._cl,x)|0,this._dh=this._dh+o+b(this._dl,k)|0,this._eh=this._eh+s+b(this._el,E)|0,this._fh=this._fh+u+b(this._fl,A)|0,this._gh=this._gh+m+b(this._gl,S)|0,this._hh=this._hh+v+b(this._hl,T)|0},u.prototype._hash=function(){var t=o.allocUnsafe(64);function e(e,n,r){t.writeInt32BE(e,r),t.writeInt32BE(n,r+4)}return e(this._ah,this._al,0),e(this._bh,this._bl,8),e(this._ch,this._cl,16),e(this._dh,this._dl,24),e(this._eh,this._el,32),e(this._fh,this._fl,40),e(this._gh,this._gl,48),e(this._hh,this._hl,56),t},t.exports=u},function(t,e,n){"use strict";var r=n(2),i=n(436),o=n(31),a=n(3).Buffer,s=n(200),u=n(118),c=n(119),f=a.alloc(128);function l(t,e){o.call(this,"digest"),"string"==typeof e&&(e=a.from(e));var n="sha512"===t||"sha384"===t?128:64;(this._alg=t,this._key=e,e.length>n)?e=("rmd160"===t?new u:c(t)).update(e).digest():e.length<n&&(e=a.concat([e,f],n));for(var r=this._ipad=a.allocUnsafe(n),i=this._opad=a.allocUnsafe(n),s=0;s<n;s++)r[s]=54^e[s],i[s]=92^e[s];this._hash="rmd160"===t?new u:c(t),this._hash.update(r)}r(l,o),l.prototype._update=function(t){this._hash.update(t)},l.prototype._final=function(){var t=this._hash.digest();return("rmd160"===this._alg?new u:c(this._alg)).update(this._opad).update(t).digest()},t.exports=function(t,e){return"rmd160"===(t=t.toLowerCase())||"ripemd160"===t?new l("rmd160",e):"md5"===t?new i(s,e):new l(t,e)}},function(t,e,n){var r=n(111);t.exports=function(t){return(new r).update(t).digest()}},function(t){t.exports=JSON.parse('{"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}}')},function(t,e,n){e.pbkdf2=n(438),e.pbkdf2Sync=n(205)},function(t,e,n){(function(e){var n=Math.pow(2,30)-1;function r(t,n){if("string"!=typeof t&&!e.isBuffer(t))throw new TypeError(n+" must be a buffer or string")}t.exports=function(t,e,i,o){if(r(t,"Password"),r(e,"Salt"),"number"!=typeof i)throw new TypeError("Iterations not a number");if(i<0)throw new TypeError("Bad iterations");if("number"!=typeof o)throw new TypeError("Key length not a number");if(o<0||o>n||o!=o)throw new TypeError("Bad key length")}}).call(this,n(8).Buffer)},function(t,e,n){(function(e){var n;e.browser?n="utf-8":n=parseInt(e.version.split(".")[0].slice(1),10)>=6?"utf-8":"binary";t.exports=n}).call(this,n(7))},function(t,e,n){var r=n(200),i=n(118),o=n(119),a=n(203),s=n(204),u=n(3).Buffer,c=u.alloc(128),f={md5:16,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64,rmd160:20,ripemd160:20};function l(t,e,n){var a=function(t){return"rmd160"===t||"ripemd160"===t?function(t){return(new i).update(t).digest()}:"md5"===t?r:function(e){return o(t).update(e).digest()}}(t),s="sha512"===t||"sha384"===t?128:64;e.length>s?e=a(e):e.length<s&&(e=u.concat([e,c],s));for(var l=u.allocUnsafe(s+f[t]),h=u.allocUnsafe(s+f[t]),d=0;d<s;d++)l[d]=54^e[d],h[d]=92^e[d];var p=u.allocUnsafe(s+n+4);l.copy(p,0,0,s),this.ipad1=p,this.ipad2=l,this.opad=h,this.alg=t,this.blocksize=s,this.hash=a,this.size=f[t]}l.prototype.run=function(t,e){return t.copy(e,this.blocksize),this.hash(e).copy(this.opad,this.blocksize),this.hash(this.opad)},t.exports=function(t,e,n,r,i){a(t,e,n,r),u.isBuffer(t)||(t=u.from(t,s)),u.isBuffer(e)||(e=u.from(e,s));var o=new l(i=i||"sha1",t,e.length),c=u.allocUnsafe(r),h=u.allocUnsafe(e.length+4);e.copy(h,0,0,e.length);for(var d=0,p=f[i],g=Math.ceil(r/p),y=1;y<=g;y++){h.writeUInt32BE(y,e.length);for(var b=o.run(h,o.ipad1),m=b,v=1;v<n;v++){m=o.run(m,o.ipad2);for(var _=0;_<p;_++)b[_]^=m[_]}b.copy(c,d),d+=p}return c}},function(t,e,n){var r=n(55),i=n(3).Buffer,o=n(207);function a(t){var e=t._cipher.encryptBlockRaw(t._prev);return o(t._prev),e}e.encrypt=function(t,e){var n=Math.ceil(e.length/16),o=t._cache.length;t._cache=i.concat([t._cache,i.allocUnsafe(16*n)]);for(var s=0;s<n;s++){var u=a(t),c=o+16*s;t._cache.writeUInt32BE(u[0],c+0),t._cache.writeUInt32BE(u[1],c+4),t._cache.writeUInt32BE(u[2],c+8),t._cache.writeUInt32BE(u[3],c+12)}var f=t._cache.slice(0,e.length);return t._cache=t._cache.slice(e.length),r(e,f)}},function(t,e){t.exports=function(t){for(var e,n=t.length;n--;){if(255!==(e=t.readUInt8(n))){e++,t.writeUInt8(e,n);break}t.writeUInt8(0,n)}}},function(t){t.exports=JSON.parse('{"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}}')},function(t,e,n){var r=n(79),i=n(3).Buffer,o=n(31),a=n(2),s=n(453),u=n(55),c=n(207);function f(t,e,n,a){o.call(this);var u=i.alloc(4,0);this._cipher=new r.AES(e);var f=this._cipher.encryptBlock(u);this._ghash=new s(f),n=function(t,e,n){if(12===e.length)return t._finID=i.concat([e,i.from([0,0,0,1])]),i.concat([e,i.from([0,0,0,2])]);var r=new s(n),o=e.length,a=o%16;r.update(e),a&&(a=16-a,r.update(i.alloc(a,0))),r.update(i.alloc(8,0));var u=8*o,f=i.alloc(8);f.writeUIntBE(u,0,8),r.update(f),t._finID=r.state;var l=i.from(t._finID);return c(l),l}(this,n,f),this._prev=i.from(n),this._cache=i.allocUnsafe(0),this._secCache=i.allocUnsafe(0),this._decrypt=a,this._alen=0,this._len=0,this._mode=t,this._authTag=null,this._called=!1}a(f,o),f.prototype._update=function(t){if(!this._called&&this._alen){var e=16-this._alen%16;e<16&&(e=i.alloc(e,0),this._ghash.update(e))}this._called=!0;var n=this._mode.encrypt(this,t);return this._decrypt?this._ghash.update(t):this._ghash.update(n),this._len+=t.length,n},f.prototype._final=function(){if(this._decrypt&&!this._authTag)throw new Error("Unsupported state or unable to authenticate data");var t=u(this._ghash.final(8*this._alen,8*this._len),this._cipher.encryptBlock(this._finID));if(this._decrypt&&function(t,e){var n=0;t.length!==e.length&&n++;for(var r=Math.min(t.length,e.length),i=0;i<r;++i)n+=t[i]^e[i];return n}(t,this._authTag))throw new Error("Unsupported state or unable to authenticate data");this._authTag=t,this._cipher.scrub()},f.prototype.getAuthTag=function(){if(this._decrypt||!i.isBuffer(this._authTag))throw new Error("Attempting to get auth tag in unsupported state");return this._authTag},f.prototype.setAuthTag=function(t){if(!this._decrypt)throw new Error("Attempting to set auth tag in unsupported state");this._authTag=t},f.prototype.setAAD=function(t){if(this._called)throw new Error("Attempting to set AAD in unsupported state");this._ghash.update(t),this._alen+=t.length},t.exports=f},function(t,e,n){var r=n(79),i=n(3).Buffer,o=n(31);function a(t,e,n,a){o.call(this),this._cipher=new r.AES(e),this._prev=i.from(n),this._cache=i.allocUnsafe(0),this._secCache=i.allocUnsafe(0),this._decrypt=a,this._mode=t}n(2)(a,o),a.prototype._update=function(t){return this._mode.encrypt(this,t,this._decrypt)},a.prototype._final=function(){this._cipher.scrub()},t.exports=a},function(t,e,n){var r=n(44);t.exports=m,m.simpleSieve=y,m.fermatTest=b;var i=n(5),o=new i(24),a=new(n(212)),s=new i(1),u=new i(2),c=new i(5),f=(new i(16),new i(8),new i(10)),l=new i(3),h=(new i(7),new i(11)),d=new i(4),p=(new i(12),null);function g(){if(null!==p)return p;var t=[];t[0]=2;for(var e=1,n=3;n<1048576;n+=2){for(var r=Math.ceil(Math.sqrt(n)),i=0;i<e&&t[i]<=r&&n%t[i]!=0;i++);e!==i&&t[i]<=r||(t[e++]=n)}return p=t,t}function y(t){for(var e=g(),n=0;n<e.length;n++)if(0===t.modn(e[n]))return 0===t.cmpn(e[n]);return!0}function b(t){var e=i.mont(t);return 0===u.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1)}function m(t,e){if(t<16)return new i(2===e||5===e?[140,123]:[140,39]);var n,p;for(e=new i(e);;){for(n=new i(r(Math.ceil(t/8)));n.bitLength()>t;)n.ishrn(1);if(n.isEven()&&n.iadd(s),n.testn(1)||n.iadd(u),e.cmp(u)){if(!e.cmp(c))for(;n.mod(f).cmp(l);)n.iadd(d)}else for(;n.mod(o).cmp(h);)n.iadd(d);if(y(p=n.shrn(1))&&y(n)&&b(p)&&b(n)&&a.test(p)&&a.test(n))return n}}},function(t,e,n){var r=n(5),i=n(123);function o(t){this.rand=t||new i.Rand}t.exports=o,o.create=function(t){return new o(t)},o.prototype._randbelow=function(t){var e=t.bitLength(),n=Math.ceil(e/8);do{var i=new r(this.rand.generate(n))}while(i.cmp(t)>=0);return i},o.prototype._randrange=function(t,e){var n=e.sub(t);return t.add(this._randbelow(n))},o.prototype.test=function(t,e,n){var i=t.bitLength(),o=r.mont(t),a=new r(1).toRed(o);e||(e=Math.max(1,i/48|0));for(var s=t.subn(1),u=0;!s.testn(u);u++);for(var c=t.shrn(u),f=s.toRed(o);e>0;e--){var l=this._randrange(new r(2),s);n&&n(l);var h=l.toRed(o).redPow(c);if(0!==h.cmp(a)&&0!==h.cmp(f)){for(var d=1;d<u;d++){if(0===(h=h.redSqr()).cmp(a))return!1;if(0===h.cmp(f))break}if(d===u)return!1}}return!0},o.prototype.getDivisor=function(t,e){var n=t.bitLength(),i=r.mont(t),o=new r(1).toRed(i);e||(e=Math.max(1,n/48|0));for(var a=t.subn(1),s=0;!a.testn(s);s++);for(var u=t.shrn(s),c=a.toRed(i);e>0;e--){var f=this._randrange(new r(2),a),l=t.gcd(f);if(0!==l.cmpn(1))return l;var h=f.toRed(i).redPow(u);if(0!==h.cmp(o)&&0!==h.cmp(c)){for(var d=1;d<s;d++){if(0===(h=h.redSqr()).cmp(o))return h.fromRed().subn(1).gcd(t);if(0===h.cmp(c))break}if(d===s)return(h=h.redSqr()).fromRed().subn(1).gcd(t)}}return!1}},function(t,e,n){"use strict";var r=e;function i(t){return 1===t.length?"0"+t:t}function o(t){for(var e="",n=0;n<t.length;n++)e+=i(t[n].toString(16));return e}r.toArray=function(t,e){if(Array.isArray(t))return t.slice();if(!t)return[];var n=[];if("string"!=typeof t){for(var r=0;r<t.length;r++)n[r]=0|t[r];return n}if("hex"===e){(t=t.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(t="0"+t);for(r=0;r<t.length;r+=2)n.push(parseInt(t[r]+t[r+1],16))}else for(r=0;r<t.length;r++){var i=t.charCodeAt(r),o=i>>8,a=255&i;o?n.push(o,a):n.push(a)}return n},r.zero2=i,r.toHex=o,r.encode=function(t,e){return"hex"===e?o(t):t}},function(t,e,n){"use strict";var r=e;r.base=n(81),r.short=n(464),r.mont=n(465),r.edwards=n(466)},function(t,e,n){"use strict";var r=n(21).rotr32;function i(t,e,n){return t&e^~t&n}function o(t,e,n){return t&e^t&n^e&n}function a(t,e,n){return t^e^n}e.ft_1=function(t,e,n,r){return 0===t?i(e,n,r):1===t||3===t?a(e,n,r):2===t?o(e,n,r):void 0},e.ch32=i,e.maj32=o,e.p32=a,e.s0_256=function(t){return r(t,2)^r(t,13)^r(t,22)},e.s1_256=function(t){return r(t,6)^r(t,11)^r(t,25)},e.g0_256=function(t){return r(t,7)^r(t,18)^t>>>3},e.g1_256=function(t){return r(t,17)^r(t,19)^t>>>10}},function(t,e,n){"use strict";var r=n(21),i=n(56),o=n(215),a=n(15),s=r.sum32,u=r.sum32_4,c=r.sum32_5,f=o.ch32,l=o.maj32,h=o.s0_256,d=o.s1_256,p=o.g0_256,g=o.g1_256,y=i.BlockHash,b=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];function m(){if(!(this instanceof m))return new m;y.call(this),this.h=[1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225],this.k=b,this.W=new Array(64)}r.inherits(m,y),t.exports=m,m.blockSize=512,m.outSize=256,m.hmacStrength=192,m.padLength=64,m.prototype._update=function(t,e){for(var n=this.W,r=0;r<16;r++)n[r]=t[e+r];for(;r<n.length;r++)n[r]=u(g(n[r-2]),n[r-7],p(n[r-15]),n[r-16]);var i=this.h[0],o=this.h[1],y=this.h[2],b=this.h[3],m=this.h[4],v=this.h[5],_=this.h[6],w=this.h[7];for(a(this.k.length===n.length),r=0;r<n.length;r++){var x=c(w,d(m),f(m,v,_),this.k[r],n[r]),k=s(h(i),l(i,o,y));w=_,_=v,v=m,m=s(b,x),b=y,y=o,o=i,i=s(x,k)}this.h[0]=s(this.h[0],i),this.h[1]=s(this.h[1],o),this.h[2]=s(this.h[2],y),this.h[3]=s(this.h[3],b),this.h[4]=s(this.h[4],m),this.h[5]=s(this.h[5],v),this.h[6]=s(this.h[6],_),this.h[7]=s(this.h[7],w)},m.prototype._digest=function(t){return"hex"===t?r.toHex32(this.h,"big"):r.split32(this.h,"big")}},function(t,e,n){"use strict";var r=n(21),i=n(56),o=n(15),a=r.rotr64_hi,s=r.rotr64_lo,u=r.shr64_hi,c=r.shr64_lo,f=r.sum64,l=r.sum64_hi,h=r.sum64_lo,d=r.sum64_4_hi,p=r.sum64_4_lo,g=r.sum64_5_hi,y=r.sum64_5_lo,b=i.BlockHash,m=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function v(){if(!(this instanceof v))return new v;b.call(this),this.h=[1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209],this.k=m,this.W=new Array(160)}function _(t,e,n,r,i){var o=t&n^~t&i;return o<0&&(o+=4294967296),o}function w(t,e,n,r,i,o){var a=e&r^~e&o;return a<0&&(a+=4294967296),a}function x(t,e,n,r,i){var o=t&n^t&i^n&i;return o<0&&(o+=4294967296),o}function k(t,e,n,r,i,o){var a=e&r^e&o^r&o;return a<0&&(a+=4294967296),a}function E(t,e){var n=a(t,e,28)^a(e,t,2)^a(e,t,7);return n<0&&(n+=4294967296),n}function A(t,e){var n=s(t,e,28)^s(e,t,2)^s(e,t,7);return n<0&&(n+=4294967296),n}function S(t,e){var n=a(t,e,14)^a(t,e,18)^a(e,t,9);return n<0&&(n+=4294967296),n}function T(t,e){var n=s(t,e,14)^s(t,e,18)^s(e,t,9);return n<0&&(n+=4294967296),n}function M(t,e){var n=a(t,e,1)^a(t,e,8)^u(t,e,7);return n<0&&(n+=4294967296),n}function D(t,e){var n=s(t,e,1)^s(t,e,8)^c(t,e,7);return n<0&&(n+=4294967296),n}function C(t,e){var n=a(t,e,19)^a(e,t,29)^u(t,e,6);return n<0&&(n+=4294967296),n}function O(t,e){var n=s(t,e,19)^s(e,t,29)^c(t,e,6);return n<0&&(n+=4294967296),n}r.inherits(v,b),t.exports=v,v.blockSize=1024,v.outSize=512,v.hmacStrength=192,v.padLength=128,v.prototype._prepareBlock=function(t,e){for(var n=this.W,r=0;r<32;r++)n[r]=t[e+r];for(;r<n.length;r+=2){var i=C(n[r-4],n[r-3]),o=O(n[r-4],n[r-3]),a=n[r-14],s=n[r-13],u=M(n[r-30],n[r-29]),c=D(n[r-30],n[r-29]),f=n[r-32],l=n[r-31];n[r]=d(i,o,a,s,u,c,f,l),n[r+1]=p(i,o,a,s,u,c,f,l)}},v.prototype._update=function(t,e){this._prepareBlock(t,e);var n=this.W,r=this.h[0],i=this.h[1],a=this.h[2],s=this.h[3],u=this.h[4],c=this.h[5],d=this.h[6],p=this.h[7],b=this.h[8],m=this.h[9],v=this.h[10],M=this.h[11],D=this.h[12],C=this.h[13],O=this.h[14],R=this.h[15];o(this.k.length===n.length);for(var I=0;I<n.length;I+=2){var N=O,B=R,L=S(b,m),P=T(b,m),F=_(b,m,v,M,D),q=w(b,m,v,M,D,C),j=this.k[I],U=this.k[I+1],z=n[I],Y=n[I+1],V=g(N,B,L,P,F,q,j,U,z,Y),H=y(N,B,L,P,F,q,j,U,z,Y);N=E(r,i),B=A(r,i),L=x(r,i,a,s,u),P=k(r,i,a,s,u,c);var $=l(N,B,L,P),G=h(N,B,L,P);O=D,R=C,D=v,C=M,v=b,M=m,b=l(d,p,V,H),m=h(p,p,V,H),d=u,p=c,u=a,c=s,a=r,s=i,r=l(V,H,$,G),i=h(V,H,$,G)}f(this.h,0,r,i),f(this.h,2,a,s),f(this.h,4,u,c),f(this.h,6,d,p),f(this.h,8,b,m),f(this.h,10,v,M),f(this.h,12,D,C),f(this.h,14,O,R)},v.prototype._digest=function(t){return"hex"===t?r.toHex32(this.h,"big"):r.split32(this.h,"big")}},function(t,e,n){var r=n(2),i=n(58).Reporter,o=n(8).Buffer;function a(t,e){i.call(this,e),o.isBuffer(t)?(this.base=t,this.offset=0,this.length=t.length):this.error("Input not Buffer")}function s(t,e){if(Array.isArray(t))this.length=0,this.value=t.map((function(t){return t instanceof s||(t=new s(t,e)),this.length+=t.length,t}),this);else if("number"==typeof t){if(!(0<=t&&t<=255))return e.error("non-byte EncoderBuffer value");this.value=t,this.length=1}else if("string"==typeof t)this.value=t,this.length=o.byteLength(t);else{if(!o.isBuffer(t))return e.error("Unsupported type: "+typeof t);this.value=t,this.length=t.length}}r(a,i),e.DecoderBuffer=a,a.prototype.save=function(){return{offset:this.offset,reporter:i.prototype.save.call(this)}},a.prototype.restore=function(t){var e=new a(this.base);return e.offset=t.offset,e.length=this.offset,this.offset=t.offset,i.prototype.restore.call(this,t.reporter),e},a.prototype.isEmpty=function(){return this.offset===this.length},a.prototype.readUInt8=function(t){return this.offset+1<=this.length?this.base.readUInt8(this.offset++,!0):this.error(t||"DecoderBuffer overrun")},a.prototype.skip=function(t,e){if(!(this.offset+t<=this.length))return this.error(e||"DecoderBuffer overrun");var n=new a(this.base);return n._reporterState=this._reporterState,n.offset=this.offset,n.length=this.offset+t,this.offset+=t,n},a.prototype.raw=function(t){return this.base.slice(t?t.offset:this.offset,this.length)},e.EncoderBuffer=s,s.prototype.join=function(t,e){return t||(t=new o(this.length)),e||(e=0),0===this.length?t:(Array.isArray(this.value)?this.value.forEach((function(n){n.join(t,e),e+=n.length})):("number"==typeof this.value?t[e]=this.value:"string"==typeof this.value?t.write(this.value,e):o.isBuffer(this.value)&&this.value.copy(t,e),e+=this.length),t)}},function(t,e,n){var r=e;r._reverse=function(t){var e={};return Object.keys(t).forEach((function(n){(0|n)==n&&(n|=0);var r=t[n];e[r]=n})),e},r.der=n(486)},function(t,e,n){var r=n(2),i=n(57),o=i.base,a=i.bignum,s=i.constants.der;function u(t){this.enc="der",this.name=t.name,this.entity=t,this.tree=new c,this.tree._init(t.body)}function c(t){o.Node.call(this,"der",t)}function f(t,e){var n=t.readUInt8(e);if(t.isError(n))return n;var r=s.tagClass[n>>6],i=0==(32&n);if(31==(31&n)){var o=n;for(n=0;128==(128&o);){if(o=t.readUInt8(e),t.isError(o))return o;n<<=7,n|=127&o}}else n&=31;return{cls:r,primitive:i,tag:n,tagStr:s.tag[n]}}function l(t,e,n){var r=t.readUInt8(n);if(t.isError(r))return r;if(!e&&128===r)return null;if(0==(128&r))return r;var i=127&r;if(i>4)return t.error("length octect is too long");r=0;for(var o=0;o<i;o++){r<<=8;var a=t.readUInt8(n);if(t.isError(a))return a;r|=a}return r}t.exports=u,u.prototype.decode=function(t,e){return t instanceof o.DecoderBuffer||(t=new o.DecoderBuffer(t,e)),this.tree._decode(t,e)},r(c,o.Node),c.prototype._peekTag=function(t,e,n){if(t.isEmpty())return!1;var r=t.save(),i=f(t,'Failed to peek tag: "'+e+'"');return t.isError(i)?i:(t.restore(r),i.tag===e||i.tagStr===e||i.tagStr+"of"===e||n)},c.prototype._decodeTag=function(t,e,n){var r=f(t,'Failed to decode tag of "'+e+'"');if(t.isError(r))return r;var i=l(t,r.primitive,'Failed to get length of "'+e+'"');if(t.isError(i))return i;if(!n&&r.tag!==e&&r.tagStr!==e&&r.tagStr+"of"!==e)return t.error('Failed to match tag: "'+e+'"');if(r.primitive||null!==i)return t.skip(i,'Failed to match body of: "'+e+'"');var o=t.save(),a=this._skipUntilEnd(t,'Failed to skip indefinite length body: "'+this.tag+'"');return t.isError(a)?a:(i=t.offset-o.offset,t.restore(o),t.skip(i,'Failed to match body of: "'+e+'"'))},c.prototype._skipUntilEnd=function(t,e){for(;;){var n=f(t,e);if(t.isError(n))return n;var r,i=l(t,n.primitive,e);if(t.isError(i))return i;if(r=n.primitive||null!==i?t.skip(i):this._skipUntilEnd(t,e),t.isError(r))return r;if("end"===n.tagStr)break}},c.prototype._decodeList=function(t,e,n,r){for(var i=[];!t.isEmpty();){var o=this._peekTag(t,"end");if(t.isError(o))return o;var a=n.decode(t,"der",r);if(t.isError(a)&&o)break;i.push(a)}return i},c.prototype._decodeStr=function(t,e){if("bitstr"===e){var n=t.readUInt8();return t.isError(n)?n:{unused:n,data:t.raw()}}if("bmpstr"===e){var r=t.raw();if(r.length%2==1)return t.error("Decoding of string type: bmpstr length mismatch");for(var i="",o=0;o<r.length/2;o++)i+=String.fromCharCode(r.readUInt16BE(2*o));return i}if("numstr"===e){var a=t.raw().toString("ascii");return this._isNumstr(a)?a:t.error("Decoding of string type: numstr unsupported characters")}if("octstr"===e)return t.raw();if("objDesc"===e)return t.raw();if("printstr"===e){var s=t.raw().toString("ascii");return this._isPrintstr(s)?s:t.error("Decoding of string type: printstr unsupported characters")}return/str$/.test(e)?t.raw().toString():t.error("Decoding of string type: "+e+" unsupported")},c.prototype._decodeObjid=function(t,e,n){for(var r,i=[],o=0;!t.isEmpty();){var a=t.readUInt8();o<<=7,o|=127&a,0==(128&a)&&(i.push(o),o=0)}128&a&&i.push(o);var s=i[0]/40|0,u=i[0]%40;if(r=n?i:[s,u].concat(i.slice(1)),e){var c=e[r.join(" ")];void 0===c&&(c=e[r.join(".")]),void 0!==c&&(r=c)}return r},c.prototype._decodeTime=function(t,e){var n=t.raw().toString();if("gentime"===e)var r=0|n.slice(0,4),i=0|n.slice(4,6),o=0|n.slice(6,8),a=0|n.slice(8,10),s=0|n.slice(10,12),u=0|n.slice(12,14);else{if("utctime"!==e)return t.error("Decoding "+e+" time is not supported yet");r=0|n.slice(0,2),i=0|n.slice(2,4),o=0|n.slice(4,6),a=0|n.slice(6,8),s=0|n.slice(8,10),u=0|n.slice(10,12);r=r<70?2e3+r:1900+r}return Date.UTC(r,i-1,o,a,s,u,0)},c.prototype._decodeNull=function(t){return null},c.prototype._decodeBool=function(t){var e=t.readUInt8();return t.isError(e)?e:0!==e},c.prototype._decodeInt=function(t,e){var n=t.raw(),r=new a(n);return e&&(r=e[r.toString(10)]||r),r},c.prototype._use=function(t,e){return"function"==typeof t&&(t=t(e)),t._getDecoder("der").tree}},function(t,e,n){var r=n(2),i=n(8).Buffer,o=n(57),a=o.base,s=o.constants.der;function u(t){this.enc="der",this.name=t.name,this.entity=t,this.tree=new c,this.tree._init(t.body)}function c(t){a.Node.call(this,"der",t)}function f(t){return t<10?"0"+t:t}t.exports=u,u.prototype.encode=function(t,e){return this.tree._encode(t,e).join()},r(c,a.Node),c.prototype._encodeComposite=function(t,e,n,r){var o,a=function(t,e,n,r){var i;"seqof"===t?t="seq":"setof"===t&&(t="set");if(s.tagByName.hasOwnProperty(t))i=s.tagByName[t];else{if("number"!=typeof t||(0|t)!==t)return r.error("Unknown tag: "+t);i=t}if(i>=31)return r.error("Multi-octet tag encoding unsupported");e||(i|=32);return i|=s.tagClassByName[n||"universal"]<<6}(t,e,n,this.reporter);if(r.length<128)return(o=new i(2))[0]=a,o[1]=r.length,this._createEncoderBuffer([o,r]);for(var u=1,c=r.length;c>=256;c>>=8)u++;(o=new i(2+u))[0]=a,o[1]=128|u;c=1+u;for(var f=r.length;f>0;c--,f>>=8)o[c]=255&f;return this._createEncoderBuffer([o,r])},c.prototype._encodeStr=function(t,e){if("bitstr"===e)return this._createEncoderBuffer([0|t.unused,t.data]);if("bmpstr"===e){for(var n=new i(2*t.length),r=0;r<t.length;r++)n.writeUInt16BE(t.charCodeAt(r),2*r);return this._createEncoderBuffer(n)}return"numstr"===e?this._isNumstr(t)?this._createEncoderBuffer(t):this.reporter.error("Encoding of string type: numstr supports only digits and space"):"printstr"===e?this._isPrintstr(t)?this._createEncoderBuffer(t):this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark"):/str$/.test(e)?this._createEncoderBuffer(t):"objDesc"===e?this._createEncoderBuffer(t):this.reporter.error("Encoding of string type: "+e+" unsupported")},c.prototype._encodeObjid=function(t,e,n){if("string"==typeof t){if(!e)return this.reporter.error("string objid given, but no values map found");if(!e.hasOwnProperty(t))return this.reporter.error("objid not found in values map");t=e[t].split(/[\s\.]+/g);for(var r=0;r<t.length;r++)t[r]|=0}else if(Array.isArray(t)){t=t.slice();for(r=0;r<t.length;r++)t[r]|=0}if(!Array.isArray(t))return this.reporter.error("objid() should be either array or string, got: "+JSON.stringify(t));if(!n){if(t[1]>=40)return this.reporter.error("Second objid identifier OOB");t.splice(0,2,40*t[0]+t[1])}var o=0;for(r=0;r<t.length;r++){var a=t[r];for(o++;a>=128;a>>=7)o++}var s=new i(o),u=s.length-1;for(r=t.length-1;r>=0;r--){a=t[r];for(s[u--]=127&a;(a>>=7)>0;)s[u--]=128|127&a}return this._createEncoderBuffer(s)},c.prototype._encodeTime=function(t,e){var n,r=new Date(t);return"gentime"===e?n=[f(r.getFullYear()),f(r.getUTCMonth()+1),f(r.getUTCDate()),f(r.getUTCHours()),f(r.getUTCMinutes()),f(r.getUTCSeconds()),"Z"].join(""):"utctime"===e?n=[f(r.getFullYear()%100),f(r.getUTCMonth()+1),f(r.getUTCDate()),f(r.getUTCHours()),f(r.getUTCMinutes()),f(r.getUTCSeconds()),"Z"].join(""):this.reporter.error("Encoding "+e+" time is not supported yet"),this._encodeStr(n,"octstr")},c.prototype._encodeNull=function(){return this._createEncoderBuffer("")},c.prototype._encodeInt=function(t,e){if("string"==typeof t){if(!e)return this.reporter.error("String int or enum given, but no values map");if(!e.hasOwnProperty(t))return this.reporter.error("Values map doesn't contain: "+JSON.stringify(t));t=e[t]}if("number"!=typeof t&&!i.isBuffer(t)){var n=t.toArray();!t.sign&&128&n[0]&&n.unshift(0),t=new i(n)}if(i.isBuffer(t)){var r=t.length;0===t.length&&r++;var o=new i(r);return t.copy(o),0===t.length&&(o[0]=0),this._createEncoderBuffer(o)}if(t<128)return this._createEncoderBuffer(t);if(t<256)return this._createEncoderBuffer([0,t]);r=1;for(var a=t;a>=256;a>>=8)r++;for(a=(o=new Array(r)).length-1;a>=0;a--)o[a]=255&t,t>>=8;return 128&o[0]&&o.unshift(0),this._createEncoderBuffer(new i(o))},c.prototype._encodeBool=function(t){return this._createEncoderBuffer(t?255:0)},c.prototype._use=function(t,e){return"function"==typeof t&&(t=t(e)),t._getEncoder("der").tree},c.prototype._skipDefault=function(t,e,n){var r,i=this._baseState;if(null===i.default)return!1;var o=t.join();if(void 0===i.defaultBuffer&&(i.defaultBuffer=this._encodeValue(i.default,e,n).join()),o.length!==i.defaultBuffer.length)return!1;for(r=0;r<o.length;r++)if(o[r]!==i.defaultBuffer[r])return!1;return!0}},function(t){t.exports=JSON.parse('{"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}')},function(t,e,n){var r=n(53),i=n(3).Buffer;function o(t){var e=i.allocUnsafe(4);return e.writeUInt32BE(t,0),e}t.exports=function(t,e){for(var n,a=i.alloc(0),s=0;a.length<e;)n=o(s++),a=i.concat([a,r("sha1").update(t).update(n).digest()]);return a.slice(0,e)}},function(t,e){t.exports=function(t,e){for(var n=t.length,r=-1;++r<n;)t[r]^=e[r];return t}},function(t,e,n){var r=n(5),i=n(3).Buffer;t.exports=function(t,e){return i.from(t.toRed(r.mont(e.modulus)).redPow(new r(e.publicExponent)).fromRed().toArray())}},function(t,e,n){(function(t,n){!function(r){var i=e,o=t&&t.exports==i&&t,a="object"==typeof n&&n;a.global!==a&&a.window!==a||(r=a);var s=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,u=/[\x01-\x7F]/g,c=/[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,f=/<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g,l={"":"shy","":"zwnj","":"zwj","":"lrm","":"ic","":"it","":"af","":"rlm","":"ZeroWidthSpace","":"NoBreak","":"DownBreve","":"tdot","":"DotDot","\t":"Tab","\n":"NewLine","":"puncsp","":"MediumSpace","":"thinsp","":"hairsp","":"emsp13","":"ensp","":"emsp14","":"emsp","":"numsp","":"nbsp","":"ThickSpace","":"oline",_:"lowbar","":"dash","":"ndash","":"mdash","":"horbar",",":"comma",";":"semi","":"bsemi",":":"colon","":"Colone","!":"excl","":"iexcl","?":"quest","":"iquest",".":"period","":"nldr","":"mldr","":"middot","'":"apos","":"lsquo","":"rsquo","":"sbquo","":"lsaquo","":"rsaquo",'"':"quot","":"ldquo","":"rdquo","":"bdquo","":"laquo","":"raquo","(":"lpar",")":"rpar","[":"lsqb","]":"rsqb","{":"lcub","}":"rcub","":"lceil","":"rceil","":"lfloor","":"rfloor","":"lopar","":"ropar","":"lbrke","":"rbrke","":"lbrkslu","":"rbrksld","":"lbrksld","":"rbrkslu","":"langd","":"rangd","":"lparlt","":"rpargt","":"gtlPar","":"ltrPar","":"lobrk","":"robrk","":"lang","":"rang","":"Lang","":"Rang","":"loang","":"roang","":"lbbrk","":"rbbrk","":"Vert","":"sect","":"para","@":"commat","*":"ast","/":"sol",undefined:null,"&":"amp","#":"num","%":"percnt","":"permil","":"pertenk","":"dagger","":"Dagger","":"bull","":"hybull","":"prime","":"Prime","":"tprime","":"qprime","":"bprime","":"caret","`":"grave","":"acute","":"tilde","^":"Hat","":"macr","":"breve","":"dot","":"die","":"ring","":"dblac","":"cedil","":"ogon","":"circ","":"caron","":"deg","":"copy","":"reg","":"copysr","":"wp","":"rx","":"mho","":"iiota","":"larr","":"nlarr","":"rarr","":"nrarr","":"uarr","":"darr","":"harr","":"nharr","":"varr","":"nwarr","":"nearr","":"searr","":"swarr","":"rarrw","":"nrarrw","":"Larr","":"Uarr","":"Rarr","":"Darr","":"larrtl","":"rarrtl","":"mapstoleft","":"mapstoup","":"map","":"mapstodown","":"larrhk","":"rarrhk","":"larrlp","":"rarrlp","":"harrw","":"lsh","":"rsh","":"ldsh","":"rdsh","":"crarr","":"cularr","":"curarr","":"olarr","":"orarr","":"lharu","":"lhard","":"uharr","":"uharl","":"rharu","":"rhard","":"dharr","":"dharl","":"rlarr","":"udarr","":"lrarr","":"llarr","":"uuarr","":"rrarr","":"ddarr","":"lrhar","":"rlhar","":"lArr","":"nlArr","":"uArr","":"rArr","":"nrArr","":"dArr","":"iff","":"nhArr","":"vArr","":"nwArr","":"neArr","":"seArr","":"swArr","":"lAarr","":"rAarr","":"zigrarr","":"larrb","":"rarrb","":"duarr","":"loarr","":"roarr","":"hoarr","":"forall","":"comp","":"part","":"npart","":"exist","":"nexist","":"empty","":"Del","":"in","":"notin","":"ni","":"notni","":"bepsi","":"prod","":"coprod","":"sum","+":"plus","":"pm","":"div","":"times","<":"lt","":"nlt","<":"nvlt","=":"equals","":"ne","=":"bne","":"Equal",">":"gt","":"ngt",">":"nvgt","":"not","|":"vert","":"brvbar","":"minus","":"mp","":"plusdo","":"frasl","":"setmn","":"lowast","":"compfn","":"Sqrt","":"prop","":"infin","":"angrt","":"ang","":"nang","":"angmsd","":"angsph","":"mid","":"nmid","":"par","":"npar","":"and","":"or","":"cap","":"caps","":"cup","":"cups","":"int","":"Int","":"tint","":"qint","":"oint","":"Conint","":"Cconint","":"cwint","":"cwconint","":"awconint","":"there4","":"becaus","":"ratio","":"Colon","":"minusd","":"mDDot","":"homtht","":"sim","":"nsim","":"nvsim","":"bsim","":"race","":"ac","":"acE","":"acd","":"wr","":"esim","":"nesim","":"sime","":"nsime","":"cong","":"ncong","":"simne","":"ap","":"nap","":"ape","":"apid","":"napid","":"bcong","":"CupCap","":"NotCupCap","":"nvap","":"bump","":"nbump","":"bumpe","":"nbumpe","":"doteq","":"nedot","":"eDot","":"efDot","":"erDot","":"colone","":"ecolon","":"ecir","":"cire","":"wedgeq","":"veeeq","":"trie","":"equest","":"equiv","":"nequiv","":"bnequiv","":"le","":"nle","":"nvle","":"ge","":"nge","":"nvge","":"lE","":"nlE","":"gE","":"ngE","":"lvnE","":"lnE","":"gnE","":"gvnE","":"ll","":"nLtv","":"nLt","":"gg","":"nGtv","":"nGt","":"twixt","":"lsim","":"nlsim","":"gsim","":"ngsim","":"lg","":"ntlg","":"gl","":"ntgl","":"pr","":"npr","":"sc","":"nsc","":"prcue","":"nprcue","":"sccue","":"nsccue","":"prsim","":"scsim","":"NotSucceedsTilde","":"sub","":"nsub","":"vnsub","":"sup","":"nsup","":"vnsup","":"sube","":"nsube","":"supe","":"nsupe","":"vsubne","":"subne","":"vsupne","":"supne","":"cupdot","":"uplus","":"sqsub","":"NotSquareSubset","":"sqsup","":"NotSquareSuperset","":"sqsube","":"nsqsube","":"sqsupe","":"nsqsupe","":"sqcap","":"sqcaps","":"sqcup","":"sqcups","":"oplus","":"ominus","":"otimes","":"osol","":"odot","":"ocir","":"oast","":"odash","":"plusb","":"minusb","":"timesb","":"sdotb","":"vdash","":"nvdash","":"dashv","":"top","":"bot","":"models","":"vDash","":"nvDash","":"Vdash","":"nVdash","":"Vvdash","":"VDash","":"nVDash","":"prurel","":"vltri","":"nltri","":"vrtri","":"nrtri","":"ltrie","":"nltrie","":"nvltrie","":"rtrie","":"nrtrie","":"nvrtrie","":"origof","":"imof","":"mumap","":"hercon","":"intcal","":"veebar","":"barvee","":"angrtvb","":"lrtri","":"Wedge","":"Vee","":"xcap","":"xcup","":"diam","":"sdot","":"Star","":"divonx","":"bowtie","":"ltimes","":"rtimes","":"lthree","":"rthree","":"bsime","":"cuvee","":"cuwed","":"Sub","":"Sup","":"Cap","":"Cup","":"fork","":"epar","":"ltdot","":"gtdot","":"Ll","":"nLl","":"Gg","":"nGg","":"lesg","":"leg","":"gel","":"gesl","":"cuepr","":"cuesc","":"lnsim","":"gnsim","":"prnsim","":"scnsim","":"vellip","":"ctdot","":"utdot","":"dtdot","":"disin","":"isinsv","":"isins","":"isindot","":"notindot","":"notinvc","":"notinvb","":"isinE","":"notinE","":"nisd","":"xnis","":"nis","":"notnivc","":"notnivb","":"barwed","":"Barwed","":"drcrop","":"dlcrop","":"urcrop","":"ulcrop","":"bnot","":"profline","":"profsurf","":"telrec","":"target","":"ulcorn","":"urcorn","":"dlcorn","":"drcorn","":"frown","":"smile","":"cylcty","":"profalar","":"topbot","":"ovbar","":"solbar","":"angzarr","":"lmoust","":"rmoust","":"tbrk","":"bbrk","":"bbrktbrk","":"OverParenthesis","":"UnderParenthesis","":"OverBrace","":"UnderBrace","":"trpezium","":"elinters","":"blank","":"boxh","":"boxv","":"boxdr","":"boxdl","":"boxur","":"boxul","":"boxvr","":"boxvl","":"boxhd","":"boxhu","":"boxvh","":"boxH","":"boxV","":"boxdR","":"boxDr","":"boxDR","":"boxdL","":"boxDl","":"boxDL","":"boxuR","":"boxUr","":"boxUR","":"boxuL","":"boxUl","":"boxUL","":"boxvR","":"boxVr","":"boxVR","":"boxvL","":"boxVl","":"boxVL","":"boxHd","":"boxhD","":"boxHD","":"boxHu","":"boxhU","":"boxHU","":"boxvH","":"boxVh","":"boxVH","":"uhblk","":"lhblk","":"block","":"blk14","":"blk12","":"blk34","":"squ","":"squf","":"EmptyVerySmallSquare","":"rect","":"marker","":"fltns","":"xutri","":"utrif","":"utri","":"rtrif","":"rtri","":"xdtri","":"dtrif","":"dtri","":"ltrif","":"ltri","":"loz","":"cir","":"tridot","":"xcirc","":"ultri","":"urtri","":"lltri","":"EmptySmallSquare","":"FilledSmallSquare","":"starf","":"star","":"phone","":"female","":"male","":"spades","":"clubs","":"hearts","":"diams","":"sung","":"check","":"cross","":"malt","":"sext","":"VerticalSeparator","":"bsolhsub","":"suphsol","":"xlarr","":"xrarr","":"xharr","":"xlArr","":"xrArr","":"xhArr","":"xmap","":"dzigrarr","":"nvlArr","":"nvrArr","":"nvHarr","":"Map","":"lbarr","":"rbarr","":"lBarr","":"rBarr","":"RBarr","":"DDotrahd","":"UpArrowBar","":"DownArrowBar","":"Rarrtl","":"latail","":"ratail","":"lAtail","":"rAtail","":"larrfs","":"rarrfs","":"larrbfs","":"rarrbfs","":"nwarhk","":"nearhk","":"searhk","":"swarhk","":"nwnear","":"toea","":"tosa","":"swnwar","":"rarrc","":"nrarrc","":"cudarrr","":"ldca","":"rdca","":"cudarrl","":"larrpl","":"curarrm","":"cularrp","":"rarrpl","":"harrcir","":"Uarrocir","":"lurdshar","":"ldrushar","":"LeftRightVector","":"RightUpDownVector","":"DownLeftRightVector","":"LeftUpDownVector","":"LeftVectorBar","":"RightVectorBar","":"RightUpVectorBar","":"RightDownVectorBar","":"DownLeftVectorBar","":"DownRightVectorBar","":"LeftUpVectorBar","":"LeftDownVectorBar","":"LeftTeeVector","":"RightTeeVector","":"RightUpTeeVector","":"RightDownTeeVector","":"DownLeftTeeVector","":"DownRightTeeVector","":"LeftUpTeeVector","":"LeftDownTeeVector","":"lHar","":"uHar","":"rHar","":"dHar","":"luruhar","":"ldrdhar","":"ruluhar","":"rdldhar","":"lharul","":"llhard","":"rharul","":"lrhard","":"udhar","":"duhar","":"RoundImplies","":"erarr","":"simrarr","":"larrsim","":"rarrsim","":"rarrap","":"ltlarr","":"gtrarr","":"subrarr","":"suplarr","":"lfisht","":"rfisht","":"ufisht","":"dfisht","":"vzigzag","":"vangrt","":"angrtvbd","":"ange","":"range","":"dwangle","":"uwangle","":"angmsdaa","":"angmsdab","":"angmsdac","":"angmsdad","":"angmsdae","":"angmsdaf","":"angmsdag","":"angmsdah","":"bemptyv","":"demptyv","":"cemptyv","":"raemptyv","":"laemptyv","":"ohbar","":"omid","":"opar","":"operp","":"olcross","":"odsold","":"olcir","":"ofcir","":"olt","":"ogt","":"cirscir","":"cirE","":"solb","":"bsolb","":"boxbox","":"trisb","":"rtriltri","":"LeftTriangleBar","":"NotLeftTriangleBar","":"RightTriangleBar","":"NotRightTriangleBar","":"iinfin","":"infintie","":"nvinfin","":"eparsl","":"smeparsl","":"eqvparsl","":"lozf","":"RuleDelayed","":"dsol","":"xodot","":"xoplus","":"xotime","":"xuplus","":"xsqcup","":"fpartint","":"cirfnint","":"awint","":"rppolint","":"scpolint","":"npolint","":"pointint","":"quatint","":"intlarhk","":"pluscir","":"plusacir","":"simplus","":"plusdu","":"plussim","":"plustwo","":"mcomma","":"minusdu","":"loplus","":"roplus","":"Cross","":"timesd","":"timesbar","":"smashp","":"lotimes","":"rotimes","":"otimesas","":"Otimes","":"odiv","":"triplus","":"triminus","":"tritime","":"iprod","":"amalg","":"capdot","":"ncup","":"ncap","":"capand","":"cupor","":"cupcap","":"capcup","":"cupbrcap","":"capbrcup","":"cupcup","":"capcap","":"ccups","":"ccaps","":"ccupssm","":"And","":"Or","":"andand","":"oror","":"orslope","":"andslope","":"andv","":"orv","":"andd","":"ord","":"wedbar","":"sdote","":"simdot","":"congdot","":"ncongdot","":"easter","":"apacir","":"apE","":"napE","":"eplus","":"pluse","":"Esim","":"eDDot","":"equivDD","":"ltcir","":"gtcir","":"ltquest","":"gtquest","":"les","":"nles","":"ges","":"nges","":"lesdot","":"gesdot","":"lesdoto","":"gesdoto","":"lesdotor","":"gesdotol","":"lap","":"gap","":"lne","":"gne","":"lnap","":"gnap","":"lEg","":"gEl","":"lsime","":"gsime","":"lsimg","":"gsiml","":"lgE","":"glE","":"lesges","":"gesles","":"els","":"egs","":"elsdot","":"egsdot","":"el","":"eg","":"siml","":"simg","":"simlE","":"simgE","":"LessLess","":"NotNestedLessLess","":"GreaterGreater","":"NotNestedGreaterGreater","":"glj","":"gla","":"ltcc","":"gtcc","":"lescc","":"gescc","":"smt","":"lat","":"smte","":"smtes","":"late","":"lates","":"bumpE","":"pre","":"npre","":"sce","":"nsce","":"prE","":"scE","":"prnE","":"scnE","":"prap","":"scap","":"prnap","":"scnap","":"Pr","":"Sc","":"subdot","":"supdot","":"subplus","":"supplus","":"submult","":"supmult","":"subedot","":"supedot","":"subE","":"nsubE","":"supE","":"nsupE","":"subsim","":"supsim","":"vsubnE","":"subnE","":"vsupnE","":"supnE","":"csub","":"csup","":"csube","":"csupe","":"subsup","":"supsub","":"subsub","":"supsup","":"suphsub","":"supdsub","":"forkv","":"topfork","":"mlcp","":"Dashv","":"Vdashl","":"Barv","":"vBar","":"vBarv","":"Vbar","":"Not","":"bNot","":"rnmid","":"cirmid","":"midcir","":"topcir","":"nhpar","":"parsim","":"parsl","":"nparsl","":"flat","":"natur","":"sharp","":"curren","":"cent",$:"dollar","":"pound","":"yen","":"euro","":"sup1","":"half","":"frac13","":"frac14","":"frac15","":"frac16","":"frac18","":"sup2","":"frac23","":"frac25","":"sup3","":"frac34","":"frac35","":"frac38","":"frac45","":"frac56","":"frac58","":"frac78","":"ascr","":"aopf","":"afr","":"Aopf","":"Afr","":"Ascr","":"ordf","":"aacute","":"Aacute","":"agrave","":"Agrave","":"abreve","":"Abreve","":"acirc","":"Acirc","":"aring","":"angst","":"auml","":"Auml","":"atilde","":"Atilde","":"aogon","":"Aogon","":"amacr","":"Amacr","":"aelig","":"AElig","":"bscr","":"bopf","":"bfr","":"Bopf","":"Bscr","":"Bfr","":"cfr","":"cscr","":"copf","":"Cfr","":"Cscr","":"Copf","":"cacute","":"Cacute","":"ccirc","":"Ccirc","":"ccaron","":"Ccaron","":"cdot","":"Cdot","":"ccedil","":"Ccedil","":"incare","":"dfr","":"dd","":"dopf","":"dscr","":"Dscr","":"Dfr","":"DD","":"Dopf","":"dcaron","":"Dcaron","":"dstrok","":"Dstrok","":"eth","":"ETH","":"ee","":"escr","":"efr","":"eopf","":"Escr","":"Efr","":"Eopf","":"eacute","":"Eacute","":"egrave","":"Egrave","":"ecirc","":"Ecirc","":"ecaron","":"Ecaron","":"euml","":"Euml","":"edot","":"Edot","":"eogon","":"Eogon","":"emacr","":"Emacr","":"ffr","":"fopf","":"fscr","":"Ffr","":"Fopf","":"Fscr","":"fflig","":"ffilig","":"ffllig","":"filig",fj:"fjlig","":"fllig","":"fnof","":"gscr","":"gopf","":"gfr","":"Gscr","":"Gopf","":"Gfr","":"gacute","":"gbreve","":"Gbreve","":"gcirc","":"Gcirc","":"gdot","":"Gdot","":"Gcedil","":"hfr","":"planckh","":"hscr","":"hopf","":"Hscr","":"Hfr","":"Hopf","":"hcirc","":"Hcirc","":"hbar","":"hstrok","":"Hstrok","":"iopf","":"ifr","":"iscr","":"ii","":"Iopf","":"Iscr","":"Im","":"iacute","":"Iacute","":"igrave","":"Igrave","":"icirc","":"Icirc","":"iuml","":"Iuml","":"itilde","":"Itilde","":"Idot","":"iogon","":"Iogon","":"imacr","":"Imacr","":"ijlig","":"IJlig","":"imath","":"jscr","":"jopf","":"jfr","":"Jscr","":"Jfr","":"Jopf","":"jcirc","":"Jcirc","":"jmath","":"kopf","":"kscr","":"kfr","":"Kscr","":"Kopf","":"Kfr","":"kcedil","":"Kcedil","":"lfr","":"lscr","":"ell","":"lopf","":"Lscr","":"Lfr","":"Lopf","":"lacute","":"Lacute","":"lcaron","":"Lcaron","":"lcedil","":"Lcedil","":"lstrok","":"Lstrok","":"lmidot","":"Lmidot","":"mfr","":"mopf","":"mscr","":"Mfr","":"Mopf","":"Mscr","":"nfr","":"nopf","":"nscr","":"Nopf","":"Nscr","":"Nfr","":"nacute","":"Nacute","":"ncaron","":"Ncaron","":"ntilde","":"Ntilde","":"ncedil","":"Ncedil","":"numero","":"eng","":"ENG","":"oopf","":"ofr","":"oscr","":"Oscr","":"Ofr","":"Oopf","":"ordm","":"oacute","":"Oacute","":"ograve","":"Ograve","":"ocirc","":"Ocirc","":"ouml","":"Ouml","":"odblac","":"Odblac","":"otilde","":"Otilde","":"oslash","":"Oslash","":"omacr","":"Omacr","":"oelig","":"OElig","":"pfr","":"pscr","":"popf","":"Popf","":"Pfr","":"Pscr","":"qopf","":"qfr","":"qscr","":"Qscr","":"Qfr","":"Qopf","":"kgreen","":"rfr","":"ropf","":"rscr","":"Rscr","":"Re","":"Ropf","":"racute","":"Racute","":"rcaron","":"Rcaron","":"rcedil","":"Rcedil","":"sopf","":"sscr","":"sfr","":"Sopf","":"Sfr","":"Sscr","":"oS","":"sacute","":"Sacute","":"scirc","":"Scirc","":"scaron","":"Scaron","":"scedil","":"Scedil","":"szlig","":"tfr","":"tscr","":"topf","":"Tscr","":"Tfr","":"Topf","":"tcaron","":"Tcaron","":"tcedil","":"Tcedil","":"trade","":"tstrok","":"Tstrok","":"uscr","":"uopf","":"ufr","":"Uopf","":"Ufr","":"Uscr","":"uacute","":"Uacute","":"ugrave","":"Ugrave","":"ubreve","":"Ubreve","":"ucirc","":"Ucirc","":"uring","":"Uring","":"uuml","":"Uuml","":"udblac","":"Udblac","":"utilde","":"Utilde","":"uogon","":"Uogon","":"umacr","":"Umacr","":"vfr","":"vopf","":"vscr","":"Vfr","":"Vopf","":"Vscr","":"wopf","":"wscr","":"wfr","":"Wscr","":"Wopf","":"Wfr","":"wcirc","":"Wcirc","":"xfr","":"xscr","":"xopf","":"Xopf","":"Xfr","":"Xscr","":"yfr","":"yscr","":"yopf","":"Yscr","":"Yfr","":"Yopf","":"yacute","":"Yacute","":"ycirc","":"Ycirc","":"yuml","":"Yuml","":"zscr","":"zfr","":"zopf","":"Zfr","":"Zopf","":"Zscr","":"zacute","":"Zacute","":"zcaron","":"Zcaron","":"zdot","":"Zdot","":"imped","":"thorn","":"THORN","":"napos","":"alpha","":"Alpha","":"beta","":"Beta","":"gamma","":"Gamma","":"delta","":"Delta","":"epsi","":"epsiv","":"Epsilon","":"gammad","":"Gammad","":"zeta","":"Zeta","":"eta","":"Eta","":"theta","":"thetav","":"Theta","":"iota","":"Iota","":"kappa","":"kappav","":"Kappa","":"lambda","":"Lambda","":"mu","":"micro","":"Mu","":"nu","":"Nu","":"xi","":"Xi","":"omicron","":"Omicron","":"pi","":"piv","":"Pi","":"rho","":"rhov","":"Rho","":"sigma","":"Sigma","":"sigmaf","":"tau","":"Tau","":"upsi","":"Upsilon","":"Upsi","":"phi","":"phiv","":"Phi","":"chi","":"Chi","":"psi","":"Psi","":"omega","":"ohm","":"acy","":"Acy","":"bcy","":"Bcy","":"vcy","":"Vcy","":"gcy","":"Gcy","":"gjcy","":"GJcy","":"dcy","":"Dcy","":"djcy","":"DJcy","":"iecy","":"IEcy","":"iocy","":"IOcy","":"jukcy","":"Jukcy","":"zhcy","":"ZHcy","":"zcy","":"Zcy","":"dscy","":"DScy","":"icy","":"Icy","":"iukcy","":"Iukcy","":"yicy","":"YIcy","":"jcy","":"Jcy","":"jsercy","":"Jsercy","":"kcy","":"Kcy","":"kjcy","":"KJcy","":"lcy","":"Lcy","":"ljcy","":"LJcy","":"mcy","":"Mcy","":"ncy","":"Ncy","":"njcy","":"NJcy","":"ocy","":"Ocy","":"pcy","":"Pcy","":"rcy","":"Rcy","":"scy","":"Scy","":"tcy","":"Tcy","":"tshcy","":"TSHcy","":"ucy","":"Ucy","":"ubrcy","":"Ubrcy","":"fcy","":"Fcy","":"khcy","":"KHcy","":"tscy","":"TScy","":"chcy","":"CHcy","":"dzcy","":"DZcy","":"shcy","":"SHcy","":"shchcy","":"SHCHcy","":"hardcy","":"HARDcy","":"ycy","":"Ycy","":"softcy","":"SOFTcy","":"ecy","":"Ecy","":"yucy","":"YUcy","":"yacy","":"YAcy","":"aleph","":"beth","":"gimel","":"daleth"},h=/["&'<>`]/g,d={'"':"&quot;","&":"&amp;","'":"&#x27;","<":"&lt;",">":"&gt;","`":"&#x60;"},p=/&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/,g=/[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,y=/&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g,b={aacute:"",Aacute:"",abreve:"",Abreve:"",ac:"",acd:"",acE:"",acirc:"",Acirc:"",acute:"",acy:"",Acy:"",aelig:"",AElig:"",af:"",afr:"",Afr:"",agrave:"",Agrave:"",alefsym:"",aleph:"",alpha:"",Alpha:"",amacr:"",Amacr:"",amalg:"",amp:"&",AMP:"&",and:"",And:"",andand:"",andd:"",andslope:"",andv:"",ang:"",ange:"",angle:"",angmsd:"",angmsdaa:"",angmsdab:"",angmsdac:"",angmsdad:"",angmsdae:"",angmsdaf:"",angmsdag:"",angmsdah:"",angrt:"",angrtvb:"",angrtvbd:"",angsph:"",angst:"",angzarr:"",aogon:"",Aogon:"",aopf:"",Aopf:"",ap:"",apacir:"",ape:"",apE:"",apid:"",apos:"'",ApplyFunction:"",approx:"",approxeq:"",aring:"",Aring:"",ascr:"",Ascr:"",Assign:"",ast:"*",asymp:"",asympeq:"",atilde:"",Atilde:"",auml:"",Auml:"",awconint:"",awint:"",backcong:"",backepsilon:"",backprime:"",backsim:"",backsimeq:"",Backslash:"",Barv:"",barvee:"",barwed:"",Barwed:"",barwedge:"",bbrk:"",bbrktbrk:"",bcong:"",bcy:"",Bcy:"",bdquo:"",becaus:"",because:"",Because:"",bemptyv:"",bepsi:"",bernou:"",Bernoullis:"",beta:"",Beta:"",beth:"",between:"",bfr:"",Bfr:"",bigcap:"",bigcirc:"",bigcup:"",bigodot:"",bigoplus:"",bigotimes:"",bigsqcup:"",bigstar:"",bigtriangledown:"",bigtriangleup:"",biguplus:"",bigvee:"",bigwedge:"",bkarow:"",blacklozenge:"",blacksquare:"",blacktriangle:"",blacktriangledown:"",blacktriangleleft:"",blacktriangleright:"",blank:"",blk12:"",blk14:"",blk34:"",block:"",bne:"=",bnequiv:"",bnot:"",bNot:"",bopf:"",Bopf:"",bot:"",bottom:"",bowtie:"",boxbox:"",boxdl:"",boxdL:"",boxDl:"",boxDL:"",boxdr:"",boxdR:"",boxDr:"",boxDR:"",boxh:"",boxH:"",boxhd:"",boxhD:"",boxHd:"",boxHD:"",boxhu:"",boxhU:"",boxHu:"",boxHU:"",boxminus:"",boxplus:"",boxtimes:"",boxul:"",boxuL:"",boxUl:"",boxUL:"",boxur:"",boxuR:"",boxUr:"",boxUR:"",boxv:"",boxV:"",boxvh:"",boxvH:"",boxVh:"",boxVH:"",boxvl:"",boxvL:"",boxVl:"",boxVL:"",boxvr:"",boxvR:"",boxVr:"",boxVR:"",bprime:"",breve:"",Breve:"",brvbar:"",bscr:"",Bscr:"",bsemi:"",bsim:"",bsime:"",bsol:"\\",bsolb:"",bsolhsub:"",bull:"",bullet:"",bump:"",bumpe:"",bumpE:"",bumpeq:"",Bumpeq:"",cacute:"",Cacute:"",cap:"",Cap:"",capand:"",capbrcup:"",capcap:"",capcup:"",capdot:"",CapitalDifferentialD:"",caps:"",caret:"",caron:"",Cayleys:"",ccaps:"",ccaron:"",Ccaron:"",ccedil:"",Ccedil:"",ccirc:"",Ccirc:"",Cconint:"",ccups:"",ccupssm:"",cdot:"",Cdot:"",cedil:"",Cedilla:"",cemptyv:"",cent:"",centerdot:"",CenterDot:"",cfr:"",Cfr:"",chcy:"",CHcy:"",check:"",checkmark:"",chi:"",Chi:"",cir:"",circ:"",circeq:"",circlearrowleft:"",circlearrowright:"",circledast:"",circledcirc:"",circleddash:"",CircleDot:"",circledR:"",circledS:"",CircleMinus:"",CirclePlus:"",CircleTimes:"",cire:"",cirE:"",cirfnint:"",cirmid:"",cirscir:"",ClockwiseContourIntegral:"",CloseCurlyDoubleQuote:"",CloseCurlyQuote:"",clubs:"",clubsuit:"",colon:":",Colon:"",colone:"",Colone:"",coloneq:"",comma:",",commat:"@",comp:"",compfn:"",complement:"",complexes:"",cong:"",congdot:"",Congruent:"",conint:"",Conint:"",ContourIntegral:"",copf:"",Copf:"",coprod:"",Coproduct:"",copy:"",COPY:"",copysr:"",CounterClockwiseContourIntegral:"",crarr:"",cross:"",Cross:"",cscr:"",Cscr:"",csub:"",csube:"",csup:"",csupe:"",ctdot:"",cudarrl:"",cudarrr:"",cuepr:"",cuesc:"",cularr:"",cularrp:"",cup:"",Cup:"",cupbrcap:"",cupcap:"",CupCap:"",cupcup:"",cupdot:"",cupor:"",cups:"",curarr:"",curarrm:"",curlyeqprec:"",curlyeqsucc:"",curlyvee:"",curlywedge:"",curren:"",curvearrowleft:"",curvearrowright:"",cuvee:"",cuwed:"",cwconint:"",cwint:"",cylcty:"",dagger:"",Dagger:"",daleth:"",darr:"",dArr:"",Darr:"",dash:"",dashv:"",Dashv:"",dbkarow:"",dblac:"",dcaron:"",Dcaron:"",dcy:"",Dcy:"",dd:"",DD:"",ddagger:"",ddarr:"",DDotrahd:"",ddotseq:"",deg:"",Del:"",delta:"",Delta:"",demptyv:"",dfisht:"",dfr:"",Dfr:"",dHar:"",dharl:"",dharr:"",DiacriticalAcute:"",DiacriticalDot:"",DiacriticalDoubleAcute:"",DiacriticalGrave:"`",DiacriticalTilde:"",diam:"",diamond:"",Diamond:"",diamondsuit:"",diams:"",die:"",DifferentialD:"",digamma:"",disin:"",div:"",divide:"",divideontimes:"",divonx:"",djcy:"",DJcy:"",dlcorn:"",dlcrop:"",dollar:"$",dopf:"",Dopf:"",dot:"",Dot:"",DotDot:"",doteq:"",doteqdot:"",DotEqual:"",dotminus:"",dotplus:"",dotsquare:"",doublebarwedge:"",DoubleContourIntegral:"",DoubleDot:"",DoubleDownArrow:"",DoubleLeftArrow:"",DoubleLeftRightArrow:"",DoubleLeftTee:"",DoubleLongLeftArrow:"",DoubleLongLeftRightArrow:"",DoubleLongRightArrow:"",DoubleRightArrow:"",DoubleRightTee:"",DoubleUpArrow:"",DoubleUpDownArrow:"",DoubleVerticalBar:"",downarrow:"",Downarrow:"",DownArrow:"",DownArrowBar:"",DownArrowUpArrow:"",DownBreve:"",downdownarrows:"",downharpoonleft:"",downharpoonright:"",DownLeftRightVector:"",DownLeftTeeVector:"",DownLeftVector:"",DownLeftVectorBar:"",DownRightTeeVector:"",DownRightVector:"",DownRightVectorBar:"",DownTee:"",DownTeeArrow:"",drbkarow:"",drcorn:"",drcrop:"",dscr:"",Dscr:"",dscy:"",DScy:"",dsol:"",dstrok:"",Dstrok:"",dtdot:"",dtri:"",dtrif:"",duarr:"",duhar:"",dwangle:"",dzcy:"",DZcy:"",dzigrarr:"",eacute:"",Eacute:"",easter:"",ecaron:"",Ecaron:"",ecir:"",ecirc:"",Ecirc:"",ecolon:"",ecy:"",Ecy:"",eDDot:"",edot:"",eDot:"",Edot:"",ee:"",efDot:"",efr:"",Efr:"",eg:"",egrave:"",Egrave:"",egs:"",egsdot:"",el:"",Element:"",elinters:"",ell:"",els:"",elsdot:"",emacr:"",Emacr:"",empty:"",emptyset:"",EmptySmallSquare:"",emptyv:"",EmptyVerySmallSquare:"",emsp:"",emsp13:"",emsp14:"",eng:"",ENG:"",ensp:"",eogon:"",Eogon:"",eopf:"",Eopf:"",epar:"",eparsl:"",eplus:"",epsi:"",epsilon:"",Epsilon:"",epsiv:"",eqcirc:"",eqcolon:"",eqsim:"",eqslantgtr:"",eqslantless:"",Equal:"",equals:"=",EqualTilde:"",equest:"",Equilibrium:"",equiv:"",equivDD:"",eqvparsl:"",erarr:"",erDot:"",escr:"",Escr:"",esdot:"",esim:"",Esim:"",eta:"",Eta:"",eth:"",ETH:"",euml:"",Euml:"",euro:"",excl:"!",exist:"",Exists:"",expectation:"",exponentiale:"",ExponentialE:"",fallingdotseq:"",fcy:"",Fcy:"",female:"",ffilig:"",fflig:"",ffllig:"",ffr:"",Ffr:"",filig:"",FilledSmallSquare:"",FilledVerySmallSquare:"",fjlig:"fj",flat:"",fllig:"",fltns:"",fnof:"",fopf:"",Fopf:"",forall:"",ForAll:"",fork:"",forkv:"",Fouriertrf:"",fpartint:"",frac12:"",frac13:"",frac14:"",frac15:"",frac16:"",frac18:"",frac23:"",frac25:"",frac34:"",frac35:"",frac38:"",frac45:"",frac56:"",frac58:"",frac78:"",frasl:"",frown:"",fscr:"",Fscr:"",gacute:"",gamma:"",Gamma:"",gammad:"",Gammad:"",gap:"",gbreve:"",Gbreve:"",Gcedil:"",gcirc:"",Gcirc:"",gcy:"",Gcy:"",gdot:"",Gdot:"",ge:"",gE:"",gel:"",gEl:"",geq:"",geqq:"",geqslant:"",ges:"",gescc:"",gesdot:"",gesdoto:"",gesdotol:"",gesl:"",gesles:"",gfr:"",Gfr:"",gg:"",Gg:"",ggg:"",gimel:"",gjcy:"",GJcy:"",gl:"",gla:"",glE:"",glj:"",gnap:"",gnapprox:"",gne:"",gnE:"",gneq:"",gneqq:"",gnsim:"",gopf:"",Gopf:"",grave:"`",GreaterEqual:"",GreaterEqualLess:"",GreaterFullEqual:"",GreaterGreater:"",GreaterLess:"",GreaterSlantEqual:"",GreaterTilde:"",gscr:"",Gscr:"",gsim:"",gsime:"",gsiml:"",gt:">",Gt:"",GT:">",gtcc:"",gtcir:"",gtdot:"",gtlPar:"",gtquest:"",gtrapprox:"",gtrarr:"",gtrdot:"",gtreqless:"",gtreqqless:"",gtrless:"",gtrsim:"",gvertneqq:"",gvnE:"",Hacek:"",hairsp:"",half:"",hamilt:"",hardcy:"",HARDcy:"",harr:"",hArr:"",harrcir:"",harrw:"",Hat:"^",hbar:"",hcirc:"",Hcirc:"",hearts:"",heartsuit:"",hellip:"",hercon:"",hfr:"",Hfr:"",HilbertSpace:"",hksearow:"",hkswarow:"",hoarr:"",homtht:"",hookleftarrow:"",hookrightarrow:"",hopf:"",Hopf:"",horbar:"",HorizontalLine:"",hscr:"",Hscr:"",hslash:"",hstrok:"",Hstrok:"",HumpDownHump:"",HumpEqual:"",hybull:"",hyphen:"",iacute:"",Iacute:"",ic:"",icirc:"",Icirc:"",icy:"",Icy:"",Idot:"",iecy:"",IEcy:"",iexcl:"",iff:"",ifr:"",Ifr:"",igrave:"",Igrave:"",ii:"",iiiint:"",iiint:"",iinfin:"",iiota:"",ijlig:"",IJlig:"",Im:"",imacr:"",Imacr:"",image:"",ImaginaryI:"",imagline:"",imagpart:"",imath:"",imof:"",imped:"",Implies:"",in:"",incare:"",infin:"",infintie:"",inodot:"",int:"",Int:"",intcal:"",integers:"",Integral:"",intercal:"",Intersection:"",intlarhk:"",intprod:"",InvisibleComma:"",InvisibleTimes:"",iocy:"",IOcy:"",iogon:"",Iogon:"",iopf:"",Iopf:"",iota:"",Iota:"",iprod:"",iquest:"",iscr:"",Iscr:"",isin:"",isindot:"",isinE:"",isins:"",isinsv:"",isinv:"",it:"",itilde:"",Itilde:"",iukcy:"",Iukcy:"",iuml:"",Iuml:"",jcirc:"",Jcirc:"",jcy:"",Jcy:"",jfr:"",Jfr:"",jmath:"",jopf:"",Jopf:"",jscr:"",Jscr:"",jsercy:"",Jsercy:"",jukcy:"",Jukcy:"",kappa:"",Kappa:"",kappav:"",kcedil:"",Kcedil:"",kcy:"",Kcy:"",kfr:"",Kfr:"",kgreen:"",khcy:"",KHcy:"",kjcy:"",KJcy:"",kopf:"",Kopf:"",kscr:"",Kscr:"",lAarr:"",lacute:"",Lacute:"",laemptyv:"",lagran:"",lambda:"",Lambda:"",lang:"",Lang:"",langd:"",langle:"",lap:"",Laplacetrf:"",laquo:"",larr:"",lArr:"",Larr:"",larrb:"",larrbfs:"",larrfs:"",larrhk:"",larrlp:"",larrpl:"",larrsim:"",larrtl:"",lat:"",latail:"",lAtail:"",late:"",lates:"",lbarr:"",lBarr:"",lbbrk:"",lbrace:"{",lbrack:"[",lbrke:"",lbrksld:"",lbrkslu:"",lcaron:"",Lcaron:"",lcedil:"",Lcedil:"",lceil:"",lcub:"{",lcy:"",Lcy:"",ldca:"",ldquo:"",ldquor:"",ldrdhar:"",ldrushar:"",ldsh:"",le:"",lE:"",LeftAngleBracket:"",leftarrow:"",Leftarrow:"",LeftArrow:"",LeftArrowBar:"",LeftArrowRightArrow:"",leftarrowtail:"",LeftCeiling:"",LeftDoubleBracket:"",LeftDownTeeVector:"",LeftDownVector:"",LeftDownVectorBar:"",LeftFloor:"",leftharpoondown:"",leftharpoonup:"",leftleftarrows:"",leftrightarrow:"",Leftrightarrow:"",LeftRightArrow:"",leftrightarrows:"",leftrightharpoons:"",leftrightsquigarrow:"",LeftRightVector:"",LeftTee:"",LeftTeeArrow:"",LeftTeeVector:"",leftthreetimes:"",LeftTriangle:"",LeftTriangleBar:"",LeftTriangleEqual:"",LeftUpDownVector:"",LeftUpTeeVector:"",LeftUpVector:"",LeftUpVectorBar:"",LeftVector:"",LeftVectorBar:"",leg:"",lEg:"",leq:"",leqq:"",leqslant:"",les:"",lescc:"",lesdot:"",lesdoto:"",lesdotor:"",lesg:"",lesges:"",lessapprox:"",lessdot:"",lesseqgtr:"",lesseqqgtr:"",LessEqualGreater:"",LessFullEqual:"",LessGreater:"",lessgtr:"",LessLess:"",lesssim:"",LessSlantEqual:"",LessTilde:"",lfisht:"",lfloor:"",lfr:"",Lfr:"",lg:"",lgE:"",lHar:"",lhard:"",lharu:"",lharul:"",lhblk:"",ljcy:"",LJcy:"",ll:"",Ll:"",llarr:"",llcorner:"",Lleftarrow:"",llhard:"",lltri:"",lmidot:"",Lmidot:"",lmoust:"",lmoustache:"",lnap:"",lnapprox:"",lne:"",lnE:"",lneq:"",lneqq:"",lnsim:"",loang:"",loarr:"",lobrk:"",longleftarrow:"",Longleftarrow:"",LongLeftArrow:"",longleftrightarrow:"",Longleftrightarrow:"",LongLeftRightArrow:"",longmapsto:"",longrightarrow:"",Longrightarrow:"",LongRightArrow:"",looparrowleft:"",looparrowright:"",lopar:"",lopf:"",Lopf:"",loplus:"",lotimes:"",lowast:"",lowbar:"_",LowerLeftArrow:"",LowerRightArrow:"",loz:"",lozenge:"",lozf:"",lpar:"(",lparlt:"",lrarr:"",lrcorner:"",lrhar:"",lrhard:"",lrm:"",lrtri:"",lsaquo:"",lscr:"",Lscr:"",lsh:"",Lsh:"",lsim:"",lsime:"",lsimg:"",lsqb:"[",lsquo:"",lsquor:"",lstrok:"",Lstrok:"",lt:"<",Lt:"",LT:"<",ltcc:"",ltcir:"",ltdot:"",lthree:"",ltimes:"",ltlarr:"",ltquest:"",ltri:"",ltrie:"",ltrif:"",ltrPar:"",lurdshar:"",luruhar:"",lvertneqq:"",lvnE:"",macr:"",male:"",malt:"",maltese:"",map:"",Map:"",mapsto:"",mapstodown:"",mapstoleft:"",mapstoup:"",marker:"",mcomma:"",mcy:"",Mcy:"",mdash:"",mDDot:"",measuredangle:"",MediumSpace:"",Mellintrf:"",mfr:"",Mfr:"",mho:"",micro:"",mid:"",midast:"*",midcir:"",middot:"",minus:"",minusb:"",minusd:"",minusdu:"",MinusPlus:"",mlcp:"",mldr:"",mnplus:"",models:"",mopf:"",Mopf:"",mp:"",mscr:"",Mscr:"",mstpos:"",mu:"",Mu:"",multimap:"",mumap:"",nabla:"",nacute:"",Nacute:"",nang:"",nap:"",napE:"",napid:"",napos:"",napprox:"",natur:"",natural:"",naturals:"",nbsp:"",nbump:"",nbumpe:"",ncap:"",ncaron:"",Ncaron:"",ncedil:"",Ncedil:"",ncong:"",ncongdot:"",ncup:"",ncy:"",Ncy:"",ndash:"",ne:"",nearhk:"",nearr:"",neArr:"",nearrow:"",nedot:"",NegativeMediumSpace:"",NegativeThickSpace:"",NegativeThinSpace:"",NegativeVeryThinSpace:"",nequiv:"",nesear:"",nesim:"",NestedGreaterGreater:"",NestedLessLess:"",NewLine:"\n",nexist:"",nexists:"",nfr:"",Nfr:"",nge:"",ngE:"",ngeq:"",ngeqq:"",ngeqslant:"",nges:"",nGg:"",ngsim:"",ngt:"",nGt:"",ngtr:"",nGtv:"",nharr:"",nhArr:"",nhpar:"",ni:"",nis:"",nisd:"",niv:"",njcy:"",NJcy:"",nlarr:"",nlArr:"",nldr:"",nle:"",nlE:"",nleftarrow:"",nLeftarrow:"",nleftrightarrow:"",nLeftrightarrow:"",nleq:"",nleqq:"",nleqslant:"",nles:"",nless:"",nLl:"",nlsim:"",nlt:"",nLt:"",nltri:"",nltrie:"",nLtv:"",nmid:"",NoBreak:"",NonBreakingSpace:"",nopf:"",Nopf:"",not:"",Not:"",NotCongruent:"",NotCupCap:"",NotDoubleVerticalBar:"",NotElement:"",NotEqual:"",NotEqualTilde:"",NotExists:"",NotGreater:"",NotGreaterEqual:"",NotGreaterFullEqual:"",NotGreaterGreater:"",NotGreaterLess:"",NotGreaterSlantEqual:"",NotGreaterTilde:"",NotHumpDownHump:"",NotHumpEqual:"",notin:"",notindot:"",notinE:"",notinva:"",notinvb:"",notinvc:"",NotLeftTriangle:"",NotLeftTriangleBar:"",NotLeftTriangleEqual:"",NotLess:"",NotLessEqual:"",NotLessGreater:"",NotLessLess:"",NotLessSlantEqual:"",NotLessTilde:"",NotNestedGreaterGreater:"",NotNestedLessLess:"",notni:"",notniva:"",notnivb:"",notnivc:"",NotPrecedes:"",NotPrecedesEqual:"",NotPrecedesSlantEqual:"",NotReverseElement:"",NotRightTriangle:"",NotRightTriangleBar:"",NotRightTriangleEqual:"",NotSquareSubset:"",NotSquareSubsetEqual:"",NotSquareSuperset:"",NotSquareSupersetEqual:"",NotSubset:"",NotSubsetEqual:"",NotSucceeds:"",NotSucceedsEqual:"",NotSucceedsSlantEqual:"",NotSucceedsTilde:"",NotSuperset:"",NotSupersetEqual:"",NotTilde:"",NotTildeEqual:"",NotTildeFullEqual:"",NotTildeTilde:"",NotVerticalBar:"",npar:"",nparallel:"",nparsl:"",npart:"",npolint:"",npr:"",nprcue:"",npre:"",nprec:"",npreceq:"",nrarr:"",nrArr:"",nrarrc:"",nrarrw:"",nrightarrow:"",nRightarrow:"",nrtri:"",nrtrie:"",nsc:"",nsccue:"",nsce:"",nscr:"",Nscr:"",nshortmid:"",nshortparallel:"",nsim:"",nsime:"",nsimeq:"",nsmid:"",nspar:"",nsqsube:"",nsqsupe:"",nsub:"",nsube:"",nsubE:"",nsubset:"",nsubseteq:"",nsubseteqq:"",nsucc:"",nsucceq:"",nsup:"",nsupe:"",nsupE:"",nsupset:"",nsupseteq:"",nsupseteqq:"",ntgl:"",ntilde:"",Ntilde:"",ntlg:"",ntriangleleft:"",ntrianglelefteq:"",ntriangleright:"",ntrianglerighteq:"",nu:"",Nu:"",num:"#",numero:"",numsp:"",nvap:"",nvdash:"",nvDash:"",nVdash:"",nVDash:"",nvge:"",nvgt:">",nvHarr:"",nvinfin:"",nvlArr:"",nvle:"",nvlt:"<",nvltrie:"",nvrArr:"",nvrtrie:"",nvsim:"",nwarhk:"",nwarr:"",nwArr:"",nwarrow:"",nwnear:"",oacute:"",Oacute:"",oast:"",ocir:"",ocirc:"",Ocirc:"",ocy:"",Ocy:"",odash:"",odblac:"",Odblac:"",odiv:"",odot:"",odsold:"",oelig:"",OElig:"",ofcir:"",ofr:"",Ofr:"",ogon:"",ograve:"",Ograve:"",ogt:"",ohbar:"",ohm:"",oint:"",olarr:"",olcir:"",olcross:"",oline:"",olt:"",omacr:"",Omacr:"",omega:"",Omega:"",omicron:"",Omicron:"",omid:"",ominus:"",oopf:"",Oopf:"",opar:"",OpenCurlyDoubleQuote:"",OpenCurlyQuote:"",operp:"",oplus:"",or:"",Or:"",orarr:"",ord:"",order:"",orderof:"",ordf:"",ordm:"",origof:"",oror:"",orslope:"",orv:"",oS:"",oscr:"",Oscr:"",oslash:"",Oslash:"",osol:"",otilde:"",Otilde:"",otimes:"",Otimes:"",otimesas:"",ouml:"",Ouml:"",ovbar:"",OverBar:"",OverBrace:"",OverBracket:"",OverParenthesis:"",par:"",para:"",parallel:"",parsim:"",parsl:"",part:"",PartialD:"",pcy:"",Pcy:"",percnt:"%",period:".",permil:"",perp:"",pertenk:"",pfr:"",Pfr:"",phi:"",Phi:"",phiv:"",phmmat:"",phone:"",pi:"",Pi:"",pitchfork:"",piv:"",planck:"",planckh:"",plankv:"",plus:"+",plusacir:"",plusb:"",pluscir:"",plusdo:"",plusdu:"",pluse:"",PlusMinus:"",plusmn:"",plussim:"",plustwo:"",pm:"",Poincareplane:"",pointint:"",popf:"",Popf:"",pound:"",pr:"",Pr:"",prap:"",prcue:"",pre:"",prE:"",prec:"",precapprox:"",preccurlyeq:"",Precedes:"",PrecedesEqual:"",PrecedesSlantEqual:"",PrecedesTilde:"",preceq:"",precnapprox:"",precneqq:"",precnsim:"",precsim:"",prime:"",Prime:"",primes:"",prnap:"",prnE:"",prnsim:"",prod:"",Product:"",profalar:"",profline:"",profsurf:"",prop:"",Proportion:"",Proportional:"",propto:"",prsim:"",prurel:"",pscr:"",Pscr:"",psi:"",Psi:"",puncsp:"",qfr:"",Qfr:"",qint:"",qopf:"",Qopf:"",qprime:"",qscr:"",Qscr:"",quaternions:"",quatint:"",quest:"?",questeq:"",quot:'"',QUOT:'"',rAarr:"",race:"",racute:"",Racute:"",radic:"",raemptyv:"",rang:"",Rang:"",rangd:"",range:"",rangle:"",raquo:"",rarr:"",rArr:"",Rarr:"",rarrap:"",rarrb:"",rarrbfs:"",rarrc:"",rarrfs:"",rarrhk:"",rarrlp:"",rarrpl:"",rarrsim:"",rarrtl:"",Rarrtl:"",rarrw:"",ratail:"",rAtail:"",ratio:"",rationals:"",rbarr:"",rBarr:"",RBarr:"",rbbrk:"",rbrace:"}",rbrack:"]",rbrke:"",rbrksld:"",rbrkslu:"",rcaron:"",Rcaron:"",rcedil:"",Rcedil:"",rceil:"",rcub:"}",rcy:"",Rcy:"",rdca:"",rdldhar:"",rdquo:"",rdquor:"",rdsh:"",Re:"",real:"",realine:"",realpart:"",reals:"",rect:"",reg:"",REG:"",ReverseElement:"",ReverseEquilibrium:"",ReverseUpEquilibrium:"",rfisht:"",rfloor:"",rfr:"",Rfr:"",rHar:"",rhard:"",rharu:"",rharul:"",rho:"",Rho:"",rhov:"",RightAngleBracket:"",rightarrow:"",Rightarrow:"",RightArrow:"",RightArrowBar:"",RightArrowLeftArrow:"",rightarrowtail:"",RightCeiling:"",RightDoubleBracket:"",RightDownTeeVector:"",RightDownVector:"",RightDownVectorBar:"",RightFloor:"",rightharpoondown:"",rightharpoonup:"",rightleftarrows:"",rightleftharpoons:"",rightrightarrows:"",rightsquigarrow:"",RightTee:"",RightTeeArrow:"",RightTeeVector:"",rightthreetimes:"",RightTriangle:"",RightTriangleBar:"",RightTriangleEqual:"",RightUpDownVector:"",RightUpTeeVector:"",RightUpVector:"",RightUpVectorBar:"",RightVector:"",RightVectorBar:"",ring:"",risingdotseq:"",rlarr:"",rlhar:"",rlm:"",rmoust:"",rmoustache:"",rnmid:"",roang:"",roarr:"",robrk:"",ropar:"",ropf:"",Ropf:"",roplus:"",rotimes:"",RoundImplies:"",rpar:")",rpargt:"",rppolint:"",rrarr:"",Rrightarrow:"",rsaquo:"",rscr:"",Rscr:"",rsh:"",Rsh:"",rsqb:"]",rsquo:"",rsquor:"",rthree:"",rtimes:"",rtri:"",rtrie:"",rtrif:"",rtriltri:"",RuleDelayed:"",ruluhar:"",rx:"",sacute:"",Sacute:"",sbquo:"",sc:"",Sc:"",scap:"",scaron:"",Scaron:"",sccue:"",sce:"",scE:"",scedil:"",Scedil:"",scirc:"",Scirc:"",scnap:"",scnE:"",scnsim:"",scpolint:"",scsim:"",scy:"",Scy:"",sdot:"",sdotb:"",sdote:"",searhk:"",searr:"",seArr:"",searrow:"",sect:"",semi:";",seswar:"",setminus:"",setmn:"",sext:"",sfr:"",Sfr:"",sfrown:"",sharp:"",shchcy:"",SHCHcy:"",shcy:"",SHcy:"",ShortDownArrow:"",ShortLeftArrow:"",shortmid:"",shortparallel:"",ShortRightArrow:"",ShortUpArrow:"",shy:"",sigma:"",Sigma:"",sigmaf:"",sigmav:"",sim:"",simdot:"",sime:"",simeq:"",simg:"",simgE:"",siml:"",simlE:"",simne:"",simplus:"",simrarr:"",slarr:"",SmallCircle:"",smallsetminus:"",smashp:"",smeparsl:"",smid:"",smile:"",smt:"",smte:"",smtes:"",softcy:"",SOFTcy:"",sol:"/",solb:"",solbar:"",sopf:"",Sopf:"",spades:"",spadesuit:"",spar:"",sqcap:"",sqcaps:"",sqcup:"",sqcups:"",Sqrt:"",sqsub:"",sqsube:"",sqsubset:"",sqsubseteq:"",sqsup:"",sqsupe:"",sqsupset:"",sqsupseteq:"",squ:"",square:"",Square:"",SquareIntersection:"",SquareSubset:"",SquareSubsetEqual:"",SquareSuperset:"",SquareSupersetEqual:"",SquareUnion:"",squarf:"",squf:"",srarr:"",sscr:"",Sscr:"",ssetmn:"",ssmile:"",sstarf:"",star:"",Star:"",starf:"",straightepsilon:"",straightphi:"",strns:"",sub:"",Sub:"",subdot:"",sube:"",subE:"",subedot:"",submult:"",subne:"",subnE:"",subplus:"",subrarr:"",subset:"",Subset:"",subseteq:"",subseteqq:"",SubsetEqual:"",subsetneq:"",subsetneqq:"",subsim:"",subsub:"",subsup:"",succ:"",succapprox:"",succcurlyeq:"",Succeeds:"",SucceedsEqual:"",SucceedsSlantEqual:"",SucceedsTilde:"",succeq:"",succnapprox:"",succneqq:"",succnsim:"",succsim:"",SuchThat:"",sum:"",Sum:"",sung:"",sup:"",Sup:"",sup1:"",sup2:"",sup3:"",supdot:"",supdsub:"",supe:"",supE:"",supedot:"",Superset:"",SupersetEqual:"",suphsol:"",suphsub:"",suplarr:"",supmult:"",supne:"",supnE:"",supplus:"",supset:"",Supset:"",supseteq:"",supseteqq:"",supsetneq:"",supsetneqq:"",supsim:"",supsub:"",supsup:"",swarhk:"",swarr:"",swArr:"",swarrow:"",swnwar:"",szlig:"",Tab:"\t",target:"",tau:"",Tau:"",tbrk:"",tcaron:"",Tcaron:"",tcedil:"",Tcedil:"",tcy:"",Tcy:"",tdot:"",telrec:"",tfr:"",Tfr:"",there4:"",therefore:"",Therefore:"",theta:"",Theta:"",thetasym:"",thetav:"",thickapprox:"",thicksim:"",ThickSpace:"",thinsp:"",ThinSpace:"",thkap:"",thksim:"",thorn:"",THORN:"",tilde:"",Tilde:"",TildeEqual:"",TildeFullEqual:"",TildeTilde:"",times:"",timesb:"",timesbar:"",timesd:"",tint:"",toea:"",top:"",topbot:"",topcir:"",topf:"",Topf:"",topfork:"",tosa:"",tprime:"",trade:"",TRADE:"",triangle:"",triangledown:"",triangleleft:"",trianglelefteq:"",triangleq:"",triangleright:"",trianglerighteq:"",tridot:"",trie:"",triminus:"",TripleDot:"",triplus:"",trisb:"",tritime:"",trpezium:"",tscr:"",Tscr:"",tscy:"",TScy:"",tshcy:"",TSHcy:"",tstrok:"",Tstrok:"",twixt:"",twoheadleftarrow:"",twoheadrightarrow:"",uacute:"",Uacute:"",uarr:"",uArr:"",Uarr:"",Uarrocir:"",ubrcy:"",Ubrcy:"",ubreve:"",Ubreve:"",ucirc:"",Ucirc:"",ucy:"",Ucy:"",udarr:"",udblac:"",Udblac:"",udhar:"",ufisht:"",ufr:"",Ufr:"",ugrave:"",Ugrave:"",uHar:"",uharl:"",uharr:"",uhblk:"",ulcorn:"",ulcorner:"",ulcrop:"",ultri:"",umacr:"",Umacr:"",uml:"",UnderBar:"_",UnderBrace:"",UnderBracket:"",UnderParenthesis:"",Union:"",UnionPlus:"",uogon:"",Uogon:"",uopf:"",Uopf:"",uparrow:"",Uparrow:"",UpArrow:"",UpArrowBar:"",UpArrowDownArrow:"",updownarrow:"",Updownarrow:"",UpDownArrow:"",UpEquilibrium:"",upharpoonleft:"",upharpoonright:"",uplus:"",UpperLeftArrow:"",UpperRightArrow:"",upsi:"",Upsi:"",upsih:"",upsilon:"",Upsilon:"",UpTee:"",UpTeeArrow:"",upuparrows:"",urcorn:"",urcorner:"",urcrop:"",uring:"",Uring:"",urtri:"",uscr:"",Uscr:"",utdot:"",utilde:"",Utilde:"",utri:"",utrif:"",uuarr:"",uuml:"",Uuml:"",uwangle:"",vangrt:"",varepsilon:"",varkappa:"",varnothing:"",varphi:"",varpi:"",varpropto:"",varr:"",vArr:"",varrho:"",varsigma:"",varsubsetneq:"",varsubsetneqq:"",varsupsetneq:"",varsupsetneqq:"",vartheta:"",vartriangleleft:"",vartriangleright:"",vBar:"",Vbar:"",vBarv:"",vcy:"",Vcy:"",vdash:"",vDash:"",Vdash:"",VDash:"",Vdashl:"",vee:"",Vee:"",veebar:"",veeeq:"",vellip:"",verbar:"|",Verbar:"",vert:"|",Vert:"",VerticalBar:"",VerticalLine:"|",VerticalSeparator:"",VerticalTilde:"",VeryThinSpace:"",vfr:"",Vfr:"",vltri:"",vnsub:"",vnsup:"",vopf:"",Vopf:"",vprop:"",vrtri:"",vscr:"",Vscr:"",vsubne:"",vsubnE:"",vsupne:"",vsupnE:"",Vvdash:"",vzigzag:"",wcirc:"",Wcirc:"",wedbar:"",wedge:"",Wedge:"",wedgeq:"",weierp:"",wfr:"",Wfr:"",wopf:"",Wopf:"",wp:"",wr:"",wreath:"",wscr:"",Wscr:"",xcap:"",xcirc:"",xcup:"",xdtri:"",xfr:"",Xfr:"",xharr:"",xhArr:"",xi:"",Xi:"",xlarr:"",xlArr:"",xmap:"",xnis:"",xodot:"",xopf:"",Xopf:"",xoplus:"",xotime:"",xrarr:"",xrArr:"",xscr:"",Xscr:"",xsqcup:"",xuplus:"",xutri:"",xvee:"",xwedge:"",yacute:"",Yacute:"",yacy:"",YAcy:"",ycirc:"",Ycirc:"",ycy:"",Ycy:"",yen:"",yfr:"",Yfr:"",yicy:"",YIcy:"",yopf:"",Yopf:"",yscr:"",Yscr:"",yucy:"",YUcy:"",yuml:"",Yuml:"",zacute:"",Zacute:"",zcaron:"",Zcaron:"",zcy:"",Zcy:"",zdot:"",Zdot:"",zeetrf:"",ZeroWidthSpace:"",zeta:"",Zeta:"",zfr:"",Zfr:"",zhcy:"",ZHcy:"",zigrarr:"",zopf:"",Zopf:"",zscr:"",Zscr:"",zwj:"",zwnj:""},m={aacute:"",Aacute:"",acirc:"",Acirc:"",acute:"",aelig:"",AElig:"",agrave:"",Agrave:"",amp:"&",AMP:"&",aring:"",Aring:"",atilde:"",Atilde:"",auml:"",Auml:"",brvbar:"",ccedil:"",Ccedil:"",cedil:"",cent:"",copy:"",COPY:"",curren:"",deg:"",divide:"",eacute:"",Eacute:"",ecirc:"",Ecirc:"",egrave:"",Egrave:"",eth:"",ETH:"",euml:"",Euml:"",frac12:"",frac14:"",frac34:"",gt:">",GT:">",iacute:"",Iacute:"",icirc:"",Icirc:"",iexcl:"",igrave:"",Igrave:"",iquest:"",iuml:"",Iuml:"",laquo:"",lt:"<",LT:"<",macr:"",micro:"",middot:"",nbsp:"",not:"",ntilde:"",Ntilde:"",oacute:"",Oacute:"",ocirc:"",Ocirc:"",ograve:"",Ograve:"",ordf:"",ordm:"",oslash:"",Oslash:"",otilde:"",Otilde:"",ouml:"",Ouml:"",para:"",plusmn:"",pound:"",quot:'"',QUOT:'"',raquo:"",reg:"",REG:"",sect:"",shy:"",sup1:"",sup2:"",sup3:"",szlig:"",thorn:"",THORN:"",times:"",uacute:"",Uacute:"",ucirc:"",Ucirc:"",ugrave:"",Ugrave:"",uml:"",uuml:"",Uuml:"",yacute:"",Yacute:"",yen:"",yuml:""},v={0:"",128:"",130:"",131:"",132:"",133:"",134:"",135:"",136:"",137:"",138:"",139:"",140:"",142:"",145:"",146:"",147:"",148:"",149:"",150:"",151:"",152:"",153:"",154:"",155:"",156:"",158:"",159:""},_=[1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65e3,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111],w=String.fromCharCode,x={}.hasOwnProperty,k=function(t,e){return x.call(t,e)},E=function(t,e){if(!t)return e;var n,r={};for(n in e)r[n]=k(t,n)?t[n]:e[n];return r},A=function(t,e){var n="";return t>=55296&&t<=57343||t>1114111?(e&&M("character reference outside the permissible Unicode range"),""):k(v,t)?(e&&M("disallowed character reference"),v[t]):(e&&function(t,e){for(var n=-1,r=t.length;++n<r;)if(t[n]==e)return!0;return!1}(_,t)&&M("disallowed character reference"),t>65535&&(n+=w((t-=65536)>>>10&1023|55296),t=56320|1023&t),n+=w(t))},S=function(t){return"&#x"+t.toString(16).toUpperCase()+";"},T=function(t){return"&#"+t+";"},M=function(t){throw Error("Parse error: "+t)},D=function(t,e){(e=E(e,D.options)).strict&&g.test(t)&&M("forbidden code point");var n=e.encodeEverything,r=e.useNamedReferences,i=e.allowUnsafeSymbols,o=e.decimal?T:S,a=function(t){return o(t.charCodeAt(0))};return n?(t=t.replace(u,(function(t){return r&&k(l,t)?"&"+l[t]+";":a(t)})),r&&(t=t.replace(/&gt;\u20D2/g,"&nvgt;").replace(/&lt;\u20D2/g,"&nvlt;").replace(/&#x66;&#x6A;/g,"&fjlig;")),r&&(t=t.replace(f,(function(t){return"&"+l[t]+";"})))):r?(i||(t=t.replace(h,(function(t){return"&"+l[t]+";"}))),t=(t=t.replace(/&gt;\u20D2/g,"&nvgt;").replace(/&lt;\u20D2/g,"&nvlt;")).replace(f,(function(t){return"&"+l[t]+";"}))):i||(t=t.replace(h,a)),t.replace(s,(function(t){var e=t.charCodeAt(0),n=t.charCodeAt(1);return o(1024*(e-55296)+n-56320+65536)})).replace(c,a)};D.options={allowUnsafeSymbols:!1,encodeEverything:!1,strict:!1,useNamedReferences:!1,decimal:!1};var C=function(t,e){var n=(e=E(e,C.options)).strict;return n&&p.test(t)&&M("malformed character reference"),t.replace(y,(function(t,r,i,o,a,s,u,c,f){var l,h,d,p,g,y;return r?b[g=r]:i?(g=i,(y=o)&&e.isAttributeValue?(n&&"="==y&&M("`&` did not start a character reference"),t):(n&&M("named character reference was not terminated by a semicolon"),m[g]+(y||""))):a?(d=a,h=s,n&&!h&&M("character reference was not terminated by a semicolon"),l=parseInt(d,10),A(l,n)):u?(p=u,h=c,n&&!h&&M("character reference was not terminated by a semicolon"),l=parseInt(p,16),A(l,n)):(n&&M("named character reference was not terminated by a semicolon"),t)}))};C.options={isAttributeValue:!1,strict:!1};var O={version:"1.2.0",encode:D,decode:C,escape:function(t){return t.replace(h,(function(t){return d[t]}))},unescape:C};if("function"==typeof define&&"object"==typeof define.amd&&define.amd)define((function(){return O}));else if(i&&!i.nodeType)if(o)o.exports=O;else for(var R in O)k(O,R)&&(i[R]=O[R]);else r.he=O}(this)}).call(this,n(9)(t),n(11))},function(t,e,n){"use strict";var r=n(229),i=n(230),o=n(231);function a(t,e,n){if(!t)return t;if(!e)return t;"string"==typeof n&&(n={keyframes:n}),n||(n={keyframes:!1}),t=s(t,e+" $1$2");var i=e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&");t=(t=(t=(t=t.replace(new RegExp("("+i+")\\s*\\1(?=[\\s\\r\\n,{])","g"),"$1")).replace(new RegExp("("+i+")\\s*:host","g"),"$1")).replace(new RegExp("("+i+")\\s*@","g"),"@")).replace(new RegExp("("+i+")\\s*:root","g"),":root");for(var o,a=[],u=/@keyframes\s+([a-zA-Z0-9_-]+)\s*{/g;null!==(o=u.exec(t));)a.indexOf(o[1])<0&&a.push(o[1]);var c=r(e);return a.forEach((function(e){var r=(!0===n.keyframes?c+"-":"string"==typeof n.keyframes?n.keyframes:"")+e;t=(t=t.replace(new RegExp("(@keyframes\\s+)"+e+"(\\s*{)","g"),"$1"+r+"$2")).replace(new RegExp("(animation(?:-name)?\\s*:[^;]*\\s*)"+e+"([\\s;}])","g"),"$1"+r+"$2")})),t=t.replace(new RegExp("("+i+" )(\\s*(?:to|from|[+-]?(?:(?:\\.\\d+)|(?:\\d+(?:\\.\\d*)?))%))(?=[\\s\\r\\n,{])","g"),"$2")}function s(t,e){var n=[];return t=o(t),t=(t=i.replace(t,!0,n)).replace(/([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/g,e),t=i.paste(t,n)}t.exports=a,a.replace=s},function(t,e,n){"use strict";const r=n(418),i="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~".split(""),o=(t,e)=>{const n=e.length,i=Math.floor(65536/n)*n-1,o=2*Math.ceil(1.1*t);let a="",s=0;for(;s<t;){const u=r.randomBytes(o);let c=0;for(;c<o&&s<t;){const t=u.readUInt16LE(c);c+=2,t>i||(a+=e[t%n],s++)}}return a},a=[void 0,"hex","base64","url-safe"];t.exports=({length:t,type:e,characters:n})=>{if(!(t>=0&&Number.isFinite(t)))throw new TypeError("Expected a `length` to be a non-negative finite number");if(void 0!==e&&void 0!==n)throw new TypeError("Expected either `type` or `characters`");if(void 0!==n&&"string"!=typeof n)throw new TypeError("Expected `characters` to be string");if(!a.includes(e))throw new TypeError(`Unknown type: ${e}`);if(void 0===e&&void 0===n&&(e="hex"),"hex"===e||void 0===e&&void 0===n)return r.randomBytes(Math.ceil(.5*t)).toString("hex").slice(0,t);if("base64"===e)return r.randomBytes(Math.ceil(.75*t)).toString("base64").slice(0,t);if("url-safe"===e)return o(t,i);if(0===n.length)throw new TypeError("Expected `characters` string length to be greater than or equal to 1");if(n.length>65536)throw new TypeError("Expected `characters` string length to be less or equal to 65536");return o(t,n.split(""))}},function(t,e,n){var r;r=function(){var t=JSON.parse('{"$":"dollar","%":"percent","&":"and","<":"less",">":"greater","|":"or","":"cent","":"pound","":"currency","":"yen","":"(c)","":"a","":"(r)","":"o","":"A","":"A","":"A","":"A","":"A","":"A","":"AE","":"C","":"E","":"E","":"E","":"E","":"I","":"I","":"I","":"I","":"D","":"N","":"O","":"O","":"O","":"O","":"O","":"O","":"U","":"U","":"U","":"U","":"Y","":"TH","":"ss","":"a","":"a","":"a","":"a","":"a","":"a","":"ae","":"c","":"e","":"e","":"e","":"e","":"i","":"i","":"i","":"i","":"d","":"n","":"o","":"o","":"o","":"o","":"o","":"o","":"u","":"u","":"u","":"u","":"y","":"th","":"y","":"A","":"a","":"A","":"a","":"A","":"a","":"C","":"c","":"C","":"c","":"D","":"d","":"DJ","":"dj","":"E","":"e","":"E","":"e","":"e","":"e","":"E","":"e","":"G","":"g","":"G","":"g","":"I","":"i","":"i","":"i","":"I","":"i","":"I","":"i","":"k","":"k","":"L","":"l","":"L","":"l","":"L","":"l","":"N","":"n","":"N","":"n","":"N","":"n","":"O","":"o","":"OE","":"oe","":"R","":"r","":"R","":"r","":"S","":"s","":"S","":"s","":"S","":"s","":"T","":"t","":"T","":"t","":"U","":"u","":"u","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"W","":"w","":"Y","":"y","":"Y","":"Z","":"z","":"Z","":"z","":"Z","":"z","":"f","":"O","":"o","":"U","":"u","":"LJ","":"lj","":"NJ","":"nj","":"S","":"s","":"T","":"t","":"o","":"A","":"E","":"H","":"I","":"O","":"Y","":"W","":"i","":"A","":"B","":"G","":"D","":"E","":"Z","":"H","":"8","":"I","":"K","":"L","":"M","":"N","":"3","":"O","":"P","":"R","":"S","":"T","":"Y","":"F","":"X","":"PS","":"W","":"I","":"Y","":"a","":"e","":"h","":"i","":"y","":"a","":"b","":"g","":"d","":"e","":"z","":"h","":"8","":"i","":"k","":"l","":"m","":"n","":"3","":"o","":"p","":"r","":"s","":"s","":"t","":"y","":"f","":"x","":"ps","":"w","":"i","":"y","":"o","":"y","":"w","":"Yo","":"DJ","":"Ye","":"I","":"Yi","":"J","":"LJ","":"NJ","":"C","":"DZ","":"A","":"B","":"V","":"G","":"D","":"E","":"Zh","":"Z","":"I","":"J","":"K","":"L","":"M","":"N","":"O","":"P","":"R","":"S","":"T","":"U","":"F","":"H","":"C","":"Ch","":"Sh","":"Sh","":"U","":"Y","":"","":"E","":"Yu","":"Ya","":"a","":"b","":"v","":"g","":"d","":"e","":"zh","":"z","":"i","":"j","":"k","":"l","":"m","":"n","":"o","":"p","":"r","":"s","":"t","":"u","":"f","":"h","":"c","":"ch","":"sh","":"sh","":"u","":"y","":"","":"e","":"yu","":"ya","":"yo","":"dj","":"ye","":"i","":"yi","":"j","":"lj","":"nj","":"c","":"dz","":"G","":"g","":"baht","":"a","":"b","":"g","":"d","":"e","":"v","":"z","":"t","":"i","":"k","":"l","":"m","":"n","":"o","":"p","":"zh","":"r","":"s","":"t","":"u","":"f","":"k","":"gh","":"q","":"sh","":"ch","":"ts","":"dz","":"ts","":"ch","":"kh","":"j","":"h","":"W","":"w","":"W","":"w","":"W","":"w","":"SS","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"A","":"a","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"E","":"e","":"I","":"i","":"I","":"i","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"O","":"o","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"U","":"u","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"Y","":"y","":"\'","":"\'","":"\\"","":"\\"","":"+","":"*","":"...","":"ecu","":"cruzeiro","":"french franc","":"lira","":"mill","":"naira","":"peseta","":"rupee","":"won","":"new shequel","":"dong","":"euro","":"kip","":"tugrik","":"drachma","":"penny","":"peso","":"guarani","":"austral","":"hryvnia","":"cedi","":"indian rupee","":"russian ruble","":"bitcoin","":"sm","":"tm","":"d","":"delta","":"sum","":"infinity","":"love","":"yuan","":"yen","":"rial"}'),e=JSON.parse('{"bg":{"locale":"Bulgarian","":"u"}}');function n(n,r){if("string"!=typeof n)throw new Error("slugify: string argument expected");var i=e[(r="string"==typeof r?{replacement:r}:r||{}).locale]||{},o=n.split("").reduce((function(e,n){return e+(i[n]||t[n]||n).replace(r.remove||/[^\w\s$*_+~.()'"!\-:@]/g,"")}),"").trim().replace(/[-\s]+/g,r.replacement||"-");return r.lower?o.toLowerCase():o}return n.extend=function(e){for(var n in e)t[n]=e[n]},n},t.exports=r(),t.exports.default=r()},function(t,e,n){
+/*!
+ * Escaper v2.5.3
+ * https://github.com/kobezzza/Escaper
+ *
+ * Released under the MIT license
+ * https://github.com/kobezzza/Escaper/blob/master/LICENSE
+ *
+ * Date: Tue, 23 Jan 2018 15:58:45 GMT
+ */
+!function(t){"use strict";var e="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},n=void 0,r=n={VERSION:[2,5,3],content:[],cache:{},snakeskinRgxp:null,symbols:null,replace:M,paste:C},i={'"':!0,"'":!0,"`":!0},o={"/":!0};for(var a in i){if(!i.hasOwnProperty(a))break;o[a]=!0}var s={"//":!0,"//*":!0,"//!":!0,"//#":!0,"//@":!0,"//$":!0},u={"/*":!0,"/**":!0,"/*!":!0,"/*#":!0,"/*@":!0,"/*$":!0},c=[],f={};for(var l in o){if(!o.hasOwnProperty(l))break;c.push(l),f[l]=!0}for(var h in s){if(!s.hasOwnProperty(h))break;c.push(h),f[h]=!0}for(var d in u){if(!u.hasOwnProperty(d))break;c.push(d),f[d]=!0}var p=[],g={g:!0,m:!0,i:!0,y:!0,u:!0};for(var y in g){if(!g.hasOwnProperty(y))break;p.push(y)}var b={"-":!0,"+":!0,"*":!0,"%":!0,"~":!0,">":!0,"<":!0,"^":!0,",":!0,";":!0,"=":!0,"|":!0,"&":!0,"!":!0,"?":!0,":":!0,"(":!0,"{":!0,"[":!0},m={return:!0,yield:!0,await:!0,typeof:!0,void:!0,instanceof:!0,delete:!0,in:!0,new:!0,of:!0};function v(t,e,n){for(var r in t){if(!t.hasOwnProperty(r))break;r in e==0&&(e[r]=n)}}var _=void 0,w=void 0,x=/[^\s/]/,k=/[a-z]/,E=/\s/,A=/[\r\n]/,S=/\${pos}/g,T={object:!0,function:!0};function M(t,r,a,l){_=_||n.symbols||"a-z",w=w||n.snakeskinRgxp||new RegExp("[!$"+_+"_]","i");var h=n,d=h.cache,y=h.content,M=Boolean(r&&T[void 0===r?"undefined":e(r)]),D=M?Object(r):{};function C(t){return D["@label"]?D["@label"].replace(S,t):"__ESCAPER_QUOT__"+t+"_"}var O=!1;"boolean"==typeof r&&(O=Boolean(r)),"@comments"in D&&(v(u,D,D["@comments"]),v(s,D,D["@comments"]),delete D["@comments"]),"@strings"in D&&(v(i,D,D["@strings"]),delete D["@strings"]),"@literals"in D&&(v(o,D,D["@literals"]),delete D["@literals"]),"@all"in D&&(v(f,D,D["@all"]),delete D["@all"]);for(var R="",I=-1;++I<c.length;){var N=c[I];u[N]||s[N]?D[N]=O||D[N]:D[N]=D[N]||!M,R+=D[N]+","}var B=t,L=a||y;if(L===y&&d[R]&&d[R][B])return d[R][B];for(var P=!1,F=!0,q=!1,j=!1,U=0,z=!1,Y=0,V=!1,H=void 0,$=void 0,G="",W="",K=-1;++K<t.length;){var X=t.charAt(K),Z=t.charAt(K+1),J=t.substr(K,2),Q=t.substr(K,3);if(j)(A.test(Z)&&s[j]||u[X+t.charAt(K-1)]&&K-U>2&&u[j])&&(D[j]&&(H=t.substring(U,K+1),-1===D[j]?$="":($=C(L.length),L.push(H)),t=t.substring(0,U)+$+t.substring(K+1),K+=$.length-H.length),j=!1);else{if(!P){if("/"===X&&((s[J]||u[J])&&(j=s[Q]||u[Q]?Q:J),j)){U=K;continue}b[X]||m[W]?(F=!0,W=""):x.test(X)&&(F=!1),k.test(X)?G+=X:(W=G,G="");var tt=!1;l&&("|"===X&&w.test(Z)?(V=!0,F=!1,tt=!0):V&&E.test(X)&&(V=!1,F=!0,tt=!0)),tt||(b[X]?F=!0:x.test(X)&&(F=!1))}if("/"!==P||q||("["===X?z=!0:"]"===X&&(z=!1)),!P&&Y&&("}"===X?Y--:"{"===X&&Y++,Y||(X="`")),"`"!==P||q||"${"!==J||(X="`",K++,Y++),!f[X]||"/"===X&&!F||P){if(P&&("\\"===X||q))q=!q;else if(f[X]&&P===X&&!q&&("/"!==P||!z)){if("/"===X)for(var et=-1;++et<p.length;)g[t.charAt(K+1)]&&K++;P=!1,F=!1,D[X]&&(H=t.substring(U,K+1),-1===D[X]?$="":($=C(L.length),L.push(H)),t=t.substring(0,U)+$+t.substring(K+1),K+=$.length-H.length)}}else P=X,U=K}}return L===y&&(d[R]=d[R]||{},d[R][B]=t),t}var D=/__ESCAPER_QUOT__(\d+)_/g;function C(t,e,r){return t.replace(r||D,(function(t,r){return(e||n.content)[r]}))}t.default=r,t.replace=M,t.paste=C,Object.defineProperty(t,"__esModule",{value:!0})}(e)},function(t,e,n){"use strict";var r=n(232);t.exports=function(t,e){var n;t=t.toString();var i="",o="",a=!1,s=!(!1===(e=e||{}).preserve||!0===e.all),u="";"function"==typeof e.preserve?(s=!1,n=e.preserve):r(e.preserve)&&(s=!1,n=function(t){return e.preserve.test(t)});for(var c=0;c<t.length;c++)if(o=t[c],"\\"!==t[c-1]&&('"'!==o&&"'"!==o||(a===o?a=!1:a||(a=o))),a||"/"!==o||"*"!==t[c+1]||s&&"!"===t[c+2])u+=o;else{for(var f=c+2;f<t.length;f++){if("*"===t[f]&&"/"===t[f+1]){n&&(u=n(i)?u+"/*"+i+"*/":u,i="");break}n&&(i+=t[f])}c=f+1}return u}},function(t,e,n){"use strict";t.exports=function(t){return"[object RegExp]"===Object.prototype.toString.call(t)}},function(t,e,n){var r={"./locale":129,"./locale.js":129};function i(t){var e=o(t);return n(e)}function o(t){if(!n.o(r,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return r[t]}i.keys=function(){return Object.keys(r)},i.resolve=o,t.exports=i,i.id=233},function(t,e,n){t.exports={Graph:n(89),version:n(335)}},function(t,e,n){var r=n(130),i=4;t.exports=function(t){return r(t,i)}},function(t,e){t.exports=function(){this.__data__=[],this.size=0}},function(t,e,n){var r=n(63),i=Array.prototype.splice;t.exports=function(t){var e=this.__data__,n=r(e,t);return!(n<0)&&(n==e.length-1?e.pop():i.call(e,n,1),--this.size,!0)}},function(t,e,n){var r=n(63);t.exports=function(t){var e=this.__data__,n=r(e,t);return n<0?void 0:e[n][1]}},function(t,e,n){var r=n(63);t.exports=function(t){return r(this.__data__,t)>-1}},function(t,e,n){var r=n(63);t.exports=function(t,e){var n=this.__data__,i=r(n,t);return i<0?(++this.size,n.push([t,e])):n[i][1]=e,this}},function(t,e,n){var r=n(62);t.exports=function(){this.__data__=new r,this.size=0}},function(t,e){t.exports=function(t){var e=this.__data__,n=e.delete(t);return this.size=e.size,n}},function(t,e){t.exports=function(t){return this.__data__.get(t)}},function(t,e){t.exports=function(t){return this.__data__.has(t)}},function(t,e,n){var r=n(62),i=n(90),o=n(91),a=200;t.exports=function(t,e){var n=this.__data__;if(n instanceof r){var s=n.__data__;if(!i||s.length<a-1)return s.push([t,e]),this.size=++n.size,this;n=this.__data__=new o(s)}return n.set(t,e),this.size=n.size,this}},function(t,e,n){var r=n(37),i=n(249),o=n(13),a=n(132),s=/^\[object .+?Constructor\]$/,u=Function.prototype,c=Object.prototype,f=u.toString,l=c.hasOwnProperty,h=RegExp("^"+f.call(l).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");t.exports=function(t){return!(!o(t)||i(t))&&(r(t)?h:s).test(a(t))}},function(t,e,n){var r=n(38),i=Object.prototype,o=i.hasOwnProperty,a=i.toString,s=r?r.toStringTag:void 0;t.exports=function(t){var e=o.call(t,s),n=t[s];try{t[s]=void 0;var r=!0}catch(t){}var i=a.call(t);return r&&(e?t[s]=n:delete t[s]),i}},function(t,e){var n=Object.prototype.toString;t.exports=function(t){return n.call(t)}},function(t,e,n){var r,i=n(250),o=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";t.exports=function(t){return!!o&&o in t}},function(t,e,n){var r=n(18)["__core-js_shared__"];t.exports=r},function(t,e){t.exports=function(t,e){return null==t?void 0:t[e]}},function(t,e,n){var r=n(253),i=n(62),o=n(90);t.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||i),string:new r}}},function(t,e,n){var r=n(254),i=n(255),o=n(256),a=n(257),s=n(258);function u(t){var e=-1,n=null==t?0:t.length;for(this.clear();++e<n;){var r=t[e];this.set(r[0],r[1])}}u.prototype.clear=r,u.prototype.delete=i,u.prototype.get=o,u.prototype.has=a,u.prototype.set=s,t.exports=u},function(t,e,n){var r=n(64);t.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(t,e){t.exports=function(t){var e=this.has(t)&&delete this.__data__[t];return this.size-=e?1:0,e}},function(t,e,n){var r=n(64),i="__lodash_hash_undefined__",o=Object.prototype.hasOwnProperty;t.exports=function(t){var e=this.__data__;if(r){var n=e[t];return n===i?void 0:n}return o.call(e,t)?e[t]:void 0}},function(t,e,n){var r=n(64),i=Object.prototype.hasOwnProperty;t.exports=function(t){var e=this.__data__;return r?void 0!==e[t]:i.call(e,t)}},function(t,e,n){var r=n(64),i="__lodash_hash_undefined__";t.exports=function(t,e){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=r&&void 0===e?i:e,this}},function(t,e,n){var r=n(65);t.exports=function(t){var e=r(this,t).delete(t);return this.size-=e?1:0,e}},function(t,e){t.exports=function(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}},function(t,e,n){var r=n(65);t.exports=function(t){return r(this,t).get(t)}},function(t,e,n){var r=n(65);t.exports=function(t){return r(this,t).has(t)}},function(t,e,n){var r=n(65);t.exports=function(t,e){var n=r(this,t),i=n.size;return n.set(t,e),this.size+=n.size==i?0:1,this}},function(t,e,n){var r=n(49),i=n(27);t.exports=function(t,e){return t&&r(e,i(e),t)}},function(t,e){t.exports=function(t,e){for(var n=-1,r=Array(t);++n<t;)r[n]=e(n);return r}},function(t,e,n){var r=n(33),i=n(20),o="[object Arguments]";t.exports=function(t){return i(t)&&r(t)==o}},function(t,e){t.exports=function(){return!1}},function(t,e,n){var r=n(33),i=n(93),o=n(20),a={};a["[object Float32Array]"]=a["[object Float64Array]"]=a["[object Int8Array]"]=a["[object Int16Array]"]=a["[object Int32Array]"]=a["[object Uint8Array]"]=a["[object Uint8ClampedArray]"]=a["[object Uint16Array]"]=a["[object Uint32Array]"]=!0,a["[object Arguments]"]=a["[object Array]"]=a["[object ArrayBuffer]"]=a["[object Boolean]"]=a["[object DataView]"]=a["[object Date]"]=a["[object Error]"]=a["[object Function]"]=a["[object Map]"]=a["[object Number]"]=a["[object Object]"]=a["[object RegExp]"]=a["[object Set]"]=a["[object String]"]=a["[object WeakMap]"]=!1,t.exports=function(t){return o(t)&&i(t.length)&&!!a[r(t)]}},function(t,e,n){var r=n(135)(Object.keys,Object);t.exports=r},function(t,e,n){var r=n(49),i=n(40);t.exports=function(t,e){return t&&r(e,i(e),t)}},function(t,e,n){var r=n(13),i=n(70),o=n(272),a=Object.prototype.hasOwnProperty;t.exports=function(t){if(!r(t))return o(t);var e=i(t),n=[];for(var s in t)("constructor"!=s||!e&&a.call(t,s))&&n.push(s);return n}},function(t,e){t.exports=function(t){var e=[];if(null!=t)for(var n in Object(t))e.push(n);return e}},function(t,e,n){var r=n(49),i=n(96);t.exports=function(t,e){return r(t,i(t),e)}},function(t,e,n){var r=n(49),i=n(140);t.exports=function(t,e){return r(t,i(t),e)}},function(t,e,n){var r=n(142),i=n(140),o=n(40);t.exports=function(t){return r(t,o,i)}},function(t,e,n){var r=n(32)(n(18),"DataView");t.exports=r},function(t,e,n){var r=n(32)(n(18),"Promise");t.exports=r},function(t,e,n){var r=n(32)(n(18),"WeakMap");t.exports=r},function(t,e){var n=Object.prototype.hasOwnProperty;t.exports=function(t){var e=t.length,r=new t.constructor(e);return e&&"string"==typeof t[0]&&n.call(t,"index")&&(r.index=t.index,r.input=t.input),r}},function(t,e,n){var r=n(98),i=n(281),o=n(282),a=n(283),s=n(145),u="[object Boolean]",c="[object Date]",f="[object Map]",l="[object Number]",h="[object RegExp]",d="[object Set]",p="[object String]",g="[object Symbol]",y="[object ArrayBuffer]",b="[object DataView]",m="[object Float32Array]",v="[object Float64Array]",_="[object Int8Array]",w="[object Int16Array]",x="[object Int32Array]",k="[object Uint8Array]",E="[object Uint8ClampedArray]",A="[object Uint16Array]",S="[object Uint32Array]";t.exports=function(t,e,n){var T=t.constructor;switch(e){case y:return r(t);case u:case c:return new T(+t);case b:return i(t,n);case m:case v:case _:case w:case x:case k:case E:case A:case S:return s(t,n);case f:return new T;case l:case p:return new T(t);case h:return o(t);case d:return new T;case g:return a(t)}}},function(t,e,n){var r=n(98);t.exports=function(t,e){var n=e?r(t.buffer):t.buffer;return new t.constructor(n,t.byteOffset,t.byteLength)}},function(t,e){var n=/\w*$/;t.exports=function(t){var e=new t.constructor(t.source,n.exec(t));return e.lastIndex=t.lastIndex,e}},function(t,e,n){var r=n(38),i=r?r.prototype:void 0,o=i?i.valueOf:void 0;t.exports=function(t){return o?Object(o.call(t)):{}}},function(t,e,n){var r=n(285),i=n(69),o=n(94),a=o&&o.isMap,s=a?i(a):r;t.exports=s},function(t,e,n){var r=n(41),i=n(20),o="[object Map]";t.exports=function(t){return i(t)&&r(t)==o}},function(t,e,n){var r=n(287),i=n(69),o=n(94),a=o&&o.isSet,s=a?i(a):r;t.exports=s},function(t,e,n){var r=n(41),i=n(20),o="[object Set]";t.exports=function(t){return i(t)&&r(t)==o}},function(t,e){t.exports=function(t){return function(e,n,r){for(var i=-1,o=Object(e),a=r(e),s=a.length;s--;){var u=a[t?s:++i];if(!1===n(o[u],u,o))break}return e}}},function(t,e,n){var r=n(24);t.exports=function(t,e){return function(n,i){if(null==n)return n;if(!r(n))return t(n,i);for(var o=n.length,a=e?o:-1,s=Object(n);(e?a--:++a<o)&&!1!==i(s[a],a,s););return n}}},function(t,e,n){var r=n(72);t.exports=function(t,e){var n=[];return r(t,(function(t,r,i){e(t,r,i)&&n.push(t)})),n}},function(t,e,n){var r=n(292),i=n(300),o=n(156);t.exports=function(t){var e=i(t);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(n){return n===t||r(n,t,e)}}},function(t,e,n){var r=n(61),i=n(151),o=1,a=2;t.exports=function(t,e,n,s){var u=n.length,c=u,f=!s;if(null==t)return!c;for(t=Object(t);u--;){var l=n[u];if(f&&l[2]?l[1]!==t[l[0]]:!(l[0]in t))return!1}for(;++u<c;){var h=(l=n[u])[0],d=t[h],p=l[1];if(f&&l[2]){if(void 0===d&&!(h in t))return!1}else{var g=new r;if(s)var y=s(d,p,h,t,e,g);if(!(void 0===y?i(p,d,o|a,s,g):y))return!1}}return!0}},function(t,e,n){var r=n(61),i=n(152),o=n(297),a=n(299),s=n(41),u=n(6),c=n(39),f=n(51),l=1,h="[object Arguments]",d="[object Array]",p="[object Object]",g=Object.prototype.hasOwnProperty;t.exports=function(t,e,n,y,b,m){var v=u(t),_=u(e),w=v?d:s(t),x=_?d:s(e),k=(w=w==h?p:w)==p,E=(x=x==h?p:x)==p,A=w==x;if(A&&c(t)){if(!c(e))return!1;v=!0,k=!1}if(A&&!k)return m||(m=new r),v||f(t)?i(t,e,n,y,b,m):o(t,e,w,n,y,b,m);if(!(n&l)){var S=k&&g.call(t,"__wrapped__"),T=E&&g.call(e,"__wrapped__");if(S||T){var M=S?t.value():t,D=T?e.value():e;return m||(m=new r),b(M,D,n,y,m)}}return!!A&&(m||(m=new r),a(t,e,n,y,b,m))}},function(t,e){var n="__lodash_hash_undefined__";t.exports=function(t){return this.__data__.set(t,n),this}},function(t,e){t.exports=function(t){return this.__data__.has(t)}},function(t,e){t.exports=function(t,e){for(var n=-1,r=null==t?0:t.length;++n<r;)if(e(t[n],n,t))return!0;return!1}},function(t,e,n){var r=n(38),i=n(144),o=n(36),a=n(152),s=n(298),u=n(103),c=1,f=2,l="[object Boolean]",h="[object Date]",d="[object Error]",p="[object Map]",g="[object Number]",y="[object RegExp]",b="[object Set]",m="[object String]",v="[object Symbol]",_="[object ArrayBuffer]",w="[object DataView]",x=r?r.prototype:void 0,k=x?x.valueOf:void 0;t.exports=function(t,e,n,r,x,E,A){switch(n){case w:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case _:return!(t.byteLength!=e.byteLength||!E(new i(t),new i(e)));case l:case h:case g:return o(+t,+e);case d:return t.name==e.name&&t.message==e.message;case y:case m:return t==e+"";case p:var S=s;case b:var T=r&c;if(S||(S=u),t.size!=e.size&&!T)return!1;var M=A.get(t);if(M)return M==e;r|=f,A.set(t,e);var D=a(S(t),S(e),r,x,E,A);return A.delete(t),D;case v:if(k)return k.call(t)==k.call(e)}return!1}},function(t,e){t.exports=function(t){var e=-1,n=Array(t.size);return t.forEach((function(t,r){n[++e]=[r,t]})),n}},function(t,e,n){var r=n(141),i=1,o=Object.prototype.hasOwnProperty;t.exports=function(t,e,n,a,s,u){var c=n&i,f=r(t),l=f.length;if(l!=r(e).length&&!c)return!1;for(var h=l;h--;){var d=f[h];if(!(c?d in e:o.call(e,d)))return!1}var p=u.get(t);if(p&&u.get(e))return p==e;var g=!0;u.set(t,e),u.set(e,t);for(var y=c;++h<l;){var b=t[d=f[h]],m=e[d];if(a)var v=c?a(m,b,d,e,t,u):a(b,m,d,t,e,u);if(!(void 0===v?b===m||s(b,m,n,a,u):v)){g=!1;break}y||(y="constructor"==d)}if(g&&!y){var _=t.constructor,w=e.constructor;_!=w&&"constructor"in t&&"constructor"in e&&!("function"==typeof _&&_ instanceof _&&"function"==typeof w&&w instanceof w)&&(g=!1)}return u.delete(t),u.delete(e),g}},function(t,e,n){var r=n(155),i=n(27);t.exports=function(t){for(var e=i(t),n=e.length;n--;){var o=e[n],a=t[o];e[n]=[o,a,r(a)]}return e}},function(t,e,n){var r=n(151),i=n(302),o=n(158),a=n(105),s=n(155),u=n(156),c=n(52),f=1,l=2;t.exports=function(t,e){return a(t)&&s(e)?u(c(t),e):function(n){var a=i(n,t);return void 0===a&&a===e?o(n,t):r(e,a,f|l)}}},function(t,e,n){var r=n(104);t.exports=function(t,e,n){var i=null==t?void 0:r(t,e);return void 0===i?n:i}},function(t,e,n){var r=n(304),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,a=r((function(t){var e=[];return 46===t.charCodeAt(0)&&e.push(""),t.replace(i,(function(t,n,r,i){e.push(r?i.replace(o,"$1"):n||t)})),e}));t.exports=a},function(t,e,n){var r=n(305),i=500;t.exports=function(t){var e=r(t,(function(t){return n.size===i&&n.clear(),t})),n=e.cache;return e}},function(t,e,n){var r=n(91),i="Expected a function";function o(t,e){if("function"!=typeof t||null!=e&&"function"!=typeof e)throw new TypeError(i);var n=function(){var r=arguments,i=e?e.apply(this,r):r[0],o=n.cache;if(o.has(i))return o.get(i);var a=t.apply(this,r);return n.cache=o.set(i,a)||o,a};return n.cache=new(o.Cache||r),n}o.Cache=r,t.exports=o},function(t,e,n){var r=n(38),i=n(74),o=n(6),a=n(42),s=1/0,u=r?r.prototype:void 0,c=u?u.toString:void 0;t.exports=function t(e){if("string"==typeof e)return e;if(o(e))return i(e,t)+"";if(a(e))return c?c.call(e):"";var n=e+"";return"0"==n&&1/e==-s?"-0":n}},function(t,e){t.exports=function(t,e){return null!=t&&e in Object(t)}},function(t,e,n){var r=n(160),i=n(309),o=n(105),a=n(52);t.exports=function(t){return o(t)?r(a(t)):i(t)}},function(t,e,n){var r=n(104);t.exports=function(t){return function(e){return r(e,t)}}},function(t,e){var n=Object.prototype.hasOwnProperty;t.exports=function(t,e){return null!=t&&n.call(t,e)}},function(t,e,n){var r=n(95),i=n(41),o=n(50),a=n(6),s=n(24),u=n(39),c=n(70),f=n(51),l="[object Map]",h="[object Set]",d=Object.prototype.hasOwnProperty;t.exports=function(t){if(null==t)return!0;if(s(t)&&(a(t)||"string"==typeof t||"function"==typeof t.splice||u(t)||f(t)||o(t)))return!t.length;var e=i(t);if(e==l||e==h)return!t.size;if(c(t))return!r(t).length;for(var n in t)if(d.call(t,n))return!1;return!0}},function(t,e){t.exports=function(t,e,n,r){var i=-1,o=null==t?0:t.length;for(r&&o&&(n=t[++i]);++i<o;)n=e(n,t[i],i,t);return n}},function(t,e){t.exports=function(t,e,n,r,i){return i(t,(function(t,i,o){n=r?(r=!1,t):e(n,t,i,o)})),n}},function(t,e,n){var r=n(95),i=n(41),o=n(24),a=n(315),s=n(316),u="[object Map]",c="[object Set]";t.exports=function(t){if(null==t)return 0;if(o(t))return a(t)?s(t):t.length;var e=i(t);return e==u||e==c?t.size:r(t).length}},function(t,e,n){var r=n(33),i=n(6),o=n(20),a="[object String]";t.exports=function(t){return"string"==typeof t||!i(t)&&o(t)&&r(t)==a}},function(t,e,n){var r=n(317),i=n(318),o=n(319);t.exports=function(t){return i(t)?o(t):r(t)}},function(t,e,n){var r=n(160)("length");t.exports=r},function(t,e){var n=RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");t.exports=function(t){return n.test(t)}},function(t,e){var n="[\\ud800-\\udfff]",r="[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",i="\\ud83c[\\udffb-\\udfff]",o="[^\\ud800-\\udfff]",a="(?:\\ud83c[\\udde6-\\uddff]){2}",s="[\\ud800-\\udbff][\\udc00-\\udfff]",u="(?:"+r+"|"+i+")"+"?",c="[\\ufe0e\\ufe0f]?"+u+("(?:\\u200d(?:"+[o,a,s].join("|")+")[\\ufe0e\\ufe0f]?"+u+")*"),f="(?:"+[o+r+"?",r,a,s,n].join("|")+")",l=RegExp(i+"(?="+i+")|"+f+c,"g");t.exports=function(t){for(var e=l.lastIndex=0;l.test(t);)++e;return e}},function(t,e,n){var r=n(92),i=n(147),o=n(101),a=n(25),s=n(71),u=n(6),c=n(39),f=n(37),l=n(13),h=n(51);t.exports=function(t,e,n){var d=u(t),p=d||c(t)||h(t);if(e=a(e,4),null==n){var g=t&&t.constructor;n=p?d?new g:[]:l(t)&&f(g)?i(s(t)):{}}return(p?r:o)(t,(function(t,r,i){return e(n,t,r,i)})),n}},function(t,e,n){var r=n(107),i=n(75),o=n(326),a=n(168),s=i((function(t){return o(r(t,1,a,!0))}));t.exports=s},function(t,e,n){var r=n(38),i=n(50),o=n(6),a=r?r.isConcatSpreadable:void 0;t.exports=function(t){return o(t)||i(t)||!!(a&&t&&t[a])}},function(t,e){t.exports=function(t,e,n){switch(n.length){case 0:return t.call(e);case 1:return t.call(e,n[0]);case 2:return t.call(e,n[0],n[1]);case 3:return t.call(e,n[0],n[1],n[2])}return t.apply(e,n)}},function(t,e,n){var r=n(99),i=n(133),o=n(34),a=i?function(t,e){return i(t,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;t.exports=a},function(t,e){var n=800,r=16,i=Date.now;t.exports=function(t){var e=0,o=0;return function(){var a=i(),s=r-(a-o);if(o=a,s>0){if(++e>=n)return arguments[0]}else e=0;return t.apply(void 0,arguments)}}},function(t,e,n){var r=n(153),i=n(327),o=n(331),a=n(154),s=n(332),u=n(103),c=200;t.exports=function(t,e,n){var f=-1,l=i,h=t.length,d=!0,p=[],g=p;if(n)d=!1,l=o;else if(h>=c){var y=e?null:s(t);if(y)return u(y);d=!1,l=a,g=new r}else g=e?[]:p;t:for(;++f<h;){var b=t[f],m=e?e(b):b;if(b=n||0!==b?b:0,d&&m==m){for(var v=g.length;v--;)if(g[v]===m)continue t;e&&g.push(m),p.push(b)}else l(g,m,n)||(g!==p&&g.push(m),p.push(b))}return p}},function(t,e,n){var r=n(328);t.exports=function(t,e){return!!(null==t?0:t.length)&&r(t,e,0)>-1}},function(t,e,n){var r=n(167),i=n(329),o=n(330);t.exports=function(t,e,n){return e==e?o(t,e,n):r(t,i,n)}},function(t,e){t.exports=function(t){return t!=t}},function(t,e){t.exports=function(t,e,n){for(var r=n-1,i=t.length;++r<i;)if(t[r]===e)return r;return-1}},function(t,e){t.exports=function(t,e,n){for(var r=-1,i=null==t?0:t.length;++r<i;)if(n(e,t[r]))return!0;return!1}},function(t,e,n){var r=n(143),i=n(333),o=n(103),a=r&&1/o(new r([,-0]))[1]==1/0?function(t){return new r(t)}:i;t.exports=a},function(t,e){t.exports=function(){}},function(t,e,n){var r=n(74);t.exports=function(t,e){return r(e,(function(e){return t[e]}))}},function(t,e){t.exports="2.1.7"},function(t,e,n){var r=n(12),i=n(89);function o(t){return r.map(t.nodes(),(function(e){var n=t.node(e),i=t.parent(e),o={v:e};return r.isUndefined(n)||(o.value=n),r.isUndefined(i)||(o.parent=i),o}))}function a(t){return r.map(t.edges(),(function(e){var n=t.edge(e),i={v:e.v,w:e.w};return r.isUndefined(e.name)||(i.name=e.name),r.isUndefined(n)||(i.value=n),i}))}t.exports={write:function(t){var e={options:{directed:t.isDirected(),multigraph:t.isMultigraph(),compound:t.isCompound()},nodes:o(t),edges:a(t)};r.isUndefined(t.graph())||(e.value=r.clone(t.graph()));return e},read:function(t){var e=new i(t.options).setGraph(t.value);return r.each(t.nodes,(function(t){e.setNode(t.v,t.value),t.parent&&e.setParent(t.v,t.parent)})),r.each(t.edges,(function(t){e.setEdge({v:t.v,w:t.w,name:t.name},t.value)})),e}}},function(t,e,n){t.exports={components:n(338),dijkstra:n(170),dijkstraAll:n(339),findCycles:n(340),floydWarshall:n(341),isAcyclic:n(342),postorder:n(343),preorder:n(344),prim:n(345),tarjan:n(172),topsort:n(173)}},function(t,e,n){var r=n(12);t.exports=function(t){var e,n={},i=[];function o(i){r.has(n,i)||(n[i]=!0,e.push(i),r.each(t.successors(i),o),r.each(t.predecessors(i),o))}return r.each(t.nodes(),(function(t){e=[],o(t),e.length&&i.push(e)})),i}},function(t,e,n){var r=n(170),i=n(12);t.exports=function(t,e,n){return i.transform(t.nodes(),(function(i,o){i[o]=r(t,o,e,n)}),{})}},function(t,e,n){var r=n(12),i=n(172);t.exports=function(t){return r.filter(i(t),(function(e){return e.length>1||1===e.length&&t.hasEdge(e[0],e[0])}))}},function(t,e,n){var r=n(12);t.exports=function(t,e,n){return function(t,e,n){var r={},i=t.nodes();return i.forEach((function(t){r[t]={},r[t][t]={distance:0},i.forEach((function(e){t!==e&&(r[t][e]={distance:Number.POSITIVE_INFINITY})})),n(t).forEach((function(n){var i=n.v===t?n.w:n.v,o=e(n);r[t][i]={distance:o,predecessor:t}}))})),i.forEach((function(t){var e=r[t];i.forEach((function(n){var o=r[n];i.forEach((function(n){var r=o[t],i=e[n],a=o[n],s=r.distance+i.distance;s<a.distance&&(a.distance=s,a.predecessor=i.predecessor)}))}))})),r}(t,e||i,n||function(e){return t.outEdges(e)})};var i=r.constant(1)},function(t,e,n){var r=n(173);t.exports=function(t){try{r(t)}catch(t){if(t instanceof r.CycleException)return!1;throw t}return!0}},function(t,e,n){var r=n(174);t.exports=function(t,e){return r(t,e,"post")}},function(t,e,n){var r=n(174);t.exports=function(t,e){return r(t,e,"pre")}},function(t,e,n){var r=n(12),i=n(89),o=n(171);t.exports=function(t,e){var n,a=new i,s={},u=new o;function c(t){var r=t.v===n?t.w:t.v,i=u.priority(r);if(void 0!==i){var o=e(t);o<i&&(s[r]=n,u.decrease(r,o))}}if(0===t.nodeCount())return a;r.each(t.nodes(),(function(t){u.add(t,Number.POSITIVE_INFINITY),a.setNode(t)})),u.decrease(t.nodes()[0],0);var f=!1;for(;u.size()>0;){if(n=u.removeMin(),r.has(s,n))a.setEdge(n,s[n]);else{if(f)throw new Error("Input graph is not connected: "+t);f=!0}t.nodeEdges(n).forEach(c)}return a}},function(t,e,n){var r;try{r=n(22)}catch(t){}r||(r=window.graphlib),t.exports=r},function(t,e,n){"use strict";var r=n(4),i=n(380),o=n(383),a=n(384),s=n(10).normalizeRanks,u=n(386),c=n(10).removeEmptyRanks,f=n(387),l=n(388),h=n(389),d=n(390),p=n(399),g=n(10),y=n(19).Graph;t.exports=function(t,e){var n=e&&e.debugTiming?g.time:g.notime;n("layout",(function(){var e=n("  buildLayoutGraph",(function(){return function(t){var e=new y({multigraph:!0,compound:!0}),n=S(t.graph());return e.setGraph(r.merge({},m,A(n,b),r.pick(n,v))),r.forEach(t.nodes(),(function(n){var i=S(t.node(n));e.setNode(n,r.defaults(A(i,_),w)),e.setParent(n,t.parent(n))})),r.forEach(t.edges(),(function(n){var i=S(t.edge(n));e.setEdge(n,r.merge({},k,A(i,x),r.pick(i,E)))})),e}(t)}));n("  runLayout",(function(){!function(t,e){e("    makeSpaceForEdgeLabels",(function(){!function(t){var e=t.graph();e.ranksep/=2,r.forEach(t.edges(),(function(n){var r=t.edge(n);r.minlen*=2,"c"!==r.labelpos.toLowerCase()&&("TB"===e.rankdir||"BT"===e.rankdir?r.width+=r.labeloffset:r.height+=r.labeloffset)}))}(t)})),e("    removeSelfEdges",(function(){!function(t){r.forEach(t.edges(),(function(e){if(e.v===e.w){var n=t.node(e.v);n.selfEdges||(n.selfEdges=[]),n.selfEdges.push({e:e,label:t.edge(e)}),t.removeEdge(e)}}))}(t)})),e("    acyclic",(function(){i.run(t)})),e("    nestingGraph.run",(function(){f.run(t)})),e("    rank",(function(){a(g.asNonCompoundGraph(t))})),e("    injectEdgeLabelProxies",(function(){!function(t){r.forEach(t.edges(),(function(e){var n=t.edge(e);if(n.width&&n.height){var r=t.node(e.v),i={rank:(t.node(e.w).rank-r.rank)/2+r.rank,e:e};g.addDummyNode(t,"edge-proxy",i,"_ep")}}))}(t)})),e("    removeEmptyRanks",(function(){c(t)})),e("    nestingGraph.cleanup",(function(){f.cleanup(t)})),e("    normalizeRanks",(function(){s(t)})),e("    assignRankMinMax",(function(){!function(t){var e=0;r.forEach(t.nodes(),(function(n){var i=t.node(n);i.borderTop&&(i.minRank=t.node(i.borderTop).rank,i.maxRank=t.node(i.borderBottom).rank,e=r.max(e,i.maxRank))})),t.graph().maxRank=e}(t)})),e("    removeEdgeLabelProxies",(function(){!function(t){r.forEach(t.nodes(),(function(e){var n=t.node(e);"edge-proxy"===n.dummy&&(t.edge(n.e).labelRank=n.rank,t.removeNode(e))}))}(t)})),e("    normalize.run",(function(){o.run(t)})),e("    parentDummyChains",(function(){u(t)})),e("    addBorderSegments",(function(){l(t)})),e("    order",(function(){d(t)})),e("    insertSelfEdges",(function(){!function(t){var e=g.buildLayerMatrix(t);r.forEach(e,(function(e){var n=0;r.forEach(e,(function(e,i){var o=t.node(e);o.order=i+n,r.forEach(o.selfEdges,(function(e){g.addDummyNode(t,"selfedge",{width:e.label.width,height:e.label.height,rank:o.rank,order:i+ ++n,e:e.e,label:e.label},"_se")})),delete o.selfEdges}))}))}(t)})),e("    adjustCoordinateSystem",(function(){h.adjust(t)})),e("    position",(function(){p(t)})),e("    positionSelfEdges",(function(){!function(t){r.forEach(t.nodes(),(function(e){var n=t.node(e);if("selfedge"===n.dummy){var r=t.node(n.e.v),i=r.x+r.width/2,o=r.y,a=n.x-i,s=r.height/2;t.setEdge(n.e,n.label),t.removeNode(e),n.label.points=[{x:i+2*a/3,y:o-s},{x:i+5*a/6,y:o-s},{x:i+a,y:o},{x:i+5*a/6,y:o+s},{x:i+2*a/3,y:o+s}],n.label.x=n.x,n.label.y=n.y}}))}(t)})),e("    removeBorderNodes",(function(){!function(t){r.forEach(t.nodes(),(function(e){if(t.children(e).length){var n=t.node(e),i=t.node(n.borderTop),o=t.node(n.borderBottom),a=t.node(r.last(n.borderLeft)),s=t.node(r.last(n.borderRight));n.width=Math.abs(s.x-a.x),n.height=Math.abs(o.y-i.y),n.x=a.x+n.width/2,n.y=i.y+n.height/2}})),r.forEach(t.nodes(),(function(e){"border"===t.node(e).dummy&&t.removeNode(e)}))}(t)})),e("    normalize.undo",(function(){o.undo(t)})),e("    fixupEdgeLabelCoords",(function(){!function(t){r.forEach(t.edges(),(function(e){var n=t.edge(e);if(r.has(n,"x"))switch("l"!==n.labelpos&&"r"!==n.labelpos||(n.width-=n.labeloffset),n.labelpos){case"l":n.x-=n.width/2+n.labeloffset;break;case"r":n.x+=n.width/2+n.labeloffset}}))}(t)})),e("    undoCoordinateSystem",(function(){h.undo(t)})),e("    translateGraph",(function(){!function(t){var e=Number.POSITIVE_INFINITY,n=0,i=Number.POSITIVE_INFINITY,o=0,a=t.graph(),s=a.marginx||0,u=a.marginy||0;function c(t){var r=t.x,a=t.y,s=t.width,u=t.height;e=Math.min(e,r-s/2),n=Math.max(n,r+s/2),i=Math.min(i,a-u/2),o=Math.max(o,a+u/2)}r.forEach(t.nodes(),(function(e){c(t.node(e))})),r.forEach(t.edges(),(function(e){var n=t.edge(e);r.has(n,"x")&&c(n)})),e-=s,i-=u,r.forEach(t.nodes(),(function(n){var r=t.node(n);r.x-=e,r.y-=i})),r.forEach(t.edges(),(function(n){var o=t.edge(n);r.forEach(o.points,(function(t){t.x-=e,t.y-=i})),r.has(o,"x")&&(o.x-=e),r.has(o,"y")&&(o.y-=i)})),a.width=n-e+s,a.height=o-i+u}(t)})),e("    assignNodeIntersects",(function(){!function(t){r.forEach(t.edges(),(function(e){var n,r,i=t.edge(e),o=t.node(e.v),a=t.node(e.w);i.points?(n=i.points[0],r=i.points[i.points.length-1]):(i.points=[],n=a,r=o),i.points.unshift(g.intersectRect(o,n)),i.points.push(g.intersectRect(a,r))}))}(t)})),e("    reversePoints",(function(){!function(t){r.forEach(t.edges(),(function(e){var n=t.edge(e);n.reversed&&n.points.reverse()}))}(t)})),e("    acyclic.undo",(function(){i.undo(t)}))}(e,n)})),n("  updateInputGraph",(function(){!function(t,e){r.forEach(t.nodes(),(function(n){var r=t.node(n),i=e.node(n);r&&(r.x=i.x,r.y=i.y,e.children(n).length&&(r.width=i.width,r.height=i.height))})),r.forEach(t.edges(),(function(n){var i=t.edge(n),o=e.edge(n);i.points=o.points,r.has(o,"x")&&(i.x=o.x,i.y=o.y)})),t.graph().width=e.graph().width,t.graph().height=e.graph().height}(t,e)}))}))};var b=["nodesep","edgesep","ranksep","marginx","marginy"],m={ranksep:50,edgesep:20,nodesep:50,rankdir:"tb"},v=["acyclicer","ranker","rankdir","align"],_=["width","height"],w={width:0,height:0},x=["minlen","weight","width","height","labeloffset"],k={minlen:1,weight:1,width:0,height:0,labeloffset:10,labelpos:"r"},E=["labelpos"];function A(t,e){return r.mapValues(r.pick(t,e),Number)}function S(t){var e={};return r.forEach(t,(function(t,n){e[n.toLowerCase()]=t})),e}},function(t,e,n){var r=n(130),i=1,o=4;t.exports=function(t){return r(t,i|o)}},function(t,e,n){var r=n(350)(n(351));t.exports=r},function(t,e,n){var r=n(25),i=n(24),o=n(27);t.exports=function(t){return function(e,n,a){var s=Object(e);if(!i(e)){var u=r(n,3);e=o(e),n=function(t){return u(s[t],t,s)}}var c=t(e,n,a);return c>-1?s[u?e[c]:c]:void 0}}},function(t,e,n){var r=n(167),i=n(25),o=n(352),a=Math.max;t.exports=function(t,e,n){var s=null==t?0:t.length;if(!s)return-1;var u=null==n?0:o(n);return u<0&&(u=a(s+u,0)),r(t,i(e,3),u)}},function(t,e,n){var r=n(177);t.exports=function(t){var e=r(t),n=e%1;return e==e?n?e-n:e:0}},function(t,e,n){var r=n(13),i=n(42),o=NaN,a=/^\s+|\s+$/g,s=/^[-+]0x[0-9a-f]+$/i,u=/^0b[01]+$/i,c=/^0o[0-7]+$/i,f=parseInt;t.exports=function(t){if("number"==typeof t)return t;if(i(t))return o;if(r(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=r(e)?e+"":e}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(a,"");var n=u.test(t);return n||c.test(t)?f(t.slice(2),n?2:8):s.test(t)?o:+t}},function(t,e,n){var r=n(102),i=n(149),o=n(40);t.exports=function(t,e){return null==t?t:r(t,i(e),o)}},function(t,e){t.exports=function(t){var e=null==t?0:t.length;return e?t[e-1]:void 0}},function(t,e,n){var r=n(67),i=n(101),o=n(25);t.exports=function(t,e){var n={};return e=o(e,3),i(t,(function(t,i,o){r(n,i,e(t,i,o))})),n}},function(t,e,n){var r=n(108),i=n(358),o=n(34);t.exports=function(t){return t&&t.length?r(t,o,i):void 0}},function(t,e){t.exports=function(t,e){return t>e}},function(t,e,n){var r=n(360),i=n(363)((function(t,e,n){r(t,e,n)}));t.exports=i},function(t,e,n){var r=n(61),i=n(179),o=n(102),a=n(361),s=n(13),u=n(40),c=n(181);t.exports=function t(e,n,f,l,h){e!==n&&o(n,(function(o,u){if(h||(h=new r),s(o))a(e,n,u,f,t,l,h);else{var d=l?l(c(e,u),o,u+"",e,n,h):void 0;void 0===d&&(d=o),i(e,u,d)}}),u)}},function(t,e,n){var r=n(179),i=n(136),o=n(145),a=n(137),s=n(146),u=n(50),c=n(6),f=n(168),l=n(39),h=n(37),d=n(13),p=n(180),g=n(51),y=n(181),b=n(362);t.exports=function(t,e,n,m,v,_,w){var x=y(t,n),k=y(e,n),E=w.get(k);if(E)r(t,n,E);else{var A=_?_(x,k,n+"",t,e,w):void 0,S=void 0===A;if(S){var T=c(k),M=!T&&l(k),D=!T&&!M&&g(k);A=k,T||M||D?c(x)?A=x:f(x)?A=a(x):M?(S=!1,A=i(k,!0)):D?(S=!1,A=o(k,!0)):A=[]:p(k)||u(k)?(A=x,u(x)?A=b(x):d(x)&&!h(x)||(A=s(k))):S=!1}S&&(w.set(k,A),v(A,k,m,_,w),w.delete(k)),r(t,n,A)}}},function(t,e,n){var r=n(49),i=n(40);t.exports=function(t){return r(t,i(t))}},function(t,e,n){var r=n(75),i=n(76);t.exports=function(t){return r((function(e,n){var r=-1,o=n.length,a=o>1?n[o-1]:void 0,s=o>2?n[2]:void 0;for(a=t.length>3&&"function"==typeof a?(o--,a):void 0,s&&i(n[0],n[1],s)&&(a=o<3?void 0:a,o=1),e=Object(e);++r<o;){var u=n[r];u&&t(e,u,r,a)}return e}))}},function(t,e,n){var r=n(108),i=n(182),o=n(34);t.exports=function(t){return t&&t.length?r(t,o,i):void 0}},function(t,e,n){var r=n(108),i=n(25),o=n(182);t.exports=function(t,e){return t&&t.length?r(t,i(e,2),o):void 0}},function(t,e,n){var r=n(18);t.exports=function(){return r.Date.now()}},function(t,e,n){var r=n(368),i=n(158);t.exports=function(t,e){return r(t,e,(function(e,n){return i(t,n)}))}},function(t,e,n){var r=n(104),i=n(369),o=n(73);t.exports=function(t,e,n){for(var a=-1,s=e.length,u={};++a<s;){var c=e[a],f=r(t,c);n(f,c)&&i(u,o(c,t),f)}return u}},function(t,e,n){var r=n(66),i=n(73),o=n(68),a=n(13),s=n(52);t.exports=function(t,e,n,u){if(!a(t))return t;for(var c=-1,f=(e=i(e,t)).length,l=f-1,h=t;null!=h&&++c<f;){var d=s(e[c]),p=n;if(c!=l){var g=h[d];void 0===(p=u?u(g,d,h):void 0)&&(p=a(g)?g:o(e[c+1])?[]:{})}r(h,d,p),h=h[d]}return t}},function(t,e,n){var r=n(178),i=n(165),o=n(166);t.exports=function(t){return o(i(t,void 0,r),t+"")}},function(t,e,n){var r=n(372),i=n(76),o=n(177);t.exports=function(t){return function(e,n,a){return a&&"number"!=typeof a&&i(e,n,a)&&(n=a=void 0),e=o(e),void 0===n?(n=e,e=0):n=o(n),a=void 0===a?e<n?1:-1:o(a),r(e,n,a,t)}}},function(t,e){var n=Math.ceil,r=Math.max;t.exports=function(t,e,i,o){for(var a=-1,s=r(n((e-t)/(i||1)),0),u=Array(s);s--;)u[o?s:++a]=t,t+=i;return u}},function(t,e,n){var r=n(107),i=n(374),o=n(75),a=n(76),s=o((function(t,e){if(null==t)return[];var n=e.length;return n>1&&a(t,e[0],e[1])?e=[]:n>2&&a(e[0],e[1],e[2])&&(e=[e[0]]),i(t,r(e,1),[])}));t.exports=s},function(t,e,n){var r=n(74),i=n(25),o=n(163),a=n(375),s=n(69),u=n(376),c=n(34);t.exports=function(t,e,n){var f=-1;e=r(e.length?e:[c],s(i));var l=o(t,(function(t,n,i){return{criteria:r(e,(function(e){return e(t)})),index:++f,value:t}}));return a(l,(function(t,e){return u(t,e,n)}))}},function(t,e){t.exports=function(t,e){var n=t.length;for(t.sort(e);n--;)t[n]=t[n].value;return t}},function(t,e,n){var r=n(377);t.exports=function(t,e,n){for(var i=-1,o=t.criteria,a=e.criteria,s=o.length,u=n.length;++i<s;){var c=r(o[i],a[i]);if(c)return i>=u?c:c*("desc"==n[i]?-1:1)}return t.index-e.index}},function(t,e,n){var r=n(42);t.exports=function(t,e){if(t!==e){var n=void 0!==t,i=null===t,o=t==t,a=r(t),s=void 0!==e,u=null===e,c=e==e,f=r(e);if(!u&&!f&&!a&&t>e||a&&s&&c&&!u&&!f||i&&s&&c||!n&&c||!o)return 1;if(!i&&!a&&!f&&t<e||f&&n&&o&&!i&&!a||u&&n&&o||!s&&o||!c)return-1}return 0}},function(t,e,n){var r=n(66),i=n(379);t.exports=function(t,e){return i(t||[],e||[],r)}},function(t,e){t.exports=function(t,e,n){for(var r=-1,i=t.length,o=e.length,a={};++r<i;){var s=r<o?e[r]:void 0;n(a,t[r],s)}return a}},function(t,e,n){"use strict";var r=n(4),i=n(381);t.exports={run:function(t){var e="greedy"===t.graph().acyclicer?i(t,function(t){return function(e){return t.edge(e).weight}}(t)):function(t){var e=[],n={},i={};return r.forEach(t.nodes(),(function o(a){if(r.has(i,a))return;i[a]=!0;n[a]=!0;r.forEach(t.outEdges(a),(function(t){r.has(n,t.w)?e.push(t):o(t.w)}));delete n[a]})),e}(t);r.forEach(e,(function(e){var n=t.edge(e);t.removeEdge(e),n.forwardName=e.name,n.reversed=!0,t.setEdge(e.w,e.v,n,r.uniqueId("rev"))}))},undo:function(t){r.forEach(t.edges(),(function(e){var n=t.edge(e);if(n.reversed){t.removeEdge(e);var r=n.forwardName;delete n.reversed,delete n.forwardName,t.setEdge(e.w,e.v,n,r)}}))}}},function(t,e,n){var r=n(4),i=n(19).Graph,o=n(382);t.exports=function(t,e){if(t.nodeCount()<=1)return[];var n=function(t,e){var n=new i,a=0,s=0;r.forEach(t.nodes(),(function(t){n.setNode(t,{v:t,in:0,out:0})})),r.forEach(t.edges(),(function(t){var r=n.edge(t.v,t.w)||0,i=e(t),o=r+i;n.setEdge(t.v,t.w,o),s=Math.max(s,n.node(t.v).out+=i),a=Math.max(a,n.node(t.w).in+=i)}));var c=r.range(s+a+3).map((function(){return new o})),f=a+1;return r.forEach(n.nodes(),(function(t){u(c,f,n.node(t))})),{graph:n,buckets:c,zeroIdx:f}}(t,e||a),c=function(t,e,n){var r,i=[],o=e[e.length-1],a=e[0];for(;t.nodeCount();){for(;r=a.dequeue();)s(t,e,n,r);for(;r=o.dequeue();)s(t,e,n,r);if(t.nodeCount())for(var u=e.length-2;u>0;--u)if(r=e[u].dequeue()){i=i.concat(s(t,e,n,r,!0));break}}return i}(n.graph,n.buckets,n.zeroIdx);return r.flatten(r.map(c,(function(e){return t.outEdges(e.v,e.w)})),!0)};var a=r.constant(1);function s(t,e,n,i,o){var a=o?[]:void 0;return r.forEach(t.inEdges(i.v),(function(r){var i=t.edge(r),s=t.node(r.v);o&&a.push({v:r.v,w:r.w}),s.out-=i,u(e,n,s)})),r.forEach(t.outEdges(i.v),(function(r){var i=t.edge(r),o=r.w,a=t.node(o);a.in-=i,u(e,n,a)})),t.removeNode(i.v),a}function u(t,e,n){n.out?n.in?t[n.out-n.in+e].enqueue(n):t[t.length-1].enqueue(n):t[0].enqueue(n)}},function(t,e){function n(){var t={};t._next=t._prev=t,this._sentinel=t}function r(t){t._prev._next=t._next,t._next._prev=t._prev,delete t._next,delete t._prev}function i(t,e){if("_next"!==t&&"_prev"!==t)return e}t.exports=n,n.prototype.dequeue=function(){var t=this._sentinel,e=t._prev;if(e!==t)return r(e),e},n.prototype.enqueue=function(t){var e=this._sentinel;t._prev&&t._next&&r(t),t._next=e._next,e._next._prev=t,e._next=t,t._prev=e},n.prototype.toString=function(){for(var t=[],e=this._sentinel,n=e._prev;n!==e;)t.push(JSON.stringify(n,i)),n=n._prev;return"["+t.join(", ")+"]"}},function(t,e,n){"use strict";var r=n(4),i=n(10);t.exports={run:function(t){t.graph().dummyChains=[],r.forEach(t.edges(),(function(e){!function(t,e){var n,r,o,a=e.v,s=t.node(a).rank,u=e.w,c=t.node(u).rank,f=e.name,l=t.edge(e),h=l.labelRank;if(c===s+1)return;for(t.removeEdge(e),o=0,++s;s<c;++o,++s)l.points=[],r={width:0,height:0,edgeLabel:l,edgeObj:e,rank:s},n=i.addDummyNode(t,"edge",r,"_d"),s===h&&(r.width=l.width,r.height=l.height,r.dummy="edge-label",r.labelpos=l.labelpos),t.setEdge(a,n,{weight:l.weight},f),0===o&&t.graph().dummyChains.push(n),a=n;t.setEdge(a,u,{weight:l.weight},f)}(t,e)}))},undo:function(t){r.forEach(t.graph().dummyChains,(function(e){var n,r=t.node(e),i=r.edgeLabel;for(t.setEdge(r.edgeObj,i);r.dummy;)n=t.successors(e)[0],t.removeNode(e),i.points.push({x:r.x,y:r.y}),"edge-label"===r.dummy&&(i.x=r.x,i.y=r.y,i.width=r.width,i.height=r.height),e=n,r=t.node(e)}))}}},function(t,e,n){"use strict";var r=n(77).longestPath,i=n(186),o=n(385);t.exports=function(t){switch(t.graph().ranker){case"network-simplex":s(t);break;case"tight-tree":!function(t){r(t),i(t)}(t);break;case"longest-path":a(t);break;default:s(t)}};var a=r;function s(t){o(t)}},function(t,e,n){"use strict";var r=n(4),i=n(186),o=n(77).slack,a=n(77).longestPath,s=n(19).alg.preorder,u=n(19).alg.postorder,c=n(10).simplify;function f(t){t=c(t),a(t);var e,n=i(t);for(d(n),l(n,t);e=p(n);)y(n,t,e,g(n,t,e))}function l(t,e){var n=u(t,t.nodes());n=n.slice(0,n.length-1),r.forEach(n,(function(n){!function(t,e,n){var r=t.node(n).parent;t.edge(n,r).cutvalue=h(t,e,n)}(t,e,n)}))}function h(t,e,n){var i=t.node(n).parent,o=!0,a=e.edge(n,i),s=0;return a||(o=!1,a=e.edge(i,n)),s=a.weight,r.forEach(e.nodeEdges(n),(function(r){var a,u,c=r.v===n,f=c?r.w:r.v;if(f!==i){var l=c===o,h=e.edge(r).weight;if(s+=l?h:-h,a=n,u=f,t.hasEdge(a,u)){var d=t.edge(n,f).cutvalue;s+=l?-d:d}}})),s}function d(t,e){arguments.length<2&&(e=t.nodes()[0]),function t(e,n,i,o,a){var s=i,u=e.node(o);n[o]=!0;r.forEach(e.neighbors(o),(function(a){r.has(n,a)||(i=t(e,n,i,a,o))}));u.low=s;u.lim=i++;a?u.parent=a:delete u.parent;return i}(t,{},1,e)}function p(t){return r.find(t.edges(),(function(e){return t.edge(e).cutvalue<0}))}function g(t,e,n){var i=n.v,a=n.w;e.hasEdge(i,a)||(i=n.w,a=n.v);var s=t.node(i),u=t.node(a),c=s,f=!1;s.lim>u.lim&&(c=u,f=!0);var l=r.filter(e.edges(),(function(e){return f===b(t,t.node(e.v),c)&&f!==b(t,t.node(e.w),c)}));return r.minBy(l,(function(t){return o(e,t)}))}function y(t,e,n,i){var o=n.v,a=n.w;t.removeEdge(o,a),t.setEdge(i.v,i.w,{}),d(t),l(t,e),function(t,e){var n=r.find(t.nodes(),(function(t){return!e.node(t).parent})),i=s(t,n);i=i.slice(1),r.forEach(i,(function(n){var r=t.node(n).parent,i=e.edge(n,r),o=!1;i||(i=e.edge(r,n),o=!0),e.node(n).rank=e.node(r).rank+(o?i.minlen:-i.minlen)}))}(t,e)}function b(t,e,n){return n.low<=e.lim&&e.lim<=n.lim}t.exports=f,f.initLowLimValues=d,f.initCutValues=l,f.calcCutValue=h,f.leaveEdge=p,f.enterEdge=g,f.exchangeEdges=y},function(t,e,n){var r=n(4);t.exports=function(t){var e=function(t){var e={},n=0;return r.forEach(t.children(),(function i(o){var a=n;r.forEach(t.children(o),i);e[o]={low:a,lim:n++}})),e}(t);r.forEach(t.graph().dummyChains,(function(n){for(var r=t.node(n),i=r.edgeObj,o=function(t,e,n,r){var i,o,a=[],s=[],u=Math.min(e[n].low,e[r].low),c=Math.max(e[n].lim,e[r].lim);i=n;do{i=t.parent(i),a.push(i)}while(i&&(e[i].low>u||c>e[i].lim));o=i,i=r;for(;(i=t.parent(i))!==o;)s.push(i);return{path:a.concat(s.reverse()),lca:o}}(t,e,i.v,i.w),a=o.path,s=o.lca,u=0,c=a[u],f=!0;n!==i.w;){if(r=t.node(n),f){for(;(c=a[u])!==s&&t.node(c).maxRank<r.rank;)u++;c===s&&(f=!1)}if(!f){for(;u<a.length-1&&t.node(c=a[u+1]).minRank<=r.rank;)u++;c=a[u]}t.setParent(n,c),n=t.successors(n)[0]}}))}},function(t,e,n){var r=n(4),i=n(10);t.exports={run:function(t){var e=i.addDummyNode(t,"root",{},"_root"),n=function(t){var e={};return r.forEach(t.children(),(function(n){!function n(i,o){var a=t.children(i);a&&a.length&&r.forEach(a,(function(t){n(t,o+1)}));e[i]=o}(n,1)})),e}(t),o=r.max(r.values(n))-1,a=2*o+1;t.graph().nestingRoot=e,r.forEach(t.edges(),(function(e){t.edge(e).minlen*=a}));var s=function(t){return r.reduce(t.edges(),(function(e,n){return e+t.edge(n).weight}),0)}(t)+1;r.forEach(t.children(),(function(u){!function t(e,n,o,a,s,u,c){var f=e.children(c);if(!f.length)return void(c!==n&&e.setEdge(n,c,{weight:0,minlen:o}));var l=i.addBorderNode(e,"_bt"),h=i.addBorderNode(e,"_bb"),d=e.node(c);e.setParent(l,c);d.borderTop=l;e.setParent(h,c);d.borderBottom=h;r.forEach(f,(function(r){t(e,n,o,a,s,u,r);var i=e.node(r),f=i.borderTop?i.borderTop:r,d=i.borderBottom?i.borderBottom:r,p=i.borderTop?a:2*a,g=f!==d?1:s-u[c]+1;e.setEdge(l,f,{weight:p,minlen:g,nestingEdge:!0}),e.setEdge(d,h,{weight:p,minlen:g,nestingEdge:!0})}));e.parent(c)||e.setEdge(n,l,{weight:0,minlen:s+u[c]})}(t,e,a,s,o,n,u)})),t.graph().nodeRankFactor=a},cleanup:function(t){var e=t.graph();t.removeNode(e.nestingRoot),delete e.nestingRoot,r.forEach(t.edges(),(function(e){t.edge(e).nestingEdge&&t.removeEdge(e)}))}}},function(t,e,n){var r=n(4),i=n(10);function o(t,e,n,r,o,a){var s={width:0,height:0,rank:a,borderType:e},u=o[e][a-1],c=i.addDummyNode(t,"border",s,n);o[e][a]=c,t.setParent(c,r),u&&t.setEdge(u,c,{weight:1})}t.exports=function(t){r.forEach(t.children(),(function e(n){var i=t.children(n),a=t.node(n);if(i.length&&r.forEach(i,e),r.has(a,"minRank")){a.borderLeft=[],a.borderRight=[];for(var s=a.minRank,u=a.maxRank+1;s<u;++s)o(t,"borderLeft","_bl",n,a,s),o(t,"borderRight","_br",n,a,s)}}))}},function(t,e,n){"use strict";var r=n(4);function i(t){r.forEach(t.nodes(),(function(e){o(t.node(e))})),r.forEach(t.edges(),(function(e){o(t.edge(e))}))}function o(t){var e=t.width;t.width=t.height,t.height=e}function a(t){t.y=-t.y}function s(t){var e=t.x;t.x=t.y,t.y=e}t.exports={adjust:function(t){var e=t.graph().rankdir.toLowerCase();"lr"!==e&&"rl"!==e||i(t)},undo:function(t){var e=t.graph().rankdir.toLowerCase();"bt"!==e&&"rl"!==e||function(t){r.forEach(t.nodes(),(function(e){a(t.node(e))})),r.forEach(t.edges(),(function(e){var n=t.edge(e);r.forEach(n.points,a),r.has(n,"y")&&a(n)}))}(t);"lr"!==e&&"rl"!==e||(!function(t){r.forEach(t.nodes(),(function(e){s(t.node(e))})),r.forEach(t.edges(),(function(e){var n=t.edge(e);r.forEach(n.points,s),r.has(n,"x")&&s(n)}))}(t),i(t))}}},function(t,e,n){"use strict";var r=n(4),i=n(391),o=n(392),a=n(393),s=n(397),u=n(398),c=n(19).Graph,f=n(10);function l(t,e,n){return r.map(e,(function(e){return s(t,e,n)}))}function h(t,e){var n=new c;r.forEach(t,(function(t){var i=t.graph().root,o=a(t,i,n,e);r.forEach(o.vs,(function(e,n){t.node(e).order=n})),u(t,n,o.vs)}))}function d(t,e){r.forEach(e,(function(e){r.forEach(e,(function(e,n){t.node(e).order=n}))}))}t.exports=function(t){var e=f.maxRank(t),n=l(t,r.range(1,e+1),"inEdges"),a=l(t,r.range(e-1,-1,-1),"outEdges"),s=i(t);d(t,s);for(var u,c=Number.POSITIVE_INFINITY,p=0,g=0;g<4;++p,++g){h(p%2?n:a,p%4>=2),s=f.buildLayerMatrix(t);var y=o(t,s);y<c&&(g=0,u=r.cloneDeep(s),c=y)}d(t,u)}},function(t,e,n){"use strict";var r=n(4);t.exports=function(t){var e={},n=r.filter(t.nodes(),(function(e){return!t.children(e).length})),i=r.max(r.map(n,(function(e){return t.node(e).rank}))),o=r.map(r.range(i+1),(function(){return[]}));var a=r.sortBy(n,(function(e){return t.node(e).rank}));return r.forEach(a,(function n(i){if(r.has(e,i))return;e[i]=!0;var a=t.node(i);o[a.rank].push(i);r.forEach(t.successors(i),n)})),o}},function(t,e,n){"use strict";var r=n(4);function i(t,e,n){for(var i=r.zipObject(n,r.map(n,(function(t,e){return e}))),o=r.flatten(r.map(e,(function(e){return r.sortBy(r.map(t.outEdges(e),(function(e){return{pos:i[e.w],weight:t.edge(e).weight}})),"pos")})),!0),a=1;a<n.length;)a<<=1;var s=2*a-1;a-=1;var u=r.map(new Array(s),(function(){return 0})),c=0;return r.forEach(o.forEach((function(t){var e=t.pos+a;u[e]+=t.weight;for(var n=0;e>0;)e%2&&(n+=u[e+1]),u[e=e-1>>1]+=t.weight;c+=t.weight*n}))),c}t.exports=function(t,e){for(var n=0,r=1;r<e.length;++r)n+=i(t,e[r-1],e[r]);return n}},function(t,e,n){var r=n(4),i=n(394),o=n(395),a=n(396);t.exports=function t(e,n,s,u){var c=e.children(n),f=e.node(n),l=f?f.borderLeft:void 0,h=f?f.borderRight:void 0,d={};l&&(c=r.filter(c,(function(t){return t!==l&&t!==h})));var p=i(e,c);r.forEach(p,(function(n){if(e.children(n.v).length){var i=t(e,n.v,s,u);d[n.v]=i,r.has(i,"barycenter")&&(o=n,a=i,r.isUndefined(o.barycenter)?(o.barycenter=a.barycenter,o.weight=a.weight):(o.barycenter=(o.barycenter*o.weight+a.barycenter*a.weight)/(o.weight+a.weight),o.weight+=a.weight))}var o,a}));var g=o(p,s);!function(t,e){r.forEach(t,(function(t){t.vs=r.flatten(t.vs.map((function(t){return e[t]?e[t].vs:t})),!0)}))}(g,d);var y=a(g,u);if(l&&(y.vs=r.flatten([l,y.vs,h],!0),e.predecessors(l).length)){var b=e.node(e.predecessors(l)[0]),m=e.node(e.predecessors(h)[0]);r.has(y,"barycenter")||(y.barycenter=0,y.weight=0),y.barycenter=(y.barycenter*y.weight+b.order+m.order)/(y.weight+2),y.weight+=2}return y}},function(t,e,n){var r=n(4);t.exports=function(t,e){return r.map(e,(function(e){var n=t.inEdges(e);if(n.length){var i=r.reduce(n,(function(e,n){var r=t.edge(n),i=t.node(n.v);return{sum:e.sum+r.weight*i.order,weight:e.weight+r.weight}}),{sum:0,weight:0});return{v:e,barycenter:i.sum/i.weight,weight:i.weight}}return{v:e}}))}},function(t,e,n){"use strict";var r=n(4);t.exports=function(t,e){var n={};return r.forEach(t,(function(t,e){var i=n[t.v]={indegree:0,in:[],out:[],vs:[t.v],i:e};r.isUndefined(t.barycenter)||(i.barycenter=t.barycenter,i.weight=t.weight)})),r.forEach(e.edges(),(function(t){var e=n[t.v],i=n[t.w];r.isUndefined(e)||r.isUndefined(i)||(i.indegree++,e.out.push(n[t.w]))})),function(t){var e=[];function n(t){return function(e){e.merged||(r.isUndefined(e.barycenter)||r.isUndefined(t.barycenter)||e.barycenter>=t.barycenter)&&function(t,e){var n=0,r=0;t.weight&&(n+=t.barycenter*t.weight,r+=t.weight);e.weight&&(n+=e.barycenter*e.weight,r+=e.weight);t.vs=e.vs.concat(t.vs),t.barycenter=n/r,t.weight=r,t.i=Math.min(e.i,t.i),e.merged=!0}(t,e)}}function i(e){return function(n){n.in.push(e),0==--n.indegree&&t.push(n)}}for(;t.length;){var o=t.pop();e.push(o),r.forEach(o.in.reverse(),n(o)),r.forEach(o.out,i(o))}return r.map(r.filter(e,(function(t){return!t.merged})),(function(t){return r.pick(t,["vs","i","barycenter","weight"])}))}(r.filter(n,(function(t){return!t.indegree})))}},function(t,e,n){var r=n(4),i=n(10);function o(t,e,n){for(var i;e.length&&(i=r.last(e)).i<=n;)e.pop(),t.push(i.vs),n++;return n}t.exports=function(t,e){var n=i.partition(t,(function(t){return r.has(t,"barycenter")})),a=n.lhs,s=r.sortBy(n.rhs,(function(t){return-t.i})),u=[],c=0,f=0,l=0;a.sort((h=!!e,function(t,e){return t.barycenter<e.barycenter?-1:t.barycenter>e.barycenter?1:h?e.i-t.i:t.i-e.i})),l=o(u,s,l),r.forEach(a,(function(t){l+=t.vs.length,u.push(t.vs),c+=t.barycenter*t.weight,f+=t.weight,l=o(u,s,l)}));var h;var d={vs:r.flatten(u,!0)};f&&(d.barycenter=c/f,d.weight=f);return d}},function(t,e,n){var r=n(4),i=n(19).Graph;t.exports=function(t,e,n){var o=function(t){var e;for(;t.hasNode(e=r.uniqueId("_root")););return e}(t),a=new i({compound:!0}).setGraph({root:o}).setDefaultNodeLabel((function(e){return t.node(e)}));return r.forEach(t.nodes(),(function(i){var s=t.node(i),u=t.parent(i);(s.rank===e||s.minRank<=e&&e<=s.maxRank)&&(a.setNode(i),a.setParent(i,u||o),r.forEach(t[n](i),(function(e){var n=e.v===i?e.w:e.v,o=a.edge(n,i),s=r.isUndefined(o)?0:o.weight;a.setEdge(n,i,{weight:t.edge(e).weight+s})})),r.has(s,"minRank")&&a.setNode(i,{borderLeft:s.borderLeft[e],borderRight:s.borderRight[e]}))})),a}},function(t,e,n){var r=n(4);t.exports=function(t,e,n){var i,o={};r.forEach(n,(function(n){for(var r,a,s=t.parent(n);s;){if((r=t.parent(s))?(a=o[r],o[r]=s):(a=i,i=s),a&&a!==s)return void e.setEdge(a,s);s=r}}))}},function(t,e,n){"use strict";var r=n(4),i=n(10),o=n(400).positionX;t.exports=function(t){(function(t){var e=i.buildLayerMatrix(t),n=t.graph().ranksep,o=0;r.forEach(e,(function(e){var i=r.max(r.map(e,(function(e){return t.node(e).height})));r.forEach(e,(function(e){t.node(e).y=o+i/2})),o+=i+n}))})(t=i.asNonCompoundGraph(t)),r.forEach(o(t),(function(e,n){t.node(n).x=e}))}},function(t,e,n){"use strict";var r=n(4),i=n(19).Graph,o=n(10);function a(t,e){var n={};return r.reduce(e,(function(e,i){var o=0,a=0,s=e.length,c=r.last(i);return r.forEach(i,(function(e,f){var l=function(t,e){if(t.node(e).dummy)return r.find(t.predecessors(e),(function(e){return t.node(e).dummy}))}(t,e),h=l?t.node(l).order:s;(l||e===c)&&(r.forEach(i.slice(a,f+1),(function(e){r.forEach(t.predecessors(e),(function(r){var i=t.node(r),a=i.order;!(a<o||h<a)||i.dummy&&t.node(e).dummy||u(n,r,e)}))})),a=f+1,o=h)})),i})),n}function s(t,e){var n={};function i(e,i,o,a,s){var c;r.forEach(r.range(i,o),(function(i){c=e[i],t.node(c).dummy&&r.forEach(t.predecessors(c),(function(e){var r=t.node(e);r.dummy&&(r.order<a||r.order>s)&&u(n,e,c)}))}))}return r.reduce(e,(function(e,n){var o,a=-1,s=0;return r.forEach(n,(function(r,u){if("border"===t.node(r).dummy){var c=t.predecessors(r);c.length&&(o=t.node(c[0]).order,i(n,s,u,a,o),s=u,a=o)}i(n,s,n.length,o,e.length)})),n})),n}function u(t,e,n){if(e>n){var r=e;e=n,n=r}var i=t[e];i||(t[e]=i={}),i[n]=!0}function c(t,e,n){if(e>n){var i=e;e=n,n=i}return r.has(t[e],n)}function f(t,e,n,i){var o={},a={},s={};return r.forEach(e,(function(t){r.forEach(t,(function(t,e){o[t]=t,a[t]=t,s[t]=e}))})),r.forEach(e,(function(t){var e=-1;r.forEach(t,(function(t){var u=i(t);if(u.length)for(var f=((u=r.sortBy(u,(function(t){return s[t]}))).length-1)/2,l=Math.floor(f),h=Math.ceil(f);l<=h;++l){var d=u[l];a[t]===t&&e<s[d]&&!c(n,t,d)&&(a[d]=t,a[t]=o[t]=o[d],e=s[d])}}))})),{root:o,align:a}}function l(t,e,n,o,a){var s={},u=function(t,e,n,o){var a=new i,s=t.graph(),u=function(t,e,n){return function(i,o,a){var s,u=i.node(o),c=i.node(a),f=0;if(f+=u.width/2,r.has(u,"labelpos"))switch(u.labelpos.toLowerCase()){case"l":s=-u.width/2;break;case"r":s=u.width/2}if(s&&(f+=n?s:-s),s=0,f+=(u.dummy?e:t)/2,f+=(c.dummy?e:t)/2,f+=c.width/2,r.has(c,"labelpos"))switch(c.labelpos.toLowerCase()){case"l":s=c.width/2;break;case"r":s=-c.width/2}return s&&(f+=n?s:-s),s=0,f}}(s.nodesep,s.edgesep,o);return r.forEach(e,(function(e){var i;r.forEach(e,(function(e){var r=n[e];if(a.setNode(r),i){var o=n[i],s=a.edge(o,r);a.setEdge(o,r,Math.max(u(t,e,i),s||0))}i=e}))})),a}(t,e,n,a),c=a?"borderLeft":"borderRight";function f(t,e){for(var n=u.nodes(),r=n.pop(),i={};r;)i[r]?t(r):(i[r]=!0,n.push(r),n=n.concat(e(r))),r=n.pop()}return f((function(t){s[t]=u.inEdges(t).reduce((function(t,e){return Math.max(t,s[e.v]+u.edge(e))}),0)}),u.predecessors.bind(u)),f((function(e){var n=u.outEdges(e).reduce((function(t,e){return Math.min(t,s[e.w]-u.edge(e))}),Number.POSITIVE_INFINITY),r=t.node(e);n!==Number.POSITIVE_INFINITY&&r.borderType!==c&&(s[e]=Math.max(s[e],n))}),u.successors.bind(u)),r.forEach(o,(function(t){s[t]=s[n[t]]})),s}function h(t,e){return r.minBy(r.values(e),(function(e){var n=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY;return r.forIn(e,(function(e,r){var o=function(t,e){return t.node(e).width}(t,r)/2;n=Math.max(e+o,n),i=Math.min(e-o,i)})),n-i}))}function d(t,e){var n=r.values(e),i=r.min(n),o=r.max(n);r.forEach(["u","d"],(function(n){r.forEach(["l","r"],(function(a){var s,u=n+a,c=t[u];if(c!==e){var f=r.values(c);(s="l"===a?i-r.min(f):o-r.max(f))&&(t[u]=r.mapValues(c,(function(t){return t+s})))}}))}))}function p(t,e){return r.mapValues(t.ul,(function(n,i){if(e)return t[e.toLowerCase()][i];var o=r.sortBy(r.map(t,i));return(o[1]+o[2])/2}))}t.exports={positionX:function(t){var e,n=o.buildLayerMatrix(t),i=r.merge(a(t,n),s(t,n)),u={};r.forEach(["u","d"],(function(o){e="u"===o?n:r.values(n).reverse(),r.forEach(["l","r"],(function(n){"r"===n&&(e=r.map(e,(function(t){return r.values(t).reverse()})));var a=("u"===o?t.predecessors:t.successors).bind(t),s=f(t,e,i,a),c=l(t,e,s.root,s.align,"r"===n);"r"===n&&(c=r.mapValues(c,(function(t){return-t}))),u[o+n]=c}))}));var c=h(t,u);return d(u,c),p(u,t.graph().align)},findType1Conflicts:a,findType2Conflicts:s,addConflict:u,hasConflict:c,verticalAlignment:f,horizontalCompaction:l,alignCoordinates:d,findSmallestWidthAlignment:h,balance:p}},function(t,e,n){var r=n(4),i=n(10),o=n(19).Graph;t.exports={debugOrdering:function(t){var e=i.buildLayerMatrix(t),n=new o({compound:!0,multigraph:!0}).setGraph({});return r.forEach(t.nodes(),(function(e){n.setNode(e,{label:e}),n.setParent(e,"layer"+t.node(e).rank)})),r.forEach(t.edges(),(function(t){n.setEdge(t.v,t.w,{},t.name)})),r.forEach(e,(function(t,e){var i="layer"+e;n.setNode(i,{rank:"same"}),r.reduce(t,(function(t,e){return n.setEdge(t,e,{style:"invis"}),e}))})),n}}},function(t,e){t.exports="0.8.4"},function(t,e,n){t.exports={node:n(187),circle:n(188),ellipse:n(109),polygon:n(189),rect:n(190)}},function(t,e){function n(t,e){return t*e>0}t.exports=function(t,e,r,i){var o,a,s,u,c,f,l,h,d,p,g,y,b;if(o=e.y-t.y,s=t.x-e.x,c=e.x*t.y-t.x*e.y,d=o*r.x+s*r.y+c,p=o*i.x+s*i.y+c,0!==d&&0!==p&&n(d,p))return;if(a=i.y-r.y,u=r.x-i.x,f=i.x*r.y-r.x*i.y,l=a*t.x+u*t.y+f,h=a*e.x+u*e.y+f,0!==l&&0!==h&&n(l,h))return;if(0===(g=o*u-a*s))return;return y=Math.abs(g/2),{x:(b=s*f-u*c)<0?(b-y)/g:(b+y)/g,y:(b=a*c-o*f)<0?(b-y)/g:(b+y)/g}}},function(t,e,n){var r=n(43),i=n(30),o=n(175).layout;t.exports=function(){var t=n(406),e=n(409),i=n(410),c=n(411),f=n(412),l=n(413),h=n(414),d=n(415),p=n(416),g=function(n,g){!function(t){t.nodes().forEach((function(e){var n=t.node(e);r.has(n,"label")||t.children(e).length||(n.label=e),r.has(n,"paddingX")&&r.defaults(n,{paddingLeft:n.paddingX,paddingRight:n.paddingX}),r.has(n,"paddingY")&&r.defaults(n,{paddingTop:n.paddingY,paddingBottom:n.paddingY}),r.has(n,"padding")&&r.defaults(n,{paddingLeft:n.padding,paddingRight:n.padding,paddingTop:n.padding,paddingBottom:n.padding}),r.defaults(n,a),r.each(["paddingLeft","paddingRight","paddingTop","paddingBottom"],(function(t){n[t]=Number(n[t])})),r.has(n,"width")&&(n._prevWidth=n.width),r.has(n,"height")&&(n._prevHeight=n.height)})),t.edges().forEach((function(e){var n=t.edge(e);r.has(n,"label")||(n.label=""),r.defaults(n,s)}))}(g);var y=u(n,"output"),b=u(y,"clusters"),m=u(y,"edgePaths"),v=i(u(y,"edgeLabels"),g),_=t(u(y,"nodes"),g,d);o(g),f(_,g),l(v,g),c(m,g,p);var w=e(b,g);h(w,g),function(t){r.each(t.nodes(),(function(e){var n=t.node(e);r.has(n,"_prevWidth")?n.width=n._prevWidth:delete n.width,r.has(n,"_prevHeight")?n.height=n._prevHeight:delete n.height,delete n._prevWidth,delete n._prevHeight}))}(g)};return g.createNodes=function(e){return arguments.length?(t=e,g):t},g.createClusters=function(t){return arguments.length?(e=t,g):e},g.createEdgeLabels=function(t){return arguments.length?(i=t,g):i},g.createEdgePaths=function(t){return arguments.length?(c=t,g):c},g.shapes=function(t){return arguments.length?(d=t,g):d},g.arrows=function(t){return arguments.length?(p=t,g):p},g};var a={paddingLeft:10,paddingRight:10,paddingTop:10,paddingBottom:10,rx:0,ry:0,shape:"rect"},s={arrowhead:"normal",curve:i.curveLinear};function u(t,e){var n=t.select("g."+e);return n.empty()&&(n=t.append("g").attr("class",e)),n}},function(t,e,n){"use strict";var r=n(43),i=n(110),o=n(14),a=n(30);t.exports=function(t,e,n){var s,u=e.nodes().filter((function(t){return!o.isSubgraph(e,t)})),c=t.selectAll("g.node").data(u,(function(t){return t})).classed("update",!0);c.exit().remove(),c.enter().append("g").attr("class","node").style("opacity",0),(c=t.selectAll("g.node")).each((function(t){var s=e.node(t),u=a.select(this);o.applyClass(u,s.class,(u.classed("update")?"update ":"")+"node"),u.select("g.label").remove();var c=u.append("g").attr("class","label"),f=i(c,s),l=n[s.shape],h=r.pick(f.node().getBBox(),"width","height");s.elem=this,s.id&&u.attr("id",s.id),s.labelId&&c.attr("id",s.labelId),r.has(s,"width")&&(h.width=s.width),r.has(s,"height")&&(h.height=s.height),h.width+=s.paddingLeft+s.paddingRight,h.height+=s.paddingTop+s.paddingBottom,c.attr("transform","translate("+(s.paddingLeft-s.paddingRight)/2+","+(s.paddingTop-s.paddingBottom)/2+")");var d=a.select(this);d.select(".label-container").remove();var p=l(d,h,s).classed("label-container",!0);o.applyStyle(p,s.style);var g=p.node().getBBox();s.width=g.width,s.height=g.height})),s=c.exit?c.exit():c.selectAll(null);return o.applyTransition(s,e).style("opacity",0).remove(),c}},function(t,e,n){var r=n(14);t.exports=function(t,e){for(var n=t.append("text"),i=function(t){for(var e,n="",r=!1,i=0;i<t.length;++i)if(e=t[i],r){switch(e){case"n":n+="\n";break;default:n+=e}r=!1}else"\\"===e?r=!0:n+=e;return n}(e.label).split("\n"),o=0;o<i.length;o++)n.append("tspan").attr("xml:space","preserve").attr("dy","1em").attr("x","1").text(i[o]);return r.applyStyle(n,e.labelStyle),n}},function(t,e,n){var r=n(14);t.exports=function(t,e){var n=t;return n.node().appendChild(e.label),r.applyStyle(n,e.labelStyle),n}},function(t,e,n){var r=n(14),i=n(30),o=n(110);t.exports=function(t,e){var n,a=e.nodes().filter((function(t){return r.isSubgraph(e,t)})),s=t.selectAll("g.cluster").data(a,(function(t){return t}));s.selectAll("*").remove(),s.enter().append("g").attr("class","cluster").attr("id",(function(t){return e.node(t).id})).style("opacity",0),s=t.selectAll("g.cluster"),r.applyTransition(s,e).style("opacity",1),s.each((function(t){var n=e.node(t),r=i.select(this);i.select(this).append("rect");var a=r.append("g").attr("class","label");o(a,n,n.clusterLabelPos)})),s.selectAll("rect").each((function(t){var n=e.node(t),o=i.select(this);r.applyStyle(o,n.style)})),n=s.exit?s.exit():s.selectAll(null);return r.applyTransition(n,e).style("opacity",0).remove(),s}},function(t,e,n){"use strict";var r=n(43),i=n(110),o=n(14),a=n(30);t.exports=function(t,e){var n,s=t.selectAll("g.edgeLabel").data(e.edges(),(function(t){return o.edgeToId(t)})).classed("update",!0);s.exit().remove(),s.enter().append("g").classed("edgeLabel",!0).style("opacity",0),(s=t.selectAll("g.edgeLabel")).each((function(t){var n=a.select(this);n.select(".label").remove();var o=e.edge(t),s=i(n,e.edge(t),0,0).classed("label",!0),u=s.node().getBBox();o.labelId&&s.attr("id",o.labelId),r.has(o,"width")||(o.width=u.width),r.has(o,"height")||(o.height=u.height)})),n=s.exit?s.exit():s.selectAll(null);return o.applyTransition(n,e).style("opacity",0).remove(),s}},function(t,e,n){"use strict";var r=n(43),i=n(187),o=n(14),a=n(30);function s(t,e){var n=(a.line||a.svg.line)().x((function(t){return t.x})).y((function(t){return t.y}));return(n.curve||n.interpolate)(t.curve),n(e)}t.exports=function(t,e,n){var u=t.selectAll("g.edgePath").data(e.edges(),(function(t){return o.edgeToId(t)})).classed("update",!0),c=function(t,e){var n=t.enter().append("g").attr("class","edgePath").style("opacity",0);return n.append("path").attr("class","path").attr("d",(function(t){var n=e.edge(t),i=e.node(t.v).elem;return s(n,r.range(n.points.length).map((function(){return e=(t=i).getBBox(),{x:(n=t.ownerSVGElement.getScreenCTM().inverse().multiply(t.getScreenCTM()).translate(e.width/2,e.height/2)).e,y:n.f};var t,e,n})))})),n.append("defs"),n}(u,e);!function(t,e){var n=t.exit();o.applyTransition(n,e).style("opacity",0).remove()}(u,e);var f=void 0!==u.merge?u.merge(c):u;return o.applyTransition(f,e).style("opacity",1),f.each((function(t){var n=a.select(this),r=e.edge(t);r.elem=this,r.id&&n.attr("id",r.id),o.applyClass(n,r.class,(n.classed("update")?"update ":"")+"edgePath")})),f.selectAll("path.path").each((function(t){var n=e.edge(t);n.arrowheadId=r.uniqueId("arrowhead");var u=a.select(this).attr("marker-end",(function(){return"url("+(t=location.href,e=n.arrowheadId,t.split("#")[0]+"#"+e)+")";var t,e})).style("fill","none");o.applyTransition(u,e).attr("d",(function(t){return function(t,e){var n=t.edge(e),r=t.node(e.v),o=t.node(e.w),a=n.points.slice(1,n.points.length-1);return a.unshift(i(r,a[0])),a.push(i(o,a[a.length-1])),s(n,a)}(e,t)})),o.applyStyle(u,n.style)})),f.selectAll("defs *").remove(),f.selectAll("defs").each((function(t){var r=e.edge(t);(0,n[r.arrowhead])(a.select(this),r.arrowheadId,r,"arrowhead")})),f}},function(t,e,n){"use strict";var r=n(14),i=n(30);t.exports=function(t,e){function n(t){var n=e.node(t);return"translate("+n.x+","+n.y+")"}t.filter((function(){return!i.select(this).classed("update")})).attr("transform",n),r.applyTransition(t,e).style("opacity",1).attr("transform",n)}},function(t,e,n){"use strict";var r=n(14),i=n(30),o=n(43);t.exports=function(t,e){function n(t){var n=e.edge(t);return o.has(n,"x")?"translate("+n.x+","+n.y+")":""}t.filter((function(){return!i.select(this).classed("update")})).attr("transform",n),r.applyTransition(t,e).style("opacity",1).attr("transform",n)}},function(t,e,n){"use strict";var r=n(14),i=n(30);t.exports=function(t,e){var n=t.filter((function(){return!i.select(this).classed("update")}));function o(t){var n=e.node(t);return"translate("+n.x+","+n.y+")"}n.attr("transform",o),r.applyTransition(t,e).style("opacity",1).attr("transform",o),r.applyTransition(n.selectAll("rect"),e).attr("width",(function(t){return e.node(t).width})).attr("height",(function(t){return e.node(t).height})).attr("x",(function(t){return-e.node(t).width/2})).attr("y",(function(t){return-e.node(t).height/2}))}},function(t,e,n){"use strict";var r=n(190),i=n(109),o=n(188),a=n(189);t.exports={rect:function(t,e,n){var i=t.insert("rect",":first-child").attr("rx",n.rx).attr("ry",n.ry).attr("x",-e.width/2).attr("y",-e.height/2).attr("width",e.width).attr("height",e.height);return n.intersect=function(t){return r(n,t)},i},ellipse:function(t,e,n){var r=e.width/2,o=e.height/2,a=t.insert("ellipse",":first-child").attr("x",-e.width/2).attr("y",-e.height/2).attr("rx",r).attr("ry",o);return n.intersect=function(t){return i(n,r,o,t)},a},circle:function(t,e,n){var r=Math.max(e.width,e.height)/2,i=t.insert("circle",":first-child").attr("x",-e.width/2).attr("y",-e.height/2).attr("r",r);return n.intersect=function(t){return o(n,r,t)},i},diamond:function(t,e,n){var r=e.width*Math.SQRT2/2,i=e.height*Math.SQRT2/2,o=[{x:0,y:-i},{x:-r,y:0},{x:0,y:i},{x:r,y:0}],s=t.insert("polygon",":first-child").attr("points",o.map((function(t){return t.x+","+t.y})).join(" "));return n.intersect=function(t){return a(n,o,t)},s}}},function(t,e,n){var r=n(14);function i(t,e,n,i){var o=t.append("marker").attr("id",e).attr("viewBox","0 0 10 10").attr("refX",9).attr("refY",5).attr("markerUnits","strokeWidth").attr("markerWidth",8).attr("markerHeight",6).attr("orient","auto").append("path").attr("d","M 0 0 L 10 5 L 0 10 z").style("stroke-width",1).style("stroke-dasharray","1,0");r.applyStyle(o,n[i+"Style"]),n[i+"Class"]&&o.attr("class",n[i+"Class"])}t.exports={default:i,normal:i,vee:function(t,e,n,i){var o=t.append("marker").attr("id",e).attr("viewBox","0 0 10 10").attr("refX",9).attr("refY",5).attr("markerUnits","strokeWidth").attr("markerWidth",8).attr("markerHeight",6).attr("orient","auto").append("path").attr("d","M 0 0 L 10 5 L 0 10 L 4 5 z").style("stroke-width",1).style("stroke-dasharray","1,0");r.applyStyle(o,n[i+"Style"]),n[i+"Class"]&&o.attr("class",n[i+"Class"])},undirected:function(t,e,n,i){var o=t.append("marker").attr("id",e).attr("viewBox","0 0 10 10").attr("refX",9).attr("refY",5).attr("markerUnits","strokeWidth").attr("markerWidth",8).attr("markerHeight",6).attr("orient","auto").append("path").attr("d","M 0 5 L 10 5").style("stroke-width",1).style("stroke-dasharray","1,0");r.applyStyle(o,n[i+"Style"]),n[i+"Class"]&&o.attr("class",n[i+"Class"])}}},function(t,e){t.exports="0.6.4"},function(t,e,n){"use strict";e.randomBytes=e.rng=e.pseudoRandomBytes=e.prng=n(44),e.createHash=e.Hash=n(53),e.createHmac=e.Hmac=n(199);var r=n(437),i=Object.keys(r),o=["sha1","sha224","sha256","sha384","sha512","md5","rmd160"].concat(i);e.getHashes=function(){return o};var a=n(202);e.pbkdf2=a.pbkdf2,e.pbkdf2Sync=a.pbkdf2Sync;var s=n(439);e.Cipher=s.Cipher,e.createCipher=s.createCipher,e.Cipheriv=s.Cipheriv,e.createCipheriv=s.createCipheriv,e.Decipher=s.Decipher,e.createDecipher=s.createDecipher,e.Decipheriv=s.Decipheriv,e.createDecipheriv=s.createDecipheriv,e.getCiphers=s.getCiphers,e.listCiphers=s.listCiphers;var u=n(456);e.DiffieHellmanGroup=u.DiffieHellmanGroup,e.createDiffieHellmanGroup=u.createDiffieHellmanGroup,e.getDiffieHellman=u.getDiffieHellman,e.createDiffieHellman=u.createDiffieHellman,e.DiffieHellman=u.DiffieHellman;var c=n(461);e.createSign=c.createSign,e.Sign=c.Sign,e.createVerify=c.createVerify,e.Verify=c.Verify,e.createECDH=n(495);var f=n(496);e.publicEncrypt=f.publicEncrypt,e.privateEncrypt=f.privateEncrypt,e.publicDecrypt=f.publicDecrypt,e.privateDecrypt=f.privateDecrypt;var l=n(499);e.randomFill=l.randomFill,e.randomFillSync=l.randomFillSync,e.createCredentials=function(){throw new Error(["sorry, createCredentials is not implemented yet","we accept pull requests","https://github.com/crypto-browserify/crypto-browserify"].join("\n"))},e.constants={DH_CHECK_P_NOT_SAFE_PRIME:2,DH_CHECK_P_NOT_PRIME:1,DH_UNABLE_TO_CHECK_GENERATOR:4,DH_NOT_SUITABLE_GENERATOR:8,NPN_ENABLED:1,ALPN_ENABLED:1,RSA_PKCS1_PADDING:1,RSA_SSLV23_PADDING:2,RSA_NO_PADDING:3,RSA_PKCS1_OAEP_PADDING:4,RSA_X931_PADDING:5,RSA_PKCS1_PSS_PADDING:6,POINT_CONVERSION_COMPRESSED:2,POINT_CONVERSION_UNCOMPRESSED:4,POINT_CONVERSION_HYBRID:6}},function(t,e,n){"use strict";e.byteLength=function(t){var e=c(t),n=e[0],r=e[1];return 3*(n+r)/4-r},e.toByteArray=function(t){var e,n,r=c(t),a=r[0],s=r[1],u=new o(function(t,e,n){return 3*(e+n)/4-n}(0,a,s)),f=0,l=s>0?a-4:a;for(n=0;n<l;n+=4)e=i[t.charCodeAt(n)]<<18|i[t.charCodeAt(n+1)]<<12|i[t.charCodeAt(n+2)]<<6|i[t.charCodeAt(n+3)],u[f++]=e>>16&255,u[f++]=e>>8&255,u[f++]=255&e;2===s&&(e=i[t.charCodeAt(n)]<<2|i[t.charCodeAt(n+1)]>>4,u[f++]=255&e);1===s&&(e=i[t.charCodeAt(n)]<<10|i[t.charCodeAt(n+1)]<<4|i[t.charCodeAt(n+2)]>>2,u[f++]=e>>8&255,u[f++]=255&e);return u},e.fromByteArray=function(t){for(var e,n=t.length,i=n%3,o=[],a=0,s=n-i;a<s;a+=16383)o.push(f(t,a,a+16383>s?s:a+16383));1===i?(e=t[n-1],o.push(r[e>>2]+r[e<<4&63]+"==")):2===i&&(e=(t[n-2]<<8)+t[n-1],o.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+"="));return o.join("")};for(var r=[],i=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,u=a.length;s<u;++s)r[s]=a[s],i[a.charCodeAt(s)]=s;function c(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=t.indexOf("=");return-1===n&&(n=e),[n,n===e?0:4-n%4]}function f(t,e,n){for(var i,o,a=[],s=e;s<n;s+=3)i=(t[s]<<16&16711680)+(t[s+1]<<8&65280)+(255&t[s+2]),a.push(r[(o=i)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return a.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(t,e){e.read=function(t,e,n,r,i){var o,a,s=8*i-r-1,u=(1<<s)-1,c=u>>1,f=-7,l=n?i-1:0,h=n?-1:1,d=t[e+l];for(l+=h,o=d&(1<<-f)-1,d>>=-f,f+=s;f>0;o=256*o+t[e+l],l+=h,f-=8);for(a=o&(1<<-f)-1,o>>=-f,f+=r;f>0;a=256*a+t[e+l],l+=h,f-=8);if(0===o)o=1-c;else{if(o===u)return a?NaN:1/0*(d?-1:1);a+=Math.pow(2,r),o-=c}return(d?-1:1)*a*Math.pow(2,o-r)},e.write=function(t,e,n,r,i,o){var a,s,u,c=8*o-i-1,f=(1<<c)-1,l=f>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,d=r?0:o-1,p=r?1:-1,g=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,a=f):(a=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-a))<1&&(a--,u*=2),(e+=a+l>=1?h/u:h*Math.pow(2,1-l))*u>=2&&(a++,u/=2),a+l>=f?(s=0,a=f):a+l>=1?(s=(e*u-1)*Math.pow(2,i),a+=l):(s=e*Math.pow(2,l-1)*Math.pow(2,i),a=0));i>=8;t[n+d]=255&s,d+=p,s/=256,i-=8);for(a=a<<i|s,c+=i;c>0;t[n+d]=255&a,d+=p,a/=256,c-=8);t[n+d-p]|=128*g}},function(t,e){},function(t,e,n){"use strict";var r=n(115).Buffer,i=n(423);t.exports=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.head=null,this.tail=null,this.length=0}return t.prototype.push=function(t){var e={data:t,next:null};this.length>0?this.tail.next=e:this.head=e,this.tail=e,++this.length},t.prototype.unshift=function(t){var e={data:t,next:this.head};0===this.length&&(this.tail=e),this.head=e,++this.length},t.prototype.shift=function(){if(0!==this.length){var t=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,t}},t.prototype.clear=function(){this.head=this.tail=null,this.length=0},t.prototype.join=function(t){if(0===this.length)return"";for(var e=this.head,n=""+e.data;e=e.next;)n+=t+e.data;return n},t.prototype.concat=function(t){if(0===this.length)return r.alloc(0);if(1===this.length)return this.head.data;for(var e,n,i,o=r.allocUnsafe(t>>>0),a=this.head,s=0;a;)e=a.data,n=o,i=s,e.copy(n,i),s+=a.data.length,a=a.next;return o},t}(),i&&i.inspect&&i.inspect.custom&&(t.exports.prototype[i.inspect.custom]=function(){var t=i.inspect({length:this.length});return this.constructor.name+" "+t})},function(t,e){},function(t,e,n){(function(t){var r=void 0!==t&&t||"undefined"!=typeof self&&self||window,i=Function.prototype.apply;function o(t,e){this._id=t,this._clearFn=e}e.setTimeout=function(){return new o(i.call(setTimeout,r,arguments),clearTimeout)},e.setInterval=function(){return new o(i.call(setInterval,r,arguments),clearInterval)},e.clearTimeout=e.clearInterval=function(t){t&&t.close()},o.prototype.unref=o.prototype.ref=function(){},o.prototype.close=function(){this._clearFn.call(r,this._id)},e.enroll=function(t,e){clearTimeout(t._idleTimeoutId),t._idleTimeout=e},e.unenroll=function(t){clearTimeout(t._idleTimeoutId),t._idleTimeout=-1},e._unrefActive=e.active=function(t){clearTimeout(t._idleTimeoutId);var e=t._idleTimeout;e>=0&&(t._idleTimeoutId=setTimeout((function(){t._onTimeout&&t._onTimeout()}),e))},n(425),e.setImmediate="undefined"!=typeof self&&self.setImmediate||void 0!==t&&t.setImmediate||this&&this.setImmediate,e.clearImmediate="undefined"!=typeof self&&self.clearImmediate||void 0!==t&&t.clearImmediate||this&&this.clearImmediate}).call(this,n(11))},function(t,e,n){(function(t,e){!function(t,n){"use strict";if(!t.setImmediate){var r,i,o,a,s,u=1,c={},f=!1,l=t.document,h=Object.getPrototypeOf&&Object.getPrototypeOf(t);h=h&&h.setTimeout?h:t,"[object process]"==={}.toString.call(t.process)?r=function(t){e.nextTick((function(){p(t)}))}:!function(){if(t.postMessage&&!t.importScripts){var e=!0,n=t.onmessage;return t.onmessage=function(){e=!1},t.postMessage("","*"),t.onmessage=n,e}}()?t.MessageChannel?((o=new MessageChannel).port1.onmessage=function(t){p(t.data)},r=function(t){o.port2.postMessage(t)}):l&&"onreadystatechange"in l.createElement("script")?(i=l.documentElement,r=function(t){var e=l.createElement("script");e.onreadystatechange=function(){p(t),e.onreadystatechange=null,i.removeChild(e),e=null},i.appendChild(e)}):r=function(t){setTimeout(p,0,t)}:(a="setImmediate$"+Math.random()+"$",s=function(e){e.source===t&&"string"==typeof e.data&&0===e.data.indexOf(a)&&p(+e.data.slice(a.length))},t.addEventListener?t.addEventListener("message",s,!1):t.attachEvent("onmessage",s),r=function(e){t.postMessage(a+e,"*")}),h.setImmediate=function(t){"function"!=typeof t&&(t=new Function(""+t));for(var e=new Array(arguments.length-1),n=0;n<e.length;n++)e[n]=arguments[n+1];var i={callback:t,args:e};return c[u]=i,r(u),u++},h.clearImmediate=d}function d(t){delete c[t]}function p(t){if(f)setTimeout(p,0,t);else{var e=c[t];if(e){f=!0;try{!function(t){var e=t.callback,r=t.args;switch(r.length){case 0:e();break;case 1:e(r[0]);break;case 2:e(r[0],r[1]);break;case 3:e(r[0],r[1],r[2]);break;default:e.apply(n,r)}}(e)}finally{d(t),f=!1}}}}}("undefined"==typeof self?void 0===t?this:t:self)}).call(this,n(11),n(7))},function(t,e,n){(function(e){function n(t){try{if(!e.localStorage)return!1}catch(t){return!1}var n=e.localStorage[t];return null!=n&&"true"===String(n).toLowerCase()}t.exports=function(t,e){if(n("noDeprecation"))return t;var r=!1;return function(){if(!r){if(n("throwDeprecation"))throw new Error(e);n("traceDeprecation")?console.trace(e):console.warn(e),r=!0}return t.apply(this,arguments)}}}).call(this,n(11))},function(t,e,n){"use strict";t.exports=o;var r=n(196),i=n(54);function o(t){if(!(this instanceof o))return new o(t);r.call(this,t)}i.inherits=n(2),i.inherits(o,r),o.prototype._transform=function(t,e,n){n(null,t)}},function(t,e,n){t.exports=n(116)},function(t,e,n){t.exports=n(35)},function(t,e,n){t.exports=n(114).Transform},function(t,e,n){t.exports=n(114).PassThrough},function(t,e,n){var r=n(2),i=n(45),o=n(3).Buffer,a=[1518500249,1859775393,-1894007588,-899497514],s=new Array(80);function u(){this.init(),this._w=s,i.call(this,64,56)}function c(t){return t<<30|t>>>2}function f(t,e,n,r){return 0===t?e&n|~e&r:2===t?e&n|e&r|n&r:e^n^r}r(u,i),u.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this},u.prototype._update=function(t){for(var e,n=this._w,r=0|this._a,i=0|this._b,o=0|this._c,s=0|this._d,u=0|this._e,l=0;l<16;++l)n[l]=t.readInt32BE(4*l);for(;l<80;++l)n[l]=n[l-3]^n[l-8]^n[l-14]^n[l-16];for(var h=0;h<80;++h){var d=~~(h/20),p=0|((e=r)<<5|e>>>27)+f(d,i,o,s)+u+n[h]+a[d];u=s,s=o,o=c(i),i=r,r=p}this._a=r+this._a|0,this._b=i+this._b|0,this._c=o+this._c|0,this._d=s+this._d|0,this._e=u+this._e|0},u.prototype._hash=function(){var t=o.allocUnsafe(20);return t.writeInt32BE(0|this._a,0),t.writeInt32BE(0|this._b,4),t.writeInt32BE(0|this._c,8),t.writeInt32BE(0|this._d,12),t.writeInt32BE(0|this._e,16),t},t.exports=u},function(t,e,n){var r=n(2),i=n(45),o=n(3).Buffer,a=[1518500249,1859775393,-1894007588,-899497514],s=new Array(80);function u(){this.init(),this._w=s,i.call(this,64,56)}function c(t){return t<<5|t>>>27}function f(t){return t<<30|t>>>2}function l(t,e,n,r){return 0===t?e&n|~e&r:2===t?e&n|e&r|n&r:e^n^r}r(u,i),u.prototype.init=function(){return this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520,this},u.prototype._update=function(t){for(var e,n=this._w,r=0|this._a,i=0|this._b,o=0|this._c,s=0|this._d,u=0|this._e,h=0;h<16;++h)n[h]=t.readInt32BE(4*h);for(;h<80;++h)n[h]=(e=n[h-3]^n[h-8]^n[h-14]^n[h-16])<<1|e>>>31;for(var d=0;d<80;++d){var p=~~(d/20),g=c(r)+l(p,i,o,s)+u+n[d]+a[p]|0;u=s,s=o,o=f(i),i=r,r=g}this._a=r+this._a|0,this._b=i+this._b|0,this._c=o+this._c|0,this._d=s+this._d|0,this._e=u+this._e|0},u.prototype._hash=function(){var t=o.allocUnsafe(20);return t.writeInt32BE(0|this._a,0),t.writeInt32BE(0|this._b,4),t.writeInt32BE(0|this._c,8),t.writeInt32BE(0|this._d,12),t.writeInt32BE(0|this._e,16),t},t.exports=u},function(t,e,n){var r=n(2),i=n(197),o=n(45),a=n(3).Buffer,s=new Array(64);function u(){this.init(),this._w=s,o.call(this,64,56)}r(u,i),u.prototype.init=function(){return this._a=3238371032,this._b=914150663,this._c=812702999,this._d=4144912697,this._e=4290775857,this._f=1750603025,this._g=1694076839,this._h=3204075428,this},u.prototype._hash=function(){var t=a.allocUnsafe(28);return t.writeInt32BE(this._a,0),t.writeInt32BE(this._b,4),t.writeInt32BE(this._c,8),t.writeInt32BE(this._d,12),t.writeInt32BE(this._e,16),t.writeInt32BE(this._f,20),t.writeInt32BE(this._g,24),t},t.exports=u},function(t,e,n){var r=n(2),i=n(198),o=n(45),a=n(3).Buffer,s=new Array(160);function u(){this.init(),this._w=s,o.call(this,128,112)}r(u,i),u.prototype.init=function(){return this._ah=3418070365,this._bh=1654270250,this._ch=2438529370,this._dh=355462360,this._eh=1731405415,this._fh=2394180231,this._gh=3675008525,this._hh=1203062813,this._al=3238371032,this._bl=914150663,this._cl=812702999,this._dl=4144912697,this._el=4290775857,this._fl=1750603025,this._gl=1694076839,this._hl=3204075428,this},u.prototype._hash=function(){var t=a.allocUnsafe(48);function e(e,n,r){t.writeInt32BE(e,r),t.writeInt32BE(n,r+4)}return e(this._ah,this._al,0),e(this._bh,this._bl,8),e(this._ch,this._cl,16),e(this._dh,this._dl,24),e(this._eh,this._el,32),e(this._fh,this._fl,40),t},t.exports=u},function(t,e,n){"use strict";var r=n(2),i=n(3).Buffer,o=n(31),a=i.alloc(128),s=64;function u(t,e){o.call(this,"digest"),"string"==typeof e&&(e=i.from(e)),this._alg=t,this._key=e,e.length>s?e=t(e):e.length<s&&(e=i.concat([e,a],s));for(var n=this._ipad=i.allocUnsafe(s),r=this._opad=i.allocUnsafe(s),u=0;u<s;u++)n[u]=54^e[u],r[u]=92^e[u];this._hash=[n]}r(u,o),u.prototype._update=function(t){this._hash.push(t)},u.prototype._final=function(){var t=this._alg(i.concat(this._hash));return this._alg(i.concat([this._opad,t]))},t.exports=u},function(t,e,n){t.exports=n(201)},function(t,e,n){(function(e,r){var i,o=n(203),a=n(204),s=n(205),u=n(3).Buffer,c=e.crypto&&e.crypto.subtle,f={sha:"SHA-1","sha-1":"SHA-1",sha1:"SHA-1",sha256:"SHA-256","sha-256":"SHA-256",sha384:"SHA-384","sha-384":"SHA-384","sha-512":"SHA-512",sha512:"SHA-512"},l=[];function h(t,e,n,r,i){return c.importKey("raw",t,{name:"PBKDF2"},!1,["deriveBits"]).then((function(t){return c.deriveBits({name:"PBKDF2",salt:e,iterations:n,hash:{name:i}},t,r<<3)})).then((function(t){return u.from(t)}))}t.exports=function(t,n,d,p,g,y){"function"==typeof g&&(y=g,g=void 0);var b=f[(g=g||"sha1").toLowerCase()];if(!b||"function"!=typeof e.Promise)return r.nextTick((function(){var e;try{e=s(t,n,d,p,g)}catch(t){return y(t)}y(null,e)}));if(o(t,n,d,p),"function"!=typeof y)throw new Error("No callback provided to pbkdf2");u.isBuffer(t)||(t=u.from(t,a)),u.isBuffer(n)||(n=u.from(n,a)),function(t,e){t.then((function(t){r.nextTick((function(){e(null,t)}))}),(function(t){r.nextTick((function(){e(t)}))}))}(function(t){if(e.process&&!e.process.browser)return Promise.resolve(!1);if(!c||!c.importKey||!c.deriveBits)return Promise.resolve(!1);if(void 0!==l[t])return l[t];var n=h(i=i||u.alloc(8),i,10,128,t).then((function(){return!0})).catch((function(){return!1}));return l[t]=n,n}(b).then((function(e){return e?h(t,n,d,p,b):s(t,n,d,p,g)})),y)}}).call(this,n(11),n(7))},function(t,e,n){var r=n(440),i=n(121),o=n(122),a=n(455),s=n(80);function u(t,e,n){if(t=t.toLowerCase(),o[t])return i.createCipheriv(t,e,n);if(a[t])return new r({key:e,iv:n,mode:t});throw new TypeError("invalid suite type")}function c(t,e,n){if(t=t.toLowerCase(),o[t])return i.createDecipheriv(t,e,n);if(a[t])return new r({key:e,iv:n,mode:t,decrypt:!0});throw new TypeError("invalid suite type")}e.createCipher=e.Cipher=function(t,e){var n,r;if(t=t.toLowerCase(),o[t])n=o[t].key,r=o[t].iv;else{if(!a[t])throw new TypeError("invalid suite type");n=8*a[t].key,r=a[t].iv}var i=s(e,!1,n,r);return u(t,i.key,i.iv)},e.createCipheriv=e.Cipheriv=u,e.createDecipher=e.Decipher=function(t,e){var n,r;if(t=t.toLowerCase(),o[t])n=o[t].key,r=o[t].iv;else{if(!a[t])throw new TypeError("invalid suite type");n=8*a[t].key,r=a[t].iv}var i=s(e,!1,n,r);return c(t,i.key,i.iv)},e.createDecipheriv=e.Decipheriv=c,e.listCiphers=e.getCiphers=function(){return Object.keys(a).concat(i.getCiphers())}},function(t,e,n){var r=n(31),i=n(120),o=n(2),a=n(3).Buffer,s={"des-ede3-cbc":i.CBC.instantiate(i.EDE),"des-ede3":i.EDE,"des-ede-cbc":i.CBC.instantiate(i.EDE),"des-ede":i.EDE,"des-cbc":i.CBC.instantiate(i.DES),"des-ecb":i.DES};function u(t){r.call(this);var e,n=t.mode.toLowerCase(),i=s[n];e=t.decrypt?"decrypt":"encrypt";var o=t.key;a.isBuffer(o)||(o=a.from(o)),"des-ede"!==n&&"des-ede-cbc"!==n||(o=a.concat([o,o.slice(0,8)]));var u=t.iv;a.isBuffer(u)||(u=a.from(u)),this._des=i.create({key:o,iv:u,type:e})}s.des=s["des-cbc"],s.des3=s["des-ede3-cbc"],t.exports=u,o(u,r),u.prototype._update=function(t){return a.from(this._des.update(t))},u.prototype._final=function(){return a.from(this._des.final())}},function(t,e,n){"use strict";e.readUInt32BE=function(t,e){return(t[0+e]<<24|t[1+e]<<16|t[2+e]<<8|t[3+e])>>>0},e.writeUInt32BE=function(t,e,n){t[0+n]=e>>>24,t[1+n]=e>>>16&255,t[2+n]=e>>>8&255,t[3+n]=255&e},e.ip=function(t,e,n,r){for(var i=0,o=0,a=6;a>=0;a-=2){for(var s=0;s<=24;s+=8)i<<=1,i|=e>>>s+a&1;for(s=0;s<=24;s+=8)i<<=1,i|=t>>>s+a&1}for(a=6;a>=0;a-=2){for(s=1;s<=25;s+=8)o<<=1,o|=e>>>s+a&1;for(s=1;s<=25;s+=8)o<<=1,o|=t>>>s+a&1}n[r+0]=i>>>0,n[r+1]=o>>>0},e.rip=function(t,e,n,r){for(var i=0,o=0,a=0;a<4;a++)for(var s=24;s>=0;s-=8)i<<=1,i|=e>>>s+a&1,i<<=1,i|=t>>>s+a&1;for(a=4;a<8;a++)for(s=24;s>=0;s-=8)o<<=1,o|=e>>>s+a&1,o<<=1,o|=t>>>s+a&1;n[r+0]=i>>>0,n[r+1]=o>>>0},e.pc1=function(t,e,n,r){for(var i=0,o=0,a=7;a>=5;a--){for(var s=0;s<=24;s+=8)i<<=1,i|=e>>s+a&1;for(s=0;s<=24;s+=8)i<<=1,i|=t>>s+a&1}for(s=0;s<=24;s+=8)i<<=1,i|=e>>s+a&1;for(a=1;a<=3;a++){for(s=0;s<=24;s+=8)o<<=1,o|=e>>s+a&1;for(s=0;s<=24;s+=8)o<<=1,o|=t>>s+a&1}for(s=0;s<=24;s+=8)o<<=1,o|=t>>s+a&1;n[r+0]=i>>>0,n[r+1]=o>>>0},e.r28shl=function(t,e){return t<<e&268435455|t>>>28-e};var r=[14,11,17,4,27,23,25,0,13,22,7,18,5,9,16,24,2,20,12,21,1,8,15,26,15,4,25,19,9,1,26,16,5,11,23,8,12,7,17,0,22,3,10,14,6,20,27,24];e.pc2=function(t,e,n,i){for(var o=0,a=0,s=r.length>>>1,u=0;u<s;u++)o<<=1,o|=t>>>r[u]&1;for(u=s;u<r.length;u++)a<<=1,a|=e>>>r[u]&1;n[i+0]=o>>>0,n[i+1]=a>>>0},e.expand=function(t,e,n){var r=0,i=0;r=(1&t)<<5|t>>>27;for(var o=23;o>=15;o-=4)r<<=6,r|=t>>>o&63;for(o=11;o>=3;o-=4)i|=t>>>o&63,i<<=6;i|=(31&t)<<1|t>>>31,e[n+0]=r>>>0,e[n+1]=i>>>0};var i=[14,0,4,15,13,7,1,4,2,14,15,2,11,13,8,1,3,10,10,6,6,12,12,11,5,9,9,5,0,3,7,8,4,15,1,12,14,8,8,2,13,4,6,9,2,1,11,7,15,5,12,11,9,3,7,14,3,10,10,0,5,6,0,13,15,3,1,13,8,4,14,7,6,15,11,2,3,8,4,14,9,12,7,0,2,1,13,10,12,6,0,9,5,11,10,5,0,13,14,8,7,10,11,1,10,3,4,15,13,4,1,2,5,11,8,6,12,7,6,12,9,0,3,5,2,14,15,9,10,13,0,7,9,0,14,9,6,3,3,4,15,6,5,10,1,2,13,8,12,5,7,14,11,12,4,11,2,15,8,1,13,1,6,10,4,13,9,0,8,6,15,9,3,8,0,7,11,4,1,15,2,14,12,3,5,11,10,5,14,2,7,12,7,13,13,8,14,11,3,5,0,6,6,15,9,0,10,3,1,4,2,7,8,2,5,12,11,1,12,10,4,14,15,9,10,3,6,15,9,0,0,6,12,10,11,1,7,13,13,8,15,9,1,4,3,5,14,11,5,12,2,7,8,2,4,14,2,14,12,11,4,2,1,12,7,4,10,7,11,13,6,1,8,5,5,0,3,15,15,10,13,3,0,9,14,8,9,6,4,11,2,8,1,12,11,7,10,1,13,14,7,2,8,13,15,6,9,15,12,0,5,9,6,10,3,4,0,5,14,3,12,10,1,15,10,4,15,2,9,7,2,12,6,9,8,5,0,6,13,1,3,13,4,14,14,0,7,11,5,3,11,8,9,4,14,3,15,2,5,12,2,9,8,5,12,15,3,10,7,11,0,14,4,1,10,7,1,6,13,0,11,8,6,13,4,13,11,0,2,11,14,7,15,4,0,9,8,1,13,10,3,14,12,3,9,5,7,12,5,2,10,15,6,8,1,6,1,6,4,11,11,13,13,8,12,1,3,4,7,10,14,7,10,9,15,5,6,0,8,15,0,14,5,2,9,3,2,12,13,1,2,15,8,13,4,8,6,10,15,3,11,7,1,4,10,12,9,5,3,6,14,11,5,0,0,14,12,9,7,2,7,2,11,1,4,14,1,7,9,4,12,10,14,8,2,13,0,15,6,12,10,9,13,0,15,3,3,5,5,6,8,11];e.substitute=function(t,e){for(var n=0,r=0;r<4;r++){n<<=4,n|=i[64*r+(t>>>18-6*r&63)]}for(r=0;r<4;r++){n<<=4,n|=i[256+64*r+(e>>>18-6*r&63)]}return n>>>0};var o=[16,25,12,11,3,20,4,15,31,17,9,6,27,14,1,22,30,24,8,18,0,5,29,23,13,19,2,26,10,21,28,7];e.permute=function(t){for(var e=0,n=0;n<o.length;n++)e<<=1,e|=t>>>o[n]&1;return e>>>0},e.padSplit=function(t,e,n){for(var r=t.toString(2);r.length<e;)r="0"+r;for(var i=[],o=0;o<e;o+=n)i.push(r.slice(o,o+n));return i.join(" ")}},function(t,e,n){"use strict";var r=n(15);function i(t){this.options=t,this.type=this.options.type,this.blockSize=8,this._init(),this.buffer=new Array(this.blockSize),this.bufferOff=0}t.exports=i,i.prototype._init=function(){},i.prototype.update=function(t){return 0===t.length?[]:"decrypt"===this.type?this._updateDecrypt(t):this._updateEncrypt(t)},i.prototype._buffer=function(t,e){for(var n=Math.min(this.buffer.length-this.bufferOff,t.length-e),r=0;r<n;r++)this.buffer[this.bufferOff+r]=t[e+r];return this.bufferOff+=n,n},i.prototype._flushBuffer=function(t,e){return this._update(this.buffer,0,t,e),this.bufferOff=0,this.blockSize},i.prototype._updateEncrypt=function(t){var e=0,n=0,r=(this.bufferOff+t.length)/this.blockSize|0,i=new Array(r*this.blockSize);0!==this.bufferOff&&(e+=this._buffer(t,e),this.bufferOff===this.buffer.length&&(n+=this._flushBuffer(i,n)));for(var o=t.length-(t.length-e)%this.blockSize;e<o;e+=this.blockSize)this._update(t,e,i,n),n+=this.blockSize;for(;e<t.length;e++,this.bufferOff++)this.buffer[this.bufferOff]=t[e];return i},i.prototype._updateDecrypt=function(t){for(var e=0,n=0,r=Math.ceil((this.bufferOff+t.length)/this.blockSize)-1,i=new Array(r*this.blockSize);r>0;r--)e+=this._buffer(t,e),n+=this._flushBuffer(i,n);return e+=this._buffer(t,e),i},i.prototype.final=function(t){var e,n;return t&&(e=this.update(t)),n="encrypt"===this.type?this._finalEncrypt():this._finalDecrypt(),e?e.concat(n):n},i.prototype._pad=function(t,e){if(0===e)return!1;for(;e<t.length;)t[e++]=0;return!0},i.prototype._finalEncrypt=function(){if(!this._pad(this.buffer,this.bufferOff))return[];var t=new Array(this.blockSize);return this._update(this.buffer,0,t,0),t},i.prototype._unpad=function(t){return t},i.prototype._finalDecrypt=function(){r.equal(this.bufferOff,this.blockSize,"Not enough data to decrypt");var t=new Array(this.blockSize);return this._flushBuffer(t,0),this._unpad(t)}},function(t,e,n){"use strict";var r=n(15),i=n(2),o=n(120),a=o.utils,s=o.Cipher;function u(){this.tmp=new Array(2),this.keys=null}function c(t){s.call(this,t);var e=new u;this._desState=e,this.deriveKeys(e,t.key)}i(c,s),t.exports=c,c.create=function(t){return new c(t)};var f=[1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1];c.prototype.deriveKeys=function(t,e){t.keys=new Array(32),r.equal(e.length,this.blockSize,"Invalid key length");var n=a.readUInt32BE(e,0),i=a.readUInt32BE(e,4);a.pc1(n,i,t.tmp,0),n=t.tmp[0],i=t.tmp[1];for(var o=0;o<t.keys.length;o+=2){var s=f[o>>>1];n=a.r28shl(n,s),i=a.r28shl(i,s),a.pc2(n,i,t.keys,o)}},c.prototype._update=function(t,e,n,r){var i=this._desState,o=a.readUInt32BE(t,e),s=a.readUInt32BE(t,e+4);a.ip(o,s,i.tmp,0),o=i.tmp[0],s=i.tmp[1],"encrypt"===this.type?this._encrypt(i,o,s,i.tmp,0):this._decrypt(i,o,s,i.tmp,0),o=i.tmp[0],s=i.tmp[1],a.writeUInt32BE(n,o,r),a.writeUInt32BE(n,s,r+4)},c.prototype._pad=function(t,e){for(var n=t.length-e,r=e;r<t.length;r++)t[r]=n;return!0},c.prototype._unpad=function(t){for(var e=t[t.length-1],n=t.length-e;n<t.length;n++)r.equal(t[n],e);return t.slice(0,t.length-e)},c.prototype._encrypt=function(t,e,n,r,i){for(var o=e,s=n,u=0;u<t.keys.length;u+=2){var c=t.keys[u],f=t.keys[u+1];a.expand(s,t.tmp,0),c^=t.tmp[0],f^=t.tmp[1];var l=a.substitute(c,f),h=s;s=(o^a.permute(l))>>>0,o=h}a.rip(s,o,r,i)},c.prototype._decrypt=function(t,e,n,r,i){for(var o=n,s=e,u=t.keys.length-2;u>=0;u-=2){var c=t.keys[u],f=t.keys[u+1];a.expand(o,t.tmp,0),c^=t.tmp[0],f^=t.tmp[1];var l=a.substitute(c,f),h=o;o=(s^a.permute(l))>>>0,s=h}a.rip(o,s,r,i)}},function(t,e,n){"use strict";var r=n(15),i=n(2),o={};function a(t){r.equal(t.length,8,"Invalid IV length"),this.iv=new Array(8);for(var e=0;e<this.iv.length;e++)this.iv[e]=t[e]}e.instantiate=function(t){function e(e){t.call(this,e),this._cbcInit()}i(e,t);for(var n=Object.keys(o),r=0;r<n.length;r++){var a=n[r];e.prototype[a]=o[a]}return e.create=function(t){return new e(t)},e},o._cbcInit=function(){var t=new a(this.options.iv);this._cbcState=t},o._update=function(t,e,n,r){var i=this._cbcState,o=this.constructor.super_.prototype,a=i.iv;if("encrypt"===this.type){for(var s=0;s<this.blockSize;s++)a[s]^=t[e+s];o._update.call(this,a,0,n,r);for(s=0;s<this.blockSize;s++)a[s]=n[r+s]}else{o._update.call(this,t,e,n,r);for(s=0;s<this.blockSize;s++)n[r+s]^=a[s];for(s=0;s<this.blockSize;s++)a[s]=t[e+s]}}},function(t,e,n){"use strict";var r=n(15),i=n(2),o=n(120),a=o.Cipher,s=o.DES;function u(t,e){r.equal(e.length,24,"Invalid key length");var n=e.slice(0,8),i=e.slice(8,16),o=e.slice(16,24);this.ciphers="encrypt"===t?[s.create({type:"encrypt",key:n}),s.create({type:"decrypt",key:i}),s.create({type:"encrypt",key:o})]:[s.create({type:"decrypt",key:o}),s.create({type:"encrypt",key:i}),s.create({type:"decrypt",key:n})]}function c(t){a.call(this,t);var e=new u(this.type,this.options.key);this._edeState=e}i(c,a),t.exports=c,c.create=function(t){return new c(t)},c.prototype._update=function(t,e,n,r){var i=this._edeState;i.ciphers[0]._update(t,e,n,r),i.ciphers[1]._update(n,r,n,r),i.ciphers[2]._update(n,r,n,r)},c.prototype._pad=s.prototype._pad,c.prototype._unpad=s.prototype._unpad},function(t,e,n){var r=n(122),i=n(209),o=n(3).Buffer,a=n(210),s=n(31),u=n(79),c=n(80);function f(t,e,n){s.call(this),this._cache=new h,this._cipher=new u.AES(e),this._prev=o.from(n),this._mode=t,this._autopadding=!0}n(2)(f,s),f.prototype._update=function(t){var e,n;this._cache.add(t);for(var r=[];e=this._cache.get();)n=this._mode.encrypt(this,e),r.push(n);return o.concat(r)};var l=o.alloc(16,16);function h(){this.cache=o.allocUnsafe(0)}function d(t,e,n){var s=r[t.toLowerCase()];if(!s)throw new TypeError("invalid suite type");if("string"==typeof e&&(e=o.from(e)),e.length!==s.key/8)throw new TypeError("invalid key length "+e.length);if("string"==typeof n&&(n=o.from(n)),"GCM"!==s.mode&&n.length!==s.iv)throw new TypeError("invalid iv length "+n.length);return"stream"===s.type?new a(s.module,e,n):"auth"===s.type?new i(s.module,e,n):new f(s.module,e,n)}f.prototype._final=function(){var t=this._cache.flush();if(this._autopadding)return t=this._mode.encrypt(this,t),this._cipher.scrub(),t;if(!t.equals(l))throw this._cipher.scrub(),new Error("data not multiple of block length")},f.prototype.setAutoPadding=function(t){return this._autopadding=!!t,this},h.prototype.add=function(t){this.cache=o.concat([this.cache,t])},h.prototype.get=function(){if(this.cache.length>15){var t=this.cache.slice(0,16);return this.cache=this.cache.slice(16),t}return null},h.prototype.flush=function(){for(var t=16-this.cache.length,e=o.allocUnsafe(t),n=-1;++n<t;)e.writeUInt8(t,n);return o.concat([this.cache,e])},e.createCipheriv=d,e.createCipher=function(t,e){var n=r[t.toLowerCase()];if(!n)throw new TypeError("invalid suite type");var i=c(e,!1,n.key,n.iv);return d(t,i.key,i.iv)}},function(t,e){e.encrypt=function(t,e){return t._cipher.encryptBlock(e)},e.decrypt=function(t,e){return t._cipher.decryptBlock(e)}},function(t,e,n){var r=n(55);e.encrypt=function(t,e){var n=r(e,t._prev);return t._prev=t._cipher.encryptBlock(n),t._prev},e.decrypt=function(t,e){var n=t._prev;t._prev=e;var i=t._cipher.decryptBlock(e);return r(i,n)}},function(t,e,n){var r=n(3).Buffer,i=n(55);function o(t,e,n){var o=e.length,a=i(e,t._cache);return t._cache=t._cache.slice(o),t._prev=r.concat([t._prev,n?e:a]),a}e.encrypt=function(t,e,n){for(var i,a=r.allocUnsafe(0);e.length;){if(0===t._cache.length&&(t._cache=t._cipher.encryptBlock(t._prev),t._prev=r.allocUnsafe(0)),!(t._cache.length<=e.length)){a=r.concat([a,o(t,e,n)]);break}i=t._cache.length,a=r.concat([a,o(t,e.slice(0,i),n)]),e=e.slice(i)}return a}},function(t,e,n){var r=n(3).Buffer;function i(t,e,n){var i=t._cipher.encryptBlock(t._prev)[0]^e;return t._prev=r.concat([t._prev.slice(1),r.from([n?e:i])]),i}e.encrypt=function(t,e,n){for(var o=e.length,a=r.allocUnsafe(o),s=-1;++s<o;)a[s]=i(t,e[s],n);return a}},function(t,e,n){var r=n(3).Buffer;function i(t,e,n){for(var r,i,a=-1,s=0;++a<8;)r=e&1<<7-a?128:0,s+=(128&(i=t._cipher.encryptBlock(t._prev)[0]^r))>>a%8,t._prev=o(t._prev,n?r:i);return s}function o(t,e){var n=t.length,i=-1,o=r.allocUnsafe(t.length);for(t=r.concat([t,r.from([e])]);++i<n;)o[i]=t[i]<<1|t[i+1]>>7;return o}e.encrypt=function(t,e,n){for(var o=e.length,a=r.allocUnsafe(o),s=-1;++s<o;)a[s]=i(t,e[s],n);return a}},function(t,e,n){(function(t){var r=n(55);function i(t){return t._prev=t._cipher.encryptBlock(t._prev),t._prev}e.encrypt=function(e,n){for(;e._cache.length<n.length;)e._cache=t.concat([e._cache,i(e)]);var o=e._cache.slice(0,n.length);return e._cache=e._cache.slice(n.length),r(n,o)}}).call(this,n(8).Buffer)},function(t,e,n){var r=n(3).Buffer,i=r.alloc(16,0);function o(t){var e=r.allocUnsafe(16);return e.writeUInt32BE(t[0]>>>0,0),e.writeUInt32BE(t[1]>>>0,4),e.writeUInt32BE(t[2]>>>0,8),e.writeUInt32BE(t[3]>>>0,12),e}function a(t){this.h=t,this.state=r.alloc(16,0),this.cache=r.allocUnsafe(0)}a.prototype.ghash=function(t){for(var e=-1;++e<t.length;)this.state[e]^=t[e];this._multiply()},a.prototype._multiply=function(){for(var t,e,n,r=[(t=this.h).readUInt32BE(0),t.readUInt32BE(4),t.readUInt32BE(8),t.readUInt32BE(12)],i=[0,0,0,0],a=-1;++a<128;){for(0!=(this.state[~~(a/8)]&1<<7-a%8)&&(i[0]^=r[0],i[1]^=r[1],i[2]^=r[2],i[3]^=r[3]),n=0!=(1&r[3]),e=3;e>0;e--)r[e]=r[e]>>>1|(1&r[e-1])<<31;r[0]=r[0]>>>1,n&&(r[0]=r[0]^225<<24)}this.state=o(i)},a.prototype.update=function(t){var e;for(this.cache=r.concat([this.cache,t]);this.cache.length>=16;)e=this.cache.slice(0,16),this.cache=this.cache.slice(16),this.ghash(e)},a.prototype.final=function(t,e){return this.cache.length&&this.ghash(r.concat([this.cache,i],16)),this.ghash(o([0,t,0,e])),this.state},t.exports=a},function(t,e,n){var r=n(209),i=n(3).Buffer,o=n(122),a=n(210),s=n(31),u=n(79),c=n(80);function f(t,e,n){s.call(this),this._cache=new l,this._last=void 0,this._cipher=new u.AES(e),this._prev=i.from(n),this._mode=t,this._autopadding=!0}function l(){this.cache=i.allocUnsafe(0)}function h(t,e,n){var s=o[t.toLowerCase()];if(!s)throw new TypeError("invalid suite type");if("string"==typeof n&&(n=i.from(n)),"GCM"!==s.mode&&n.length!==s.iv)throw new TypeError("invalid iv length "+n.length);if("string"==typeof e&&(e=i.from(e)),e.length!==s.key/8)throw new TypeError("invalid key length "+e.length);return"stream"===s.type?new a(s.module,e,n,!0):"auth"===s.type?new r(s.module,e,n,!0):new f(s.module,e,n)}n(2)(f,s),f.prototype._update=function(t){var e,n;this._cache.add(t);for(var r=[];e=this._cache.get(this._autopadding);)n=this._mode.decrypt(this,e),r.push(n);return i.concat(r)},f.prototype._final=function(){var t=this._cache.flush();if(this._autopadding)return function(t){var e=t[15];if(e<1||e>16)throw new Error("unable to decrypt data");var n=-1;for(;++n<e;)if(t[n+(16-e)]!==e)throw new Error("unable to decrypt data");if(16===e)return;return t.slice(0,16-e)}(this._mode.decrypt(this,t));if(t)throw new Error("data not multiple of block length")},f.prototype.setAutoPadding=function(t){return this._autopadding=!!t,this},l.prototype.add=function(t){this.cache=i.concat([this.cache,t])},l.prototype.get=function(t){var e;if(t){if(this.cache.length>16)return e=this.cache.slice(0,16),this.cache=this.cache.slice(16),e}else if(this.cache.length>=16)return e=this.cache.slice(0,16),this.cache=this.cache.slice(16),e;return null},l.prototype.flush=function(){if(this.cache.length)return this.cache},e.createDecipher=function(t,e){var n=o[t.toLowerCase()];if(!n)throw new TypeError("invalid suite type");var r=c(e,!1,n.key,n.iv);return h(t,r.key,r.iv)},e.createDecipheriv=h},function(t,e){e["des-ecb"]={key:8,iv:0},e["des-cbc"]=e.des={key:8,iv:8},e["des-ede3-cbc"]=e.des3={key:24,iv:8},e["des-ede3"]={key:24,iv:0},e["des-ede-cbc"]={key:16,iv:8},e["des-ede"]={key:16,iv:0}},function(t,e,n){(function(t){var r=n(211),i=n(459),o=n(460);var a={binary:!0,hex:!0,base64:!0};e.DiffieHellmanGroup=e.createDiffieHellmanGroup=e.getDiffieHellman=function(e){var n=new t(i[e].prime,"hex"),r=new t(i[e].gen,"hex");return new o(n,r)},e.createDiffieHellman=e.DiffieHellman=function e(n,i,s,u){return t.isBuffer(i)||void 0===a[i]?e(n,"binary",i,s):(i=i||"binary",u=u||"binary",s=s||new t([2]),t.isBuffer(s)||(s=new t(s,u)),"number"==typeof n?new o(r(n,s),s,!0):(t.isBuffer(n)||(n=new t(n,i)),new o(n,s,!0)))}}).call(this,n(8).Buffer)},function(t,e){},function(t,e){},function(t){t.exports=JSON.parse('{"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}')},function(t,e,n){(function(e){var r=n(5),i=new(n(212)),o=new r(24),a=new r(11),s=new r(10),u=new r(3),c=new r(7),f=n(211),l=n(44);function h(t,n){return n=n||"utf8",e.isBuffer(t)||(t=new e(t,n)),this._pub=new r(t),this}function d(t,n){return n=n||"utf8",e.isBuffer(t)||(t=new e(t,n)),this._priv=new r(t),this}t.exports=g;var p={};function g(t,e,n){this.setGenerator(e),this.__prime=new r(t),this._prime=r.mont(this.__prime),this._primeLen=t.length,this._pub=void 0,this._priv=void 0,this._primeCode=void 0,n?(this.setPublicKey=h,this.setPrivateKey=d):this._primeCode=8}function y(t,n){var r=new e(t.toArray());return n?r.toString(n):r}Object.defineProperty(g.prototype,"verifyError",{enumerable:!0,get:function(){return"number"!=typeof this._primeCode&&(this._primeCode=function(t,e){var n=e.toString("hex"),r=[n,t.toString(16)].join("_");if(r in p)return p[r];var l,h=0;if(t.isEven()||!f.simpleSieve||!f.fermatTest(t)||!i.test(t))return h+=1,h+="02"===n||"05"===n?8:4,p[r]=h,h;switch(i.test(t.shrn(1))||(h+=2),n){case"02":t.mod(o).cmp(a)&&(h+=8);break;case"05":(l=t.mod(s)).cmp(u)&&l.cmp(c)&&(h+=8);break;default:h+=4}return p[r]=h,h}(this.__prime,this.__gen)),this._primeCode}}),g.prototype.generateKeys=function(){return this._priv||(this._priv=new r(l(this._primeLen))),this._pub=this._gen.toRed(this._prime).redPow(this._priv).fromRed(),this.getPublicKey()},g.prototype.computeSecret=function(t){var n=(t=(t=new r(t)).toRed(this._prime)).redPow(this._priv).fromRed(),i=new e(n.toArray()),o=this.getPrime();if(i.length<o.length){var a=new e(o.length-i.length);a.fill(0),i=e.concat([a,i])}return i},g.prototype.getPublicKey=function(t){return y(this._pub,t)},g.prototype.getPrivateKey=function(t){return y(this._priv,t)},g.prototype.getPrime=function(t){return y(this.__prime,t)},g.prototype.getGenerator=function(t){return y(this._gen,t)},g.prototype.setGenerator=function(t,n){return n=n||"utf8",e.isBuffer(t)||(t=new e(t,n)),this.__gen=t,this._gen=new r(t),this}}).call(this,n(8).Buffer)},function(t,e,n){(function(e){var r=n(53),i=n(112),o=n(2),a=n(462),s=n(494),u=n(201);function c(t){i.Writable.call(this);var e=u[t];if(!e)throw new Error("Unknown message digest");this._hashType=e.hash,this._hash=r(e.hash),this._tag=e.id,this._signType=e.sign}function f(t){i.Writable.call(this);var e=u[t];if(!e)throw new Error("Unknown message digest");this._hash=r(e.hash),this._tag=e.id,this._signType=e.sign}function l(t){return new c(t)}function h(t){return new f(t)}Object.keys(u).forEach((function(t){u[t].id=new e(u[t].id,"hex"),u[t.toLowerCase()]=u[t]})),o(c,i.Writable),c.prototype._write=function(t,e,n){this._hash.update(t),n()},c.prototype.update=function(t,n){return"string"==typeof t&&(t=new e(t,n)),this._hash.update(t),this},c.prototype.sign=function(t,e){this.end();var n=this._hash.digest(),r=a(n,t,this._hashType,this._signType,this._tag);return e?r.toString(e):r},o(f,i.Writable),f.prototype._write=function(t,e,n){this._hash.update(t),n()},f.prototype.update=function(t,n){return"string"==typeof t&&(t=new e(t,n)),this._hash.update(t),this},f.prototype.verify=function(t,n,r){"string"==typeof n&&(n=new e(n,r)),this.end();var i=this._hash.digest();return s(n,i,t,this._signType,this._tag)},t.exports={Sign:l,Verify:h,createSign:l,createVerify:h}}).call(this,n(8).Buffer)},function(t,e,n){(function(e){var r=n(199),i=n(124),o=n(125).ec,a=n(5),s=n(82),u=n(222);function c(t,n,i,o){if((t=new e(t.toArray())).length<n.byteLength()){var a=new e(n.byteLength()-t.length);a.fill(0),t=e.concat([a,t])}var s=i.length,u=function(t,n){t=(t=f(t,n)).mod(n);var r=new e(t.toArray());if(r.length<n.byteLength()){var i=new e(n.byteLength()-r.length);i.fill(0),r=e.concat([i,r])}return r}(i,n),c=new e(s);c.fill(1);var l=new e(s);return l.fill(0),l=r(o,l).update(c).update(new e([0])).update(t).update(u).digest(),c=r(o,l).update(c).digest(),{k:l=r(o,l).update(c).update(new e([1])).update(t).update(u).digest(),v:c=r(o,l).update(c).digest()}}function f(t,e){var n=new a(t),r=(t.length<<3)-e.bitLength();return r>0&&n.ishrn(r),n}function l(t,n,i){var o,a;do{for(o=new e(0);8*o.length<t.bitLength();)n.v=r(i,n.k).update(n.v).digest(),o=e.concat([o,n.v]);a=f(o,t),n.k=r(i,n.k).update(n.v).update(new e([0])).digest(),n.v=r(i,n.k).update(n.v).digest()}while(-1!==a.cmp(t));return a}function h(t,e,n,r){return t.toRed(a.mont(n)).redPow(e).fromRed().mod(r)}t.exports=function(t,n,r,d,p){var g=s(n);if(g.curve){if("ecdsa"!==d&&"ecdsa/rsa"!==d)throw new Error("wrong private key type");return function(t,n){var r=u[n.curve.join(".")];if(!r)throw new Error("unknown curve "+n.curve.join("."));var i=new o(r).keyFromPrivate(n.privateKey).sign(t);return new e(i.toDER())}(t,g)}if("dsa"===g.type){if("dsa"!==d)throw new Error("wrong private key type");return function(t,n,r){var i,o=n.params.priv_key,s=n.params.p,u=n.params.q,d=n.params.g,p=new a(0),g=f(t,u).mod(u),y=!1,b=c(o,u,t,r);for(;!1===y;)i=l(u,b,r),p=h(d,i,s,u),0===(y=i.invm(u).imul(g.add(o.mul(p))).mod(u)).cmpn(0)&&(y=!1,p=new a(0));return function(t,n){t=t.toArray(),n=n.toArray(),128&t[0]&&(t=[0].concat(t));128&n[0]&&(n=[0].concat(n));var r=[48,t.length+n.length+4,2,t.length];return r=r.concat(t,[2,n.length],n),new e(r)}(p,y)}(t,g,r)}if("rsa"!==d&&"ecdsa/rsa"!==d)throw new Error("wrong private key type");t=e.concat([p,t]);for(var y=g.modulus.byteLength(),b=[0,1];t.length+b.length+1<y;)b.push(255);b.push(0);for(var m=-1;++m<t.length;)b.push(t[m]);return i(b,g)},t.exports.getKey=c,t.exports.makeKey=l}).call(this,n(8).Buffer)},function(t){t.exports=JSON.parse('{"name":"elliptic","version":"6.5.1","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^1.4.3","coveralls":"^3.0.4","grunt":"^1.0.4","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.2","jscs":"^3.0.7","jshint":"^2.6.0","mocha":"^6.1.4"},"dependencies":{"bn.js":"^4.4.0","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"}}')},function(t,e,n){"use strict";var r=n(16),i=n(5),o=n(2),a=n(81),s=r.assert;function u(t){a.call(this,"short",t),this.a=new i(t.a,16).toRed(this.red),this.b=new i(t.b,16).toRed(this.red),this.tinv=this.two.redInvm(),this.zeroA=0===this.a.fromRed().cmpn(0),this.threeA=0===this.a.fromRed().sub(this.p).cmpn(-3),this.endo=this._getEndomorphism(t),this._endoWnafT1=new Array(4),this._endoWnafT2=new Array(4)}function c(t,e,n,r){a.BasePoint.call(this,t,"affine"),null===e&&null===n?(this.x=null,this.y=null,this.inf=!0):(this.x=new i(e,16),this.y=new i(n,16),r&&(this.x.forceRed(this.curve.red),this.y.forceRed(this.curve.red)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.inf=!1)}function f(t,e,n,r){a.BasePoint.call(this,t,"jacobian"),null===e&&null===n&&null===r?(this.x=this.curve.one,this.y=this.curve.one,this.z=new i(0)):(this.x=new i(e,16),this.y=new i(n,16),this.z=new i(r,16)),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.zOne=this.z===this.curve.one}o(u,a),t.exports=u,u.prototype._getEndomorphism=function(t){if(this.zeroA&&this.g&&this.n&&1===this.p.modn(3)){var e,n;if(t.beta)e=new i(t.beta,16).toRed(this.red);else{var r=this._getEndoRoots(this.p);e=(e=r[0].cmp(r[1])<0?r[0]:r[1]).toRed(this.red)}if(t.lambda)n=new i(t.lambda,16);else{var o=this._getEndoRoots(this.n);0===this.g.mul(o[0]).x.cmp(this.g.x.redMul(e))?n=o[0]:(n=o[1],s(0===this.g.mul(n).x.cmp(this.g.x.redMul(e))))}return{beta:e,lambda:n,basis:t.basis?t.basis.map((function(t){return{a:new i(t.a,16),b:new i(t.b,16)}})):this._getEndoBasis(n)}}},u.prototype._getEndoRoots=function(t){var e=t===this.p?this.red:i.mont(t),n=new i(2).toRed(e).redInvm(),r=n.redNeg(),o=new i(3).toRed(e).redNeg().redSqrt().redMul(n);return[r.redAdd(o).fromRed(),r.redSub(o).fromRed()]},u.prototype._getEndoBasis=function(t){for(var e,n,r,o,a,s,u,c,f,l=this.n.ushrn(Math.floor(this.n.bitLength()/2)),h=t,d=this.n.clone(),p=new i(1),g=new i(0),y=new i(0),b=new i(1),m=0;0!==h.cmpn(0);){var v=d.div(h);c=d.sub(v.mul(h)),f=y.sub(v.mul(p));var _=b.sub(v.mul(g));if(!r&&c.cmp(l)<0)e=u.neg(),n=p,r=c.neg(),o=f;else if(r&&2==++m)break;u=c,d=h,h=c,y=p,p=f,b=g,g=_}a=c.neg(),s=f;var w=r.sqr().add(o.sqr());return a.sqr().add(s.sqr()).cmp(w)>=0&&(a=e,s=n),r.negative&&(r=r.neg(),o=o.neg()),a.negative&&(a=a.neg(),s=s.neg()),[{a:r,b:o},{a:a,b:s}]},u.prototype._endoSplit=function(t){var e=this.endo.basis,n=e[0],r=e[1],i=r.b.mul(t).divRound(this.n),o=n.b.neg().mul(t).divRound(this.n),a=i.mul(n.a),s=o.mul(r.a),u=i.mul(n.b),c=o.mul(r.b);return{k1:t.sub(a).sub(s),k2:u.add(c).neg()}},u.prototype.pointFromX=function(t,e){(t=new i(t,16)).red||(t=t.toRed(this.red));var n=t.redSqr().redMul(t).redIAdd(t.redMul(this.a)).redIAdd(this.b),r=n.redSqrt();if(0!==r.redSqr().redSub(n).cmp(this.zero))throw new Error("invalid point");var o=r.fromRed().isOdd();return(e&&!o||!e&&o)&&(r=r.redNeg()),this.point(t,r)},u.prototype.validate=function(t){if(t.inf)return!0;var e=t.x,n=t.y,r=this.a.redMul(e),i=e.redSqr().redMul(e).redIAdd(r).redIAdd(this.b);return 0===n.redSqr().redISub(i).cmpn(0)},u.prototype._endoWnafMulAdd=function(t,e,n){for(var r=this._endoWnafT1,i=this._endoWnafT2,o=0;o<t.length;o++){var a=this._endoSplit(e[o]),s=t[o],u=s._getBeta();a.k1.negative&&(a.k1.ineg(),s=s.neg(!0)),a.k2.negative&&(a.k2.ineg(),u=u.neg(!0)),r[2*o]=s,r[2*o+1]=u,i[2*o]=a.k1,i[2*o+1]=a.k2}for(var c=this._wnafMulAdd(1,r,i,2*o,n),f=0;f<2*o;f++)r[f]=null,i[f]=null;return c},o(c,a.BasePoint),u.prototype.point=function(t,e,n){return new c(this,t,e,n)},u.prototype.pointFromJSON=function(t,e){return c.fromJSON(this,t,e)},c.prototype._getBeta=function(){if(this.curve.endo){var t=this.precomputed;if(t&&t.beta)return t.beta;var e=this.curve.point(this.x.redMul(this.curve.endo.beta),this.y);if(t){var n=this.curve,r=function(t){return n.point(t.x.redMul(n.endo.beta),t.y)};t.beta=e,e.precomputed={beta:null,naf:t.naf&&{wnd:t.naf.wnd,points:t.naf.points.map(r)},doubles:t.doubles&&{step:t.doubles.step,points:t.doubles.points.map(r)}}}return e}},c.prototype.toJSON=function(){return this.precomputed?[this.x,this.y,this.precomputed&&{doubles:this.precomputed.doubles&&{step:this.precomputed.doubles.step,points:this.precomputed.doubles.points.slice(1)},naf:this.precomputed.naf&&{wnd:this.precomputed.naf.wnd,points:this.precomputed.naf.points.slice(1)}}]:[this.x,this.y]},c.fromJSON=function(t,e,n){"string"==typeof e&&(e=JSON.parse(e));var r=t.point(e[0],e[1],n);if(!e[2])return r;function i(e){return t.point(e[0],e[1],n)}var o=e[2];return r.precomputed={beta:null,doubles:o.doubles&&{step:o.doubles.step,points:[r].concat(o.doubles.points.map(i))},naf:o.naf&&{wnd:o.naf.wnd,points:[r].concat(o.naf.points.map(i))}},r},c.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+">"},c.prototype.isInfinity=function(){return this.inf},c.prototype.add=function(t){if(this.inf)return t;if(t.inf)return this;if(this.eq(t))return this.dbl();if(this.neg().eq(t))return this.curve.point(null,null);if(0===this.x.cmp(t.x))return this.curve.point(null,null);var e=this.y.redSub(t.y);0!==e.cmpn(0)&&(e=e.redMul(this.x.redSub(t.x).redInvm()));var n=e.redSqr().redISub(this.x).redISub(t.x),r=e.redMul(this.x.redSub(n)).redISub(this.y);return this.curve.point(n,r)},c.prototype.dbl=function(){if(this.inf)return this;var t=this.y.redAdd(this.y);if(0===t.cmpn(0))return this.curve.point(null,null);var e=this.curve.a,n=this.x.redSqr(),r=t.redInvm(),i=n.redAdd(n).redIAdd(n).redIAdd(e).redMul(r),o=i.redSqr().redISub(this.x.redAdd(this.x)),a=i.redMul(this.x.redSub(o)).redISub(this.y);return this.curve.point(o,a)},c.prototype.getX=function(){return this.x.fromRed()},c.prototype.getY=function(){return this.y.fromRed()},c.prototype.mul=function(t){return t=new i(t,16),this.isInfinity()?this:this._hasDoubles(t)?this.curve._fixedNafMul(this,t):this.curve.endo?this.curve._endoWnafMulAdd([this],[t]):this.curve._wnafMul(this,t)},c.prototype.mulAdd=function(t,e,n){var r=[this,e],i=[t,n];return this.curve.endo?this.curve._endoWnafMulAdd(r,i):this.curve._wnafMulAdd(1,r,i,2)},c.prototype.jmulAdd=function(t,e,n){var r=[this,e],i=[t,n];return this.curve.endo?this.curve._endoWnafMulAdd(r,i,!0):this.curve._wnafMulAdd(1,r,i,2,!0)},c.prototype.eq=function(t){return this===t||this.inf===t.inf&&(this.inf||0===this.x.cmp(t.x)&&0===this.y.cmp(t.y))},c.prototype.neg=function(t){if(this.inf)return this;var e=this.curve.point(this.x,this.y.redNeg());if(t&&this.precomputed){var n=this.precomputed,r=function(t){return t.neg()};e.precomputed={naf:n.naf&&{wnd:n.naf.wnd,points:n.naf.points.map(r)},doubles:n.doubles&&{step:n.doubles.step,points:n.doubles.points.map(r)}}}return e},c.prototype.toJ=function(){return this.inf?this.curve.jpoint(null,null,null):this.curve.jpoint(this.x,this.y,this.curve.one)},o(f,a.BasePoint),u.prototype.jpoint=function(t,e,n){return new f(this,t,e,n)},f.prototype.toP=function(){if(this.isInfinity())return this.curve.point(null,null);var t=this.z.redInvm(),e=t.redSqr(),n=this.x.redMul(e),r=this.y.redMul(e).redMul(t);return this.curve.point(n,r)},f.prototype.neg=function(){return this.curve.jpoint(this.x,this.y.redNeg(),this.z)},f.prototype.add=function(t){if(this.isInfinity())return t;if(t.isInfinity())return this;var e=t.z.redSqr(),n=this.z.redSqr(),r=this.x.redMul(e),i=t.x.redMul(n),o=this.y.redMul(e.redMul(t.z)),a=t.y.redMul(n.redMul(this.z)),s=r.redSub(i),u=o.redSub(a);if(0===s.cmpn(0))return 0!==u.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var c=s.redSqr(),f=c.redMul(s),l=r.redMul(c),h=u.redSqr().redIAdd(f).redISub(l).redISub(l),d=u.redMul(l.redISub(h)).redISub(o.redMul(f)),p=this.z.redMul(t.z).redMul(s);return this.curve.jpoint(h,d,p)},f.prototype.mixedAdd=function(t){if(this.isInfinity())return t.toJ();if(t.isInfinity())return this;var e=this.z.redSqr(),n=this.x,r=t.x.redMul(e),i=this.y,o=t.y.redMul(e).redMul(this.z),a=n.redSub(r),s=i.redSub(o);if(0===a.cmpn(0))return 0!==s.cmpn(0)?this.curve.jpoint(null,null,null):this.dbl();var u=a.redSqr(),c=u.redMul(a),f=n.redMul(u),l=s.redSqr().redIAdd(c).redISub(f).redISub(f),h=s.redMul(f.redISub(l)).redISub(i.redMul(c)),d=this.z.redMul(a);return this.curve.jpoint(l,h,d)},f.prototype.dblp=function(t){if(0===t)return this;if(this.isInfinity())return this;if(!t)return this.dbl();if(this.curve.zeroA||this.curve.threeA){for(var e=this,n=0;n<t;n++)e=e.dbl();return e}var r=this.curve.a,i=this.curve.tinv,o=this.x,a=this.y,s=this.z,u=s.redSqr().redSqr(),c=a.redAdd(a);for(n=0;n<t;n++){var f=o.redSqr(),l=c.redSqr(),h=l.redSqr(),d=f.redAdd(f).redIAdd(f).redIAdd(r.redMul(u)),p=o.redMul(l),g=d.redSqr().redISub(p.redAdd(p)),y=p.redISub(g),b=d.redMul(y);b=b.redIAdd(b).redISub(h);var m=c.redMul(s);n+1<t&&(u=u.redMul(h)),o=g,s=m,c=b}return this.curve.jpoint(o,c.redMul(i),s)},f.prototype.dbl=function(){return this.isInfinity()?this:this.curve.zeroA?this._zeroDbl():this.curve.threeA?this._threeDbl():this._dbl()},f.prototype._zeroDbl=function(){var t,e,n;if(this.zOne){var r=this.x.redSqr(),i=this.y.redSqr(),o=i.redSqr(),a=this.x.redAdd(i).redSqr().redISub(r).redISub(o);a=a.redIAdd(a);var s=r.redAdd(r).redIAdd(r),u=s.redSqr().redISub(a).redISub(a),c=o.redIAdd(o);c=(c=c.redIAdd(c)).redIAdd(c),t=u,e=s.redMul(a.redISub(u)).redISub(c),n=this.y.redAdd(this.y)}else{var f=this.x.redSqr(),l=this.y.redSqr(),h=l.redSqr(),d=this.x.redAdd(l).redSqr().redISub(f).redISub(h);d=d.redIAdd(d);var p=f.redAdd(f).redIAdd(f),g=p.redSqr(),y=h.redIAdd(h);y=(y=y.redIAdd(y)).redIAdd(y),t=g.redISub(d).redISub(d),e=p.redMul(d.redISub(t)).redISub(y),n=(n=this.y.redMul(this.z)).redIAdd(n)}return this.curve.jpoint(t,e,n)},f.prototype._threeDbl=function(){var t,e,n;if(this.zOne){var r=this.x.redSqr(),i=this.y.redSqr(),o=i.redSqr(),a=this.x.redAdd(i).redSqr().redISub(r).redISub(o);a=a.redIAdd(a);var s=r.redAdd(r).redIAdd(r).redIAdd(this.curve.a),u=s.redSqr().redISub(a).redISub(a);t=u;var c=o.redIAdd(o);c=(c=c.redIAdd(c)).redIAdd(c),e=s.redMul(a.redISub(u)).redISub(c),n=this.y.redAdd(this.y)}else{var f=this.z.redSqr(),l=this.y.redSqr(),h=this.x.redMul(l),d=this.x.redSub(f).redMul(this.x.redAdd(f));d=d.redAdd(d).redIAdd(d);var p=h.redIAdd(h),g=(p=p.redIAdd(p)).redAdd(p);t=d.redSqr().redISub(g),n=this.y.redAdd(this.z).redSqr().redISub(l).redISub(f);var y=l.redSqr();y=(y=(y=y.redIAdd(y)).redIAdd(y)).redIAdd(y),e=d.redMul(p.redISub(t)).redISub(y)}return this.curve.jpoint(t,e,n)},f.prototype._dbl=function(){var t=this.curve.a,e=this.x,n=this.y,r=this.z,i=r.redSqr().redSqr(),o=e.redSqr(),a=n.redSqr(),s=o.redAdd(o).redIAdd(o).redIAdd(t.redMul(i)),u=e.redAdd(e),c=(u=u.redIAdd(u)).redMul(a),f=s.redSqr().redISub(c.redAdd(c)),l=c.redISub(f),h=a.redSqr();h=(h=(h=h.redIAdd(h)).redIAdd(h)).redIAdd(h);var d=s.redMul(l).redISub(h),p=n.redAdd(n).redMul(r);return this.curve.jpoint(f,d,p)},f.prototype.trpl=function(){if(!this.curve.zeroA)return this.dbl().add(this);var t=this.x.redSqr(),e=this.y.redSqr(),n=this.z.redSqr(),r=e.redSqr(),i=t.redAdd(t).redIAdd(t),o=i.redSqr(),a=this.x.redAdd(e).redSqr().redISub(t).redISub(r),s=(a=(a=(a=a.redIAdd(a)).redAdd(a).redIAdd(a)).redISub(o)).redSqr(),u=r.redIAdd(r);u=(u=(u=u.redIAdd(u)).redIAdd(u)).redIAdd(u);var c=i.redIAdd(a).redSqr().redISub(o).redISub(s).redISub(u),f=e.redMul(c);f=(f=f.redIAdd(f)).redIAdd(f);var l=this.x.redMul(s).redISub(f);l=(l=l.redIAdd(l)).redIAdd(l);var h=this.y.redMul(c.redMul(u.redISub(c)).redISub(a.redMul(s)));h=(h=(h=h.redIAdd(h)).redIAdd(h)).redIAdd(h);var d=this.z.redAdd(a).redSqr().redISub(n).redISub(s);return this.curve.jpoint(l,h,d)},f.prototype.mul=function(t,e){return t=new i(t,e),this.curve._wnafMul(this,t)},f.prototype.eq=function(t){if("affine"===t.type)return this.eq(t.toJ());if(this===t)return!0;var e=this.z.redSqr(),n=t.z.redSqr();if(0!==this.x.redMul(n).redISub(t.x.redMul(e)).cmpn(0))return!1;var r=e.redMul(this.z),i=n.redMul(t.z);return 0===this.y.redMul(i).redISub(t.y.redMul(r)).cmpn(0)},f.prototype.eqXToP=function(t){var e=this.z.redSqr(),n=t.toRed(this.curve.red).redMul(e);if(0===this.x.cmp(n))return!0;for(var r=t.clone(),i=this.curve.redN.redMul(e);;){if(r.iadd(this.curve.n),r.cmp(this.curve.p)>=0)return!1;if(n.redIAdd(i),0===this.x.cmp(n))return!0}},f.prototype.inspect=function(){return this.isInfinity()?"<EC JPoint Infinity>":"<EC JPoint x: "+this.x.toString(16,2)+" y: "+this.y.toString(16,2)+" z: "+this.z.toString(16,2)+">"},f.prototype.isInfinity=function(){return 0===this.z.cmpn(0)}},function(t,e,n){"use strict";var r=n(5),i=n(2),o=n(81),a=n(16);function s(t){o.call(this,"mont",t),this.a=new r(t.a,16).toRed(this.red),this.b=new r(t.b,16).toRed(this.red),this.i4=new r(4).toRed(this.red).redInvm(),this.two=new r(2).toRed(this.red),this.a24=this.i4.redMul(this.a.redAdd(this.two))}function u(t,e,n){o.BasePoint.call(this,t,"projective"),null===e&&null===n?(this.x=this.curve.one,this.z=this.curve.zero):(this.x=new r(e,16),this.z=new r(n,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)))}i(s,o),t.exports=s,s.prototype.validate=function(t){var e=t.normalize().x,n=e.redSqr(),r=n.redMul(e).redAdd(n.redMul(this.a)).redAdd(e);return 0===r.redSqrt().redSqr().cmp(r)},i(u,o.BasePoint),s.prototype.decodePoint=function(t,e){return this.point(a.toArray(t,e),1)},s.prototype.point=function(t,e){return new u(this,t,e)},s.prototype.pointFromJSON=function(t){return u.fromJSON(this,t)},u.prototype.precompute=function(){},u.prototype._encode=function(){return this.getX().toArray("be",this.curve.p.byteLength())},u.fromJSON=function(t,e){return new u(t,e[0],e[1]||t.one)},u.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},u.prototype.isInfinity=function(){return 0===this.z.cmpn(0)},u.prototype.dbl=function(){var t=this.x.redAdd(this.z).redSqr(),e=this.x.redSub(this.z).redSqr(),n=t.redSub(e),r=t.redMul(e),i=n.redMul(e.redAdd(this.curve.a24.redMul(n)));return this.curve.point(r,i)},u.prototype.add=function(){throw new Error("Not supported on Montgomery curve")},u.prototype.diffAdd=function(t,e){var n=this.x.redAdd(this.z),r=this.x.redSub(this.z),i=t.x.redAdd(t.z),o=t.x.redSub(t.z).redMul(n),a=i.redMul(r),s=e.z.redMul(o.redAdd(a).redSqr()),u=e.x.redMul(o.redISub(a).redSqr());return this.curve.point(s,u)},u.prototype.mul=function(t){for(var e=t.clone(),n=this,r=this.curve.point(null,null),i=[];0!==e.cmpn(0);e.iushrn(1))i.push(e.andln(1));for(var o=i.length-1;o>=0;o--)0===i[o]?(n=n.diffAdd(r,this),r=r.dbl()):(r=n.diffAdd(r,this),n=n.dbl());return r},u.prototype.mulAdd=function(){throw new Error("Not supported on Montgomery curve")},u.prototype.jumlAdd=function(){throw new Error("Not supported on Montgomery curve")},u.prototype.eq=function(t){return 0===this.getX().cmp(t.getX())},u.prototype.normalize=function(){return this.x=this.x.redMul(this.z.redInvm()),this.z=this.curve.one,this},u.prototype.getX=function(){return this.normalize(),this.x.fromRed()}},function(t,e,n){"use strict";var r=n(16),i=n(5),o=n(2),a=n(81),s=r.assert;function u(t){this.twisted=1!=(0|t.a),this.mOneA=this.twisted&&-1==(0|t.a),this.extended=this.mOneA,a.call(this,"edwards",t),this.a=new i(t.a,16).umod(this.red.m),this.a=this.a.toRed(this.red),this.c=new i(t.c,16).toRed(this.red),this.c2=this.c.redSqr(),this.d=new i(t.d,16).toRed(this.red),this.dd=this.d.redAdd(this.d),s(!this.twisted||0===this.c.fromRed().cmpn(1)),this.oneC=1==(0|t.c)}function c(t,e,n,r,o){a.BasePoint.call(this,t,"projective"),null===e&&null===n&&null===r?(this.x=this.curve.zero,this.y=this.curve.one,this.z=this.curve.one,this.t=this.curve.zero,this.zOne=!0):(this.x=new i(e,16),this.y=new i(n,16),this.z=r?new i(r,16):this.curve.one,this.t=o&&new i(o,16),this.x.red||(this.x=this.x.toRed(this.curve.red)),this.y.red||(this.y=this.y.toRed(this.curve.red)),this.z.red||(this.z=this.z.toRed(this.curve.red)),this.t&&!this.t.red&&(this.t=this.t.toRed(this.curve.red)),this.zOne=this.z===this.curve.one,this.curve.extended&&!this.t&&(this.t=this.x.redMul(this.y),this.zOne||(this.t=this.t.redMul(this.z.redInvm()))))}o(u,a),t.exports=u,u.prototype._mulA=function(t){return this.mOneA?t.redNeg():this.a.redMul(t)},u.prototype._mulC=function(t){return this.oneC?t:this.c.redMul(t)},u.prototype.jpoint=function(t,e,n,r){return this.point(t,e,n,r)},u.prototype.pointFromX=function(t,e){(t=new i(t,16)).red||(t=t.toRed(this.red));var n=t.redSqr(),r=this.c2.redSub(this.a.redMul(n)),o=this.one.redSub(this.c2.redMul(this.d).redMul(n)),a=r.redMul(o.redInvm()),s=a.redSqrt();if(0!==s.redSqr().redSub(a).cmp(this.zero))throw new Error("invalid point");var u=s.fromRed().isOdd();return(e&&!u||!e&&u)&&(s=s.redNeg()),this.point(t,s)},u.prototype.pointFromY=function(t,e){(t=new i(t,16)).red||(t=t.toRed(this.red));var n=t.redSqr(),r=n.redSub(this.c2),o=n.redMul(this.d).redMul(this.c2).redSub(this.a),a=r.redMul(o.redInvm());if(0===a.cmp(this.zero)){if(e)throw new Error("invalid point");return this.point(this.zero,t)}var s=a.redSqrt();if(0!==s.redSqr().redSub(a).cmp(this.zero))throw new Error("invalid point");return s.fromRed().isOdd()!==e&&(s=s.redNeg()),this.point(s,t)},u.prototype.validate=function(t){if(t.isInfinity())return!0;t.normalize();var e=t.x.redSqr(),n=t.y.redSqr(),r=e.redMul(this.a).redAdd(n),i=this.c2.redMul(this.one.redAdd(this.d.redMul(e).redMul(n)));return 0===r.cmp(i)},o(c,a.BasePoint),u.prototype.pointFromJSON=function(t){return c.fromJSON(this,t)},u.prototype.point=function(t,e,n,r){return new c(this,t,e,n,r)},c.fromJSON=function(t,e){return new c(t,e[0],e[1],e[2])},c.prototype.inspect=function(){return this.isInfinity()?"<EC Point Infinity>":"<EC Point x: "+this.x.fromRed().toString(16,2)+" y: "+this.y.fromRed().toString(16,2)+" z: "+this.z.fromRed().toString(16,2)+">"},c.prototype.isInfinity=function(){return 0===this.x.cmpn(0)&&(0===this.y.cmp(this.z)||this.zOne&&0===this.y.cmp(this.curve.c))},c.prototype._extDbl=function(){var t=this.x.redSqr(),e=this.y.redSqr(),n=this.z.redSqr();n=n.redIAdd(n);var r=this.curve._mulA(t),i=this.x.redAdd(this.y).redSqr().redISub(t).redISub(e),o=r.redAdd(e),a=o.redSub(n),s=r.redSub(e),u=i.redMul(a),c=o.redMul(s),f=i.redMul(s),l=a.redMul(o);return this.curve.point(u,c,l,f)},c.prototype._projDbl=function(){var t,e,n,r=this.x.redAdd(this.y).redSqr(),i=this.x.redSqr(),o=this.y.redSqr();if(this.curve.twisted){var a=(c=this.curve._mulA(i)).redAdd(o);if(this.zOne)t=r.redSub(i).redSub(o).redMul(a.redSub(this.curve.two)),e=a.redMul(c.redSub(o)),n=a.redSqr().redSub(a).redSub(a);else{var s=this.z.redSqr(),u=a.redSub(s).redISub(s);t=r.redSub(i).redISub(o).redMul(u),e=a.redMul(c.redSub(o)),n=a.redMul(u)}}else{var c=i.redAdd(o);s=this.curve._mulC(this.z).redSqr(),u=c.redSub(s).redSub(s);t=this.curve._mulC(r.redISub(c)).redMul(u),e=this.curve._mulC(c).redMul(i.redISub(o)),n=c.redMul(u)}return this.curve.point(t,e,n)},c.prototype.dbl=function(){return this.isInfinity()?this:this.curve.extended?this._extDbl():this._projDbl()},c.prototype._extAdd=function(t){var e=this.y.redSub(this.x).redMul(t.y.redSub(t.x)),n=this.y.redAdd(this.x).redMul(t.y.redAdd(t.x)),r=this.t.redMul(this.curve.dd).redMul(t.t),i=this.z.redMul(t.z.redAdd(t.z)),o=n.redSub(e),a=i.redSub(r),s=i.redAdd(r),u=n.redAdd(e),c=o.redMul(a),f=s.redMul(u),l=o.redMul(u),h=a.redMul(s);return this.curve.point(c,f,h,l)},c.prototype._projAdd=function(t){var e,n,r=this.z.redMul(t.z),i=r.redSqr(),o=this.x.redMul(t.x),a=this.y.redMul(t.y),s=this.curve.d.redMul(o).redMul(a),u=i.redSub(s),c=i.redAdd(s),f=this.x.redAdd(this.y).redMul(t.x.redAdd(t.y)).redISub(o).redISub(a),l=r.redMul(u).redMul(f);return this.curve.twisted?(e=r.redMul(c).redMul(a.redSub(this.curve._mulA(o))),n=u.redMul(c)):(e=r.redMul(c).redMul(a.redSub(o)),n=this.curve._mulC(u).redMul(c)),this.curve.point(l,e,n)},c.prototype.add=function(t){return this.isInfinity()?t:t.isInfinity()?this:this.curve.extended?this._extAdd(t):this._projAdd(t)},c.prototype.mul=function(t){return this._hasDoubles(t)?this.curve._fixedNafMul(this,t):this.curve._wnafMul(this,t)},c.prototype.mulAdd=function(t,e,n){return this.curve._wnafMulAdd(1,[this,e],[t,n],2,!1)},c.prototype.jmulAdd=function(t,e,n){return this.curve._wnafMulAdd(1,[this,e],[t,n],2,!0)},c.prototype.normalize=function(){if(this.zOne)return this;var t=this.z.redInvm();return this.x=this.x.redMul(t),this.y=this.y.redMul(t),this.t&&(this.t=this.t.redMul(t)),this.z=this.curve.one,this.zOne=!0,this},c.prototype.neg=function(){return this.curve.point(this.x.redNeg(),this.y,this.z,this.t&&this.t.redNeg())},c.prototype.getX=function(){return this.normalize(),this.x.fromRed()},c.prototype.getY=function(){return this.normalize(),this.y.fromRed()},c.prototype.eq=function(t){return this===t||0===this.getX().cmp(t.getX())&&0===this.getY().cmp(t.getY())},c.prototype.eqXToP=function(t){var e=t.toRed(this.curve.red).redMul(this.z);if(0===this.x.cmp(e))return!0;for(var n=t.clone(),r=this.curve.redN.redMul(this.z);;){if(n.iadd(this.curve.n),n.cmp(this.curve.p)>=0)return!1;if(e.redIAdd(r),0===this.x.cmp(e))return!0}},c.prototype.toP=c.prototype.normalize,c.prototype.mixedAdd=c.prototype.add},function(t,e,n){"use strict";e.sha1=n(468),e.sha224=n(469),e.sha256=n(216),e.sha384=n(470),e.sha512=n(217)},function(t,e,n){"use strict";var r=n(21),i=n(56),o=n(215),a=r.rotl32,s=r.sum32,u=r.sum32_5,c=o.ft_1,f=i.BlockHash,l=[1518500249,1859775393,2400959708,3395469782];function h(){if(!(this instanceof h))return new h;f.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.W=new Array(80)}r.inherits(h,f),t.exports=h,h.blockSize=512,h.outSize=160,h.hmacStrength=80,h.padLength=64,h.prototype._update=function(t,e){for(var n=this.W,r=0;r<16;r++)n[r]=t[e+r];for(;r<n.length;r++)n[r]=a(n[r-3]^n[r-8]^n[r-14]^n[r-16],1);var i=this.h[0],o=this.h[1],f=this.h[2],h=this.h[3],d=this.h[4];for(r=0;r<n.length;r++){var p=~~(r/20),g=u(a(i,5),c(p,o,f,h),d,n[r],l[p]);d=h,h=f,f=a(o,30),o=i,i=g}this.h[0]=s(this.h[0],i),this.h[1]=s(this.h[1],o),this.h[2]=s(this.h[2],f),this.h[3]=s(this.h[3],h),this.h[4]=s(this.h[4],d)},h.prototype._digest=function(t){return"hex"===t?r.toHex32(this.h,"big"):r.split32(this.h,"big")}},function(t,e,n){"use strict";var r=n(21),i=n(216);function o(){if(!(this instanceof o))return new o;i.call(this),this.h=[3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]}r.inherits(o,i),t.exports=o,o.blockSize=512,o.outSize=224,o.hmacStrength=192,o.padLength=64,o.prototype._digest=function(t){return"hex"===t?r.toHex32(this.h.slice(0,7),"big"):r.split32(this.h.slice(0,7),"big")}},function(t,e,n){"use strict";var r=n(21),i=n(217);function o(){if(!(this instanceof o))return new o;i.call(this),this.h=[3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]}r.inherits(o,i),t.exports=o,o.blockSize=1024,o.outSize=384,o.hmacStrength=192,o.padLength=128,o.prototype._digest=function(t){return"hex"===t?r.toHex32(this.h.slice(0,12),"big"):r.split32(this.h.slice(0,12),"big")}},function(t,e,n){"use strict";var r=n(21),i=n(56),o=r.rotl32,a=r.sum32,s=r.sum32_3,u=r.sum32_4,c=i.BlockHash;function f(){if(!(this instanceof f))return new f;c.call(this),this.h=[1732584193,4023233417,2562383102,271733878,3285377520],this.endian="little"}function l(t,e,n,r){return t<=15?e^n^r:t<=31?e&n|~e&r:t<=47?(e|~n)^r:t<=63?e&r|n&~r:e^(n|~r)}function h(t){return t<=15?0:t<=31?1518500249:t<=47?1859775393:t<=63?2400959708:2840853838}function d(t){return t<=15?1352829926:t<=31?1548603684:t<=47?1836072691:t<=63?2053994217:0}r.inherits(f,c),e.ripemd160=f,f.blockSize=512,f.outSize=160,f.hmacStrength=192,f.padLength=64,f.prototype._update=function(t,e){for(var n=this.h[0],r=this.h[1],i=this.h[2],c=this.h[3],f=this.h[4],m=n,v=r,_=i,w=c,x=f,k=0;k<80;k++){var E=a(o(u(n,l(k,r,i,c),t[p[k]+e],h(k)),y[k]),f);n=f,f=c,c=o(i,10),i=r,r=E,E=a(o(u(m,l(79-k,v,_,w),t[g[k]+e],d(k)),b[k]),x),m=x,x=w,w=o(_,10),_=v,v=E}E=s(this.h[1],i,w),this.h[1]=s(this.h[2],c,x),this.h[2]=s(this.h[3],f,m),this.h[3]=s(this.h[4],n,v),this.h[4]=s(this.h[0],r,_),this.h[0]=E},f.prototype._digest=function(t){return"hex"===t?r.toHex32(this.h,"little"):r.split32(this.h,"little")};var p=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],g=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],y=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],b=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11]},function(t,e,n){"use strict";var r=n(21),i=n(15);function o(t,e,n){if(!(this instanceof o))return new o(t,e,n);this.Hash=t,this.blockSize=t.blockSize/8,this.outSize=t.outSize/8,this.inner=null,this.outer=null,this._init(r.toArray(e,n))}t.exports=o,o.prototype._init=function(t){t.length>this.blockSize&&(t=(new this.Hash).update(t).digest()),i(t.length<=this.blockSize);for(var e=t.length;e<this.blockSize;e++)t.push(0);for(e=0;e<t.length;e++)t[e]^=54;for(this.inner=(new this.Hash).update(t),e=0;e<t.length;e++)t[e]^=106;this.outer=(new this.Hash).update(t)},o.prototype.update=function(t,e){return this.inner.update(t,e),this},o.prototype.digest=function(t){return this.outer.update(this.inner.digest()),this.outer.digest(t)}},function(t,e){t.exports={doubles:{step:4,points:[["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a","f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"],["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508","11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"],["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739","d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"],["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640","4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"],["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c","4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"],["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda","96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"],["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa","5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"],["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0","cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"],["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d","9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"],["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d","e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"],["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1","9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"],["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0","5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"],["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047","10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"],["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862","283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"],["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7","7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"],["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd","56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"],["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83","7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"],["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a","53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"],["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8","bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"],["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d","4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"],["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725","7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"],["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754","4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"],["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c","17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"],["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6","6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"],["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39","c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"],["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891","893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"],["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b","febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"],["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03","2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"],["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d","eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"],["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070","7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"],["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4","e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"],["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da","662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"],["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11","1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"],["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e","efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"],["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41","2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"],["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef","67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"],["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8","db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"],["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d","648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"],["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96","35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"],["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd","ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"],["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5","9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"],["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266","40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"],["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71","34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"],["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac","c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"],["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751","1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"],["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e","493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"],["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241","c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"],["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3","be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"],["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f","4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"],["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19","aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"],["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be","b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"],["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9","6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"],["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2","8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"],["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13","7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"],["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c","ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"],["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba","2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"],["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151","e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"],["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073","d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"],["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458","38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"],["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b","69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"],["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366","d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"],["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa","40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"],["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0","620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"],["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787","7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"],["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e","ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]},naf:{wnd:7,points:[["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9","388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"],["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4","d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"],["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc","6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"],["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe","cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"],["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb","d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"],["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8","ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"],["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e","581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"],["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34","4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"],["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c","85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"],["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5","321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"],["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f","2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"],["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714","73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"],["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729","a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"],["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db","2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"],["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4","e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"],["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5","b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"],["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479","2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"],["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d","80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"],["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f","1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"],["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb","d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"],["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9","eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"],["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963","758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"],["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74","958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"],["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530","e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"],["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b","5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"],["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247","cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"],["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1","cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"],["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120","4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"],["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435","91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"],["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18","673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"],["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8","59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"],["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb","3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"],["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f","55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"],["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143","efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"],["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba","e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"],["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45","f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"],["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a","744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"],["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e","c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"],["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8","e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"],["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c","30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"],["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519","e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"],["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab","100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"],["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca","ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"],["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf","8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"],["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610","68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"],["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4","f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"],["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c","d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"],["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940","edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"],["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980","a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"],["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3","66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"],["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf","9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"],["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63","4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"],["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448","fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"],["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf","5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"],["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5","8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"],["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6","8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"],["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5","5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"],["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99","f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"],["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51","f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"],["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5","42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"],["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5","204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"],["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997","4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"],["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881","73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"],["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5","39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"],["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66","d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"],["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726","ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"],["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede","6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"],["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94","60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"],["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31","3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"],["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51","b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"],["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252","ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"],["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5","cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"],["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b","6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"],["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4","322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"],["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f","6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"],["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889","2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"],["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246","b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"],["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984","998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"],["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a","b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"],["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030","bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"],["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197","6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"],["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593","c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"],["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef","21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"],["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38","60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"],["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a","49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"],["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111","5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"],["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502","7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"],["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea","be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"],["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26","8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"],["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986","39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"],["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e","62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"],["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4","25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"],["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda","ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"],["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859","cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"],["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f","f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"],["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c","6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"],["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942","fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"],["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a","1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"],["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80","5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"],["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d","438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"],["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1","cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"],["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63","c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"],["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352","6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"],["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193","ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"],["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00","9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"],["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58","ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"],["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7","d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"],["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8","c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"],["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e","67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"],["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d","cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"],["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b","299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"],["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f","f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"],["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6","462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"],["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297","62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"],["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a","7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"],["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c","ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"],["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52","4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"],["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb","bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"],["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065","bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"],["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917","603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"],["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9","cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"],["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3","553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"],["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57","712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"],["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66","ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"],["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8","9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"],["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721","9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"],["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180","4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]}}},function(t,e,n){"use strict";var r=n(5),i=n(475),o=n(16),a=n(126),s=n(123),u=o.assert,c=n(476),f=n(477);function l(t){if(!(this instanceof l))return new l(t);"string"==typeof t&&(u(a.hasOwnProperty(t),"Unknown curve "+t),t=a[t]),t instanceof a.PresetCurve&&(t={curve:t}),this.curve=t.curve.curve,this.n=this.curve.n,this.nh=this.n.ushrn(1),this.g=this.curve.g,this.g=t.curve.g,this.g.precompute(t.curve.n.bitLength()+1),this.hash=t.hash||t.curve.hash}t.exports=l,l.prototype.keyPair=function(t){return new c(this,t)},l.prototype.keyFromPrivate=function(t,e){return c.fromPrivate(this,t,e)},l.prototype.keyFromPublic=function(t,e){return c.fromPublic(this,t,e)},l.prototype.genKeyPair=function(t){t||(t={});for(var e=new i({hash:this.hash,pers:t.pers,persEnc:t.persEnc||"utf8",entropy:t.entropy||s(this.hash.hmacStrength),entropyEnc:t.entropy&&t.entropyEnc||"utf8",nonce:this.n.toArray()}),n=this.n.byteLength(),o=this.n.sub(new r(2));;){var a=new r(e.generate(n));if(!(a.cmp(o)>0))return a.iaddn(1),this.keyFromPrivate(a)}},l.prototype._truncateToN=function(t,e){var n=8*t.byteLength()-this.n.bitLength();return n>0&&(t=t.ushrn(n)),!e&&t.cmp(this.n)>=0?t.sub(this.n):t},l.prototype.sign=function(t,e,n,o){"object"==typeof n&&(o=n,n=null),o||(o={}),e=this.keyFromPrivate(e,n),t=this._truncateToN(new r(t,16));for(var a=this.n.byteLength(),s=e.getPrivate().toArray("be",a),u=t.toArray("be",a),c=new i({hash:this.hash,entropy:s,nonce:u,pers:o.pers,persEnc:o.persEnc||"utf8"}),l=this.n.sub(new r(1)),h=0;;h++){var d=o.k?o.k(h):new r(c.generate(this.n.byteLength()));if(!((d=this._truncateToN(d,!0)).cmpn(1)<=0||d.cmp(l)>=0)){var p=this.g.mul(d);if(!p.isInfinity()){var g=p.getX(),y=g.umod(this.n);if(0!==y.cmpn(0)){var b=d.invm(this.n).mul(y.mul(e.getPrivate()).iadd(t));if(0!==(b=b.umod(this.n)).cmpn(0)){var m=(p.getY().isOdd()?1:0)|(0!==g.cmp(y)?2:0);return o.canonical&&b.cmp(this.nh)>0&&(b=this.n.sub(b),m^=1),new f({r:y,s:b,recoveryParam:m})}}}}}},l.prototype.verify=function(t,e,n,i){t=this._truncateToN(new r(t,16)),n=this.keyFromPublic(n,i);var o=(e=new f(e,"hex")).r,a=e.s;if(o.cmpn(1)<0||o.cmp(this.n)>=0)return!1;if(a.cmpn(1)<0||a.cmp(this.n)>=0)return!1;var s,u=a.invm(this.n),c=u.mul(t).umod(this.n),l=u.mul(o).umod(this.n);return this.curve._maxwellTrick?!(s=this.g.jmulAdd(c,n.getPublic(),l)).isInfinity()&&s.eqXToP(o):!(s=this.g.mulAdd(c,n.getPublic(),l)).isInfinity()&&0===s.getX().umod(this.n).cmp(o)},l.prototype.recoverPubKey=function(t,e,n,i){u((3&n)===n,"The recovery param is more than two bits"),e=new f(e,i);var o=this.n,a=new r(t),s=e.r,c=e.s,l=1&n,h=n>>1;if(s.cmp(this.curve.p.umod(this.curve.n))>=0&&h)throw new Error("Unable to find sencond key candinate");s=h?this.curve.pointFromX(s.add(this.curve.n),l):this.curve.pointFromX(s,l);var d=e.r.invm(o),p=o.sub(a).mul(d).umod(o),g=c.mul(d).umod(o);return this.g.mulAdd(p,s,g)},l.prototype.getKeyRecoveryParam=function(t,e,n,r){if(null!==(e=new f(e,r)).recoveryParam)return e.recoveryParam;for(var i=0;i<4;i++){var o;try{o=this.recoverPubKey(t,e,i)}catch(t){continue}if(o.eq(n))return i}throw new Error("Unable to find valid recovery factor")}},function(t,e,n){"use strict";var r=n(127),i=n(213),o=n(15);function a(t){if(!(this instanceof a))return new a(t);this.hash=t.hash,this.predResist=!!t.predResist,this.outLen=this.hash.outSize,this.minEntropy=t.minEntropy||this.hash.hmacStrength,this._reseed=null,this.reseedInterval=null,this.K=null,this.V=null;var e=i.toArray(t.entropy,t.entropyEnc||"hex"),n=i.toArray(t.nonce,t.nonceEnc||"hex"),r=i.toArray(t.pers,t.persEnc||"hex");o(e.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._init(e,n,r)}t.exports=a,a.prototype._init=function(t,e,n){var r=t.concat(e).concat(n);this.K=new Array(this.outLen/8),this.V=new Array(this.outLen/8);for(var i=0;i<this.V.length;i++)this.K[i]=0,this.V[i]=1;this._update(r),this._reseed=1,this.reseedInterval=281474976710656},a.prototype._hmac=function(){return new r.hmac(this.hash,this.K)},a.prototype._update=function(t){var e=this._hmac().update(this.V).update([0]);t&&(e=e.update(t)),this.K=e.digest(),this.V=this._hmac().update(this.V).digest(),t&&(this.K=this._hmac().update(this.V).update([1]).update(t).digest(),this.V=this._hmac().update(this.V).digest())},a.prototype.reseed=function(t,e,n,r){"string"!=typeof e&&(r=n,n=e,e=null),t=i.toArray(t,e),n=i.toArray(n,r),o(t.length>=this.minEntropy/8,"Not enough entropy. Minimum is: "+this.minEntropy+" bits"),this._update(t.concat(n||[])),this._reseed=1},a.prototype.generate=function(t,e,n,r){if(this._reseed>this.reseedInterval)throw new Error("Reseed is required");"string"!=typeof e&&(r=n,n=e,e=null),n&&(n=i.toArray(n,r||"hex"),this._update(n));for(var o=[];o.length<t;)this.V=this._hmac().update(this.V).digest(),o=o.concat(this.V);var a=o.slice(0,t);return this._update(n),this._reseed++,i.encode(a,e)}},function(t,e,n){"use strict";var r=n(5),i=n(16).assert;function o(t,e){this.ec=t,this.priv=null,this.pub=null,e.priv&&this._importPrivate(e.priv,e.privEnc),e.pub&&this._importPublic(e.pub,e.pubEnc)}t.exports=o,o.fromPublic=function(t,e,n){return e instanceof o?e:new o(t,{pub:e,pubEnc:n})},o.fromPrivate=function(t,e,n){return e instanceof o?e:new o(t,{priv:e,privEnc:n})},o.prototype.validate=function(){var t=this.getPublic();return t.isInfinity()?{result:!1,reason:"Invalid public key"}:t.validate()?t.mul(this.ec.curve.n).isInfinity()?{result:!0,reason:null}:{result:!1,reason:"Public key * N != O"}:{result:!1,reason:"Public key is not a point"}},o.prototype.getPublic=function(t,e){return"string"==typeof t&&(e=t,t=null),this.pub||(this.pub=this.ec.g.mul(this.priv)),e?this.pub.encode(e,t):this.pub},o.prototype.getPrivate=function(t){return"hex"===t?this.priv.toString(16,2):this.priv},o.prototype._importPrivate=function(t,e){this.priv=new r(t,e||16),this.priv=this.priv.umod(this.ec.curve.n)},o.prototype._importPublic=function(t,e){if(t.x||t.y)return"mont"===this.ec.curve.type?i(t.x,"Need x coordinate"):"short"!==this.ec.curve.type&&"edwards"!==this.ec.curve.type||i(t.x&&t.y,"Need both x and y coordinate"),void(this.pub=this.ec.curve.point(t.x,t.y));this.pub=this.ec.curve.decodePoint(t,e)},o.prototype.derive=function(t){return t.mul(this.priv).getX()},o.prototype.sign=function(t,e,n){return this.ec.sign(t,this,e,n)},o.prototype.verify=function(t,e){return this.ec.verify(t,e,this)},o.prototype.inspect=function(){return"<Key priv: "+(this.priv&&this.priv.toString(16,2))+" pub: "+(this.pub&&this.pub.inspect())+" >"}},function(t,e,n){"use strict";var r=n(5),i=n(16),o=i.assert;function a(t,e){if(t instanceof a)return t;this._importDER(t,e)||(o(t.r&&t.s,"Signature without r or s"),this.r=new r(t.r,16),this.s=new r(t.s,16),void 0===t.recoveryParam?this.recoveryParam=null:this.recoveryParam=t.recoveryParam)}function s(){this.place=0}function u(t,e){var n=t[e.place++];if(!(128&n))return n;for(var r=15&n,i=0,o=0,a=e.place;o<r;o++,a++)i<<=8,i|=t[a];return e.place=a,i}function c(t){for(var e=0,n=t.length-1;!t[e]&&!(128&t[e+1])&&e<n;)e++;return 0===e?t:t.slice(e)}function f(t,e){if(e<128)t.push(e);else{var n=1+(Math.log(e)/Math.LN2>>>3);for(t.push(128|n);--n;)t.push(e>>>(n<<3)&255);t.push(e)}}t.exports=a,a.prototype._importDER=function(t,e){t=i.toArray(t,e);var n=new s;if(48!==t[n.place++])return!1;if(u(t,n)+n.place!==t.length)return!1;if(2!==t[n.place++])return!1;var o=u(t,n),a=t.slice(n.place,o+n.place);if(n.place+=o,2!==t[n.place++])return!1;var c=u(t,n);if(t.length!==c+n.place)return!1;var f=t.slice(n.place,c+n.place);return 0===a[0]&&128&a[1]&&(a=a.slice(1)),0===f[0]&&128&f[1]&&(f=f.slice(1)),this.r=new r(a),this.s=new r(f),this.recoveryParam=null,!0},a.prototype.toDER=function(t){var e=this.r.toArray(),n=this.s.toArray();for(128&e[0]&&(e=[0].concat(e)),128&n[0]&&(n=[0].concat(n)),e=c(e),n=c(n);!(n[0]||128&n[1]);)n=n.slice(1);var r=[2];f(r,e.length),(r=r.concat(e)).push(2),f(r,n.length);var o=r.concat(n),a=[48];return f(a,o.length),a=a.concat(o),i.encode(a,t)}},function(t,e,n){"use strict";var r=n(127),i=n(126),o=n(16),a=o.assert,s=o.parseBytes,u=n(479),c=n(480);function f(t){if(a("ed25519"===t,"only tested with ed25519 so far"),!(this instanceof f))return new f(t);t=i[t].curve;this.curve=t,this.g=t.g,this.g.precompute(t.n.bitLength()+1),this.pointClass=t.point().constructor,this.encodingLength=Math.ceil(t.n.bitLength()/8),this.hash=r.sha512}t.exports=f,f.prototype.sign=function(t,e){t=s(t);var n=this.keyFromSecret(e),r=this.hashInt(n.messagePrefix(),t),i=this.g.mul(r),o=this.encodePoint(i),a=this.hashInt(o,n.pubBytes(),t).mul(n.priv()),u=r.add(a).umod(this.curve.n);return this.makeSignature({R:i,S:u,Rencoded:o})},f.prototype.verify=function(t,e,n){t=s(t),e=this.makeSignature(e);var r=this.keyFromPublic(n),i=this.hashInt(e.Rencoded(),r.pubBytes(),t),o=this.g.mul(e.S());return e.R().add(r.pub().mul(i)).eq(o)},f.prototype.hashInt=function(){for(var t=this.hash(),e=0;e<arguments.length;e++)t.update(arguments[e]);return o.intFromLE(t.digest()).umod(this.curve.n)},f.prototype.keyFromPublic=function(t){return u.fromPublic(this,t)},f.prototype.keyFromSecret=function(t){return u.fromSecret(this,t)},f.prototype.makeSignature=function(t){return t instanceof c?t:new c(this,t)},f.prototype.encodePoint=function(t){var e=t.getY().toArray("le",this.encodingLength);return e[this.encodingLength-1]|=t.getX().isOdd()?128:0,e},f.prototype.decodePoint=function(t){var e=(t=o.parseBytes(t)).length-1,n=t.slice(0,e).concat(-129&t[e]),r=0!=(128&t[e]),i=o.intFromLE(n);return this.curve.pointFromY(i,r)},f.prototype.encodeInt=function(t){return t.toArray("le",this.encodingLength)},f.prototype.decodeInt=function(t){return o.intFromLE(t)},f.prototype.isPoint=function(t){return t instanceof this.pointClass}},function(t,e,n){"use strict";var r=n(16),i=r.assert,o=r.parseBytes,a=r.cachedProperty;function s(t,e){this.eddsa=t,this._secret=o(e.secret),t.isPoint(e.pub)?this._pub=e.pub:this._pubBytes=o(e.pub)}s.fromPublic=function(t,e){return e instanceof s?e:new s(t,{pub:e})},s.fromSecret=function(t,e){return e instanceof s?e:new s(t,{secret:e})},s.prototype.secret=function(){return this._secret},a(s,"pubBytes",(function(){return this.eddsa.encodePoint(this.pub())})),a(s,"pub",(function(){return this._pubBytes?this.eddsa.decodePoint(this._pubBytes):this.eddsa.g.mul(this.priv())})),a(s,"privBytes",(function(){var t=this.eddsa,e=this.hash(),n=t.encodingLength-1,r=e.slice(0,t.encodingLength);return r[0]&=248,r[n]&=127,r[n]|=64,r})),a(s,"priv",(function(){return this.eddsa.decodeInt(this.privBytes())})),a(s,"hash",(function(){return this.eddsa.hash().update(this.secret()).digest()})),a(s,"messagePrefix",(function(){return this.hash().slice(this.eddsa.encodingLength)})),s.prototype.sign=function(t){return i(this._secret,"KeyPair can only verify"),this.eddsa.sign(t,this)},s.prototype.verify=function(t,e){return this.eddsa.verify(t,e,this)},s.prototype.getSecret=function(t){return i(this._secret,"KeyPair is public only"),r.encode(this.secret(),t)},s.prototype.getPublic=function(t){return r.encode(this.pubBytes(),t)},t.exports=s},function(t,e,n){"use strict";var r=n(5),i=n(16),o=i.assert,a=i.cachedProperty,s=i.parseBytes;function u(t,e){this.eddsa=t,"object"!=typeof e&&(e=s(e)),Array.isArray(e)&&(e={R:e.slice(0,t.encodingLength),S:e.slice(t.encodingLength)}),o(e.R&&e.S,"Signature without R or S"),t.isPoint(e.R)&&(this._R=e.R),e.S instanceof r&&(this._S=e.S),this._Rencoded=Array.isArray(e.R)?e.R:e.Rencoded,this._Sencoded=Array.isArray(e.S)?e.S:e.Sencoded}a(u,"S",(function(){return this.eddsa.decodeInt(this.Sencoded())})),a(u,"R",(function(){return this.eddsa.decodePoint(this.Rencoded())})),a(u,"Rencoded",(function(){return this.eddsa.encodePoint(this.R())})),a(u,"Sencoded",(function(){return this.eddsa.encodeInt(this.S())})),u.prototype.toBytes=function(){return this.Rencoded().concat(this.Sencoded())},u.prototype.toHex=function(){return i.encode(this.toBytes(),"hex").toUpperCase()},t.exports=u},function(t,e,n){"use strict";var r=n(57);e.certificate=n(491);var i=r.define("RSAPrivateKey",(function(){this.seq().obj(this.key("version").int(),this.key("modulus").int(),this.key("publicExponent").int(),this.key("privateExponent").int(),this.key("prime1").int(),this.key("prime2").int(),this.key("exponent1").int(),this.key("exponent2").int(),this.key("coefficient").int())}));e.RSAPrivateKey=i;var o=r.define("RSAPublicKey",(function(){this.seq().obj(this.key("modulus").int(),this.key("publicExponent").int())}));e.RSAPublicKey=o;var a=r.define("SubjectPublicKeyInfo",(function(){this.seq().obj(this.key("algorithm").use(s),this.key("subjectPublicKey").bitstr())}));e.PublicKey=a;var s=r.define("AlgorithmIdentifier",(function(){this.seq().obj(this.key("algorithm").objid(),this.key("none").null_().optional(),this.key("curve").objid().optional(),this.key("params").seq().obj(this.key("p").int(),this.key("q").int(),this.key("g").int()).optional())})),u=r.define("PrivateKeyInfo",(function(){this.seq().obj(this.key("version").int(),this.key("algorithm").use(s),this.key("subjectPrivateKey").octstr())}));e.PrivateKey=u;var c=r.define("EncryptedPrivateKeyInfo",(function(){this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(),this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(),this.key("kdeparams").seq().obj(this.key("salt").octstr(),this.key("iters").int())),this.key("cipher").seq().obj(this.key("algo").objid(),this.key("iv").octstr()))),this.key("subjectPrivateKey").octstr())}));e.EncryptedPrivateKey=c;var f=r.define("DSAPrivateKey",(function(){this.seq().obj(this.key("version").int(),this.key("p").int(),this.key("q").int(),this.key("g").int(),this.key("pub_key").int(),this.key("priv_key").int())}));e.DSAPrivateKey=f,e.DSAparam=r.define("DSAparam",(function(){this.int()}));var l=r.define("ECPrivateKey",(function(){this.seq().obj(this.key("version").int(),this.key("privateKey").octstr(),this.key("parameters").optional().explicit(0).use(h),this.key("publicKey").optional().explicit(1).bitstr())}));e.ECPrivateKey=l;var h=r.define("ECParameters",(function(){this.choice({namedCurve:this.objid()})}));e.signature=r.define("signature",(function(){this.seq().obj(this.key("r").int(),this.key("s").int())}))},function(t,e,n){var r=n(57),i=n(2);function o(t,e){this.name=t,this.body=e,this.decoders={},this.encoders={}}e.define=function(t,e){return new o(t,e)},o.prototype._createNamed=function(t){var e;try{e=n(483).runInThisContext("(function "+this.name+"(entity) {\n  this._initNamed(entity);\n})")}catch(t){e=function(t){this._initNamed(t)}}return i(e,t),e.prototype._initNamed=function(e){t.call(this,e)},new e(this)},o.prototype._getDecoder=function(t){return t=t||"der",this.decoders.hasOwnProperty(t)||(this.decoders[t]=this._createNamed(r.decoders[t])),this.decoders[t]},o.prototype.decode=function(t,e,n){return this._getDecoder(e).decode(t,n)},o.prototype._getEncoder=function(t){return t=t||"der",this.encoders.hasOwnProperty(t)||(this.encoders[t]=this._createNamed(r.encoders[t])),this.encoders[t]},o.prototype.encode=function(t,e,n){return this._getEncoder(e).encode(t,n)}},function(module,exports){var indexOf=function(t,e){if(t.indexOf)return t.indexOf(e);for(var n=0;n<t.length;n++)if(t[n]===e)return n;return-1},Object_keys=function(t){if(Object.keys)return Object.keys(t);var e=[];for(var n in t)e.push(n);return e},forEach=function(t,e){if(t.forEach)return t.forEach(e);for(var n=0;n<t.length;n++)e(t[n],n,t)},defineProp=function(){try{return Object.defineProperty({},"_",{}),function(t,e,n){Object.defineProperty(t,e,{writable:!0,enumerable:!1,configurable:!0,value:n})}}catch(t){return function(t,e,n){t[e]=n}}}(),globals=["Array","Boolean","Date","Error","EvalError","Function","Infinity","JSON","Math","NaN","Number","Object","RangeError","ReferenceError","RegExp","String","SyntaxError","TypeError","URIError","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","eval","isFinite","isNaN","parseFloat","parseInt","undefined","unescape"];function Context(){}Context.prototype={};var Script=exports.Script=function(t){if(!(this instanceof Script))return new Script(t);this.code=t};Script.prototype.runInContext=function(t){if(!(t instanceof Context))throw new TypeError("needs a 'context' argument.");var e=document.createElement("iframe");e.style||(e.style={}),e.style.display="none",document.body.appendChild(e);var n=e.contentWindow,r=n.eval,i=n.execScript;!r&&i&&(i.call(n,"null"),r=n.eval),forEach(Object_keys(t),(function(e){n[e]=t[e]})),forEach(globals,(function(e){t[e]&&(n[e]=t[e])}));var o=Object_keys(n),a=r.call(n,this.code);return forEach(Object_keys(n),(function(e){(e in t||-1===indexOf(o,e))&&(t[e]=n[e])})),forEach(globals,(function(e){e in t||defineProp(t,e,n[e])})),document.body.removeChild(e),a},Script.prototype.runInThisContext=function(){return eval(this.code)},Script.prototype.runInNewContext=function(t){var e=Script.createContext(t),n=this.runInContext(e);return t&&forEach(Object_keys(e),(function(n){t[n]=e[n]})),n},forEach(Object_keys(Script.prototype),(function(t){exports[t]=Script[t]=function(e){var n=Script(e);return n[t].apply(n,[].slice.call(arguments,1))}})),exports.isContext=function(t){return t instanceof Context},exports.createScript=function(t){return exports.Script(t)},exports.createContext=Script.createContext=function(t){var e=new Context;return"object"==typeof t&&forEach(Object_keys(t),(function(n){e[n]=t[n]})),e}},function(t,e,n){var r=n(2);function i(t){this._reporterState={obj:null,path:[],options:t||{},errors:[]}}function o(t,e){this.path=t,this.rethrow(e)}e.Reporter=i,i.prototype.isError=function(t){return t instanceof o},i.prototype.save=function(){var t=this._reporterState;return{obj:t.obj,pathLen:t.path.length}},i.prototype.restore=function(t){var e=this._reporterState;e.obj=t.obj,e.path=e.path.slice(0,t.pathLen)},i.prototype.enterKey=function(t){return this._reporterState.path.push(t)},i.prototype.exitKey=function(t){var e=this._reporterState;e.path=e.path.slice(0,t-1)},i.prototype.leaveKey=function(t,e,n){var r=this._reporterState;this.exitKey(t),null!==r.obj&&(r.obj[e]=n)},i.prototype.path=function(){return this._reporterState.path.join("/")},i.prototype.enterObject=function(){var t=this._reporterState,e=t.obj;return t.obj={},e},i.prototype.leaveObject=function(t){var e=this._reporterState,n=e.obj;return e.obj=t,n},i.prototype.error=function(t){var e,n=this._reporterState,r=t instanceof o;if(e=r?t:new o(n.path.map((function(t){return"["+JSON.stringify(t)+"]"})).join(""),t.message||t,t.stack),!n.options.partial)throw e;return r||n.errors.push(e),e},i.prototype.wrapResult=function(t){var e=this._reporterState;return e.options.partial?{result:this.isError(t)?null:t,errors:e.errors}:t},r(o,Error),o.prototype.rethrow=function(t){if(this.message=t+" at: "+(this.path||"(shallow)"),Error.captureStackTrace&&Error.captureStackTrace(this,o),!this.stack)try{throw new Error(this.message)}catch(t){this.stack=t.stack}return this}},function(t,e,n){var r=n(58).Reporter,i=n(58).EncoderBuffer,o=n(58).DecoderBuffer,a=n(15),s=["seq","seqof","set","setof","objid","bool","gentime","utctime","null_","enum","int","objDesc","bitstr","bmpstr","charstr","genstr","graphstr","ia5str","iso646str","numstr","octstr","printstr","t61str","unistr","utf8str","videostr"],u=["key","obj","use","optional","explicit","implicit","def","choice","any","contains"].concat(s);function c(t,e){var n={};this._baseState=n,n.enc=t,n.parent=e||null,n.children=null,n.tag=null,n.args=null,n.reverseArgs=null,n.choice=null,n.optional=!1,n.any=!1,n.obj=!1,n.use=null,n.useDecoder=null,n.key=null,n.default=null,n.explicit=null,n.implicit=null,n.contains=null,n.parent||(n.children=[],this._wrap())}t.exports=c;var f=["enc","parent","children","tag","args","reverseArgs","choice","optional","any","obj","use","alteredUse","key","default","explicit","implicit","contains"];c.prototype.clone=function(){var t=this._baseState,e={};f.forEach((function(n){e[n]=t[n]}));var n=new this.constructor(e.parent);return n._baseState=e,n},c.prototype._wrap=function(){var t=this._baseState;u.forEach((function(e){this[e]=function(){var n=new this.constructor(this);return t.children.push(n),n[e].apply(n,arguments)}}),this)},c.prototype._init=function(t){var e=this._baseState;a(null===e.parent),t.call(this),e.children=e.children.filter((function(t){return t._baseState.parent===this}),this),a.equal(e.children.length,1,"Root node can have only one child")},c.prototype._useArgs=function(t){var e=this._baseState,n=t.filter((function(t){return t instanceof this.constructor}),this);t=t.filter((function(t){return!(t instanceof this.constructor)}),this),0!==n.length&&(a(null===e.children),e.children=n,n.forEach((function(t){t._baseState.parent=this}),this)),0!==t.length&&(a(null===e.args),e.args=t,e.reverseArgs=t.map((function(t){if("object"!=typeof t||t.constructor!==Object)return t;var e={};return Object.keys(t).forEach((function(n){n==(0|n)&&(n|=0);var r=t[n];e[r]=n})),e})))},["_peekTag","_decodeTag","_use","_decodeStr","_decodeObjid","_decodeTime","_decodeNull","_decodeInt","_decodeBool","_decodeList","_encodeComposite","_encodeStr","_encodeObjid","_encodeTime","_encodeNull","_encodeInt","_encodeBool"].forEach((function(t){c.prototype[t]=function(){var e=this._baseState;throw new Error(t+" not implemented for encoding: "+e.enc)}})),s.forEach((function(t){c.prototype[t]=function(){var e=this._baseState,n=Array.prototype.slice.call(arguments);return a(null===e.tag),e.tag=t,this._useArgs(n),this}})),c.prototype.use=function(t){a(t);var e=this._baseState;return a(null===e.use),e.use=t,this},c.prototype.optional=function(){return this._baseState.optional=!0,this},c.prototype.def=function(t){var e=this._baseState;return a(null===e.default),e.default=t,e.optional=!0,this},c.prototype.explicit=function(t){var e=this._baseState;return a(null===e.explicit&&null===e.implicit),e.explicit=t,this},c.prototype.implicit=function(t){var e=this._baseState;return a(null===e.explicit&&null===e.implicit),e.implicit=t,this},c.prototype.obj=function(){var t=this._baseState,e=Array.prototype.slice.call(arguments);return t.obj=!0,0!==e.length&&this._useArgs(e),this},c.prototype.key=function(t){var e=this._baseState;return a(null===e.key),e.key=t,this},c.prototype.any=function(){return this._baseState.any=!0,this},c.prototype.choice=function(t){var e=this._baseState;return a(null===e.choice),e.choice=t,this._useArgs(Object.keys(t).map((function(e){return t[e]}))),this},c.prototype.contains=function(t){var e=this._baseState;return a(null===e.use),e.contains=t,this},c.prototype._decode=function(t,e){var n=this._baseState;if(null===n.parent)return t.wrapResult(n.children[0]._decode(t,e));var r,i=n.default,a=!0,s=null;if(null!==n.key&&(s=t.enterKey(n.key)),n.optional){var u=null;if(null!==n.explicit?u=n.explicit:null!==n.implicit?u=n.implicit:null!==n.tag&&(u=n.tag),null!==u||n.any){if(a=this._peekTag(t,u,n.any),t.isError(a))return a}else{var c=t.save();try{null===n.choice?this._decodeGeneric(n.tag,t,e):this._decodeChoice(t,e),a=!0}catch(t){a=!1}t.restore(c)}}if(n.obj&&a&&(r=t.enterObject()),a){if(null!==n.explicit){var f=this._decodeTag(t,n.explicit);if(t.isError(f))return f;t=f}var l=t.offset;if(null===n.use&&null===n.choice){if(n.any)c=t.save();var h=this._decodeTag(t,null!==n.implicit?n.implicit:n.tag,n.any);if(t.isError(h))return h;n.any?i=t.raw(c):t=h}if(e&&e.track&&null!==n.tag&&e.track(t.path(),l,t.length,"tagged"),e&&e.track&&null!==n.tag&&e.track(t.path(),t.offset,t.length,"content"),i=n.any?i:null===n.choice?this._decodeGeneric(n.tag,t,e):this._decodeChoice(t,e),t.isError(i))return i;if(n.any||null!==n.choice||null===n.children||n.children.forEach((function(n){n._decode(t,e)})),n.contains&&("octstr"===n.tag||"bitstr"===n.tag)){var d=new o(i);i=this._getUse(n.contains,t._reporterState.obj)._decode(d,e)}}return n.obj&&a&&(i=t.leaveObject(r)),null===n.key||null===i&&!0!==a?null!==s&&t.exitKey(s):t.leaveKey(s,n.key,i),i},c.prototype._decodeGeneric=function(t,e,n){var r=this._baseState;return"seq"===t||"set"===t?null:"seqof"===t||"setof"===t?this._decodeList(e,t,r.args[0],n):/str$/.test(t)?this._decodeStr(e,t,n):"objid"===t&&r.args?this._decodeObjid(e,r.args[0],r.args[1],n):"objid"===t?this._decodeObjid(e,null,null,n):"gentime"===t||"utctime"===t?this._decodeTime(e,t,n):"null_"===t?this._decodeNull(e,n):"bool"===t?this._decodeBool(e,n):"objDesc"===t?this._decodeStr(e,t,n):"int"===t||"enum"===t?this._decodeInt(e,r.args&&r.args[0],n):null!==r.use?this._getUse(r.use,e._reporterState.obj)._decode(e,n):e.error("unknown tag: "+t)},c.prototype._getUse=function(t,e){var n=this._baseState;return n.useDecoder=this._use(t,e),a(null===n.useDecoder._baseState.parent),n.useDecoder=n.useDecoder._baseState.children[0],n.implicit!==n.useDecoder._baseState.implicit&&(n.useDecoder=n.useDecoder.clone(),n.useDecoder._baseState.implicit=n.implicit),n.useDecoder},c.prototype._decodeChoice=function(t,e){var n=this._baseState,r=null,i=!1;return Object.keys(n.choice).some((function(o){var a=t.save(),s=n.choice[o];try{var u=s._decode(t,e);if(t.isError(u))return!1;r={type:o,value:u},i=!0}catch(e){return t.restore(a),!1}return!0}),this),i?r:t.error("Choice not matched")},c.prototype._createEncoderBuffer=function(t){return new i(t,this.reporter)},c.prototype._encode=function(t,e,n){var r=this._baseState;if(null===r.default||r.default!==t){var i=this._encodeValue(t,e,n);if(void 0!==i&&!this._skipDefault(i,e,n))return i}},c.prototype._encodeValue=function(t,e,n){var i=this._baseState;if(null===i.parent)return i.children[0]._encode(t,e||new r);var o=null;if(this.reporter=e,i.optional&&void 0===t){if(null===i.default)return;t=i.default}var a=null,s=!1;if(i.any)o=this._createEncoderBuffer(t);else if(i.choice)o=this._encodeChoice(t,e);else if(i.contains)a=this._getUse(i.contains,n)._encode(t,e),s=!0;else if(i.children)a=i.children.map((function(n){if("null_"===n._baseState.tag)return n._encode(null,e,t);if(null===n._baseState.key)return e.error("Child should have a key");var r=e.enterKey(n._baseState.key);if("object"!=typeof t)return e.error("Child expected, but input is not object");var i=n._encode(t[n._baseState.key],e,t);return e.leaveKey(r),i}),this).filter((function(t){return t})),a=this._createEncoderBuffer(a);else if("seqof"===i.tag||"setof"===i.tag){if(!i.args||1!==i.args.length)return e.error("Too many args for : "+i.tag);if(!Array.isArray(t))return e.error("seqof/setof, but data is not Array");var u=this.clone();u._baseState.implicit=null,a=this._createEncoderBuffer(t.map((function(n){var r=this._baseState;return this._getUse(r.args[0],t)._encode(n,e)}),u))}else null!==i.use?o=this._getUse(i.use,n)._encode(t,e):(a=this._encodePrimitive(i.tag,t),s=!0);if(!i.any&&null===i.choice){var c=null!==i.implicit?i.implicit:i.tag,f=null===i.implicit?"universal":"context";null===c?null===i.use&&e.error("Tag could be omitted only for .use()"):null===i.use&&(o=this._encodeComposite(c,s,f,a))}return null!==i.explicit&&(o=this._encodeComposite(i.explicit,!1,"context",o)),o},c.prototype._encodeChoice=function(t,e){var n=this._baseState,r=n.choice[t.type];return r||a(!1,t.type+" not found in "+JSON.stringify(Object.keys(n.choice))),r._encode(t.value,e)},c.prototype._encodePrimitive=function(t,e){var n=this._baseState;if(/str$/.test(t))return this._encodeStr(e,t);if("objid"===t&&n.args)return this._encodeObjid(e,n.reverseArgs[0],n.args[1]);if("objid"===t)return this._encodeObjid(e,null,null);if("gentime"===t||"utctime"===t)return this._encodeTime(e,t);if("null_"===t)return this._encodeNull();if("int"===t||"enum"===t)return this._encodeInt(e,n.args&&n.reverseArgs[0]);if("bool"===t)return this._encodeBool(e);if("objDesc"===t)return this._encodeStr(e,t);throw new Error("Unsupported tag: "+t)},c.prototype._isNumstr=function(t){return/^[0-9 ]*$/.test(t)},c.prototype._isPrintstr=function(t){return/^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(t)}},function(t,e,n){var r=n(219);e.tagClass={0:"universal",1:"application",2:"context",3:"private"},e.tagClassByName=r._reverse(e.tagClass),e.tag={0:"end",1:"bool",2:"int",3:"bitstr",4:"octstr",5:"null_",6:"objid",7:"objDesc",8:"external",9:"real",10:"enum",11:"embed",12:"utf8str",13:"relativeOid",16:"seq",17:"set",18:"numstr",19:"printstr",20:"t61str",21:"videostr",22:"ia5str",23:"utctime",24:"gentime",25:"graphstr",26:"iso646str",27:"genstr",28:"unistr",29:"charstr",30:"bmpstr"},e.tagByName=r._reverse(e.tag)},function(t,e,n){var r=e;r.der=n(220),r.pem=n(488)},function(t,e,n){var r=n(2),i=n(8).Buffer,o=n(220);function a(t){o.call(this,t),this.enc="pem"}r(a,o),t.exports=a,a.prototype.decode=function(t,e){for(var n=t.toString().split(/[\r\n]+/g),r=e.label.toUpperCase(),a=/^-----(BEGIN|END) ([^-]+)-----$/,s=-1,u=-1,c=0;c<n.length;c++){var f=n[c].match(a);if(null!==f&&f[2]===r){if(-1!==s){if("END"!==f[1])break;u=c;break}if("BEGIN"!==f[1])break;s=c}}if(-1===s||-1===u)throw new Error("PEM section not found for: "+r);var l=n.slice(s+1,u).join("");l.replace(/[^a-z0-9\+\/=]+/gi,"");var h=new i(l,"base64");return o.prototype.decode.call(this,h,e)}},function(t,e,n){var r=e;r.der=n(221),r.pem=n(490)},function(t,e,n){var r=n(2),i=n(221);function o(t){i.call(this,t),this.enc="pem"}r(o,i),t.exports=o,o.prototype.encode=function(t,e){for(var n=i.prototype.encode.call(this,t).toString("base64"),r=["-----BEGIN "+e.label+"-----"],o=0;o<n.length;o+=64)r.push(n.slice(o,o+64));return r.push("-----END "+e.label+"-----"),r.join("\n")}},function(t,e,n){"use strict";var r=n(57),i=r.define("Time",(function(){this.choice({utcTime:this.utctime(),generalTime:this.gentime()})})),o=r.define("AttributeTypeValue",(function(){this.seq().obj(this.key("type").objid(),this.key("value").any())})),a=r.define("AlgorithmIdentifier",(function(){this.seq().obj(this.key("algorithm").objid(),this.key("parameters").optional(),this.key("curve").objid().optional())})),s=r.define("SubjectPublicKeyInfo",(function(){this.seq().obj(this.key("algorithm").use(a),this.key("subjectPublicKey").bitstr())})),u=r.define("RelativeDistinguishedName",(function(){this.setof(o)})),c=r.define("RDNSequence",(function(){this.seqof(u)})),f=r.define("Name",(function(){this.choice({rdnSequence:this.use(c)})})),l=r.define("Validity",(function(){this.seq().obj(this.key("notBefore").use(i),this.key("notAfter").use(i))})),h=r.define("Extension",(function(){this.seq().obj(this.key("extnID").objid(),this.key("critical").bool().def(!1),this.key("extnValue").octstr())})),d=r.define("TBSCertificate",(function(){this.seq().obj(this.key("version").explicit(0).int().optional(),this.key("serialNumber").int(),this.key("signature").use(a),this.key("issuer").use(f),this.key("validity").use(l),this.key("subject").use(f),this.key("subjectPublicKeyInfo").use(s),this.key("issuerUniqueID").implicit(1).bitstr().optional(),this.key("subjectUniqueID").implicit(2).bitstr().optional(),this.key("extensions").explicit(3).seqof(h).optional())})),p=r.define("X509Certificate",(function(){this.seq().obj(this.key("tbsCertificate").use(d),this.key("signatureAlgorithm").use(a),this.key("signatureValue").bitstr())}));t.exports=p},function(t){t.exports=JSON.parse('{"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}')},function(t,e,n){var r=/Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/\=]+)[\n\r]+/m,i=/^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m,o=/^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/\=]+)-----END \1-----$/m,a=n(80),s=n(121),u=n(3).Buffer;t.exports=function(t,e){var n,c=t.toString(),f=c.match(r);if(f){var l="aes"+f[1],h=u.from(f[2],"hex"),d=u.from(f[3].replace(/[\r\n]/g,""),"base64"),p=a(e,h.slice(0,8),parseInt(f[1],10)).key,g=[],y=s.createDecipheriv(l,p,h);g.push(y.update(d)),g.push(y.final()),n=u.concat(g)}else{var b=c.match(o);n=new u(b[2].replace(/[\r\n]/g,""),"base64")}return{tag:c.match(i)[1],data:n}}},function(t,e,n){(function(e){var r=n(5),i=n(125).ec,o=n(82),a=n(222);function s(t,e){if(t.cmpn(0)<=0)throw new Error("invalid sig");if(t.cmp(e)>=e)throw new Error("invalid sig")}t.exports=function(t,n,u,c,f){var l=o(u);if("ec"===l.type){if("ecdsa"!==c&&"ecdsa/rsa"!==c)throw new Error("wrong public key type");return function(t,e,n){var r=a[n.data.algorithm.curve.join(".")];if(!r)throw new Error("unknown curve "+n.data.algorithm.curve.join("."));var o=new i(r),s=n.data.subjectPrivateKey.data;return o.verify(e,t,s)}(t,n,l)}if("dsa"===l.type){if("dsa"!==c)throw new Error("wrong public key type");return function(t,e,n){var i=n.data.p,a=n.data.q,u=n.data.g,c=n.data.pub_key,f=o.signature.decode(t,"der"),l=f.s,h=f.r;s(l,a),s(h,a);var d=r.mont(i),p=l.invm(a);return 0===u.toRed(d).redPow(new r(e).mul(p).mod(a)).fromRed().mul(c.toRed(d).redPow(h.mul(p).mod(a)).fromRed()).mod(i).mod(a).cmp(h)}(t,n,l)}if("rsa"!==c&&"ecdsa/rsa"!==c)throw new Error("wrong public key type");n=e.concat([f,n]);for(var h=l.modulus.byteLength(),d=[1],p=0;n.length+d.length+2<h;)d.push(255),p++;d.push(0);for(var g=-1;++g<n.length;)d.push(n[g]);d=new e(d);var y=r.mont(l.modulus);t=(t=new r(t).toRed(y)).redPow(new r(l.publicExponent)),t=new e(t.fromRed().toArray());var b=p<8?1:0;for(h=Math.min(t.length,d.length),t.length!==d.length&&(b=1),g=-1;++g<h;)b|=t[g]^d[g];return 0===b}}).call(this,n(8).Buffer)},function(t,e,n){(function(e){var r=n(125),i=n(5);t.exports=function(t){return new a(t)};var o={secp256k1:{name:"secp256k1",byteLength:32},secp224r1:{name:"p224",byteLength:28},prime256v1:{name:"p256",byteLength:32},prime192v1:{name:"p192",byteLength:24},ed25519:{name:"ed25519",byteLength:32},secp384r1:{name:"p384",byteLength:48},secp521r1:{name:"p521",byteLength:66}};function a(t){this.curveType=o[t],this.curveType||(this.curveType={name:t}),this.curve=new r.ec(this.curveType.name),this.keys=void 0}function s(t,n,r){Array.isArray(t)||(t=t.toArray());var i=new e(t);if(r&&i.length<r){var o=new e(r-i.length);o.fill(0),i=e.concat([o,i])}return n?i.toString(n):i}o.p224=o.secp224r1,o.p256=o.secp256r1=o.prime256v1,o.p192=o.secp192r1=o.prime192v1,o.p384=o.secp384r1,o.p521=o.secp521r1,a.prototype.generateKeys=function(t,e){return this.keys=this.curve.genKeyPair(),this.getPublicKey(t,e)},a.prototype.computeSecret=function(t,n,r){return n=n||"utf8",e.isBuffer(t)||(t=new e(t,n)),s(this.curve.keyFromPublic(t).getPublic().mul(this.keys.getPrivate()).getX(),r,this.curveType.byteLength)},a.prototype.getPublicKey=function(t,e){var n=this.keys.getPublic("compressed"===e,!0);return"hybrid"===e&&(n[n.length-1]%2?n[0]=7:n[0]=6),s(n,t)},a.prototype.getPrivateKey=function(t){return s(this.keys.getPrivate(),t)},a.prototype.setPublicKey=function(t,n){return n=n||"utf8",e.isBuffer(t)||(t=new e(t,n)),this.keys._importPublic(t),this},a.prototype.setPrivateKey=function(t,n){n=n||"utf8",e.isBuffer(t)||(t=new e(t,n));var r=new i(t);return r=r.toString(16),this.keys=this.curve.genKeyPair(),this.keys._importPrivate(r),this}}).call(this,n(8).Buffer)},function(t,e,n){e.publicEncrypt=n(497),e.privateDecrypt=n(498),e.privateEncrypt=function(t,n){return e.publicEncrypt(t,n,!0)},e.publicDecrypt=function(t,n){return e.privateDecrypt(t,n,!0)}},function(t,e,n){var r=n(82),i=n(44),o=n(53),a=n(223),s=n(224),u=n(5),c=n(225),f=n(124),l=n(3).Buffer;t.exports=function(t,e,n){var h;h=t.padding?t.padding:n?1:4;var d,p=r(t);if(4===h)d=function(t,e){var n=t.modulus.byteLength(),r=e.length,c=o("sha1").update(l.alloc(0)).digest(),f=c.length,h=2*f;if(r>n-h-2)throw new Error("message too long");var d=l.alloc(n-r-h-2),p=n-f-1,g=i(f),y=s(l.concat([c,d,l.alloc(1,1),e],p),a(g,p)),b=s(g,a(y,f));return new u(l.concat([l.alloc(1),b,y],n))}(p,e);else if(1===h)d=function(t,e,n){var r,o=e.length,a=t.modulus.byteLength();if(o>a-11)throw new Error("message too long");r=n?l.alloc(a-o-3,255):function(t){var e,n=l.allocUnsafe(t),r=0,o=i(2*t),a=0;for(;r<t;)a===o.length&&(o=i(2*t),a=0),(e=o[a++])&&(n[r++]=e);return n}(a-o-3);return new u(l.concat([l.from([0,n?1:2]),r,l.alloc(1),e],a))}(p,e,n);else{if(3!==h)throw new Error("unknown padding");if((d=new u(e)).cmp(p.modulus)>=0)throw new Error("data too long for modulus")}return n?f(d,p):c(d,p)}},function(t,e,n){var r=n(82),i=n(223),o=n(224),a=n(5),s=n(124),u=n(53),c=n(225),f=n(3).Buffer;t.exports=function(t,e,n){var l;l=t.padding?t.padding:n?1:4;var h,d=r(t),p=d.modulus.byteLength();if(e.length>p||new a(e).cmp(d.modulus)>=0)throw new Error("decryption error");h=n?c(new a(e),d):s(e,d);var g=f.alloc(p-h.length);if(h=f.concat([g,h],p),4===l)return function(t,e){var n=t.modulus.byteLength(),r=u("sha1").update(f.alloc(0)).digest(),a=r.length;if(0!==e[0])throw new Error("decryption error");var s=e.slice(1,a+1),c=e.slice(a+1),l=o(s,i(c,a)),h=o(c,i(l,n-a-1));if(function(t,e){t=f.from(t),e=f.from(e);var n=0,r=t.length;t.length!==e.length&&(n++,r=Math.min(t.length,e.length));var i=-1;for(;++i<r;)n+=t[i]^e[i];return n}(r,h.slice(0,a)))throw new Error("decryption error");var d=a;for(;0===h[d];)d++;if(1!==h[d++])throw new Error("decryption error");return h.slice(d)}(d,h);if(1===l)return function(t,e,n){var r=e.slice(0,2),i=2,o=0;for(;0!==e[i++];)if(i>=e.length){o++;break}var a=e.slice(2,i-1);("0002"!==r.toString("hex")&&!n||"0001"!==r.toString("hex")&&n)&&o++;a.length<8&&o++;if(o)throw new Error("decryption error");return e.slice(i)}(0,h,n);if(3===l)return h;throw new Error("unknown padding")}},function(t,e,n){"use strict";(function(t,r){function i(){throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11")}var o=n(3),a=n(44),s=o.Buffer,u=o.kMaxLength,c=t.crypto||t.msCrypto,f=Math.pow(2,32)-1;function l(t,e){if("number"!=typeof t||t!=t)throw new TypeError("offset must be a number");if(t>f||t<0)throw new TypeError("offset must be a uint32");if(t>u||t>e)throw new RangeError("offset out of range")}function h(t,e,n){if("number"!=typeof t||t!=t)throw new TypeError("size must be a number");if(t>f||t<0)throw new TypeError("size must be a uint32");if(t+e>n||t>u)throw new RangeError("buffer too small")}function d(t,e,n,i){if(r.browser){var o=t.buffer,s=new Uint8Array(o,e,n);return c.getRandomValues(s),i?void r.nextTick((function(){i(null,t)})):t}if(!i)return a(n).copy(t,e),t;a(n,(function(n,r){if(n)return i(n);r.copy(t,e),i(null,t)}))}c&&c.getRandomValues||!r.browser?(e.randomFill=function(e,n,r,i){if(!(s.isBuffer(e)||e instanceof t.Uint8Array))throw new TypeError('"buf" argument must be a Buffer or Uint8Array');if("function"==typeof n)i=n,n=0,r=e.length;else if("function"==typeof r)i=r,r=e.length-n;else if("function"!=typeof i)throw new TypeError('"cb" argument must be a function');return l(n,e.length),h(r,n,e.length),d(e,n,r,i)},e.randomFillSync=function(e,n,r){void 0===n&&(n=0);if(!(s.isBuffer(e)||e instanceof t.Uint8Array))throw new TypeError('"buf" argument must be a Buffer or Uint8Array');l(n,e.length),void 0===r&&(r=e.length-n);return h(r,n,e.length),d(e,n,r)}):(e.randomFill=i,e.randomFillSync=i)}).call(this,n(11),n(7))},function(t,e,n){var r={"./dark/index.scss":501,"./default/index.scss":503,"./forest/index.scss":505,"./neutral/index.scss":507};function i(t){var e=o(t);return n(e)}function o(t){if(!n.o(r,t)){var e=new Error("Cannot find module '"+t+"'");throw e.code="MODULE_NOT_FOUND",e}return r[t]}i.keys=function(){return Object.keys(r)},i.resolve=o,t.exports=i,i.id=500},function(t,e,n){var r=n(502);t.exports="string"==typeof r?r:r.toString()},function(t,e,n){(t.exports=n(83)(!1)).push([t.i,".label{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);color:#333}.label text{fill:#333}.node rect,.node circle,.node ellipse,.node polygon{fill:#BDD5EA;stroke:purple;stroke-width:1px}.node .label{text-align:center}.node.clickable{cursor:pointer}.arrowheadPath{fill:#d3d3d3}.edgePath .path{stroke:#d3d3d3;stroke-width:1.5px}.edgeLabel{background-color:#e8e8e8;text-align:center}.cluster rect{fill:#6D6D65;stroke:rgba(255,255,255,0.25);stroke-width:1px}.cluster text{fill:#F9FFFE}div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:12px;background:#6D6D65;border:1px solid rgba(255,255,255,0.25);border-radius:2px;pointer-events:none;z-index:100}.actor{stroke:#81B1DB;fill:#BDD5EA}text.actor{fill:#000;stroke:none}.actor-line{stroke:#d3d3d3}.messageLine0{stroke-width:1.5;stroke-dasharray:'2 2';stroke:#d3d3d3}.messageLine1{stroke-width:1.5;stroke-dasharray:'2 2';stroke:#d3d3d3}#arrowhead{fill:#d3d3d3}.sequenceNumber{fill:#fff}#sequencenumber{fill:#d3d3d3}#crosshead path{fill:#d3d3d3 !important;stroke:#d3d3d3 !important}.messageText{fill:#d3d3d3;stroke:none}.labelBox{stroke:#81B1DB;fill:#BDD5EA}.labelText{fill:#323D47;stroke:none}.loopText{fill:#d3d3d3;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:'2 2';stroke:#81B1DB}.note{stroke:rgba(255,255,255,0.25);fill:#fff5ad}.noteText{fill:black;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:14px}.activation0{fill:#f4f4f4;stroke:#666}.activation1{fill:#f4f4f4;stroke:#666}.activation2{fill:#f4f4f4;stroke:#666}.mermaid-main-font{font-family:\"trebuchet ms\", verdana, arial;font-family:var(--mermaid-font-family)}.section{stroke:none;opacity:0.2}.section0{fill:rgba(255,255,255,0.3)}.section2{fill:#EAE8B9}.section1,.section3{fill:#fff;opacity:0.2}.sectionTitle0{fill:#F9FFFE}.sectionTitle1{fill:#F9FFFE}.sectionTitle2{fill:#F9FFFE}.sectionTitle3{fill:#F9FFFE}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.grid .tick{stroke:#d3d3d3;opacity:0.3;shape-rendering:crispEdges}.grid .tick text{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.grid path{stroke-width:0}.today{fill:none;stroke:#DB5757;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.taskText:not([font-size]){font-size:11px}.taskTextOutsideRight{fill:#323D47;text-anchor:start;font-size:11px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.taskTextOutsideLeft{fill:#323D47;text-anchor:end;font-size:11px}.task.clickable{cursor:pointer}.taskText.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskTextOutsideRight.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskText0,.taskText1,.taskText2,.taskText3{fill:#323D47}.task0,.task1,.task2,.task3{fill:#BDD5EA;stroke:rgba(255,255,255,0.5)}.taskTextOutside0,.taskTextOutside2{fill:#d3d3d3}.taskTextOutside1,.taskTextOutside3{fill:#d3d3d3}.active0,.active1,.active2,.active3{fill:#81B1DB;stroke:rgba(255,255,255,0.5)}.activeText0,.activeText1,.activeText2,.activeText3{fill:#323D47 !important}.done0,.done1,.done2,.done3{stroke:grey;fill:#d3d3d3;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#323D47 !important}.crit0,.crit1,.crit2,.crit3{stroke:#E83737;fill:#E83737;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#E83737;fill:#81B1DB;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#E83737;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.milestone{transform:rotate(45deg) scale(0.8, 0.8)}.milestoneText{font-style:italic}.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#323D47 !important}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3{fill:#323D47 !important}.titleText{text-anchor:middle;font-size:18px;fill:#323D47;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.classGroup text{fill:purple;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:10px}g.classGroup text .title{font-weight:bolder}g.classGroup rect{fill:#BDD5EA;stroke:purple}g.classGroup line{stroke:purple;stroke-width:1}.classLabel .box{stroke:none;stroke-width:0;fill:#BDD5EA;opacity:0.5}.classLabel .label{fill:purple;font-size:10px}.relation{stroke:purple;stroke-width:1;fill:none}#compositionStart{fill:purple;stroke:purple;stroke-width:1}#compositionEnd{fill:purple;stroke:purple;stroke-width:1}#aggregationStart{fill:#BDD5EA;stroke:purple;stroke-width:1}#aggregationEnd{fill:#BDD5EA;stroke:purple;stroke-width:1}#dependencyStart{fill:purple;stroke:purple;stroke-width:1}#dependencyEnd{fill:purple;stroke:purple;stroke-width:1}#extensionStart{fill:purple;stroke:purple;stroke-width:1}#extensionEnd{fill:purple;stroke:purple;stroke-width:1}.commit-id,.commit-msg,.branch-label{fill:lightgrey;color:lightgrey;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.pieTitleText{text-anchor:middle;font-size:25px;fill:#323D47;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.slice{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.stateGroup text{fill:purple;stroke:none;font-size:10px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.stateGroup text{fill:purple;stroke:none;font-size:10px}g.stateGroup .state-title{font-weight:bolder;fill:#000}g.stateGroup rect{fill:#BDD5EA;stroke:purple}g.stateGroup line{stroke:purple;stroke-width:1}.transition{stroke:purple;stroke-width:1;fill:none}.stateGroup .composit{fill:white;border-bottom:1px}.state-note{stroke:rgba(255,255,255,0.25);fill:#fff5ad}.state-note text{fill:black;stroke:none;font-size:10px}.stateLabel .box{stroke:none;stroke-width:0;fill:#BDD5EA;opacity:0.5}.stateLabel text{fill:#000;font-size:10px;font-weight:bold;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}:root{--mermaid-font-family: '\"trebuchet ms\", verdana, arial';--mermaid-font-family: \"Comic Sans MS\", \"Comic Sans\", cursive}\n",""])},function(t,e,n){var r=n(504);t.exports="string"==typeof r?r:r.toString()},function(t,e,n){(t.exports=n(83)(!1)).push([t.i,".label{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);color:#333}.label text{fill:#333}.node rect,.node circle,.node ellipse,.node polygon{fill:#ECECFF;stroke:#9370db;stroke-width:1px}.node .label{text-align:center}.node.clickable{cursor:pointer}.arrowheadPath{fill:#333}.edgePath .path{stroke:#333;stroke-width:1.5px}.edgeLabel{background-color:#e8e8e8;text-align:center}.cluster rect{fill:#ffffde;stroke:#aa3;stroke-width:1px}.cluster text{fill:#333}div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:12px;background:#ffffde;border:1px solid #aa3;border-radius:2px;pointer-events:none;z-index:100}.actor{stroke:#ccf;fill:#ECECFF}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:'2 2';stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:'2 2';stroke:#333}#arrowhead{fill:#333}.sequenceNumber{fill:#fff}#sequencenumber{fill:#333}#crosshead path{fill:#333 !important;stroke:#333 !important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#ccf;fill:#ECECFF}.labelText{fill:#000;stroke:none}.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:'2 2';stroke:#ccf}.note{stroke:#aa3;fill:#fff5ad}.noteText{fill:black;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:14px}.activation0{fill:#f4f4f4;stroke:#666}.activation1{fill:#f4f4f4;stroke:#666}.activation2{fill:#f4f4f4;stroke:#666}.mermaid-main-font{font-family:\"trebuchet ms\", verdana, arial;font-family:var(--mermaid-font-family)}.section{stroke:none;opacity:0.2}.section0{fill:rgba(102,102,255,0.49)}.section2{fill:#fff400}.section1,.section3{fill:#fff;opacity:0.2}.sectionTitle0{fill:#333}.sectionTitle1{fill:#333}.sectionTitle2{fill:#333}.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.grid .tick{stroke:#d3d3d3;opacity:0.3;shape-rendering:crispEdges}.grid .tick text{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.taskText:not([font-size]){font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.task.clickable{cursor:pointer}.taskText.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskTextOutsideRight.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#8a90dd;stroke:#534fbc}.taskTextOutside0,.taskTextOutside2{fill:#000}.taskTextOutside1,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#bfc7ff;stroke:#534fbc}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000 !important}.done0,.done1,.done2,.done3{stroke:grey;fill:#d3d3d3;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000 !important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#bfc7ff;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.milestone{transform:rotate(45deg) scale(0.8, 0.8)}.milestoneText{font-style:italic}.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000 !important}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3{fill:#000 !important}.titleText{text-anchor:middle;font-size:18px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.classGroup text{fill:#9370db;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:10px}g.classGroup text .title{font-weight:bolder}g.classGroup rect{fill:#ECECFF;stroke:#9370db}g.classGroup line{stroke:#9370db;stroke-width:1}.classLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5}.classLabel .label{fill:#9370db;font-size:10px}.relation{stroke:#9370db;stroke-width:1;fill:none}#compositionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#compositionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#aggregationStart{fill:#ECECFF;stroke:#9370db;stroke-width:1}#aggregationEnd{fill:#ECECFF;stroke:#9370db;stroke-width:1}#dependencyStart{fill:#9370db;stroke:#9370db;stroke-width:1}#dependencyEnd{fill:#9370db;stroke:#9370db;stroke-width:1}#extensionStart{fill:#9370db;stroke:#9370db;stroke-width:1}#extensionEnd{fill:#9370db;stroke:#9370db;stroke-width:1}.commit-id,.commit-msg,.branch-label{fill:lightgrey;color:lightgrey;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.pieTitleText{text-anchor:middle;font-size:25px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.slice{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.stateGroup text{fill:#9370db;stroke:none;font-size:10px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.stateGroup text{fill:#9370db;stroke:none;font-size:10px}g.stateGroup .state-title{font-weight:bolder;fill:#000}g.stateGroup rect{fill:#ECECFF;stroke:#9370db}g.stateGroup line{stroke:#9370db;stroke-width:1}.transition{stroke:#9370db;stroke-width:1;fill:none}.stateGroup .composit{fill:white;border-bottom:1px}.state-note{stroke:#aa3;fill:#fff5ad}.state-note text{fill:black;stroke:none;font-size:10px}.stateLabel .box{stroke:none;stroke-width:0;fill:#ECECFF;opacity:0.5}.stateLabel text{fill:#000;font-size:10px;font-weight:bold;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}:root{--mermaid-font-family: '\"trebuchet ms\", verdana, arial';--mermaid-font-family: \"Comic Sans MS\", \"Comic Sans\", cursive}\n",""])},function(t,e,n){var r=n(506);t.exports="string"==typeof r?r:r.toString()},function(t,e,n){(t.exports=n(83)(!1)).push([t.i,".label{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);color:#333}.label text{fill:#333}.node rect,.node circle,.node ellipse,.node polygon{fill:#cde498;stroke:#13540c;stroke-width:1px}.node .label{text-align:center}.node.clickable{cursor:pointer}.arrowheadPath{fill:green}.edgePath .path{stroke:green;stroke-width:1.5px}.edgeLabel{background-color:#e8e8e8;text-align:center}.cluster rect{fill:#cdffb2;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:12px;background:#cdffb2;border:1px solid #6eaa49;border-radius:2px;pointer-events:none;z-index:100}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:'2 2';stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:'2 2';stroke:#333}#arrowhead{fill:#333}.sequenceNumber{fill:#fff}#sequencenumber{fill:#333}#crosshead path{fill:#333 !important;stroke:#333 !important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText{fill:#000;stroke:none}.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:'2 2';stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:black;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:14px}.activation0{fill:#f4f4f4;stroke:#666}.activation1{fill:#f4f4f4;stroke:#666}.activation2{fill:#f4f4f4;stroke:#666}.mermaid-main-font{font-family:\"trebuchet ms\", verdana, arial;font-family:var(--mermaid-font-family)}.section{stroke:none;opacity:0.2}.section0{fill:#6eaa49}.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:0.2}.sectionTitle0{fill:#333}.sectionTitle1{fill:#333}.sectionTitle2{fill:#333}.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.grid .tick{stroke:#d3d3d3;opacity:0.3;shape-rendering:crispEdges}.grid .tick text{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.taskText:not([font-size]){font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.task.clickable{cursor:pointer}.taskText.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskTextOutsideRight.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside2{fill:#000}.taskTextOutside1,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000 !important}.done0,.done1,.done2,.done3{stroke:grey;fill:#d3d3d3;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000 !important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:#d3d3d3;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.milestone{transform:rotate(45deg) scale(0.8, 0.8)}.milestoneText{font-style:italic}.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000 !important}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3{fill:#000 !important}.titleText{text-anchor:middle;font-size:18px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.classGroup text{fill:#13540c;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:10px}g.classGroup text .title{font-weight:bolder}g.classGroup rect{fill:#cde498;stroke:#13540c}g.classGroup line{stroke:#13540c;stroke-width:1}.classLabel .box{stroke:none;stroke-width:0;fill:#cde498;opacity:0.5}.classLabel .label{fill:#13540c;font-size:10px}.relation{stroke:#13540c;stroke-width:1;fill:none}#compositionStart{fill:#13540c;stroke:#13540c;stroke-width:1}#compositionEnd{fill:#13540c;stroke:#13540c;stroke-width:1}#aggregationStart{fill:#cde498;stroke:#13540c;stroke-width:1}#aggregationEnd{fill:#cde498;stroke:#13540c;stroke-width:1}#dependencyStart{fill:#13540c;stroke:#13540c;stroke-width:1}#dependencyEnd{fill:#13540c;stroke:#13540c;stroke-width:1}#extensionStart{fill:#13540c;stroke:#13540c;stroke-width:1}#extensionEnd{fill:#13540c;stroke:#13540c;stroke-width:1}.commit-id,.commit-msg,.branch-label{fill:lightgrey;color:lightgrey;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.pieTitleText{text-anchor:middle;font-size:25px;fill:#000;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.slice{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.stateGroup text{fill:#13540c;stroke:none;font-size:10px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.stateGroup text{fill:#13540c;stroke:none;font-size:10px}g.stateGroup .state-title{font-weight:bolder;fill:#000}g.stateGroup rect{fill:#cde498;stroke:#13540c}g.stateGroup line{stroke:#13540c;stroke-width:1}.transition{stroke:#13540c;stroke-width:1;fill:none}.stateGroup .composit{fill:white;border-bottom:1px}.state-note{stroke:#6eaa49;fill:#fff5ad}.state-note text{fill:black;stroke:none;font-size:10px}.stateLabel .box{stroke:none;stroke-width:0;fill:#cde498;opacity:0.5}.stateLabel text{fill:#000;font-size:10px;font-weight:bold;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}:root{--mermaid-font-family: '\"trebuchet ms\", verdana, arial';--mermaid-font-family: \"Comic Sans MS\", \"Comic Sans\", cursive}\n",""])},function(t,e,n){var r=n(508);t.exports="string"==typeof r?r:r.toString()},function(t,e,n){(t.exports=n(83)(!1)).push([t.i,".label{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);color:#333}.label text{fill:#333}.node rect,.node circle,.node ellipse,.node polygon{fill:#eee;stroke:#999;stroke-width:1px}.node .label{text-align:center}.node.clickable{cursor:pointer}.arrowheadPath{fill:#333}.edgePath .path{stroke:#666;stroke-width:1.5px}.edgeLabel{background-color:#fff;text-align:center}.cluster rect{fill:#eaf2fb;stroke:#26a;stroke-width:1px}.cluster text{fill:#333}div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:12px;background:#eaf2fb;border:1px solid #26a;border-radius:2px;pointer-events:none;z-index:100}.actor{stroke:#999;fill:#eee}text.actor{fill:#333;stroke:none}.actor-line{stroke:#666}.messageLine0{stroke-width:1.5;stroke-dasharray:'2 2';stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:'2 2';stroke:#333}#arrowhead{fill:#333}.sequenceNumber{fill:#fff}#sequencenumber{fill:#333}#crosshead path{fill:#333 !important;stroke:#333 !important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#999;fill:#eee}.labelText{fill:#333;stroke:none}.loopText{fill:#333;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:'2 2';stroke:#999}.note{stroke:#770;fill:#ffa}.noteText{fill:black;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:14px}.activation0{fill:#f4f4f4;stroke:#666}.activation1{fill:#f4f4f4;stroke:#666}.activation2{fill:#f4f4f4;stroke:#666}.mermaid-main-font{font-family:\"trebuchet ms\", verdana, arial;font-family:var(--mermaid-font-family)}.section{stroke:none;opacity:0.2}.section0{fill:#80b3e6}.section2{fill:#80b3e6}.section1,.section3{fill:#fff;opacity:0.2}.sectionTitle0{fill:#333}.sectionTitle1{fill:#333}.sectionTitle2{fill:#333}.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.grid .tick{stroke:#e6e6e6;opacity:0.3;shape-rendering:crispEdges}.grid .tick text{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.grid path{stroke-width:0}.today{fill:none;stroke:#d42;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.taskText:not([font-size]){font-size:11px}.taskTextOutsideRight{fill:#333;text-anchor:start;font-size:11px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.taskTextOutsideLeft{fill:#333;text-anchor:end;font-size:11px}.task.clickable{cursor:pointer}.taskText.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskTextOutsideLeft.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskTextOutsideRight.clickable{cursor:pointer;fill:#003163 !important;font-weight:bold}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#26a;stroke:#1a4d80}.taskTextOutside0,.taskTextOutside2{fill:#333}.taskTextOutside1,.taskTextOutside3{fill:#333}.active0,.active1,.active2,.active3{fill:#eee;stroke:#1a4d80}.activeText0,.activeText1,.activeText2,.activeText3{fill:#333 !important}.done0,.done1,.done2,.done3{stroke:#666;fill:#bbb;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#333 !important}.crit0,.crit1,.crit2,.crit3{stroke:#b1361b;fill:#d42;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#b1361b;fill:#eee;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#b1361b;fill:#bbb;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.milestone{transform:rotate(45deg) scale(0.8, 0.8)}.milestoneText{font-style:italic}.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#333 !important}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3{fill:#333 !important}.titleText{text-anchor:middle;font-size:18px;fill:#333;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.classGroup text{fill:#999;stroke:none;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family);font-size:10px}g.classGroup text .title{font-weight:bolder}g.classGroup rect{fill:#eee;stroke:#999}g.classGroup line{stroke:#999;stroke-width:1}.classLabel .box{stroke:none;stroke-width:0;fill:#eee;opacity:0.5}.classLabel .label{fill:#999;font-size:10px}.relation{stroke:#999;stroke-width:1;fill:none}#compositionStart{fill:#999;stroke:#999;stroke-width:1}#compositionEnd{fill:#999;stroke:#999;stroke-width:1}#aggregationStart{fill:#eee;stroke:#999;stroke-width:1}#aggregationEnd{fill:#eee;stroke:#999;stroke-width:1}#dependencyStart{fill:#999;stroke:#999;stroke-width:1}#dependencyEnd{fill:#999;stroke:#999;stroke-width:1}#extensionStart{fill:#999;stroke:#999;stroke-width:1}#extensionEnd{fill:#999;stroke:#999;stroke-width:1}.commit-id,.commit-msg,.branch-label{fill:lightgrey;color:lightgrey;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.pieTitleText{text-anchor:middle;font-size:25px;fill:#333;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}.slice{font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.stateGroup text{fill:#999;stroke:none;font-size:10px;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}g.stateGroup text{fill:#999;stroke:none;font-size:10px}g.stateGroup .state-title{font-weight:bolder;fill:#000}g.stateGroup rect{fill:#eee;stroke:#999}g.stateGroup line{stroke:#999;stroke-width:1}.transition{stroke:#999;stroke-width:1;fill:none}.stateGroup .composit{fill:white;border-bottom:1px}.state-note{stroke:#770;fill:#ffa}.state-note text{fill:black;stroke:none;font-size:10px}.stateLabel .box{stroke:none;stroke-width:0;fill:#eee;opacity:0.5}.stateLabel text{fill:#000;font-size:10px;font-weight:bold;font-family:'trebuchet ms', verdana, arial;font-family:var(--mermaid-font-family)}:root{--mermaid-font-family: '\"trebuchet ms\", verdana, arial';--mermaid-font-family: \"Comic Sans MS\", \"Comic Sans\", cursive}\n",""])},function(t,e,n){"use strict";n.r(e);var r=n(226),i=n.n(r),o=n(0),a=n(227),s=n.n(a),u=n(88);let c={};const f=t=>{!function(t){const e=Object.keys(t);for(let n=0;n<e.length;n++)if("object"==typeof t[e[n]]&&null!=t[e[n]]){const r=Object.keys(t[e[n]]);for(let i=0;i<r.length;i++)void 0===c[e[n]]&&(c[e[n]]={}),c[e[n]][r[i]]=t[e[n]][r[i]]}else c[e[n]]=t[e[n]]}(t)},l=()=>c;var h=n(23),d=n.n(h);const p=1,g=2,y=3,b=4,m=5,v={debug:()=>{},info:()=>{},warn:()=>{},error:()=>{},fatal:()=>{}},_=function(t){v.debug=()=>{},v.info=()=>{},v.warn=()=>{},v.error=()=>{},v.fatal=()=>{},t<=m&&(v.fatal=console.log.bind(console,"[35m",w("FATAL"))),t<=b&&(v.error=console.log.bind(console,"[31m",w("ERROR"))),t<=y&&(v.warn=console.log.bind(console,"[33m",w("WARN"))),t<=g&&(v.info=console.log.bind(console,"[34m",w("INFO"))),t<=p&&(v.debug=console.log.bind(console,"[32m",w("DEBUG")))},w=t=>{return`${d()().format("HH:mm:ss.SSS")} : ${t} : `},x=(t,e)=>{if(!t)return e;const n=`curve${t.charAt(0).toUpperCase()+t.slice(1)}`;return o[n]||e},k=(t,e)=>t&&e?Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2)):0;var E={detectType:function(t){return t=t.replace(/^\s*%%.*\n/g,"\n"),v.debug("Detecting diagram type based on the text "+t),t.match(/^\s*sequenceDiagram/)?"sequence":t.match(/^\s*gantt/)?"gantt":t.match(/^\s*classDiagram/)?"class":t.match(/^\s*stateDiagram/)?"state":t.match(/^\s*gitGraph/)?"git":t.match(/^\s*info/)?"info":t.match(/^\s*pie/)?"pie":"flowchart"},isSubstringInArray:function(t,e){for(let n=0;n<e.length;n++)if(e[n].match(t))return n;return-1},interpolateToCurve:x,calcLabelPosition:t=>{return(t=>{let e,n=0;t.forEach(t=>{n+=k(t,e),e=t});let r,i=n/2;return e=void 0,t.forEach(t=>{if(e&&!r){const n=k(t,e);if(n<i)i-=n;else{const o=i/n;o<=0&&(r=e),o>=1&&(r={x:t.x,y:t.y}),o>0&&o<1&&(r={x:(1-o)*e.x+o*t.x,y:(1-o)*e.y+o*t.y})}}e=t}),r})(t)},calcCardinalityPosition:(t,e,n)=>{let r,i=0;e[0]!==n&&(e=e.reverse()),e.forEach(t=>{i+=k(t,r),r=t});let o,a=25;r=void 0,e.forEach(t=>{if(r&&!o){const e=k(t,r);if(e<a)a-=e;else{const n=a/e;n<=0&&(o=r),n>=1&&(o={x:t.x,y:t.y}),n>0&&n<1&&(o={x:(1-n)*r.x+n*t.x,y:(1-n)*r.y+n*t.y})}}r=t});let s=t?10:5,u=Math.atan2(e[0].y-o.y,e[0].x-o.x),c={x:0,y:0};return c.x=Math.sin(u)*s+(e[0].x+o.x)/2,c.y=-Math.cos(u)*s+(e[0].y+o.y)/2,c}},A=n(22),S=n.n(A),T=n(84);const M=l();let D,C={},O=[],R=[],I=[],N={},B={},L=0,P=!0,F=[];const q=t=>{let e=t;return"loose"!==M.securityLevel&&(e=(e=(e=(e=(e=e.replace(/<br>/g,"#br#")).replace(/<br\S*?\/>/g,"#br#")).replace(/</g,"&lt;").replace(/>/g,"&gt;")).replace(/=/g,"&equals;")).replace(/#br#/g,"<br/>")),e},j=function(t,e){t.split(",").forEach((function(t){let n=t;t[0].match(/\d/)&&(n=""+n),void 0!==C[n]&&C[n].classes.push(e),void 0!==N[n]&&N[n].classes.push(e)}))},U=function(t,e){t.split(",").forEach((function(t){void 0!==e&&(B[t]=q(e))}))},z=function(t){let e=o.select(".mermaidTooltip");null===(e._groups||e)[0][0]&&(e=o.select("body").append("div").attr("class","mermaidTooltip").style("opacity",0)),o.select(t).select("svg").selectAll("g.node").on("mouseover",(function(){const t=o.select(this);if(null===t.attr("title"))return;const n=this.getBoundingClientRect();e.transition().duration(200).style("opacity",".9"),e.html(t.attr("title")).style("left",n.left+(n.right-n.left)/2+"px").style("top",n.top-14+document.body.scrollTop+"px"),t.classed("hover",!0)})).on("mouseout",(function(){e.transition().duration(500).style("opacity",0),o.select(this).classed("hover",!1)}))};F.push(z);const Y=function(t){for(let e=0;e<I.length;e++)if(I[e].id===t)return e;return-1};let V=-1;const H=[],$=function(t,e){const n=I[e].nodes;if((V+=1)>2e3)return;if(H[V]=e,I[e].id===t)return{result:!0,count:0};let r=0,i=1;for(;r<n.length;){const e=Y(n[r]);if(e>=0){const n=$(t,e);if(n.result)return{result:!0,count:i+n.count};i+=n.count}r+=1}return{result:!1,count:i}};var G={addVertex:function(t,e,n,r,i){let o,a=t;void 0!==a&&0!==a.trim().length&&(a[0].match(/\d/)&&(a=""+a),void 0===C[a]&&(C[a]={id:a,styles:[],classes:[]}),void 0!==e?('"'===(o=q(e.trim()))[0]&&'"'===o[o.length-1]&&(o=o.substring(1,o.length-1)),C[a].text=o):C[a].text||(C[a].text=t),void 0!==n&&(C[a].type=n),null!=r&&r.forEach((function(t){C[a].styles.push(t)})),null!=i&&i.forEach((function(t){C[a].classes.push(t)})))},addLink:function(t,e,n,r){let i=t,o=e;i[0].match(/\d/)&&(i=""+i),o[0].match(/\d/)&&(o=""+o),v.info("Got edge...",i,o);const a={start:i,end:o,type:void 0,text:""};void 0!==(r=n.text)&&(a.text=q(r.trim()),'"'===a.text[0]&&'"'===a.text[a.text.length-1]&&(a.text=a.text.substring(1,a.text.length-1))),void 0!==n&&(a.type=n.type,a.stroke=n.stroke),O.push(a)},updateLinkInterpolate:function(t,e){t.forEach((function(t){"default"===t?O.defaultInterpolate=e:O[t].interpolate=e}))},updateLink:function(t,e){t.forEach((function(t){"default"===t?O.defaultStyle=e:(-1===E.isSubstringInArray("fill",e)&&e.push("fill:none"),O[t].style=e)}))},addClass:function(t,e){void 0===R[t]&&(R[t]={id:t,styles:[]}),null!=e&&e.forEach((function(e){R[t].styles.push(e)}))},setDirection:function(t){(D=t).match(/.*</)&&(D="RL"),D.match(/.*\^/)&&(D="BT"),D.match(/.*>/)&&(D="LR"),D.match(/.*v/)&&(D="TB")},setClass:j,getTooltip:function(t){return B[t]},setClickEvent:function(t,e,n){t.split(",").forEach((function(t){!function(t,e){let n=t;t[0].match(/\d/)&&(n=""+n),"loose"===M.securityLevel&&void 0!==e&&void 0!==C[n]&&F.push((function(){const t=document.querySelector(`[id="${n}"]`);null!==t&&t.addEventListener("click",(function(){window[e](n)}),!1)}))}(t,e)})),U(t,n),j(t,"clickable")},setLink:function(t,e,n){t.split(",").forEach((function(t){let n=t;t[0].match(/\d/)&&(n=""+n),void 0!==C[n]&&("loose"!==M.securityLevel?C[n].link=Object(T.sanitizeUrl)(e):C[n].link=e)})),U(t,n),j(t,"clickable")},bindFunctions:function(t){F.forEach((function(e){e(t)}))},getDirection:function(){return D.trim()},getVertices:function(){return C},getEdges:function(){return O},getClasses:function(){return R},clear:function(){C={},R={},O=[],(F=[]).push(z),I=[],N={},L=0,B=[],P=!0},defaultStyle:function(){return"fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;"},addSubGraph:function(t,e,n){let r=t,i=n;t===n&&n.match(/\s/)&&(r=void 0);let o=[];o=function(t){const e={boolean:{},number:{},string:{}},n=[];return t.filter((function(t){const r=typeof t;return""!==t.trim()&&(r in e?!e[r].hasOwnProperty(t)&&(e[r][t]=!0):!(n.indexOf(t)>=0)&&n.push(t))}))}(o.concat.apply(o,e));for(let t=0;t<o.length;t++)o[t][0].match(/\d/)&&(o[t]=""+o[t]);(r=r||"subGraph"+L)[0].match(/\d/)&&(r=""+r),i=q(i=i||""),L+=1;const a={id:r,nodes:o,title:i.trim(),classes:[]};return I.push(a),N[r]=a,r},getDepthFirstPos:function(t){return H[t]},indexNodes:function(){V=-1,I.length>0&&$("none",I.length-1,0)},getSubGraphs:function(){return I},lex:{firstGraph:()=>!!P&&(P=!1,!0)}},W=n(60),K=n.n(W),X=n(17),Z=n.n(X),J=n(128),Q=n.n(J);function tt(t,e,n){const r=.9*(e.width+e.height),i=[{x:r/2,y:0},{x:r,y:-r/2},{x:r/2,y:-r},{x:0,y:-r/2}],o=ut(t,r,r,i);return n.intersect=function(t){return Z.a.intersect.polygon(n,i,t)},o}function et(t,e,n){const r=e.height,i=r/4,o=e.width+2*i,a=[{x:i,y:0},{x:o-i,y:0},{x:o,y:-r/2},{x:o-i,y:-r},{x:i,y:-r},{x:0,y:-r/2}],s=ut(t,o,r,a);return n.intersect=function(t){return Z.a.intersect.polygon(n,a,t)},s}function nt(t,e,n){const r=e.width,i=e.height,o=[{x:-i/2,y:0},{x:r,y:0},{x:r,y:-i},{x:-i/2,y:-i},{x:0,y:-i/2}],a=ut(t,r,i,o);return n.intersect=function(t){return Z.a.intersect.polygon(n,o,t)},a}function rt(t,e,n){const r=e.width,i=e.height,o=[{x:-2*i/6,y:0},{x:r-i/6,y:0},{x:r+2*i/6,y:-i},{x:i/6,y:-i}],a=ut(t,r,i,o);return n.intersect=function(t){return Z.a.intersect.polygon(n,o,t)},a}function it(t,e,n){const r=e.width,i=e.height,o=[{x:2*i/6,y:0},{x:r+i/6,y:0},{x:r-2*i/6,y:-i},{x:-i/6,y:-i}],a=ut(t,r,i,o);return n.intersect=function(t){return Z.a.intersect.polygon(n,o,t)},a}function ot(t,e,n){const r=e.width,i=e.height,o=[{x:-2*i/6,y:0},{x:r+2*i/6,y:0},{x:r-i/6,y:-i},{x:i/6,y:-i}],a=ut(t,r,i,o);return n.intersect=function(t){return Z.a.intersect.polygon(n,o,t)},a}function at(t,e,n){const r=e.width,i=e.height,o=[{x:i/6,y:0},{x:r-i/6,y:0},{x:r+2*i/6,y:-i},{x:-2*i/6,y:-i}],a=ut(t,r,i,o);return n.intersect=function(t){return Z.a.intersect.polygon(n,o,t)},a}function st(t,e,n){const r=e.width,i=e.height,o=[{x:0,y:0},{x:r+i/2,y:0},{x:r,y:-i/2},{x:r+i/2,y:-i},{x:0,y:-i}],a=ut(t,r,i,o);return n.intersect=function(t){return Z.a.intersect.polygon(n,o,t)},a}function ut(t,e,n,r){return t.insert("polygon",":first-child").attr("points",r.map((function(t){return t.x+","+t.y})).join(" ")).attr("transform","translate("+-e/2+","+n/2+")")}var ct={addToRender:function(t){t.shapes().question=tt,t.shapes().hexagon=et,t.shapes().rect_left_inv_arrow=nt,t.shapes().lean_right=rt,t.shapes().lean_left=it,t.shapes().trapezoid=ot,t.shapes().inv_trapezoid=at,t.shapes().rect_right_inv_arrow=st}};const ft={},lt=function(t,e,n){const r=o.select(`[id="${n}"]`),i=Object.keys(t),a=function(t,e,{label:n}){if(n)for(let n=0;n<e.length;n++)void 0!==e[n]&&e[n].match("^color:|^text-align:")&&(t=t+e[n]+";");else for(let n=0;n<e.length;n++)void 0!==e[n]&&(t=t+e[n]+";");return t};i.forEach((function(n){const i=t[n];let o="";i.classes.length>0&&(o=i.classes.join(" "));let s="";s=a(s,i.styles,{label:!1});let u="";u=a(u,i.styles,{label:!0});let c,f=void 0!==i.text?i.text:i.id;if(l().flowchart.htmlLabels){const t={label:f.replace(/fa[lrsb]?:fa-[\w-]+/g,t=>`<i class='${t.replace(":"," ")}'></i>`)};(c=Q()(r,t).node()).parentNode.removeChild(c)}else{const t=document.createElementNS("http://www.w3.org/2000/svg","text"),e=f.split(/<br[/]{0,1}>/);for(let n=0;n<e.length;n++){const r=document.createElementNS("http://www.w3.org/2000/svg","tspan");r.setAttributeNS("http://www.w3.org/XML/1998/namespace","xml:space","preserve"),r.setAttribute("dy","1em"),r.setAttribute("x","1"),r.textContent=e[n],t.appendChild(r)}c=t}if(i.link){const t=document.createElementNS("http://www.w3.org/2000/svg","a");t.setAttributeNS("http://www.w3.org/2000/svg","href",i.link),t.setAttributeNS("http://www.w3.org/2000/svg","rel","noopener"),t.appendChild(c),c=t}let h=0,d="";switch(i.type){case"round":h=5,d="rect";break;case"square":d="rect";break;case"diamond":d="question";break;case"hexagon":d="hexagon";break;case"odd":d="rect_left_inv_arrow";break;case"lean_right":d="lean_right";break;case"lean_left":d="lean_left";break;case"trapezoid":d="trapezoid";break;case"inv_trapezoid":d="inv_trapezoid";break;case"odd_right":d="rect_left_inv_arrow";break;case"circle":d="circle";break;case"ellipse":d="ellipse";break;case"group":d="rect";break;default:d="rect"}e.setNode(i.id,{labelType:"svg",labelStyle:u,shape:d,label:c,rx:h,ry:h,class:o,style:s,id:i.id})}))},ht=function(t,e){let n,r=0;void 0!==t.defaultStyle&&(n=t.defaultStyle.toString().replace(/,/g,";")),t.forEach((function(i){r++;const a={};"arrow_open"===i.type?a.arrowhead="none":a.arrowhead="normal";let s="";if(void 0!==i.style)i.style.forEach((function(t){s=s+t+";"}));else switch(i.stroke){case"normal":s="fill:none",void 0!==n&&(s=n);break;case"dotted":s="stroke: #333; fill:none;stroke-width:2px;stroke-dasharray:3;";break;case"thick":s="stroke: #333; stroke-width: 3.5px;fill:none"}a.style=s,void 0!==i.interpolate?a.curve=x(i.interpolate,o.curveLinear):void 0!==t.defaultInterpolate?a.curve=x(t.defaultInterpolate,o.curveLinear):a.curve=x(ft.curve,o.curveLinear),void 0===i.text?void 0!==i.style&&(a.arrowheadStyle="fill: #333"):(a.arrowheadStyle="fill: #333",void 0===i.style?(a.labelpos="c",l().flowchart.htmlLabels?(a.labelType="html",a.label='<span class="edgeLabel">'+i.text+"</span>"):(a.labelType="text",a.style=a.style||"stroke: #333; stroke-width: 1.5px;fill:none",a.label=i.text.replace(/<br>/g,"\n"))):a.label=i.text.replace(/<br>/g,"\n")),e.setEdge(i.start,i.end,a,r)}))};var dt=function(t){const e=Object.keys(t);for(let n=0;n<e.length;n++)ft[e[n]]=t[e[n]]},pt=function(t){v.info("Extracting classes"),G.clear();const e=K.a.parser;return e.yy=G,e.parse(t),G.getClasses()},gt=function(t,e){v.info("Drawing flowchart"),G.clear();const n=K.a.parser;n.yy=G;try{n.parse(t)}catch(t){v.debug("Parsing failed")}let r,i,a=G.getDirection();void 0===a&&(a="TD"),r=new S.a.Graph({multigraph:!0,compound:!0}).setGraph({rankdir:a,marginx:8,marginy:8}).setDefaultEdgeLabel((function(){return{}}));const s=G.getSubGraphs();for(let t=s.length-1;t>=0;t--)i=s[t],G.addVertex(i.id,i.title,"group",void 0,i.classes);const u=G.getVertices(),c=G.getEdges();let f=0;for(f=s.length-1;f>=0;f--){i=s[f],o.selectAll("cluster").append("text");for(let t=0;t<i.nodes.length;t++)r.setParent(i.nodes[t],i.id)}lt(u,r,e),ht(c,r);const h=new(0,Z.a.render);ct.addToRender(h),h.arrows().none=function(t,e,n,r){const i=t.append("marker").attr("id",e).attr("viewBox","0 0 10 10").attr("refX",9).attr("refY",5).attr("markerUnits","strokeWidth").attr("markerWidth",8).attr("markerHeight",6).attr("orient","auto").append("path").attr("d","M 0 0 L 0 0 L 0 0 z");Z.a.util.applyStyle(i,n[r+"Style"])},h.arrows().normal=function(t,e){t.append("marker").attr("id",e).attr("viewBox","0 0 10 10").attr("refX",9).attr("refY",5).attr("markerUnits","strokeWidth").attr("markerWidth",8).attr("markerHeight",6).attr("orient","auto").append("path").attr("d","M 0 0 L 10 5 L 0 10 z").attr("class","arrowheadPath").style("stroke-width",1).style("stroke-dasharray","1,0")};const d=o.select(`[id="${e}"]`),p=o.select("#"+e+" g");h(p,r),p.selectAll("g.node").attr("title",(function(){return G.getTooltip(this.id)}));const g=l().flowchart;{const t=d.node().getBBox(),e=t.width+16,n=t.height+16;v.debug(`new ViewBox 0 0 ${e} ${n}`,`translate(${8-r._label.marginx}, ${8-r._label.marginy})`),g.useMaxWidth?(d.attr("width","100%"),d.attr("style",`max-width: ${e}px;`)):(d.attr("height",n),d.attr("width",e)),d.attr("viewBox",`0 0 ${e} ${n}`),d.select("g").attr("transform",`translate(${8-r._label.marginx}, ${8-t.y})`)}for(G.indexNodes("subGraph"+f),f=0;f<s.length;f++)if("undefined"!==(i=s[f]).title){const t=document.querySelectorAll("#"+e+' [id="'+i.id+'"] rect'),n=document.querySelectorAll("#"+e+' [id="'+i.id+'"]'),r=t[0].x.baseVal.value,a=t[0].y.baseVal.value,s=t[0].width.baseVal.value,u=o.select(n[0]).select(".label");u.attr("transform",`translate(${r+s/2}, ${a+14})`),u.attr("id",e+"Text")}if(!g.htmlLabels){const t=document.querySelectorAll('[id="'+e+'"] .edgeLabel .label');for(let e=0;e<t.length;e++){const n=t[e],r=n.getBBox(),i=document.createElementNS("http://www.w3.org/2000/svg","rect");i.setAttribute("rx",0),i.setAttribute("ry",0),i.setAttribute("width",r.width),i.setAttribute("height",r.height),i.setAttribute("style","fill:#e8e8e8;"),n.insertBefore(i,n.firstChild)}}};const yt=function(t,e){const n=t.append("rect");return n.attr("x",e.x),n.attr("y",e.y),n.attr("fill",e.fill),n.attr("stroke",e.stroke),n.attr("width",e.width),n.attr("height",e.height),n.attr("rx",e.rx),n.attr("ry",e.ry),void 0!==e.class&&n.attr("class",e.class),n},bt=function(t,e){const n=e.text.replace(/<br\/?>/gi," "),r=t.append("text");r.attr("x",e.x),r.attr("y",e.y),r.style("text-anchor",e.anchor),r.attr("fill",e.fill),void 0!==e.class&&r.attr("class",e.class);const i=r.append("tspan");return i.attr("x",e.x+2*e.textMargin),i.attr("fill",e.fill),i.text(n),r},mt=function(t,e){const n=t.append("polygon");var r,i,o,a,s;n.attr("points",(r=e.x,i=e.y,r+","+i+" "+(r+(o=50))+","+i+" "+(r+o)+","+(i+(a=20)-(s=7))+" "+(r+o-1.2*s)+","+(i+a)+" "+r+","+(i+a))),n.attr("class","labelBox"),e.y=e.y+e.labelMargin,e.x=e.x+.5*e.labelMargin,bt(t,e)};let vt=-1;const _t=function(){return{x:0,y:0,fill:void 0,"text-anchor":"start",style:"#666",width:100,height:100,textMargin:0,rx:0,ry:0}},wt=function(){return{x:0,y:0,fill:"#EDF2AE",stroke:"#666",width:100,anchor:"start",height:100,rx:0,ry:0}},xt=function(){function t(t,e,n,i,o,a,s){r(e.append("text").attr("x",n+o/2).attr("y",i+a/2+5).style("text-anchor","middle").text(t),s)}function e(t,e,n,i,o,a,s,u){const{actorFontSize:c,actorFontFamily:f}=u,l=t.split(/<br\/?>/gi);for(let t=0;t<l.length;t++){const u=t*c-c*(l.length-1)/2,h=e.append("text").attr("x",n+o/2).attr("y",i).style("text-anchor","middle").style("font-size",c).style("font-family",f);h.append("tspan").attr("x",n+o/2).attr("dy",u).text(l[t]),h.attr("y",i+a/2).attr("dominant-baseline","central").attr("alignment-baseline","central"),r(h,s)}}function n(t,n,i,o,a,s,u,c){const f=n.append("switch"),l=f.append("foreignObject").attr("x",i).attr("y",o).attr("width",a).attr("height",s).append("div").style("display","table").style("height","100%").style("width","100%");l.append("div").style("display","table-cell").style("text-align","center").style("vertical-align","middle").text(t),e(t,f,i,o,a,s,u,c),r(l,u)}function r(t,e){for(const n in e)e.hasOwnProperty(n)&&t.attr(n,e[n])}return function(r){return"fo"===r.textPlacement?n:"old"===r.textPlacement?t:e}}();var kt={drawRect:yt,drawText:bt,drawLabel:mt,drawActor:function(t,e,n,r,i){const o=e+i.width/2,a=t.append("g");0===n&&(vt++,a.append("line").attr("id","actor"+vt).attr("x1",o).attr("y1",5).attr("x2",o).attr("y2",2e3).attr("class","actor-line").attr("stroke-width","0.5px").attr("stroke","#999"));const s=wt();s.x=e,s.y=n,s.fill="#eaeaea",s.width=i.width,s.height=i.height,s.class="actor",s.rx=3,s.ry=3,yt(a,s),xt(i)(r,a,s.x,s.y,s.width,s.height,{class:"actor"},i)},anchorElement:function(t){return t.append("g")},drawActivation:function(t,e,n,r,i){const o=wt(),a=e.anchored;o.x=e.startx,o.y=e.starty,o.class="activation"+i%3,o.width=e.stopx-e.startx,o.height=n-e.starty,yt(a,o)},drawLoop:function(t,e,n,r){const i=t.append("g"),o=function(t,e,n,r){return i.append("line").attr("x1",t).attr("y1",e).attr("x2",n).attr("y2",r).attr("class","loopLine")};o(e.startx,e.starty,e.stopx,e.starty),o(e.stopx,e.starty,e.stopx,e.stopy),o(e.startx,e.stopy,e.stopx,e.stopy),o(e.startx,e.starty,e.startx,e.stopy),void 0!==e.sections&&e.sections.forEach((function(t){o(e.startx,t,e.stopx,t).style("stroke-dasharray","3, 3")}));let a=_t();a.text=n,a.x=e.startx,a.y=e.starty,a.labelMargin=15,a.class="labelText",mt(i,a),(a=_t()).text="[ "+e.title+" ]",a.x=e.startx+(e.stopx-e.startx)/2,a.y=e.starty+1.5*r.boxMargin,a.anchor="middle",a.class="loopText",bt(i,a),void 0!==e.sectionTitles&&e.sectionTitles.forEach((function(t,n){""!==t&&(a.text="[ "+t+" ]",a.y=e.sections[n]+1.5*r.boxMargin,bt(i,a))}))},drawBackgroundRect:function(t,e){yt(t,{x:e.startx,y:e.starty,width:e.stopx-e.startx,height:e.stopy-e.starty,fill:e.fill,class:"rect"}).lower()},insertArrowHead:function(t){t.append("defs").append("marker").attr("id","arrowhead").attr("refX",5).attr("refY",2).attr("markerWidth",6).attr("markerHeight",4).attr("orient","auto").append("path").attr("d","M 0,0 V 4 L6,2 Z")},insertSequenceNumber:function(t){t.append("defs").append("marker").attr("id","sequencenumber").attr("refX",15).attr("refY",15).attr("markerWidth",60).attr("markerHeight",40).attr("orient","auto").append("circle").attr("cx",15).attr("cy",15).attr("r",6)},insertArrowCrossHead:function(t){const e=t.append("defs").append("marker").attr("id","crosshead").attr("markerWidth",15).attr("markerHeight",8).attr("orient","auto").attr("refX",16).attr("refY",4);e.append("path").attr("fill","black").attr("stroke","#000000").style("stroke-dasharray","0, 0").attr("stroke-width","1px").attr("d","M 9,2 V 6 L16,4 Z"),e.append("path").attr("fill","none").attr("stroke","#000000").style("stroke-dasharray","0, 0").attr("stroke-width","1px").attr("d","M 0,1 L 6,7 M 6,1 L 0,7")},getTextObj:_t,getNoteRect:wt},Et=n(1),At=n.n(Et);let St={},Tt=[];const Mt=[];let Dt="";const Ct=function(t,e,n){const r=St[t];r&&e===r.name&&null==n||(null==n&&(n=e),St[t]={name:e,description:n})},Ot=function(t,e,n,r){v.debug("Adding message from="+t+" to="+e+" message="+n+" type="+r),Tt.push({from:t,to:e,message:n,type:r})},Rt={SOLID:0,DOTTED:1,NOTE:2,SOLID_CROSS:3,DOTTED_CROSS:4,SOLID_OPEN:5,DOTTED_OPEN:6,LOOP_START:10,LOOP_END:11,ALT_START:12,ALT_ELSE:13,ALT_END:14,OPT_START:15,OPT_END:16,ACTIVE_START:17,ACTIVE_END:18,PAR_START:19,PAR_AND:20,PAR_END:21,RECT_START:22,RECT_END:23},It=function(t,e,n){const r={actor:t,placement:e,message:n},i=[].concat(t,t);Mt.push(r),Tt.push({from:i[0],to:i[1],message:n,type:Rt.NOTE,placement:e})},Nt=function(t){Dt=t},Bt=function(t){if(t instanceof Array)t.forEach((function(t){Bt(t)}));else switch(t.type){case"addActor":Ct(t.actor,t.actor,t.description);break;case"activeStart":case"activeEnd":Ot(t.actor,void 0,void 0,t.signalType);break;case"addNote":It(t.actor,t.placement,t.text);break;case"addMessage":Ot(t.from,t.to,t.msg,t.signalType);break;case"loopStart":Ot(void 0,void 0,t.loopText,t.signalType);break;case"loopEnd":Ot(void 0,void 0,void 0,t.signalType);break;case"rectStart":Ot(void 0,void 0,t.color,t.signalType);break;case"rectEnd":Ot(void 0,void 0,void 0,t.signalType);break;case"optStart":Ot(void 0,void 0,t.optText,t.signalType);break;case"optEnd":Ot(void 0,void 0,void 0,t.signalType);break;case"altStart":case"else":Ot(void 0,void 0,t.altText,t.signalType);break;case"altEnd":Ot(void 0,void 0,void 0,t.signalType);break;case"setTitle":Nt(t.text);break;case"parStart":case"and":Ot(void 0,void 0,t.parText,t.signalType);break;case"parEnd":Ot(void 0,void 0,void 0,t.signalType)}};var Lt={addActor:Ct,addMessage:function(t,e,n,r){Tt.push({from:t,to:e,message:n,answer:r})},addSignal:Ot,getMessages:function(){return Tt},getActors:function(){return St},getActor:function(t){return St[t]},getActorKeys:function(){return Object.keys(St)},getTitle:function(){return Dt},clear:function(){St={},Tt=[]},LINETYPE:Rt,ARROWTYPE:{FILLED:0,OPEN:1},PLACEMENT:{LEFTOF:0,RIGHTOF:1,OVER:2},addNote:It,setTitle:Nt,apply:Bt};Et.parser.yy=Lt;const Pt={diagramMarginX:50,diagramMarginY:30,actorMargin:50,width:150,height:65,actorFontSize:14,actorFontFamily:'"Open-Sans", "sans-serif"',boxMargin:10,boxTextMargin:5,noteMargin:10,messageMargin:35,mirrorActors:!1,bottomMarginAdj:1,activationWidth:10,textPlacement:"tspan",showSequenceNumbers:!1},Ft={data:{startx:void 0,stopx:void 0,starty:void 0,stopy:void 0},verticalPos:0,sequenceItems:[],activations:[],init:function(){this.sequenceItems=[],this.activations=[],this.data={startx:void 0,stopx:void 0,starty:void 0,stopy:void 0},this.verticalPos=0},updateVal:function(t,e,n,r){void 0===t[e]?t[e]=n:t[e]=r(n,t[e])},updateBounds:function(t,e,n,r){const i=this;let o=0;function a(a){return function(s){o++;const u=i.sequenceItems.length-o+1;i.updateVal(s,"starty",e-u*Pt.boxMargin,Math.min),i.updateVal(s,"stopy",r+u*Pt.boxMargin,Math.max),i.updateVal(Ft.data,"startx",t-u*Pt.boxMargin,Math.min),i.updateVal(Ft.data,"stopx",n+u*Pt.boxMargin,Math.max),"activation"!==a&&(i.updateVal(s,"startx",t-u*Pt.boxMargin,Math.min),i.updateVal(s,"stopx",n+u*Pt.boxMargin,Math.max),i.updateVal(Ft.data,"starty",e-u*Pt.boxMargin,Math.min),i.updateVal(Ft.data,"stopy",r+u*Pt.boxMargin,Math.max))}}this.sequenceItems.forEach(a()),this.activations.forEach(a("activation"))},insert:function(t,e,n,r){const i=Math.min(t,n),o=Math.max(t,n),a=Math.min(e,r),s=Math.max(e,r);this.updateVal(Ft.data,"startx",i,Math.min),this.updateVal(Ft.data,"starty",a,Math.min),this.updateVal(Ft.data,"stopx",o,Math.max),this.updateVal(Ft.data,"stopy",s,Math.max),this.updateBounds(i,a,o,s)},newActivation:function(t,e){const n=Et.parser.yy.getActors()[t.from.actor],r=Ut(t.from.actor).length,i=n.x+Pt.width/2+(r-1)*Pt.activationWidth/2;this.activations.push({startx:i,starty:this.verticalPos+2,stopx:i+Pt.activationWidth,stopy:void 0,actor:t.from.actor,anchored:kt.anchorElement(e)})},endActivation:function(t){const e=this.activations.map((function(t){return t.actor})).lastIndexOf(t.from.actor);return this.activations.splice(e,1)[0]},newLoop:function(t,e){this.sequenceItems.push({startx:void 0,starty:this.verticalPos,stopx:void 0,stopy:void 0,title:t,fill:e})},endLoop:function(){return this.sequenceItems.pop()},addSectionToLoop:function(t){const e=this.sequenceItems.pop();e.sections=e.sections||[],e.sectionTitles=e.sectionTitles||[],e.sections.push(Ft.getVerticalPos()),e.sectionTitles.push(t),this.sequenceItems.push(e)},bumpVerticalPos:function(t){this.verticalPos=this.verticalPos+t,this.data.stopy=this.verticalPos},getVerticalPos:function(){return this.verticalPos},getBounds:function(){return this.data}},qt=function(t,e,n,r,i){const o=kt.getNoteRect();o.x=e,o.y=n,o.width=i||Pt.width,o.class="note";let a=t.append("g");const s=kt.drawRect(a,o),u=((t,e,n,r,i)=>{let o=0;const a=t.split(/<br\/?>/gi);for(const t of a){const a=kt.getTextObj();a.x=e,a.y=n+o,a.textMargin=Pt.noteMargin,a.dy="1em",a.text=t,a.class="noteText";const s=kt.drawText(r,a,i);o+=(s._groups||s)[0][0].getBBox().height}return o})(r.message,e-4,n+24,a,o.width-Pt.noteMargin);Ft.insert(e,n,e+o.width,n+2*Pt.noteMargin+u),s.attr("height",u+2*Pt.noteMargin),Ft.bumpVerticalPos(u+2*Pt.noteMargin)},jt=function(t,e,n,r){for(let i=0;i<n.length;i++){const o=n[i];e[o].x=i*Pt.actorMargin+i*Pt.width,e[o].y=r,e[o].width=Pt.diagramMarginX,e[o].height=Pt.diagramMarginY,kt.drawActor(t,e[o].x,r,e[o].description,Pt),Ft.insert(e[o].x,r,e[o].x+Pt.width,Pt.height)}Ft.bumpVerticalPos(Pt.height)},Ut=function(t){return Ft.activations.filter((function(e){return e.actor===t}))},zt=function(t){const e=Et.parser.yy.getActors(),n=Ut(t);return[n.reduce((function(t,e){return Math.min(t,e.startx)}),e[t].x+Pt.width/2),n.reduce((function(t,e){return Math.max(t,e.stopx)}),e[t].x+Pt.width/2)]};var Yt=function(t){Object.keys(t).forEach((function(e){Pt[e]=t[e]})),Pt.actorFontFamily=t.fontFamily},Vt=function(t,e){Et.parser.yy.clear(),Et.parser.parse(t+"\n"),Ft.init();const n=o.select(`[id="${e}"]`);let r,i,a;const s=Et.parser.yy.getActors(),u=Et.parser.yy.getActorKeys(),c=Et.parser.yy.getMessages(),f=Et.parser.yy.getTitle();jt(n,s,u,0),kt.insertArrowHead(n),kt.insertArrowCrossHead(n),kt.insertSequenceNumber(n);let l=1;c.forEach((function(t){let e;switch(t.type){case Et.parser.yy.LINETYPE.NOTE:Ft.bumpVerticalPos(Pt.boxMargin),r=s[t.from].x,i=s[t.to].x,t.placement===Et.parser.yy.PLACEMENT.RIGHTOF?qt(n,r+(Pt.width+Pt.actorMargin)/2,Ft.getVerticalPos(),t):t.placement===Et.parser.yy.PLACEMENT.LEFTOF?qt(n,r-(Pt.width+Pt.actorMargin)/2,Ft.getVerticalPos(),t):t.to===t.from?qt(n,r,Ft.getVerticalPos(),t):(a=Math.abs(r-i)+Pt.actorMargin,qt(n,(r+i+Pt.width-a)/2,Ft.getVerticalPos(),t,a));break;case Et.parser.yy.LINETYPE.ACTIVE_START:Ft.newActivation(t,n);break;case Et.parser.yy.LINETYPE.ACTIVE_END:!function(t,e){const r=Ft.endActivation(t);r.starty+18>e&&(r.starty=e-6,e+=12),kt.drawActivation(n,r,e,Pt,Ut(t.from.actor).length),Ft.insert(r.startx,e-10,r.stopx,e)}(t,Ft.getVerticalPos());break;case Et.parser.yy.LINETYPE.LOOP_START:Ft.bumpVerticalPos(Pt.boxMargin),Ft.newLoop(t.message),Ft.bumpVerticalPos(Pt.boxMargin+Pt.boxTextMargin);break;case Et.parser.yy.LINETYPE.LOOP_END:e=Ft.endLoop(),kt.drawLoop(n,e,"loop",Pt),Ft.bumpVerticalPos(Pt.boxMargin);break;case Et.parser.yy.LINETYPE.RECT_START:Ft.bumpVerticalPos(Pt.boxMargin),Ft.newLoop(void 0,t.message),Ft.bumpVerticalPos(Pt.boxMargin);break;case Et.parser.yy.LINETYPE.RECT_END:{const t=Ft.endLoop();kt.drawBackgroundRect(n,t),Ft.bumpVerticalPos(Pt.boxMargin);break}case Et.parser.yy.LINETYPE.OPT_START:Ft.bumpVerticalPos(Pt.boxMargin),Ft.newLoop(t.message),Ft.bumpVerticalPos(Pt.boxMargin+Pt.boxTextMargin);break;case Et.parser.yy.LINETYPE.OPT_END:e=Ft.endLoop(),kt.drawLoop(n,e,"opt",Pt),Ft.bumpVerticalPos(Pt.boxMargin);break;case Et.parser.yy.LINETYPE.ALT_START:Ft.bumpVerticalPos(Pt.boxMargin),Ft.newLoop(t.message),Ft.bumpVerticalPos(Pt.boxMargin+Pt.boxTextMargin);break;case Et.parser.yy.LINETYPE.ALT_ELSE:Ft.bumpVerticalPos(Pt.boxMargin),e=Ft.addSectionToLoop(t.message),Ft.bumpVerticalPos(Pt.boxMargin);break;case Et.parser.yy.LINETYPE.ALT_END:e=Ft.endLoop(),kt.drawLoop(n,e,"alt",Pt),Ft.bumpVerticalPos(Pt.boxMargin);break;case Et.parser.yy.LINETYPE.PAR_START:Ft.bumpVerticalPos(Pt.boxMargin),Ft.newLoop(t.message),Ft.bumpVerticalPos(Pt.boxMargin+Pt.boxTextMargin);break;case Et.parser.yy.LINETYPE.PAR_AND:Ft.bumpVerticalPos(Pt.boxMargin),e=Ft.addSectionToLoop(t.message),Ft.bumpVerticalPos(Pt.boxMargin);break;case Et.parser.yy.LINETYPE.PAR_END:e=Ft.endLoop(),kt.drawLoop(n,e,"par",Pt),Ft.bumpVerticalPos(Pt.boxMargin);break;default:try{Ft.bumpVerticalPos(Pt.messageMargin);const e=zt(t.from),o=zt(t.to),a=e[0]<=o[0]?1:0,s=e[0]<o[0]?0:1;r=e[a],i=o[s];const u=Ft.getVerticalPos();!function(t,e,n,r,i,o){const a=t.append("g"),s=e+(n-e)/2;let u,c=0;const f=i.message.split(/<br\/?>/gi);for(const t of f)u=a.append("text").attr("x",s).attr("y",r-7+17*c).style("text-anchor","middle").attr("class","messageText").text(t.trim()),c++;const l=17*(c-1);let h,d=(u._groups||u)[0][0].getBBox().width;if(e===n){h=Pt.rightAngles?a.append("path").attr("d",`M  ${e},${r+l} H ${e+Pt.width/2} V ${r+25+l} H ${e}`):a.append("path").attr("d","M "+e+","+(r+l)+" C "+(e+60)+","+(r-10+l)+" "+(e+60)+","+(r+30+l)+" "+e+","+(r+20+l)),Ft.bumpVerticalPos(30+l);const t=Math.max(d/2,100);Ft.insert(e-t,Ft.getVerticalPos()-10+l,n+t,Ft.getVerticalPos()+l)}else(h=a.append("line")).attr("x1",e),h.attr("y1",r),h.attr("x2",n),h.attr("y2",r),Ft.insert(e,Ft.getVerticalPos()-10+l,n,Ft.getVerticalPos()+l);i.type===Et.parser.yy.LINETYPE.DOTTED||i.type===Et.parser.yy.LINETYPE.DOTTED_CROSS||i.type===Et.parser.yy.LINETYPE.DOTTED_OPEN?(h.style("stroke-dasharray","3, 3"),h.attr("class","messageLine1")):h.attr("class","messageLine0");let p="";Pt.arrowMarkerAbsolute&&(p=(p=(p=window.location.protocol+"//"+window.location.host+window.location.pathname+window.location.search).replace(/\(/g,"\\(")).replace(/\)/g,"\\)")),h.attr("stroke-width",2),h.attr("stroke","black"),h.style("fill","none"),i.type!==Et.parser.yy.LINETYPE.SOLID&&i.type!==Et.parser.yy.LINETYPE.DOTTED||h.attr("marker-end","url("+p+"#arrowhead)"),i.type!==Et.parser.yy.LINETYPE.SOLID_CROSS&&i.type!==Et.parser.yy.LINETYPE.DOTTED_CROSS||h.attr("marker-end","url("+p+"#crosshead)"),Pt.showSequenceNumbers&&(h.attr("marker-start","url("+p+"#sequencenumber)"),a.append("text").attr("x",e).attr("y",r+4).attr("font-family","sans-serif").attr("font-size","12px").attr("text-anchor","middle").attr("textLength","16px").attr("class","sequenceNumber").text(o))}(n,r,i,u,t,l);const c=e.concat(o);Ft.insert(Math.min.apply(null,c),u,Math.max.apply(null,c),u)}catch(t){v.error("error while drawing message",t)}}[Et.parser.yy.LINETYPE.SOLID_OPEN,Et.parser.yy.LINETYPE.DOTTED_OPEN,Et.parser.yy.LINETYPE.SOLID,Et.parser.yy.LINETYPE.DOTTED,Et.parser.yy.LINETYPE.SOLID_CROSS,Et.parser.yy.LINETYPE.DOTTED_CROSS].includes(t.type)&&l++})),Pt.mirrorActors&&(Ft.bumpVerticalPos(2*Pt.boxMargin),jt(n,s,u,Ft.getVerticalPos()));const h=Ft.getBounds();v.debug("For line height fix Querying: #"+e+" .actor-line"),o.selectAll("#"+e+" .actor-line").attr("y2",h.stopy);let d=h.stopy-h.starty+2*Pt.diagramMarginY;Pt.mirrorActors&&(d=d-Pt.boxMargin+Pt.bottomMarginAdj);const p=h.stopx-h.startx+2*Pt.diagramMarginX;f&&n.append("text").text(f).attr("x",(h.stopx-h.startx)/2-2*Pt.diagramMarginX).attr("y",-25),Pt.useMaxWidth?(n.attr("height","100%"),n.attr("width","100%"),n.attr("style","max-width:"+p+"px;")):(n.attr("height",d),n.attr("width",p));const g=f?40:0;n.attr("viewBox",h.startx-Pt.diagramMarginX+" -"+(Pt.diagramMarginY+g)+" "+p+" "+(d+g))},Ht=n(26),$t=n.n(Ht);const Gt=l();let Wt="",Kt="",Xt=[],Zt="",Jt=[],Qt=[],te="";const ee=["active","done","crit","milestone"];let ne=[],re=!1;const ie=function(t,e,n){return t.isoWeekday()>=6&&n.indexOf("weekends")>=0||(n.indexOf(t.format("dddd").toLowerCase())>=0||n.indexOf(t.format(e.trim()))>=0)},oe=function(t,e,n){if(!n.length||t.manualEndTime)return;let r=d()(t.startTime,e,!0);r.add(1,"d");let i=d()(t.endTime,e,!0),o=ae(r,i,e,n);t.endTime=i.toDate(),t.renderEndTime=o},ae=function(t,e,n,r){let i=!1,o=null;for(;t.date()<=e.date();)i||(o=e.toDate()),(i=ie(t,n,r))&&e.add(1,"d"),t.add(1,"d");return o},se=function(t,e,n){n=n.trim();const r=/^after\s+([\d\w-]+)/.exec(n.trim());if(null!==r){const t=ye(r[1]);if(void 0===t){const t=new Date;return t.setHours(0,0,0,0),t}return t.endTime}let i=d()(n,e.trim(),!0);return i.isValid()?i.toDate():(v.debug("Invalid date:"+n),v.debug("With date format:"+e.trim()),new Date)},ue=function(t,e){if(null!==t)switch(t[2]){case"s":e.add(t[1],"seconds");break;case"m":e.add(t[1],"minutes");break;case"h":e.add(t[1],"hours");break;case"d":e.add(t[1],"days");break;case"w":e.add(t[1],"weeks")}return e.toDate()},ce=function(t,e,n,r){r=r||!1,n=n.trim();let i=d()(n,e.trim(),!0);return i.isValid()?(r&&i.add(1,"d"),i.toDate()):ue(/^([\d]+)([wdhms])/.exec(n.trim()),d()(t))};let fe=0;const le=function(t){return void 0===t?"task"+(fe+=1):t};let he,de,pe=[];const ge={},ye=function(t){const e=ge[t];return pe[e]},be=function(){const t=function(t){const e=pe[t];let n="";switch(pe[t].raw.startTime.type){case"prevTaskEnd":{const t=ye(e.prevTaskId);e.startTime=t.endTime;break}case"getStartDate":(n=se(0,Wt,pe[t].raw.startTime.startData))&&(pe[t].startTime=n)}return pe[t].startTime&&(pe[t].endTime=ce(pe[t].startTime,Wt,pe[t].raw.endTime.data,re),pe[t].endTime&&(pe[t].processed=!0,pe[t].manualEndTime=d()(pe[t].raw.endTime.data,"YYYY-MM-DD",!0).isValid(),oe(pe[t],Wt,Xt))),pe[t].processed};let e=!0;for(let n=0;n<pe.length;n++)t(n),e=e&&pe[n].processed;return e},me=function(t,e){t.split(",").forEach((function(t){let n=ye(t);void 0!==n&&n.classes.push(e)}))},ve=function(t,e){ne.push((function(){const n=document.querySelector(`[id="${t}"]`);null!==n&&n.addEventListener("click",(function(){e()}))})),ne.push((function(){const n=document.querySelector(`[id="${t}-text"]`);null!==n&&n.addEventListener("click",(function(){e()}))}))};var _e={clear:function(){Jt=[],Qt=[],te="",ne=[],Zt="",fe=0,he=void 0,de=void 0,pe=[],Wt="",Kt="",Xt=[],re=!1},setDateFormat:function(t){Wt=t},getDateFormat:function(){return Wt},enableInclusiveEndDates:function(){re=!0},endDatesAreInclusive:function(){return re},setAxisFormat:function(t){Kt=t},getAxisFormat:function(){return Kt},setTitle:function(t){Zt=t},getTitle:function(){return Zt},addSection:function(t){te=t,Jt.push(t)},getSections:function(){return Jt},getTasks:function(){let t=be();let e=0;for(;!t&&e<10;)t=be(),e++;return Qt=pe},addTask:function(t,e){const n={section:te,type:te,processed:!1,manualEndTime:!1,renderEndTime:null,raw:{data:e},task:t,classes:[]},r=function(t,e){let n;const r=(n=":"===e.substr(0,1)?e.substr(1,e.length):e).split(","),i={};we(r,i,ee);for(let t=0;t<r.length;t++)r[t]=r[t].trim();switch(r.length){case 1:i.id=le(),i.startTime={type:"prevTaskEnd",id:t},i.endTime={data:r[0]};break;case 2:i.id=le(),i.startTime={type:"getStartDate",startData:r[0]},i.endTime={data:r[1]};break;case 3:i.id=le(r[0]),i.startTime={type:"getStartDate",startData:r[1]},i.endTime={data:r[2]}}return i}(de,e);n.raw.startTime=r.startTime,n.raw.endTime=r.endTime,n.id=r.id,n.prevTaskId=de,n.active=r.active,n.done=r.done,n.crit=r.crit,n.milestone=r.milestone;const i=pe.push(n);de=n.id,ge[n.id]=i-1},findTaskById:ye,addTaskOrg:function(t,e){const n={section:te,type:te,description:t,task:t,classes:[]},r=function(t,e){let n;const r=(n=":"===e.substr(0,1)?e.substr(1,e.length):e).split(","),i={};we(r,i,ee);for(let t=0;t<r.length;t++)r[t]=r[t].trim();let o="";switch(r.length){case 1:i.id=le(),i.startTime=t.endTime,o=r[0];break;case 2:i.id=le(),i.startTime=se(0,Wt,r[0]),o=r[1];break;case 3:i.id=le(r[0]),i.startTime=se(0,Wt,r[1]),o=r[2]}return o&&(i.endTime=ce(i.startTime,Wt,o,re),i.manualEndTime=d()(o,"YYYY-MM-DD",!0).isValid(),oe(i,Wt,Xt)),i}(he,e);n.startTime=r.startTime,n.endTime=r.endTime,n.id=r.id,n.active=r.active,n.done=r.done,n.crit=r.crit,n.milestone=r.milestone,he=n,Qt.push(n)},setExcludes:function(t){Xt=t.toLowerCase().split(/[\s,]+/)},getExcludes:function(){return Xt},setClickEvent:function(t,e,n){t.split(",").forEach((function(t){!function(t,e,n){if("loose"!==Gt.securityLevel)return;if(void 0===e)return;let r=[];if("string"==typeof n){r=n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);for(let t=0;t<r.length;t++){let e=r[t].trim();'"'===e.charAt(0)&&'"'===e.charAt(e.length-1)&&(e=e.substr(1,e.length-2)),r[t]=e}}void 0!==ye(t)&&ve(t,()=>{window[e](...r)})}(t,e,n)})),me(t,"clickable")},setLink:function(t,e){let n=e;"loose"!==Gt.securityLevel&&(n=Object(T.sanitizeUrl)(e)),t.split(",").forEach((function(t){void 0!==ye(t)&&ve(t,()=>{window.open(n,"_self")})})),me(t,"clickable")},bindFunctions:function(t){ne.forEach((function(e){e(t)}))},durationToDate:ue};function we(t,e,n){let r=!0;for(;r;)r=!1,n.forEach((function(n){const i=new RegExp("^\\s*"+n+"\\s*$");t[0].match(i)&&(e[n]=!0,t.shift(1),r=!0)}))}Ht.parser.yy=_e;const xe={titleTopMargin:25,barHeight:20,barGap:4,topPadding:50,rightPadding:75,leftPadding:75,gridLineStartPadding:35,fontSize:11,fontFamily:'"Open-Sans", "sans-serif"'};let ke;var Ee=function(t){Object.keys(t).forEach((function(e){xe[e]=t[e]}))},Ae=function(t,e){Ht.parser.yy.clear(),Ht.parser.parse(t);const n=document.getElementById(e);void 0===(ke=n.parentElement.offsetWidth)&&(ke=1200),void 0!==xe.useWidth&&(ke=xe.useWidth);const r=Ht.parser.yy.getTasks(),i=r.length*(xe.barHeight+xe.barGap)+2*xe.topPadding;n.setAttribute("height","100%"),n.setAttribute("viewBox","0 0 "+ke+" "+i);const a=o.select(`[id="${e}"]`),s=o.scaleTime().domain([o.min(r,(function(t){return t.startTime})),o.max(r,(function(t){return t.endTime}))]).rangeRound([0,ke-xe.leftPadding-xe.rightPadding]);let u=[];for(let t=0;t<r.length;t++)u.push(r[t].type);const c=u;function f(t){let e=t.length;const n={};for(;e;)n[t[--e]]=(n[t[e]]||0)+1;return n}u=function(t){const e={},n=[];for(let r=0,i=t.length;r<i;++r)e.hasOwnProperty(t[r])||(e[t[r]]=!0,n.push(t[r]));return n}(u),function(t,e,n){const r=xe.barHeight,i=r+xe.barGap,l=xe.topPadding,h=xe.leftPadding;o.scaleLinear().domain([0,u.length]).range(["#00B9FA","#F95002"]).interpolate(o.interpolateHcl);(function(t,e,n,r){let i=o.axisBottom(s).tickSize(-r+e+xe.gridLineStartPadding).tickFormat(o.timeFormat(Ht.parser.yy.getAxisFormat()||xe.axisFormat||"%Y-%m-%d"));a.append("g").attr("class","grid").attr("transform","translate("+t+", "+(r-50)+")").call(i).selectAll("text").style("text-anchor","middle").attr("fill","#000").attr("stroke","none").attr("font-size",10).attr("dy","1em")})(h,l,0,n),function(t,e,n,r,i,o,c){a.append("g").selectAll("rect").data(t).enter().append("rect").attr("x",0).attr("y",(function(t,r){return r*e+n-2})).attr("width",(function(){return c-xe.rightPadding/2})).attr("height",e).attr("class",(function(t){for(let e=0;e<u.length;e++)if(t.type===u[e])return"section section"+e%xe.numberSectionStyles;return"section section0"}));const f=a.append("g").selectAll("rect").data(t).enter();f.append("rect").attr("id",(function(t){return t.id})).attr("rx",3).attr("ry",3).attr("x",(function(t){return t.milestone?s(t.startTime)+r+.5*(s(t.endTime)-s(t.startTime))-.5*i:s(t.startTime)+r})).attr("y",(function(t,r){return r*e+n})).attr("width",(function(t){return t.milestone?i:s(t.renderEndTime||t.endTime)-s(t.startTime)})).attr("height",i).attr("transform-origin",(function(t,o){return(s(t.startTime)+r+.5*(s(t.endTime)-s(t.startTime))).toString()+"px "+(o*e+n+.5*i).toString()+"px"})).attr("class",(function(t){let e="";t.classes.length>0&&(e=t.classes.join(" "));let n=0;for(let e=0;e<u.length;e++)t.type===u[e]&&(n=e%xe.numberSectionStyles);let r="";return t.active?t.crit?r+=" activeCrit":r=" active":t.done?r=t.crit?" doneCrit":" done":t.crit&&(r+=" crit"),0===r.length&&(r=" task"),t.milestone&&(r=" milestone "+r),r+=n,"task"+(r+=" "+e)})),f.append("text").attr("id",(function(t){return t.id+"-text"})).text((function(t){return t.task})).attr("font-size",xe.fontSize).attr("x",(function(t){let e=s(t.startTime),n=s(t.renderEndTime||t.endTime);t.milestone&&(e+=.5*(s(t.endTime)-s(t.startTime))-.5*i),t.milestone&&(n=e+i);const o=this.getBBox().width;return o>n-e?n+o+1.5*xe.leftPadding>c?e+r-5:n+r+5:(n-e)/2+e+r})).attr("y",(function(t,r){return r*e+xe.barHeight/2+(xe.fontSize/2-2)+n})).attr("text-height",i).attr("class",(function(t){const e=s(t.startTime);let n=s(t.endTime);t.milestone&&(n=e+i);const r=this.getBBox().width;let o="";t.classes.length>0&&(o=t.classes.join(" "));let a=0;for(let e=0;e<u.length;e++)t.type===u[e]&&(a=e%xe.numberSectionStyles);let f="";return t.active&&(f=t.crit?"activeCritText"+a:"activeText"+a),t.done?f=t.crit?f+" doneCritText"+a:f+" doneText"+a:t.crit&&(f=f+" critText"+a),t.milestone&&(f+=" milestoneText"),r>n-e?n+r+1.5*xe.leftPadding>c?o+" taskTextOutsideLeft taskTextOutside"+a+" "+f:o+" taskTextOutsideRight taskTextOutside"+a+" "+f+" width-"+r:o+" taskText taskText"+a+" "+f+" width-"+r}))}(t,i,l,h,r,0,e),function(t,e){const n=[];let r=0;for(let t=0;t<u.length;t++)n[t]=[u[t],(i=u[t],o=c,f(o)[i]||0)];var i,o;a.append("g").selectAll("text").data(n).enter().append("text").text((function(t){return t[0]})).attr("x",10).attr("y",(function(i,o){if(!(o>0))return i[1]*t/2+e;for(let a=0;a<o;a++)return r+=n[o-1][1],i[1]*t/2+r*t+e})).attr("class",(function(t){for(let e=0;e<u.length;e++)if(t[0]===u[e])return"sectionTitle sectionTitle"+e%xe.numberSectionStyles;return"sectionTitle"}))}(i,l),function(t,e,n,r){const i=a.append("g").attr("class","today"),o=new Date;i.append("line").attr("x1",s(o)+t).attr("x2",s(o)+t).attr("y1",xe.titleTopMargin).attr("y2",r-xe.titleTopMargin).attr("class","today")}(h,0,0,n)}(r,ke,i),void 0!==xe.useWidth&&n.setAttribute("width",ke),a.append("text").text(Ht.parser.yy.getTitle()).attr("x",ke/2).attr("y",xe.titleTopMargin).attr("class","titleText")},Se=n(59),Te=n.n(Se);let Me=[],De={};const Ce=function(t){void 0===De[t]&&(De[t]={id:t,methods:[],members:[],annotations:[]})},Oe=function(t,e){const n=De[t];if("string"==typeof e){const t=e.trim();t.startsWith("<<")&&t.endsWith(">>")?n.annotations.push(t.substring(2,t.length-2)):t.endsWith(")")?n.methods.push(t):t&&n.members.push(t)}};var Re={addClass:Ce,clear:function(){Me=[],De={}},getClass:function(t){return De[t]},getClasses:function(){return De},addAnnotation:function(t,e){De[t].annotations.push(e)},getRelations:function(){return Me},addRelation:function(t){v.debug("Adding relation: "+JSON.stringify(t)),Ce(t.id1),Ce(t.id2),Me.push(t)},addMember:Oe,addMembers:function(t,e){Array.isArray(e)&&(e.reverse(),e.forEach(e=>Oe(t,e)))},cleanupLabel:function(t){return":"===t.substring(0,1)?t.substr(2).trim():t.trim()},lineType:{LINE:0,DOTTED_LINE:1},relationType:{AGGREGATION:0,EXTENSION:1,COMPOSITION:2,DEPENDENCY:3}},Ie=n(46),Ne=n.n(Ie);Ie.parser.yy=Re;let Be={},Le=0;const Pe={dividerMargin:10,padding:5,textHeight:10},Fe=function(t){const e=Object.keys(Be);for(let n=0;n<e.length;n++)if(Be[e[n]].label===t)return e[n]};let qe=0;const je=function(t,e){v.info("Rendering class "+e);const n=function(t,e,n){const r=t.append("tspan").attr("x",Pe.padding).text(e);n||r.attr("dy",Pe.textHeight)},r="classId"+Le,i={id:r,label:e.id,width:0,height:0},o=t.append("g").attr("id",r).attr("class","classGroup"),a=o.append("text").attr("y",Pe.textHeight+Pe.padding).attr("x",0);let s=!0;e.annotations.forEach((function(t){const e=a.append("tspan").text(""+t+"");s||e.attr("dy",Pe.textHeight),s=!1}));const u=a.append("tspan").text(e.id).attr("class","title");s||u.attr("dy",Pe.textHeight);const c=a.node().getBBox().height,f=o.append("line").attr("x1",0).attr("y1",Pe.padding+c+Pe.dividerMargin/2).attr("y2",Pe.padding+c+Pe.dividerMargin/2),l=o.append("text").attr("x",Pe.padding).attr("y",c+Pe.dividerMargin+Pe.textHeight).attr("fill","white").attr("class","classText");s=!0,e.members.forEach((function(t){n(l,t,s),s=!1}));const h=l.node().getBBox(),d=o.append("line").attr("x1",0).attr("y1",Pe.padding+c+Pe.dividerMargin+h.height).attr("y2",Pe.padding+c+Pe.dividerMargin+h.height),p=o.append("text").attr("x",Pe.padding).attr("y",c+2*Pe.dividerMargin+h.height+Pe.textHeight).attr("fill","white").attr("class","classText");s=!0,e.methods.forEach((function(t){n(p,t,s),s=!1}));const g=o.node().getBBox(),y=o.insert("rect",":first-child").attr("x",0).attr("y",0).attr("width",g.width+2*Pe.padding).attr("height",g.height+Pe.padding+.5*Pe.dividerMargin).node().getBBox().width;return a.node().childNodes.forEach((function(t){t.setAttribute("x",(y-t.getBBox().width)/2)})),f.attr("x2",y),d.attr("x2",y),i.width=y,i.height=g.height+Pe.padding+.5*Pe.dividerMargin,Be[r]=i,Le++,i};var Ue=function(t){Object.keys(t).forEach((function(e){Pe[e]=t[e]}))},ze=function(t,e){Be={},Ie.parser.yy.clear(),Ie.parser.parse(t),v.info("Rendering diagram "+t);const n=o.select(`[id='${e}']`);var r;(r=n).append("defs").append("marker").attr("id","extensionStart").attr("class","extension").attr("refX",0).attr("refY",7).attr("markerWidth",190).attr("markerHeight",240).attr("orient","auto").append("path").attr("d","M 1,7 L18,13 V 1 Z"),r.append("defs").append("marker").attr("id","extensionEnd").attr("refX",19).attr("refY",7).attr("markerWidth",20).attr("markerHeight",28).attr("orient","auto").append("path").attr("d","M 1,1 V 13 L18,7 Z"),r.append("defs").append("marker").attr("id","compositionStart").attr("class","extension").attr("refX",0).attr("refY",7).attr("markerWidth",190).attr("markerHeight",240).attr("orient","auto").append("path").attr("d","M 18,7 L9,13 L1,7 L9,1 Z"),r.append("defs").append("marker").attr("id","compositionEnd").attr("refX",19).attr("refY",7).attr("markerWidth",20).attr("markerHeight",28).attr("orient","auto").append("path").attr("d","M 18,7 L9,13 L1,7 L9,1 Z"),r.append("defs").append("marker").attr("id","aggregationStart").attr("class","extension").attr("refX",0).attr("refY",7).attr("markerWidth",190).attr("markerHeight",240).attr("orient","auto").append("path").attr("d","M 18,7 L9,13 L1,7 L9,1 Z"),r.append("defs").append("marker").attr("id","aggregationEnd").attr("refX",19).attr("refY",7).attr("markerWidth",20).attr("markerHeight",28).attr("orient","auto").append("path").attr("d","M 18,7 L9,13 L1,7 L9,1 Z"),r.append("defs").append("marker").attr("id","dependencyStart").attr("class","extension").attr("refX",0).attr("refY",7).attr("markerWidth",190).attr("markerHeight",240).attr("orient","auto").append("path").attr("d","M 5,7 L9,13 L1,7 L9,1 Z"),r.append("defs").append("marker").attr("id","dependencyEnd").attr("refX",19).attr("refY",7).attr("markerWidth",20).attr("markerHeight",28).attr("orient","auto").append("path").attr("d","M 18,7 L9,13 L14,7 L9,1 Z");const i=new S.a.Graph({multigraph:!0});i.setGraph({isMultiGraph:!0}),i.setDefaultEdgeLabel((function(){return{}}));const a=Re.getClasses(),s=Object.keys(a);for(let t=0;t<s.length;t++){const e=a[s[t]],r=je(n,e);i.setNode(r.id,r),v.info("Org height: "+r.height)}Re.getRelations().forEach((function(t){v.info("tjoho"+Fe(t.id1)+Fe(t.id2)+JSON.stringify(t)),i.setEdge(Fe(t.id1),Fe(t.id2),{relation:t})})),Te.a.layout(i),i.nodes().forEach((function(t){void 0!==t&&void 0!==i.node(t)&&(v.debug("Node "+t+": "+JSON.stringify(i.node(t))),o.select("#"+t).attr("transform","translate("+(i.node(t).x-i.node(t).width/2)+","+(i.node(t).y-i.node(t).height/2)+" )"))})),i.edges().forEach((function(t){void 0!==t&&void 0!==i.edge(t)&&(v.debug("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(i.edge(t))),function(t,e,n){const r=function(t){switch(t){case Re.relationType.AGGREGATION:return"aggregation";case Re.relationType.EXTENSION:return"extension";case Re.relationType.COMPOSITION:return"composition";case Re.relationType.DEPENDENCY:return"dependency"}};e.points=e.points.filter(t=>!Number.isNaN(t.y));const i=e.points,a=o.line().x((function(t){return t.x})).y((function(t){return t.y})).curve(o.curveBasis),s=t.append("path").attr("d",a(i)).attr("id","edge"+qe).attr("class","relation");let u,c,f="";Pe.arrowMarkerAbsolute&&(f=(f=(f=window.location.protocol+"//"+window.location.host+window.location.pathname+window.location.search).replace(/\(/g,"\\(")).replace(/\)/g,"\\)")),"none"!==n.relation.type1&&s.attr("marker-start","url("+f+"#"+r(n.relation.type1)+"Start)"),"none"!==n.relation.type2&&s.attr("marker-end","url("+f+"#"+r(n.relation.type2)+"End)");const l=e.points.length;let h,d,p,g,y=E.calcLabelPosition(e.points);if(u=y.x,c=y.y,l%2!=0&&l>1){let t=E.calcCardinalityPosition("none"!==n.relation.type1,e.points,e.points[0]),r=E.calcCardinalityPosition("none"!==n.relation.type2,e.points,e.points[l-1]);v.debug("cardinality_1_point "+JSON.stringify(t)),v.debug("cardinality_2_point "+JSON.stringify(r)),h=t.x,d=t.y,p=r.x,g=r.y}if(void 0!==n.title){const e=t.append("g").attr("class","classLabel"),r=e.append("text").attr("class","label").attr("x",u).attr("y",c).attr("fill","red").attr("text-anchor","middle").text(n.title);window.label=r;const i=r.node().getBBox();e.insert("rect",":first-child").attr("class","box").attr("x",i.x-Pe.padding/2).attr("y",i.y-Pe.padding/2).attr("width",i.width+Pe.padding).attr("height",i.height+Pe.padding)}if(v.info("Rendering relation "+JSON.stringify(n)),void 0!==n.relationTitle1&&"none"!==n.relationTitle1){t.append("g").attr("class","cardinality").append("text").attr("class","type1").attr("x",h).attr("y",d).attr("fill","black").attr("font-size","6").text(n.relationTitle1)}if(void 0!==n.relationTitle2&&"none"!==n.relationTitle2){t.append("g").attr("class","cardinality").append("text").attr("class","type2").attr("x",p).attr("y",g).attr("fill","black").attr("font-size","6").text(n.relationTitle2)}qe++}(n,i.edge(t),i.edge(t).relation))})),n.attr("height","100%"),n.attr("width",`${1.5*i.graph().width+20}`),n.attr("viewBox","-10 -10 "+(i.graph().width+20)+" "+(i.graph().height+20))};let Ye=[];let Ve={root:{relations:[],states:{},documents:{}}},He=Ve.root,$e=0;const Ge=function(t,e,n,r,i){void 0===He.states[t]?He.states[t]={id:t,descriptions:[],type:e,doc:n,note:i}:(He.states[t].doc||(He.states[t].doc=n),He.states[t].type||(He.states[t].type=e)),r&&("string"==typeof r&&Xe(t,r.trim()),"object"==typeof r&&r.forEach(e=>Xe(t,e.trim()))),i&&(He.states[t].note=i)},We=function(){He=(Ve={root:{relations:[],states:{},documents:{}}}).root},Ke=function(t,e,n){let r=t,i=e,o="default",a="default";"[*]"===t&&(r="start"+ ++$e,o="start"),"[*]"===e&&(i="end"+$e,a="end"),Ge(r,o),Ge(i,a),He.relations.push({id1:r,id2:i,title:n})},Xe=function(t,e){const n=He.states[t];let r=e;":"===r[0]&&(r=r.substr(1).trim()),n.descriptions.push(r)};let Ze=0;var Je={addState:Ge,clear:We,getState:function(t){return He.states[t]},getStates:function(){return He.states},getRelations:function(){return He.relations},addRelation:Ke,getDividerId:()=>"divider-id-"+ ++Ze,cleanupLabel:function(t){return":"===t.substring(0,1)?t.substr(2).trim():t.trim()},lineType:{LINE:0,DOTTED_LINE:1},relationType:{AGGREGATION:0,EXTENSION:1,COMPOSITION:2,DEPENDENCY:3},logDocuments:function(){v.info("Documents = ",Ve)},getRootDoc:()=>Ye,setRootDoc:t=>{v.info("Setting root doc",t),Ye=t},extract:t=>{We(),t.forEach(t=>{"state"===t.stmt&&Ge(t.id,t.type,t.doc,t.description,t.note),"relation"===t.stmt&&Ke(t.state1.id,t.state2.id,t.description)})}},Qe=n(47),tn=n.n(Qe);const en={};var nn=(t,e)=>{en[t]=e};const rn=(t,e)=>{const n=t.append("text").attr("x",2*l().state.padding).attr("y",l().state.textHeight+1.5*l().state.padding).attr("font-size",l().state.fontSize).attr("class","state-title").text(e.descriptions[0]).node().getBBox(),r=n.height,i=t.append("text").attr("x",l().state.padding).attr("y",r+.2*l().state.padding+l().state.dividerMargin+l().state.textHeight).attr("class","state-description");let o=!0,a=!0;e.descriptions.forEach((function(t){o||(!function(t,e,n){const r=t.append("tspan").attr("x",2*l().state.padding).text(e);n||r.attr("dy",l().state.textHeight)}(i,t,a),a=!1),o=!1}));const s=t.append("line").attr("x1",l().state.padding).attr("y1",l().state.padding+r+l().state.dividerMargin/2).attr("y2",l().state.padding+r+l().state.dividerMargin/2).attr("class","descr-divider"),u=i.node().getBBox(),c=Math.max(u.width,n.width);return s.attr("x2",c+3*l().state.padding),t.insert("rect",":first-child").attr("x",l().state.padding).attr("y",l().state.padding).attr("width",c+2*l().state.padding).attr("height",u.height+r+2*l().state.padding).attr("rx",l().state.radius),t},on=(t,e)=>{const n=t.append("text").attr("x",2*l().state.padding).attr("y",l().state.titleShift).attr("font-size",l().state.fontSize).attr("class","state-title").text(e.id),r=n.node().getBBox(),i=1-l().state.textHeight,o=t.append("line").attr("x1",0).attr("y1",i).attr("y2",i).attr("class","descr-divider"),a=t.node().getBBox();return n.attr("x",a.width/2-r.width/2),o.attr("x2",a.width+l().state.padding),t.insert("rect",":first-child").attr("x",a.x).attr("y",i).attr("class","composit").attr("width",a.width+l().state.padding).attr("height",a.height+l().state.textHeight+l().state.titleShift+1).attr("rx","0"),t.insert("rect",":first-child").attr("x",a.x).attr("y",l().state.titleShift-l().state.textHeight-l().state.padding).attr("width",a.width+l().state.padding).attr("height",3*l().state.textHeight).attr("rx",l().state.radius),t.insert("rect",":first-child").attr("x",a.x).attr("y",l().state.titleShift-l().state.textHeight-l().state.padding).attr("width",a.width+l().state.padding).attr("height",a.height+3+2*l().state.textHeight).attr("rx",l().state.radius),t},an=(t,e)=>{e.attr("class","state-note");const n=e.append("rect").attr("x",0).attr("y",l().state.padding),r=e.append("g"),{textWidth:i,textHeight:o}=((t,e,n,r)=>{let i=0;const o=r.append("text");o.style("text-anchor","start"),o.attr("class","noteText");let a=t.replace(/\r\n/g,"<br/>");const s=(a=a.replace(/\n/g,"<br/>")).split(/<br\/?>/gi);let u=1.25*l().state.noteMargin;for(const t of s){const r=t.trim();if(r.length>0){const t=o.append("tspan");if(t.text(r),0===u){u+=t.node().getBBox().height}i+=u,t.attr("x",e+l().state.noteMargin),t.attr("y",n+i+1.25*l().state.noteMargin)}}return{textWidth:o.node().getBBox().width,textHeight:i}})(t,0,0,r);return n.attr("height",o+2*l().state.noteMargin),n.attr("width",i+2*l().state.noteMargin),n},sn=function(t,e){const n=e.id,r={id:n,label:e.id,width:0,height:0},i=t.append("g").attr("id",n).attr("class","stateGroup");"start"===e.type&&(t=>t.append("circle").style("stroke","black").style("fill","black").attr("r",l().state.sizeUnit).attr("cx",l().state.padding+l().state.sizeUnit).attr("cy",l().state.padding+l().state.sizeUnit))(i),"end"===e.type&&(t=>(t.append("circle").style("stroke","black").style("fill","white").attr("r",l().state.sizeUnit+l().state.miniPadding).attr("cx",l().state.padding+l().state.sizeUnit+l().state.miniPadding).attr("cy",l().state.padding+l().state.sizeUnit+l().state.miniPadding),t.append("circle").style("stroke","black").style("fill","black").attr("r",l().state.sizeUnit).attr("cx",l().state.padding+l().state.sizeUnit+2).attr("cy",l().state.padding+l().state.sizeUnit+2)))(i),"fork"!==e.type&&"join"!==e.type||((t,e)=>{let n=l().state.forkWidth,r=l().state.forkHeight;if(e.parentId){let t=n;n=r,r=t}t.append("rect").style("stroke","black").style("fill","black").attr("width",n).attr("height",r).attr("x",l().state.padding).attr("y",l().state.padding)})(i,e),"note"===e.type&&an(e.note.text,i),"divider"===e.type&&(t=>t.append("line").style("stroke","grey").style("stroke-dasharray","3").attr("x1",l().state.textHeight).attr("class","divider").attr("x2",2*l().state.textHeight).attr("y1",0).attr("y2",0))(i),"default"===e.type&&0===e.descriptions.length&&((t,e)=>{const n=t.append("text").attr("x",2*l().state.padding).attr("y",l().state.textHeight+2*l().state.padding).attr("font-size",l().state.fontSize).attr("class","state-title").text(e.id),r=n.node().getBBox();t.insert("rect",":first-child").attr("x",l().state.padding).attr("y",l().state.padding).attr("width",r.width+2*l().state.padding).attr("height",r.height+2*l().state.padding).attr("rx",l().state.radius)})(i,e),"default"===e.type&&e.descriptions.length>0&&rn(i,e);const o=i.node().getBBox();return r.width=o.width+2*l().state.padding,r.height=o.height+2*l().state.padding,nn(n,r),r};let un=0;let cn;Qe.parser.yy=Je;const fn={},ln=t=>t?t.length*cn.fontSizeFactor:1,hn=t=>{if(!t)return 1;let e=t.replace(/<br\/?>/gi,"#br#");return(e=e.replace(/\\n/g,"#br#")).split("#br#")},dn=(t,e,n)=>{const r=new S.a.Graph({compound:!0});n?r.setGraph({rankdir:"LR",compound:!0,ranker:"tight-tree",ranksep:cn.edgeLengthFactor}):r.setGraph({rankdir:"TB",compound:!0,ranksep:cn.edgeLengthFactor,ranker:"tight-tree"}),r.setDefaultEdgeLabel((function(){return{}})),Je.extract(t);const i=Je.getStates(),a=Je.getRelations(),s=Object.keys(i);for(let t=0;t<s.length;t++){const o=i[s[t]];let a;if(n&&(o.parentId=n),o.doc){let t=e.append("g").attr("id",o.id).attr("class","stateGroup");a=dn(o.doc,t,o.id);{let e=(t=on(t,o)).node().getBBox();a.width=e.width,a.height=e.height+2*cn.padding,fn[o.id]={y:cn.compositTitleSize}}}else a=sn(e,o);if(o.note){const t={descriptions:[],id:o.id+"-note",note:o.note,type:"note"},n=sn(e,t);"left of"===o.note.position?(r.setNode(a.id+"-note",n),r.setNode(a.id,a)):(r.setNode(a.id,a),r.setNode(a.id+"-note",n)),r.setParent(a.id,a.id+"-group"),r.setParent(a.id+"-note",a.id+"-group")}else r.setNode(a.id,a)}v.info("Count=",r.nodeCount()),a.forEach((function(t){r.setEdge(t.id1,t.id2,{relation:t,width:ln(t.title),height:cn.labelHeight*hn(t.title).length,labelpos:"c"})})),Te.a.layout(r),v.debug("Graph after layout",r.nodes());const u=e.node();r.nodes().forEach((function(t){if(void 0!==t&&void 0!==r.node(t)){v.warn("Node "+t+": "+JSON.stringify(r.node(t))),o.select("#"+u.id+" #"+t).attr("transform","translate("+(r.node(t).x-r.node(t).width/2)+","+(r.node(t).y+(fn[t]?fn[t].y:0)-r.node(t).height/2)+" )"),o.select("#"+u.id+" #"+t).attr("data-x-shift",r.node(t).x-r.node(t).width/2),document.querySelectorAll("#"+u.id+" #"+t+" .divider").forEach(t=>{const e=t.parentElement;let n=0,r=0;e&&(e.parentElement&&(n=e.parentElement.getBBox().width),r=parseInt(e.getAttribute("data-x-shift"),10),Number.isNaN(r)&&(r=0)),t.setAttribute("x1",0-r),t.setAttribute("x2",n-r)})}else v.debug("No Node "+t+": "+JSON.stringify(r.node(t)))}));let c=u.getBBox();r.edges().forEach((function(t){void 0!==t&&void 0!==r.edge(t)&&(v.debug("Edge "+t.v+" -> "+t.w+": "+JSON.stringify(r.edge(t))),function(t,e,n){e.points=e.points.filter(t=>!Number.isNaN(t.y));const r=e.points,i=o.line().x((function(t){return t.x})).y((function(t){return t.y})).curve(o.curveBasis),a=t.append("path").attr("d",i(r)).attr("id","edge"+un).attr("class","transition");let s="";if(l().state.arrowMarkerAbsolute&&(s=(s=(s=window.location.protocol+"//"+window.location.host+window.location.pathname+window.location.search).replace(/\(/g,"\\(")).replace(/\)/g,"\\)")),a.attr("marker-end","url("+s+"#"+function(t){switch(t){case Je.relationType.AGGREGATION:return"aggregation";case Je.relationType.EXTENSION:return"extension";case Je.relationType.COMPOSITION:return"composition";case Je.relationType.DEPENDENCY:return"dependency"}}(Je.relationType.DEPENDENCY)+"End)"),void 0!==n.title){const r=t.append("g").attr("class","stateLabel"),{x:i,y:o}=E.calcLabelPosition(e.points),a=(t=>{let e=t.replace(/<br\/?>/gi,"#br#");return(e=e.replace(/\\n/g,"#br#")).split("#br#")})(n.title);let s=0;const u=[];for(let t=0;t<=a.length;t++){const e=r.append("text").attr("text-anchor","middle").text(a[t]).attr("x",i).attr("y",o+s);if(0===s){const t=e.node().getBBox();s=t.height}u.push(e)}if(a.length>1){const t=a.length*s*.25;u.forEach((e,n)=>e.attr("y",o+n*s-t))}const c=r.node().getBBox();r.insert("rect",":first-child").attr("class","box").attr("x",c.x-l().state.padding/2).attr("y",c.y-l().state.padding/2).attr("width",c.width+l().state.padding).attr("height",c.height+l().state.padding)}un++}(e,r.edge(t),r.edge(t).relation))})),c=u.getBBox();const f={id:n||"root",label:n||"root",width:0,height:0};return f.width=c.width+2*cn.padding,f.height=c.height+2*cn.padding,v.info("Doc rendered",f,r),f};var pn=function(){},gn=function(t,e){cn=l().state,Qe.parser.yy.clear(),Qe.parser.parse(t),v.debug("Rendering diagram "+t);const n=o.select(`[id='${e}']`);n.append("defs").append("marker").attr("id","dependencyEnd").attr("refX",19).attr("refY",7).attr("markerWidth",20).attr("markerHeight",28).attr("orient","auto").append("path").attr("d","M 19,7 L9,13 L14,7 L9,1 Z"),new S.a.Graph({multigraph:!1,compound:!0,rankdir:"RL"}).setDefaultEdgeLabel((function(){return{}}));const r=Je.getRootDoc();dn(r,n);const i=cn.padding,a=n.node().getBBox(),s=a.width+2*i,u=a.height+2*i;n.attr("width",2*s),n.attr("viewBox",`${a.x-cn.padding}  ${a.y-cn.padding} `+s+" "+u)},yn=n(48),bn=n.n(yn),mn=n(228),vn=n.n(mn);let _n={},wn=null,xn={master:wn},kn="master",En="LR",An=0;function Sn(){return vn()({length:7,characters:"0123456789abcdef"})}function Tn(t,e){for(v.debug("Entering isfastforwardable:",t.id,e.id);t.seq<=e.seq&&t!==e&&null!=e.parent;){if(Array.isArray(e.parent))return v.debug("In merge commit:",e.parent),Tn(t,_n[e.parent[0]])||Tn(t,_n[e.parent[1]]);e=_n[e.parent]}return v.debug(t.id,e.id),t.id===e.id}let Mn={};function Dn(t,e,n){const r=t.indexOf(e);-1===r?t.push(n):t.splice(r,1,n)}const Cn=function(){const t=Object.keys(_n).map((function(t){return _n[t]}));return t.forEach((function(t){v.debug(t.id)})),bn.a.orderBy(t,["seq"],["desc"])};var On={setDirection:function(t){En=t},setOptions:function(t){v.debug("options str",t),t=(t=t&&t.trim())||"{}";try{Mn=JSON.parse(t)}catch(t){v.error("error while parsing gitGraph options",t.message)}},getOptions:function(){return Mn},commit:function(t){const e={id:Sn(),message:t,seq:An++,parent:null==wn?null:wn.id};wn=e,_n[e.id]=e,xn[kn]=e.id,v.debug("in pushCommit "+e.id)},branch:function(t){xn[t]=null!=wn?wn.id:null,v.debug("in createBranch")},merge:function(t){const e=_n[xn[kn]],n=_n[xn[t]];if(function(t,e){return t.seq>e.seq&&Tn(e,t)}(e,n))v.debug("Already merged");else{if(Tn(e,n))xn[kn]=xn[t],wn=_n[xn[kn]];else{const e={id:Sn(),message:"merged branch "+t+" into "+kn,seq:An++,parent:[null==wn?null:wn.id,xn[t]]};wn=e,_n[e.id]=e,xn[kn]=e.id}v.debug(xn),v.debug("in mergeBranch")}},checkout:function(t){v.debug("in checkout");const e=xn[kn=t];wn=_n[e]},reset:function(t){v.debug("in reset",t);const e=t.split(":")[0];let n=parseInt(t.split(":")[1]),r="HEAD"===e?wn:_n[xn[e]];for(v.debug(r,n);n>0;)if(n--,!(r=_n[r.parent])){const t="Critical error - unique parent commit not found during reset";throw v.error(t),t}wn=r,xn[kn]=r.id},prettyPrint:function(){v.debug(_n),function t(e){const n=bn.a.maxBy(e,"seq");let r="";e.forEach((function(t){r+=t===n?"\t*":"\t|"}));const i=[r,n.id,n.seq];for(let t in xn)xn[t]===n.id&&i.push(t);if(v.debug(i.join(" ")),Array.isArray(n.parent)){const t=_n[n.parent[0]];Dn(e,n,t),e.push(_n[n.parent[1]])}else{if(null==n.parent)return;{const t=_n[n.parent];Dn(e,n,t)}}t(e=bn.a.uniqBy(e,"id"))}([Cn()[0]])},clear:function(){_n={},xn={master:wn=null},kn="master",An=0},getBranchesAsObjArray:function(){const t=[];for(let e in xn)t.push({name:e,commit:_n[xn[e]]});return t},getBranches:function(){return xn},getCommits:function(){return _n},getCommitsArray:Cn,getCurrentBranch:function(){return kn},getDirection:function(){return En},getHead:function(){return wn}},Rn=n(85),In=n.n(Rn);let Nn,Bn={},Ln={nodeSpacing:150,nodeFillColor:"yellow",nodeStrokeWidth:2,nodeStrokeColor:"grey",lineStrokeWidth:4,branchOffset:50,lineColor:"grey",leftMargin:50,branchColors:["#442f74","#983351","#609732","#AA9A39"],nodeRadius:10,nodeLabel:{width:75,height:100,x:-25,y:0}},Pn={};function Fn(t,e,n,r){const i=x(r,o.curveBasis),a=Ln.branchColors[n%Ln.branchColors.length],s=o.line().x((function(t){return Math.round(t.x)})).y((function(t){return Math.round(t.y)})).curve(i);t.append("svg:path").attr("d",s(e)).style("stroke",a).style("stroke-width",Ln.lineStrokeWidth).style("fill","none")}function qn(t,e){e=e||t.node().getBBox();const n=t.node().getCTM();return{left:n.e+e.x*n.a,top:n.f+e.y*n.d,width:e.width,height:e.height}}function jn(t,e,n,r,i){v.debug("svgDrawLineForCommits: ",e,n);const o=qn(t.select("#node-"+e+" circle")),a=qn(t.select("#node-"+n+" circle"));switch(r){case"LR":if(o.left-a.left>Ln.nodeSpacing){const e={x:o.left-Ln.nodeSpacing,y:a.top+a.height/2};Fn(t,[e,{x:a.left+a.width,y:a.top+a.height/2}],i,"linear"),Fn(t,[{x:o.left,y:o.top+o.height/2},{x:o.left-Ln.nodeSpacing/2,y:o.top+o.height/2},{x:o.left-Ln.nodeSpacing/2,y:e.y},e],i)}else Fn(t,[{x:o.left,y:o.top+o.height/2},{x:o.left-Ln.nodeSpacing/2,y:o.top+o.height/2},{x:o.left-Ln.nodeSpacing/2,y:a.top+a.height/2},{x:a.left+a.width,y:a.top+a.height/2}],i);break;case"BT":if(a.top-o.top>Ln.nodeSpacing){const e={x:a.left+a.width/2,y:o.top+o.height+Ln.nodeSpacing};Fn(t,[e,{x:a.left+a.width/2,y:a.top}],i,"linear"),Fn(t,[{x:o.left+o.width/2,y:o.top+o.height},{x:o.left+o.width/2,y:o.top+o.height+Ln.nodeSpacing/2},{x:a.left+a.width/2,y:e.y-Ln.nodeSpacing/2},e],i)}else Fn(t,[{x:o.left+o.width/2,y:o.top+o.height},{x:o.left+o.width/2,y:o.top+Ln.nodeSpacing/2},{x:a.left+a.width/2,y:a.top-Ln.nodeSpacing/2},{x:a.left+a.width/2,y:a.top}],i)}}function Un(t,e){return t.select(e).node().cloneNode(!0)}function zn(t,e,n,r){let i;const o=Object.keys(Bn).length;if("string"==typeof e)do{if(i=Bn[e],v.debug("in renderCommitHistory",i.id,i.seq),t.select("#node-"+e).size()>0)return;let a;t.append((function(){return Un(t,"#def-commit")})).attr("class","commit").attr("id",(function(){return"node-"+i.id})).attr("transform",(function(){switch(r){case"LR":return"translate("+(i.seq*Ln.nodeSpacing+Ln.leftMargin)+", "+Nn*Ln.branchOffset+")";case"BT":return"translate("+(Nn*Ln.branchOffset+Ln.leftMargin)+", "+(o-i.seq)*Ln.nodeSpacing+")"}})).attr("fill",Ln.nodeFillColor).attr("stroke",Ln.nodeStrokeColor).attr("stroke-width",Ln.nodeStrokeWidth);for(let t in n)if(n[t].commit===i){a=n[t];break}a&&(v.debug("found branch ",a.name),t.select("#node-"+i.id+" p").append("xhtml:span").attr("class","branch-label").text(a.name+", ")),t.select("#node-"+i.id+" p").append("xhtml:span").attr("class","commit-id").text(i.id),""!==i.message&&"BT"===r&&t.select("#node-"+i.id+" p").append("xhtml:span").attr("class","commit-msg").text(", "+i.message),e=i.parent}while(e&&Bn[e]);Array.isArray(e)&&(v.debug("found merge commmit",e),zn(t,e[0],n,r),Nn++,zn(t,e[1],n,r),Nn--)}function Yn(t,e,n,r){for(r=r||0;e.seq>0&&!e.lineDrawn;)"string"==typeof e.parent?(jn(t,e.id,e.parent,n,r),e.lineDrawn=!0,e=Bn[e.parent]):Array.isArray(e.parent)&&(jn(t,e.id,e.parent[0],n,r),jn(t,e.id,e.parent[1],n,r+1),Yn(t,Bn[e.parent[1]],n,r+1),e.lineDrawn=!0,e=Bn[e.parent[0]])}var Vn=function(t){Pn=t},Hn=function(t,e,n){try{const r=In.a.parser;r.yy=On,v.debug("in gitgraph renderer",t+"\n","id:",e,n),r.parse(t+"\n"),Ln=bn.a.assign(Ln,Pn,On.getOptions()),v.debug("effective options",Ln);const i=On.getDirection();Bn=On.getCommits();const a=On.getBranchesAsObjArray();"BT"===i&&(Ln.nodeLabel.x=a.length*Ln.branchOffset,Ln.nodeLabel.width="100%",Ln.nodeLabel.y=-2*Ln.nodeRadius);const s=o.select(`[id="${e}"]`);!function(t){t.append("defs").append("g").attr("id","def-commit").append("circle").attr("r",Ln.nodeRadius).attr("cx",0).attr("cy",0),t.select("#def-commit").append("foreignObject").attr("width",Ln.nodeLabel.width).attr("height",Ln.nodeLabel.height).attr("x",Ln.nodeLabel.x).attr("y",Ln.nodeLabel.y).attr("class","node-label").attr("requiredFeatures","http://www.w3.org/TR/SVG11/feature#Extensibility").append("p").html("")}(s),Nn=1;for(let t in a){const e=a[t];zn(s,e.commit.id,a,i),Yn(s,e.commit,i),Nn++}s.attr("height",(function(){return"BT"===i?Object.keys(Bn).length*Ln.nodeSpacing:(a.length+1)*Ln.branchOffset}))}catch(t){v.error("Error while rendering gitgraph"),v.error(t.message)}},$n="",Gn=!1;var Wn={setMessage:t=>{v.debug("Setting message to: "+t),$n=t},getMessage:()=>$n,setInfo:t=>{Gn=t},getInfo:()=>Gn},Kn=n(86),Xn=n.n(Kn);const Zn={};var Jn=function(t){Object.keys(t).forEach((function(e){Zn[e]=t[e]}))},Qn=(t,e,n)=>{try{const r=Xn.a.parser;r.yy=Wn,v.debug("Renering info diagram\n"+t),r.parse(t),v.debug("Parsed info diagram");const i=o.select("#"+e);i.append("g").append("text").attr("x",100).attr("y",40).attr("class","version").attr("font-size","32px").style("text-anchor","middle").text("v "+n),i.attr("height",100),i.attr("width",400)}catch(t){v.error("Error while rendering info diagram"),v.error(t.message)}};let tr={},er="";var nr={addSection:function(t,e){void 0===tr[t]&&(tr[t]=e,v.debug("Added new section :",t))},getSections:()=>tr,cleanupValue:function(t){return":"===t.substring(0,1)?(t=t.substring(1).trim(),Number(t.trim())):Number(t.trim())},clear:function(){tr={},er=""},setTitle:function(t){er=t},getTitle:function(){return er}},rr=n(87),ir=n.n(rr);const or={};let ar;var sr=function(t){Object.keys(t).forEach((function(e){or[e]=t[e]}))},ur=(t,e)=>{try{const h=ir.a.parser;h.yy=nr,v.debug("Rendering info diagram\n"+t),h.yy.clear(),h.parse(t),v.debug("Parsed info diagram");const d=document.getElementById(e);void 0===(ar=d.parentElement.offsetWidth)&&(ar=1200),void 0!==or.useWidth&&(ar=or.useWidth);const p=450;d.setAttribute("height","100%"),d.setAttribute("viewBox","0 0 "+ar+" "+p);var n=ar,r=Math.min(n,450)/2-40,i=o.select("#"+e).append("svg").attr("width",n).attr("height",450).append("g").attr("transform","translate("+n/2+",225)"),a=nr.getSections(),s=0;Object.keys(a).forEach((function(t){s+=a[t]})),v.info(a);var u=o.scaleOrdinal().domain(a).range(o.schemeSet2),c=o.pie().value((function(t){return t.value}))(o.entries(a)),f=o.arc().innerRadius(0).outerRadius(r);i.selectAll("mySlices").data(c).enter().append("path").attr("d",f).attr("fill",(function(t){return u(t.data.key)})).attr("stroke","black").style("stroke-width","2px").style("opacity",.7),i.selectAll("mySlices").data(c).enter().append("text").text((function(t){return(t.data.value/s*100).toFixed(0)+"%"})).attr("transform",(function(t){return"translate("+f.centroid(t)+")"})).style("text-anchor","middle").attr("class","slice").style("font-size",17),i.append("text").text(h.yy.getTitle()).attr("x",0).attr("y",-(p-50)/2).attr("class","pieTitleText");var l=i.selectAll(".legend").data(u.domain()).enter().append("g").attr("class","legend").attr("transform",(function(t,e){return"translate(216,"+(22*e-22*u.domain().length/2)+")"}));l.append("rect").attr("width",18).attr("height",18).style("fill",u).style("stroke",u),l.append("text").attr("x",22).attr("y",14).text((function(t){return t}))}catch(t){v.error("Error while rendering info diagram"),v.error(t.message)}};const cr={};for(const t of["default","forest","dark","neutral"])cr[t]=n(500)(`./${t}/index.scss`);const fr={theme:"default",themeCSS:void 0,fontFamily:'"trebuchet ms", verdana, arial;',logLevel:5,securityLevel:"strict",startOnLoad:!0,arrowMarkerAbsolute:!1,flowchart:{htmlLabels:!0,curve:"linear"},sequence:{diagramMarginX:50,diagramMarginY:10,actorMargin:50,width:150,height:65,boxMargin:10,boxTextMargin:5,noteMargin:10,messageMargin:35,mirrorActors:!0,bottomMarginAdj:1,useMaxWidth:!0,rightAngles:!1,showSequenceNumbers:!1},gantt:{titleTopMargin:25,barHeight:20,barGap:4,topPadding:50,leftPadding:75,gridLineStartPadding:35,fontSize:11,fontFamily:'"Open-Sans", "sans-serif"',numberSectionStyles:4,axisFormat:"%Y-%m-%d"},class:{},git:{},state:{dividerMargin:10,sizeUnit:5,padding:8,textHeight:10,titleShift:-15,noteMargin:10,forkWidth:70,forkHeight:7,miniPadding:2,fontSizeFactor:5.02,fontSize:24,labelHeight:16,edgeLengthFactor:"20",compositTitleSize:35,radius:5}};_(fr.logLevel),f(fr);const lr=function(t){const e=Object.keys(t);for(let n=0;n<e.length;n++)if("object"==typeof t[e[n]]&&null!=t[e[n]]){const r=Object.keys(t[e[n]]);for(let i=0;i<r.length;i++)v.debug("Setting conf ",e[n],"-",r[i]),void 0===fr[e[n]]&&(fr[e[n]]={}),v.debug("Setting config: "+e[n]+" "+r[i]+" to "+t[e[n]][r[i]]),fr[e[n]][r[i]]=t[e[n]][r[i]]}else fr[e[n]]=t[e[n]]};var hr={render:function(t,e,n,r){if(void 0!==r)r.innerHTML="",o.select(r).append("div").attr("id","d"+t).attr("style","font-family: "+fr.fontFamily).append("svg").attr("id",t).attr("width","100%").attr("xmlns","http://www.w3.org/2000/svg").append("g");else{const e=document.getElementById(t);e&&e.remove();const n=document.querySelector("#d"+t);n&&(n.innerHTML=""),o.select("body").append("div").attr("id","d"+t).append("svg").attr("id",t).attr("width","100%").attr("xmlns","http://www.w3.org/2000/svg").append("g")}window.txt=e,e=function(t){let e=t;return e=(e=(e=e.replace(/style.*:\S*#.*;/g,(function(t){return t.substring(0,t.length-1)}))).replace(/classDef.*:\S*#.*;/g,(function(t){return t.substring(0,t.length-1)}))).replace(/#\w+;/g,(function(t){const e=t.substring(1,t.length-1);return/^\+?\d+$/.test(e)?""+e+"":""+e+""}))}(e);const i=o.select("#d"+t).node(),a=E.detectType(e),c=i.firstChild,f=c.firstChild;let l=cr[fr.theme];if(void 0===l&&(l=""),void 0!==fr.themeCSS&&(l+=`\n${fr.themeCSS}`),void 0!==fr.fontFamily&&(l+=`\n:root { --mermaid-font-family: ${fr.fontFamily}}`),void 0!==fr.altFontFamily&&(l+=`\n:root { --mermaid-alt-font-family: ${fr.altFontFamily}}`),"flowchart"===a){const t=pt(e);for(const e in t)l+=`\n.${e} > * { ${t[e].styles.join(" !important; ")} !important; }`}const h=document.createElement("style");h.innerHTML=s()(l,`#${t}`),c.insertBefore(h,f);const d=document.createElement("style"),p=window.getComputedStyle(c);switch(d.innerHTML=`#${t} {\n    color: ${p.color};\n    font: ${p.font};\n  }`,c.insertBefore(d,f),a){case"git":fr.flowchart.arrowMarkerAbsolute=fr.arrowMarkerAbsolute,Vn(fr.git),Hn(e,t,!1);break;case"flowchart":fr.flowchart.arrowMarkerAbsolute=fr.arrowMarkerAbsolute,dt(fr.flowchart),gt(e,t,!1);break;case"sequence":fr.sequence.arrowMarkerAbsolute=fr.arrowMarkerAbsolute,fr.sequenceDiagram?(Yt(Object.assign(fr.sequence,fr.sequenceDiagram)),console.error("`mermaid config.sequenceDiagram` has been renamed to `config.sequence`. Please update your mermaid config.")):Yt(fr.sequence),Vt(e,t);break;case"gantt":fr.gantt.arrowMarkerAbsolute=fr.arrowMarkerAbsolute,Ee(fr.gantt),Ae(e,t);break;case"class":fr.class.arrowMarkerAbsolute=fr.arrowMarkerAbsolute,Ue(fr.class),ze(e,t);break;case"state":pn(fr.state),gn(e,t);break;case"info":fr.class.arrowMarkerAbsolute=fr.arrowMarkerAbsolute,Jn(fr.class),Qn(e,t,u.version);break;case"pie":fr.class.arrowMarkerAbsolute=fr.arrowMarkerAbsolute,sr(fr.class),ur(e,t,u.version)}o.select(`[id="${t}"]`).selectAll("foreignobject > *").attr("xmlns","http://www.w3.org/1999/xhtml");let g=o.select("#d"+t).node().innerHTML;if(fr.arrowMarkerAbsolute&&"false"!==fr.arrowMarkerAbsolute||(g=g.replace(/marker-end="url\(.*?#/g,'marker-end="url(#',"g")),g=function(t){let e=t;return e=(e=(e=e.replace(//g,(function(){return"&#"}))).replace(//g,(function(){return"&"}))).replace(//g,(function(){return";"}))}(g),void 0!==n)switch(a){case"flowchart":n(g,G.bindFunctions);break;case"gantt":n(g,_e.bindFunctions);break;default:n(g)}else v.debug("CB = undefined!");const y=o.select("#d"+t).node();return null!==y&&"function"==typeof y.remove&&o.select("#d"+t).node().remove(),g},parse:function(t){const e=E.detectType(t);let n;switch(v.debug("Type "+e),e){case"git":(n=In.a).parser.yy=On;break;case"flowchart":G.clear(),(n=K.a).parser.yy=G;break;case"sequence":(n=At.a).parser.yy=Lt;break;case"gantt":(n=$t.a).parser.yy=_e;break;case"class":(n=Ne.a).parser.yy=Re;break;case"state":(n=tn.a).parser.yy=Je;break;case"info":v.debug("info info info"),(n=Xn.a).parser.yy=Wn;break;case"pie":v.debug("pie"),(n=ir.a).parser.yy=nr}n.parser.yy.parseError=(t,e)=>{throw{str:t,hash:e}},n.parse(t)},initialize:function(t){v.debug("Initializing mermaidAPI ",u.version),"object"==typeof t&&lr(t),f(fr),_(fr.logLevel)},getConfig:l};const dr=function(){let t;pr.startOnLoad?(t=hr.getConfig()).startOnLoad&&pr.init():void 0===pr.startOnLoad&&(v.debug("In start, no config"),(t=hr.getConfig()).startOnLoad&&pr.init())};"undefined"!=typeof document&&
+/*!
+   * Wait for document loaded before starting the execution
+   */
+window.addEventListener("load",(function(){dr()}),!1);const pr={startOnLoad:!0,htmlLabels:!0,mermaidAPI:hr,parse:hr.parse,render:hr.render,init:function(){const t=hr.getConfig();let e,n,r;v.debug("Starting rendering diagrams"),arguments.length>=2?(
+/*! sequence config was passed as #1 */
+void 0!==arguments[0]&&(pr.sequenceConfig=arguments[0]),e=arguments[1]):e=arguments[0],"function"==typeof arguments[arguments.length-1]?(n=arguments[arguments.length-1],v.debug("Callback function found")):void 0!==t.mermaid&&("function"==typeof t.mermaid.callback?(n=t.mermaid.callback,v.debug("Callback function found")):v.debug("No Callback function found")),e=void 0===e?document.querySelectorAll(".mermaid"):"string"==typeof e?document.querySelectorAll(e):e instanceof window.Node?[e]:e,v.debug("Start On Load before: "+pr.startOnLoad),void 0!==pr.startOnLoad&&(v.debug("Start On Load inner: "+pr.startOnLoad),hr.initialize({startOnLoad:pr.startOnLoad})),void 0!==pr.ganttConfig&&hr.initialize({gantt:pr.ganttConfig});for(let t=0;t<e.length;t++){const o=e[t];
+/*! Check if previously processed */if(o.getAttribute("data-processed"))continue;o.setAttribute("data-processed",!0);const a=`mermaid-${Date.now()}`;r=o.innerHTML,r=i.a.decode(r).trim().replace(/<br>/gi,"<br/>"),hr.render(a,r,(t,e)=>{o.innerHTML=t,void 0!==n&&n(a),e&&e(o)},o)}},initialize:function(t){v.debug("Initializing mermaid "),void 0!==t.mermaid&&(void 0!==t.mermaid.startOnLoad&&(pr.startOnLoad=t.mermaid.startOnLoad),void 0!==t.mermaid.htmlLabels&&(pr.htmlLabels=t.mermaid.htmlLabels)),hr.initialize(t)},contentLoaded:dr};e.default=pr}]).default}));
+//# sourceMappingURL=mermaid.min.js.map
\ No newline at end of file
diff --git a/crates/salsa/book/netlify.sh b/crates/salsa/book/netlify.sh
new file mode 100755
index 000000000..8b83ce610
--- /dev/null
+++ b/crates/salsa/book/netlify.sh
@@ -0,0 +1,19 @@
+#!/bin/bash
+#
+# Script meant to be run from netlify
+
+set -x
+
+MDBOOK_VERSION='0.4.12'
+MDBOOK_LINKCHECK_VERSION='0.7.4'
+MDBOOK_MERMAID_VERSION='0.8.3'
+
+curl -L https://github.com/rust-lang/mdBook/releases/download/v$MDBOOK_VERSION/mdbook-v$MDBOOK_VERSION-x86_64-unknown-linux-gnu.tar.gz | tar xz -C ~/.cargo/bin
+curl -L https://github.com/badboy/mdbook-mermaid/releases/download/v$MDBOOK_MERMAID_VERSION/mdbook-mermaid-v$MDBOOK_MERMAID_VERSION-x86_64-unknown-linux-gnu.tar.gz | tar xz -C ~/.cargo/bin
+curl -L https://github.com/Michael-F-Bryan/mdbook-linkcheck/releases/download/v$MDBOOK_LINKCHECK_VERSION/mdbook-linkcheck.v$MDBOOK_LINKCHECK_VERSION.x86_64-unknown-linux-gnu.zip -O
+unzip mdbook-linkcheck.v$MDBOOK_LINKCHECK_VERSION.x86_64-unknown-linux-gnu.zip -d ~/.cargo/bin
+chmod +x ~/.cargo/bin/mdbook-linkcheck
+
+mdbook build
+mkdir versions
+mv book/html/* versions
diff --git a/crates/salsa/book/src/SUMMARY.md b/crates/salsa/book/src/SUMMARY.md
new file mode 100644
index 000000000..4602916ed
--- /dev/null
+++ b/crates/salsa/book/src/SUMMARY.md
@@ -0,0 +1,60 @@
+# Summary
+
+- [About salsa](./about_salsa.md)
+
+# How to use Salsa
+
+- [Overview](./overview.md)
+- [Tutorial: calc language](./tutorial.md)
+  - [Basic structure](./tutorial/structure.md)
+  - [Jars and databases](./tutorial/jar.md)
+  - [Defining the database struct](./tutorial/db.md)
+  - [Defining the IR: the various "salsa structs"](./tutorial/ir.md)
+  - [Defining the parser: memoized functions and inputs](./tutorial/parser.md)
+  - [Defining the parser: reporting errors](./tutorial/accumulators.md)
+  - [Defining the parser: debug impls and testing](./tutorial/debug.md)
+  - [Defining the checker](./tutorial/checker.md)
+  - [Defining the interpreter](./tutorial/interpreter.md)
+- [Reference](./reference.md)
+  - [Durability](./reference/durability.md)
+  - [Algorithm](./reference/algorithm.md)
+- [Common patterns](./common_patterns.md)
+  - [On-demand (Lazy) inputs](./common_patterns/on_demand_inputs.md)
+- [Tuning](./tuning.md)
+- [Cycle handling](./cycles.md)
+
+# How Salsa works internally
+
+- [How Salsa works](./how_salsa_works.md)
+- [Videos](./videos.md)
+- [Plumbing](./plumbing.md)
+  - [Jars and ingredients](./plumbing/jars_and_ingredients.md)
+  - [Databases and runtime](./plumbing/database_and_runtime.md)
+  - [The db lifetime on tracked/interned structs](./plumbing/db_lifetime.md)
+  - [Tracked structures](./plumbing/tracked_structs.md)
+  - [Query operations](./plumbing/query_ops.md)
+    - [maybe changed after](./plumbing/maybe_changed_after.md)
+    - [Fetch](./plumbing/fetch.md)
+    - [Derived queries flowchart](./plumbing/derived_flowchart.md)
+    - [Cycle handling](./plumbing/cycles.md)
+  - [Terminology](./plumbing/terminology.md)
+    - [Backdate](./plumbing/terminology/backdate.md)
+    - [Changed at](./plumbing/terminology/changed_at.md)
+    - [Dependency](./plumbing/terminology/dependency.md)
+    - [Derived query](./plumbing/terminology/derived_query.md)
+    - [Durability](./plumbing/terminology/durability.md)
+    - [Input query](./plumbing/terminology/input_query.md)
+    - [Ingredient](./plumbing/terminology/ingredient.md)
+    - [LRU](./plumbing/terminology/LRU.md)
+    - [Memo](./plumbing/terminology/memo.md)
+    - [Query](./plumbing/terminology/query.md)
+    - [Query function](./plumbing/terminology/query_function.md)
+    - [Revision](./plumbing/terminology/revision.md)
+    - [Salsa item](./plumbing/terminology/salsa_item.md)
+    - [Salsa struct](./plumbing/terminology/salsa_struct.md)
+    - [Untracked dependency](./plumbing/terminology/untracked.md)
+    - [Verified](./plumbing/terminology/verified.md)
+
+# Appendices
+
+- [Meta: about the book itself](./meta.md)
diff --git a/crates/salsa/book/src/about_salsa.md b/crates/salsa/book/src/about_salsa.md
new file mode 100644
index 000000000..ac0147540
--- /dev/null
+++ b/crates/salsa/book/src/about_salsa.md
@@ -0,0 +1,18 @@
+# About salsa
+
+Salsa is a Rust framework for writing incremental, on-demand programs
+-- these are programs that want to adapt to changes in their inputs,
+continuously producing a new output that is up-to-date. Salsa is based
+on the incremental recompilation techniques that we built for
+rustc, and many (but not all) of its users are building compilers or
+other similar tooling.
+
+If you'd like to learn more about Salsa, check out:
+
+- The [overview](./overview.md), for a brief summary.
+- The [tutorial](./tutorial.md), for a detailed look.
+- You can also watch some of our [videos](./videos.md), though the content there is rather out of date.
+
+If you'd like to chat about Salsa, or you think you might like to
+contribute, please jump on to our Zulip instance at
+[salsa.zulipchat.com](https://salsa.zulipchat.com/).
diff --git a/crates/salsa/book/src/common_patterns.md b/crates/salsa/book/src/common_patterns.md
new file mode 100644
index 000000000..05aef10a1
--- /dev/null
+++ b/crates/salsa/book/src/common_patterns.md
@@ -0,0 +1,3 @@
+# Common patterns
+
+This section documents patterns for using Salsa.
diff --git a/crates/salsa/book/src/common_patterns/on_demand_inputs.md b/crates/salsa/book/src/common_patterns/on_demand_inputs.md
new file mode 100644
index 000000000..c64edd18c
--- /dev/null
+++ b/crates/salsa/book/src/common_patterns/on_demand_inputs.md
@@ -0,0 +1,35 @@
+# On-Demand (Lazy) Inputs
+
+Salsa inputs work best if you can easily provide all of the inputs upfront.
+However sometimes the set of inputs is not known beforehand.
+
+A typical example is reading files from disk.
+While it is possible to eagerly scan a particular directory and create an in-memory file tree as salsa input structs, a more straight-forward approach is to read the files lazily.
+That is, when a query requests the text of a file for the first time:
+
+1. Read the file from disk and cache it.
+2. Setup a file-system watcher for this path.
+3. Update the cached file when the watcher sends a change notification.
+
+This is possible to achieve in salsa, by caching the inputs in your database structs and adding a method to the database trait to retrieve them out of this cache.
+
+A complete, runnable file-watching example can be found in [the lazy-input example](https://github.com/salsa-rs/salsa/tree/master/examples/lazy-input).
+
+The setup looks roughly like this:
+
+```rust,ignore
+{{#include ../../../examples/lazy-input/main.rs:db}}
+```
+
+- We declare a method on the `Db` trait that gives us a `File` input on-demand (it only requires a `&dyn Db` not a `&mut dyn Db`).
+- There should only be one input struct per file, so we implement that method using a cache (`DashMap` is like a `RwLock<HashMap>`).
+
+The driving code that's doing the top-level queries is then in charge of updating the file contents when a file-change notification arrives.
+It does this by updating the Salsa input in the same way that you would update any other input.
+
+Here we implement a simple driving loop, that recompiles the code whenever a file changes.
+You can use the logs to check that only the queries that could have changed are re-evaluated.
+
+```rust,ignore
+{{#include ../../../examples/lazy-input/main.rs:main}}
+```
diff --git a/crates/salsa/book/src/cycles.md b/crates/salsa/book/src/cycles.md
new file mode 100644
index 000000000..8222d9eaf
--- /dev/null
+++ b/crates/salsa/book/src/cycles.md
@@ -0,0 +1,40 @@
+# Cycle handling
+
+By default, when Salsa detects a cycle in the computation graph, Salsa will panic with a message naming the "cycle head"; this is the query that was called while it was also on the active query stack, creating a cycle.
+
+Salsa also supports recovering from query cycles via fixed-point iteration. Fixed-point iteration is only usable if the queries which may be involved in a cycle are monotone and operate on a value domain which is a partial order with fixed height. Effectively, this means that the queries' output must always be "larger" than its input, and there must be some "maximum" or "top" value. This ensures that fixed-point iteration will converge to a value. (A typical case would be queries operating on types, which form a partial order with a "top" type.)
+
+In order to support fixed-point iteration for a query, provide the `cycle_fn` and `cycle_initial` arguments to `salsa::tracked`:
+
+```rust
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=initial_fn)]
+fn query(db: &dyn salsa::Database) -> u32 {
+    // ...
+}
+
+fn cycle_fn(_db: &dyn KnobsDatabase, _value: &u32, _count: u32) -> salsa::CycleRecoveryAction<u32> {
+    salsa::CycleRecoveryAction::Iterate
+}
+
+fn initial(_db: &dyn KnobsDatabase) -> u32 {
+    0
+}
+```
+
+If `query` becomes the head of a cycle (that is, `query` is executing and on the active query stack, it calls `query2`, `query2` calls `query3`, and `query3` calls `query` again -- there could be any number of queries involved in the cycle), the `initial_fn` will be called to generate an "initial" value for `query` in the fixed-point computation. (The initial value should usually be the "bottom" value in the partial order.) All queries in the cycle will compute a provisional result based on this initial value for the cycle head. That is, `query3` will compute a provisional result using the initial value for `query`, `query2` will compute a provisional result using this provisional value for `query3`. When `cycle2` returns its provisional result back to `cycle`, `cycle` will observe that it has received a provisional result from its own cycle, and will call the `cycle_fn` (with the current value and the number of iterations that have occurred so far). The `cycle_fn` can return `salsa::CycleRecoveryAction::Iterate` to indicate that the cycle should iterate again, or `salsa::CycleRecoveryAction::Fallback(value)` to indicate that the cycle should stop iterating and fall back to the value provided.
+
+If the `cycle_fn` continues to return `Iterate`, the cycle will iterate until it converges: that is, until two successive iterations produce the same result.
+
+If the `cycle_fn` returns `Fallback`, the cycle will iterate one last time and verify that the returned value is the same as the fallback value; that is, the fallback value results in a stable converged cycle. If not, Salsa will panic. It is not permitted to use a fallback value that does not converge, because this would leave the cycle in an unpredictable state, depending on the order of query execution.
+
+## All potential cycle heads must set `cycle_fn` and `cycle_initial`
+
+Consider a two-query cycle where `query_a` calls `query_b`, and `query_b` calls `query_a`. If `query_a` is called first, then it will become the "cycle head", but if `query_b` is called first, then `query_b` will be the cycle head. In order for a cycle to use fixed-point iteration instead of panicking, the cycle head must set `cycle_fn` and `cycle_initial`. This means that in order to be robust against varying query execution order, both `query_a` and `query_b` must set `cycle_fn` and `cycle_initial`.
+
+## Ensuring convergence
+
+Fixed-point iteration is a powerful tool, but is also easy to misuse, potentially resulting in infinite iteration. To avoid this, ensure that all queries participating in fixpoint iteration are deterministic and monotone.
+
+## Calling Salsa queries from within `cycle_fn` or `cycle_initial`
+
+It is permitted to call other Salsa queries from within the `cycle_fn` and `cycle_initial` functions. However, if these functions re-enter the same cycle, this can lead to unpredictable results. Take care which queries are called from within cycle-recovery functions, and avoid triggering further cycles.
diff --git a/crates/salsa/book/src/derived-query-maybe-changed-after.drawio.svg b/crates/salsa/book/src/derived-query-maybe-changed-after.drawio.svg
new file mode 100644
index 000000000..5f88bd52d
--- /dev/null
+++ b/crates/salsa/book/src/derived-query-maybe-changed-after.drawio.svg
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Do not edit this file with editors other than diagrams.net -->
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="826px" height="851px" viewBox="-0.5 -0.5 826 851" content="&lt;mxfile host=&quot;app.diagrams.net&quot; modified=&quot;2022-01-21T20:14:08.908Z&quot; agent=&quot;5.0 (Macintosh)&quot; etag=&quot;COuILB8VnoPZ5FpVq6-Y&quot; version=&quot;16.4.3&quot; type=&quot;github&quot;&gt;&lt;diagram id=&quot;cWgktREh_h1Ou9hSuS4n&quot; name=&quot;Page-1&quot;&gt;7Vxbc9o6EP41zOQ8hPHd+DEQcjrT9kymyUzbp4xiC+zGWBxbJHB+/ZFsCV9kQAkGEZI8tFhYstj99tvVauWeOZot/07BPPyOAhj3DC1Y9szrnmHohmmQ/2jLqmixNLNomKZRwG4qG+6i/yBr1FjrIgpgVrsRIxTjaF5v9FGSQB/X2kCaopf6bRMU1586B1MoNNz5IBZbf0YBDovWga2V7V9gNA35k3WNfTMD/GbWkIUgQC+VJnPcM0cpQrj4NFuOYEyFx+VS9LvZ8O16YilMsEwHEOt/7h/+XV76Px+/GOirez92Lj2rGOYZxAv2i9ls8YqLIEWLJIB0FK1nDl/CCMO7OfDpty9E6aQtxLOYXOnk4ySK4xGKUZr3NcfWtTsekvbsCWI/ZDexZ8IUw+XGX6OvZUTABdEM4nRFbmEdTJeJleFKN7mcX0o1OQ5rCysqcrjuAIPGdD14KT3ygQnwFcK0W2TpxOSxwyB6Jh+n9ON3OEP5LMkk+b2GBpdRhsl8rngPMoFKp5ZxYpDhQojRJCLaIXNLyD8/nsvBg0UKHqM4wlRu13yMx7Q5avNZDf3DgFgEu0QpDtEUJSAel63DOkLKe74hNGcq/wMxXjHzBguM6qgpnkkftB0OZF5okfpwixLcdtikMAY4eq6P34YA1vUWRQmuwE1rws1soAiDdAox69YA0noeb8eWI4Otfyiy5il8jtAioxyUY408UJNXvjAoMWU+khYCOmyCSuSeLqYIctLVL9q/b/PL32y4/OJ6WbtasauusUgcVg6NLffpG0DLwHep9XVHZ37zrUDmt6DJJIMHgagrA9FvCAQMTw8z4jzs4dee/XZuKlGiS/gmlGAGF53IZzglHJoxrWc4RU9rF0/vXvtrreHWAjgBi3xyRSexnT5IbO3A65HwqU5D6zip4vV0o8XrWYdyerqU17uKUwhIDChLOn4Mohn1aifML8sI/6p8zrmlb9jssmQXenEActFl2aUSbW5gF8fmYd/psosuesARB8mHdC7y+vf2DIn24wcpt5Crkv7qVeJ/+oVX+wXLFMJTQ7VfGMjo/T6kfiFfv8/mMcQl5e90EQlKZyCOVyftI0qacF/FE9y5MHrh7uVYvoUjZSe37AxcvZP3K54UP638mK7TAwJR/zUozVdPmKN8DpLIf3qPcc32sKbEeQ3kfcfchXN6dQtT4scxTBUC2bZ2Idm03BrHXlr7QZuN7NlN6tblMgvHNBIuxoqRDGPkP5GmRYIj2h/hENawzhk9++jO2TGai7aWVOVxnbNhypDe51q905jMNpWrXSLbfxaLp5107xh7ronaydzymjp3G7osPNYWMt80krBtceCEszFQAY0uXf++y15ZFR95J8CQClhvFxndAvpKPXOCUa5IQB32J3m/ibwtWzV5W20LaqXkTQLiCnvrO9j70KG+5Uly/6ZQf99AfqB4i9ASieEHjCHI6MI1T6j3T8Kse4Z5c+ORPxWGPRC1pDpTxpnlNIKwXWbcocXastGapTSDzadZsatbIuS1R9UmKZjBT9sSbUu907QlVjxEmHP6cbac0hq2fhZNk6yfgQnEq35IJvnwjGIMpvBBr+tsTpkcpuNnIp+M67GuDC3/E5SRoIQaMZV25BOjBY8wvkVZhCOUkK8fEcZoVrnhKiZzIl9gatxDwK58mOSetCyu0qrY6KjSyjMpQzQSGC2c6YlqNQeHUqu4GXhxDYmMFz5G6V8inybBFS0GLEUfgCxc22ZFp7T9FmAi1yRvMTRTsEBD4N/2nKn7tqRpuVNwQpuImyi4ggC7xbB5256xldMsv1qvwl67rnaa6VaryT0HjtJscT/0BKF7tCoGQzpq38BSxwGg7TRh08zSywLQa2aDhZEODED3NJKAHWLIMSQx5O5bHLqX03LFSqkbENPVWYv085CgLjHB7Tejg1kUBIVyYBb9Bx7z8TQeqOQ/xx7SDP6WuIDV0bPOvfVWRVUvW2C1MYrQ+lojiOjELi8bPQ63BTawVVjJCazSpK1rE0Mfx7oGYkh4S3fbz8O6CvRtr+HzzJqBXXZkYZbROuzhLc5TbHH1qHxXUL6u2FETR8n7wA3VoK+DCQlJwapyA7OBjSgyhe0sq3FaaVcHz9QaICvm0C3kRBK5Txdn4qG9nRyiG26dQ/Y8c8BHbhATj0APTyHcKrbvlV1DOO+xo1RUIMVhl3e0UdYj5uKNRjc3KrJ+wlbZut5FWdbPsd6T5+jSC5iSXmDTiaPjxGqOmAM5o5WQs2sl1B5Q7b0SUhWnOaexMa3CjBxHqRmJG77nE60UqNoWrRjmQK9B3u7GkOyjGY5UFeZdCOKYuP3PAOWNAYpwaFL9lr8jrjN+QLxI6Ql+PwTJFAYPgGKSaBHMqE6YLjV6uDuju4T0O7FwQNme82ikZs9ZUK6l/EQsL/n8VG7nSwtPvXIdFbHNCRw3dWVjor0TTPulgb1T0s8R0/TS+lGbpvdEcjynNP2GKonKeUhCajVO6+gYGV9zNUY9wls/xCB2vIT+AovrkA8XeQr+a6A8Nea+92MdrmzFUgFMZZv94tr8d8tRyHfJcu7Opblmu/Wl+Z4bCZzVzGOxGs8snE9OS9puBmrjN0MQPH2r2TmYzWC7s6D7b/USGaMTozGOFglIvenlC3im51HoezhZIsu8eVe5rFM6leYqjycGW5IdOE9GaxczsHqEZfJDrHH9cIkNoQpZvSI9GY9X1iL7VOpk2VZTTaOyWP0x7w27nMepGRbeGao3lSdbM7x+t+16pCMfLfREr5wb9QPPZ2ZR4sMLnr8ULZyYCj6cr6aBU8YoQTBnVjVftX3W1IEhG82qVr3NkL0WkBkHM2RxO7auKzAhAn/wiQe++DiKGjQL+D2rRVFuN4oil+V7vQsbLN+Obo7/Bw==&lt;/diagram&gt;&lt;/mxfile&gt;" resource="https://app.diagrams.net/#Hnikomatsakis%2Fsalsa%2Fslot-no-more%2Fbook%2Fsrc%2Fderived-query-maybe-changed-after.drawio.svg"><defs/><g><rect x="165" y="200" width="660" height="650" fill="none" stroke="none" pointer-events="all"/><path d="M 165.23 199.73 C 165.23 199.73 165.23 199.73 165.23 199.73 M 165.23 199.73 C 165.23 199.73 165.23 199.73 165.23 199.73 M 164.97 206.13 C 166.34 204.87 168.36 202.14 170.22 200.09 M 164.97 206.13 C 166.25 204.22 167.99 202.51 170.22 200.09 M 164.71 212.53 C 166.67 209.72 171.2 207.23 175.86 199.7 M 164.71 212.53 C 169.48 208.4 172.89 203.86 175.86 199.7 M 165.11 218.17 C 170.63 213.64 172.28 211.29 180.85 200.06 M 165.11 218.17 C 169.6 212.12 174.46 208.15 180.85 200.06 M 164.85 224.57 C 168.58 216.95 173.21 214.4 186.5 199.66 M 164.85 224.57 C 173.43 216.42 179.94 206.46 186.5 199.66 M 165.24 230.21 C 172.79 221.47 179.06 215.28 191.48 200.02 M 165.24 230.21 C 170.7 223.79 177.98 215.82 191.48 200.02 M 164.98 236.61 C 174.47 225.84 185.81 216.71 197.13 199.63 M 164.98 236.61 C 177.08 222.29 190.5 208.49 197.13 199.63 M 164.72 243 C 174.04 234.93 182.74 224.59 202.11 199.99 M 164.72 243 C 176.87 229.26 188.23 216.2 202.11 199.99 M 165.11 248.65 C 183.34 229.09 198.37 209.77 207.1 200.35 M 165.11 248.65 C 176.03 235.95 186.85 223.85 207.1 200.35 M 164.85 255.05 C 173.37 242.36 186.5 232.18 212.74 199.95 M 164.85 255.05 C 176.17 243.72 185.13 231.93 212.74 199.95 M 165.24 260.69 C 186.63 240.48 205.25 214.38 217.73 200.31 M 165.24 260.69 C 184.63 238.9 203.52 216.78 217.73 200.31 M 164.98 267.09 C 182.26 244.59 200.83 223.71 223.37 199.92 M 164.98 267.09 C 177.91 252.73 189.17 239.2 223.37 199.92 M 164.72 273.48 C 186.4 248.2 208.88 222.83 228.36 200.28 M 164.72 273.48 C 189.69 245.87 215.07 217.72 228.36 200.28 M 165.12 279.13 C 188.15 249.66 213.68 221.25 234 199.88 M 165.12 279.13 C 183.06 258.48 198.26 240.93 234 199.88 M 164.85 285.53 C 185.84 261.03 210.18 231.69 238.99 200.24 M 164.85 285.53 C 182.92 265.42 200.32 245.13 238.99 200.24 M 165.25 291.17 C 191.58 258.48 221.47 226.76 244.63 199.85 M 165.25 291.17 C 189.03 263.89 213.61 237.75 244.63 199.85 M 164.99 297.57 C 184.92 277.53 202.78 254.77 249.62 200.21 M 164.99 297.57 C 187.84 272.28 210.49 247.82 249.62 200.21 M 164.73 303.96 C 185.63 284.82 202.01 259.78 255.26 199.81 M 164.73 303.96 C 182.93 284.2 201.53 261.45 255.26 199.81 M 165.12 309.61 C 183.24 289.21 205.82 268.07 260.25 200.17 M 165.12 309.61 C 191.07 281.48 215.64 252.91 260.25 200.17 M 164.86 316 C 191.65 283.79 222.53 249.95 265.89 199.78 M 164.86 316 C 187.2 290.4 208.49 263.13 265.89 199.78 M 165.25 321.65 C 204.16 277.36 243.3 234.88 270.88 200.14 M 165.25 321.65 C 196.09 286.04 225.93 251.65 270.88 200.14 M 164.99 328.05 C 208.47 277.44 250.6 229.71 276.52 199.74 M 164.99 328.05 C 194.67 292.37 225.64 256.73 276.52 199.74 M 164.73 334.44 C 199.54 294.67 234.29 255.99 281.51 200.11 M 164.73 334.44 C 190.05 306.79 215.01 275.77 281.51 200.11 M 165.13 340.09 C 210.53 289.44 252.05 238.71 287.15 199.71 M 165.13 340.09 C 204.15 295.5 243.6 249.96 287.15 199.71 M 164.86 346.48 C 196.93 308.84 226.71 272.21 292.14 200.07 M 164.86 346.48 C 215.07 291.12 264.56 234.83 292.14 200.07 M 165.26 352.13 C 212.28 299.73 257.19 244.5 297.78 199.68 M 165.26 352.13 C 211.99 296.15 258.64 242.7 297.78 199.68 M 165 358.53 C 209.5 308.6 253.42 255.73 302.77 200.04 M 165 358.53 C 213.91 302.5 263.09 245.73 302.77 200.04 M 164.74 364.92 C 210.79 310.37 258.94 253.73 308.41 199.64 M 164.74 364.92 C 197.22 327.79 231.13 289.94 308.41 199.64 M 165.13 370.57 C 204.24 327.86 242.09 281.19 313.4 200 M 165.13 370.57 C 215.98 309.54 269.11 247.62 313.4 200 M 164.87 376.96 C 213.28 317.89 264.65 256.2 318.39 200.36 M 164.87 376.96 C 199.64 336.24 234.3 296.09 318.39 200.36 M 165.26 382.61 C 213.27 329.38 259.27 276.83 324.03 199.97 M 165.26 382.61 C 204.69 339.84 243.74 294.82 324.03 199.97 M 165 389 C 205.95 341.2 246.7 294.78 329.02 200.33 M 165 389 C 210.09 336.68 257.49 281.89 329.02 200.33 M 164.74 395.4 C 212.77 343.13 259.29 288.13 334.66 199.93 M 164.74 395.4 C 219.54 332.54 273.81 269.7 334.66 199.93 M 165.14 401.05 C 206.19 355.03 244.44 309.73 339.65 200.29 M 165.14 401.05 C 230.8 326.83 295.53 252.3 339.65 200.29 M 164.87 407.44 C 227.13 336.42 288.2 265.12 345.29 199.9 M 164.87 407.44 C 224.18 339.43 284.21 270.08 345.29 199.9 M 165.27 413.09 C 214.09 356.09 262.84 299.79 350.28 200.26 M 165.27 413.09 C 224.1 345.93 283.38 278.36 350.28 200.26 M 165.01 419.48 C 216 359.15 267.39 302.36 355.92 199.86 M 165.01 419.48 C 219.84 357.66 273.62 295.7 355.92 199.86 M 164.75 425.88 C 210.86 374.2 256.95 322.31 360.91 200.22 M 164.75 425.88 C 240.18 337.74 315.36 252.18 360.91 200.22 M 165.14 431.52 C 225.23 365.64 283.96 298.12 366.55 199.83 M 165.14 431.52 C 243.43 340.97 323.47 248.61 366.55 199.83 M 164.88 437.92 C 213.28 380.7 261.05 325.79 371.54 200.19 M 164.88 437.92 C 221.61 370.51 278.49 305.82 371.54 200.19 M 165.27 443.57 C 231.46 370.88 296.07 295.64 377.18 199.79 M 165.27 443.57 C 239.98 355.88 315.45 269.17 377.18 199.79 M 165.01 449.96 C 220.41 390.21 271.9 328.79 382.17 200.15 M 165.01 449.96 C 239.83 362.87 315.21 277.29 382.17 200.15 M 164.75 456.36 C 222.4 386.93 281.03 316.92 387.81 199.76 M 164.75 456.36 C 230.34 382.47 295.29 308.74 387.81 199.76 M 165.15 462 C 233.27 383.56 299.33 305.69 392.8 200.12 M 165.15 462 C 252.92 360.05 339.89 258.7 392.8 200.12 M 164.88 468.4 C 250.85 369.59 338.26 267.5 398.44 199.73 M 164.88 468.4 C 248.73 371.07 332.78 274.79 398.44 199.73 M 165.28 474.05 C 229.81 399.37 294.23 323.99 403.43 200.09 M 165.28 474.05 C 222.44 407.29 280.2 341.34 403.43 200.09 M 165.02 480.44 C 237.84 395.81 311.88 313.2 409.07 199.69 M 165.02 480.44 C 257.08 375.44 348.89 269.35 409.07 199.69 M 164.76 486.84 C 242.73 395.52 321.38 307.54 414.06 200.05 M 164.76 486.84 C 262.66 374.17 360.77 261.65 414.06 200.05 M 165.15 492.48 C 253.97 391.39 341.12 290.72 419.7 199.66 M 165.15 492.48 C 265.14 376.08 366.26 260.3 419.7 199.66 M 164.89 498.88 C 220.11 436.84 277.23 373.75 424.69 200.02 M 164.89 498.88 C 260.36 389.94 354.54 282.11 424.69 200.02 M 165.28 504.52 C 244.45 410.79 325.69 318.7 429.68 200.38 M 165.28 504.52 C 249.7 406.68 333.96 310.36 429.68 200.38 M 165.02 510.92 C 225.51 441.76 286.9 370.82 435.32 199.98 M 165.02 510.92 C 253.24 410.82 342.04 308.56 435.32 199.98 M 164.76 517.32 C 274.17 391.17 383.22 265.96 440.31 200.34 M 164.76 517.32 C 243.09 428.47 320.46 338.96 440.31 200.34 M 165.15 522.96 C 239.09 436.25 312.84 350.79 445.95 199.95 M 165.15 522.96 C 248.93 427.99 331.23 332.24 445.95 199.95 M 164.89 529.36 C 255.87 425.11 345.9 321.35 450.94 200.31 M 164.89 529.36 C 244.79 439.07 324.53 347.86 450.94 200.31 M 165.29 535 C 252.17 435.79 336.54 338.54 456.58 199.91 M 165.29 535 C 259.97 426.15 354.85 315.84 456.58 199.91 M 165.03 541.4 C 225.42 471.67 285.28 403.06 461.57 200.27 M 165.03 541.4 C 263.51 429.85 361.14 318.27 461.57 200.27 M 164.77 547.8 C 265.61 432.86 366.73 316.18 467.21 199.88 M 164.77 547.8 C 262.88 436.41 360.79 322.93 467.21 199.88 M 165.16 553.44 C 243.96 463.14 323.46 371.84 472.2 200.24 M 165.16 553.44 C 261.34 442.05 356.93 332.28 472.2 200.24 M 164.9 559.84 C 245.93 466.11 329.3 372.83 477.84 199.84 M 164.9 559.84 C 237.11 477.21 309.72 394.11 477.84 199.84 M 165.29 565.48 C 272.36 440.96 379.67 317.35 482.83 200.2 M 165.29 565.48 C 275.17 439.11 385.13 313.35 482.83 200.2 M 165.03 571.88 C 235.24 490.85 304.62 411.07 488.47 199.81 M 165.03 571.88 C 241.38 482.89 318.01 395.26 488.47 199.81 M 164.77 578.28 C 281.94 442.77 399.77 307.28 493.46 200.17 M 164.77 578.28 C 292.99 430.51 421.27 283.91 493.46 200.17 M 165.16 583.92 C 295.16 437.11 423.53 289.53 499.1 199.78 M 165.16 583.92 C 290.87 441.11 415.78 296.96 499.1 199.78 M 164.9 590.32 C 258.84 480.34 354 371.59 504.09 200.14 M 164.9 590.32 C 247.02 493.92 330.8 397.51 504.09 200.14 M 165.3 595.96 C 239.35 510.11 313.83 425.49 509.73 199.74 M 165.3 595.96 C 275.27 468.24 385.38 341.26 509.73 199.74 M 165.04 602.36 C 283.55 466.54 400.91 329.31 514.72 200.1 M 165.04 602.36 C 293.01 454.31 420.98 307.01 514.72 200.1 M 164.77 608.76 C 239.81 522.61 313.67 437.49 520.36 199.71 M 164.77 608.76 C 304.19 446.59 444.28 285.38 520.36 199.71 M 165.17 614.4 C 237.64 528.04 311.85 443.95 525.35 200.07 M 165.17 614.4 C 253.22 513.72 339.83 413.18 525.35 200.07 M 164.91 620.8 C 286.13 481.26 407.24 342.65 530.99 199.67 M 164.91 620.8 C 296.45 467.34 428.53 314.7 530.99 199.67 M 165.3 626.44 C 246.57 530.9 330.34 434.76 535.98 200.03 M 165.3 626.44 C 244.52 536.96 321.36 448.34 535.98 200.03 M 165.04 632.84 C 313.09 462.43 458.83 294.86 541.62 199.64 M 165.04 632.84 C 250.74 535.18 336.55 436.44 541.62 199.64 M 164.78 639.24 C 311.84 468.88 460.96 298.83 546.61 200 M 164.78 639.24 C 258.29 531.36 351.77 423.87 546.61 200 M 165.17 644.88 C 266.32 527.3 368.49 410.64 551.59 200.36 M 165.17 644.88 C 260.73 536.18 356.01 425.91 551.59 200.36 M 164.91 651.28 C 302.75 495.53 438.8 339.55 557.24 199.96 M 164.91 651.28 C 311.4 480.7 458.64 311.01 557.24 199.96 M 165.31 656.92 C 275.99 530.36 384.52 403.16 562.22 200.32 M 165.31 656.92 C 287.73 514.22 411.61 372.12 562.22 200.32 M 165.05 663.32 C 246.49 567.91 329.58 471.94 567.87 199.93 M 165.05 663.32 C 272.94 540.36 379.63 416.84 567.87 199.93 M 164.78 669.72 C 250.72 569.37 338.07 468.61 572.85 200.29 M 164.78 669.72 C 312.14 499.16 459.64 329.15 572.85 200.29 M 165.18 675.36 C 302.46 518.27 436.69 364.21 578.5 199.89 M 165.18 675.36 C 260.94 565.89 354.91 457.21 578.5 199.89 M 164.92 681.76 C 297.97 530.6 431.05 376.46 583.48 200.25 M 164.92 681.76 C 325.66 496.62 485.23 312.59 583.48 200.25 M 165.31 687.4 C 304.27 526.86 444.08 364.88 589.13 199.86 M 165.31 687.4 C 258.26 580.54 349.94 474.32 589.13 199.86 M 165.05 693.8 C 286.29 551.51 408.62 411.51 594.11 200.22 M 165.05 693.8 C 333.41 498.22 503.26 302.52 594.11 200.22 M 164.79 700.2 C 292.68 554.77 420.45 409.55 599.76 199.82 M 164.79 700.2 C 263.45 585.79 363.9 470.37 599.76 199.82 M 165.18 705.84 C 284.57 569.06 402.32 434.19 604.74 200.19 M 165.18 705.84 C 287.31 566.34 408.44 427.75 604.74 200.19 M 164.92 712.24 C 316.53 537.98 470.2 362.51 610.39 199.79 M 164.92 712.24 C 303.12 554.75 441.44 394.95 610.39 199.79 M 165.32 717.88 C 290.17 573.64 413.9 431.8 615.37 200.15 M 165.32 717.88 C 316.13 546.1 466.57 373.94 615.37 200.15 M 165.06 724.28 C 287.4 582.78 409.89 441.17 621.02 199.76 M 165.06 724.28 C 323.3 544.4 479.97 364.93 621.02 199.76 M 164.79 730.68 C 338.55 532 511.36 334.21 626 200.12 M 164.79 730.68 C 316.98 557.79 468.23 383.62 626 200.12 M 165.19 736.32 C 313.65 568.88 459.76 400.46 631.65 199.72 M 165.19 736.32 C 284 596.61 403.93 458.74 631.65 199.72 M 164.93 742.72 C 301.96 586.69 436.33 431.16 636.63 200.08 M 164.93 742.72 C 290.58 598.97 413.95 456.21 636.63 200.08 M 165.32 748.36 C 348.21 539.15 529.27 330.5 642.28 199.69 M 165.32 748.36 C 275.45 622.94 384.51 498.08 642.28 199.69 M 165.06 754.76 C 352.69 540.27 540.59 322.74 647.26 200.05 M 165.06 754.76 C 349.5 543.26 532.8 332.71 647.26 200.05 M 164.8 761.16 C 275.53 637.31 383.74 512.29 652.91 199.65 M 164.8 761.16 C 296.01 610.42 427.52 458.42 652.91 199.65 M 165.19 766.8 C 323.92 586.09 481.27 404.92 657.89 200.01 M 165.19 766.8 C 346.14 559.31 527.29 351.21 657.89 200.01 M 164.93 773.2 C 291.45 627.03 418.98 481.75 662.88 200.37 M 164.93 773.2 C 287.44 633.32 409.95 492.72 662.88 200.37 M 165.33 778.84 C 348.42 567.74 531.6 356.87 668.52 199.98 M 165.33 778.84 C 350.47 567.48 532.55 357.29 668.52 199.98 M 165.07 785.24 C 341.65 584.71 517.63 382.99 673.51 200.34 M 165.07 785.24 C 295.12 635.04 426.78 483.65 673.51 200.34 M 164.8 791.64 C 307.05 628.95 447.5 468.22 679.15 199.94 M 164.8 791.64 C 341.07 588.77 515.45 388.43 679.15 199.94 M 165.2 797.28 C 277.26 666.14 390.26 535.58 684.14 200.3 M 165.2 797.28 C 300.39 644.24 434.75 488.92 684.14 200.3 M 164.94 803.68 C 297.91 655.53 428.57 505.17 689.78 199.91 M 164.94 803.68 C 331.61 613.13 497.6 421.79 689.78 199.91 M 164.68 810.07 C 299.8 655.2 435.64 500.36 694.77 200.27 M 164.68 810.07 C 288.46 665.01 414.99 520.39 694.77 200.27 M 165.07 815.72 C 351.5 597.84 539.1 381.15 700.41 199.87 M 165.07 815.72 C 356.99 592.34 550.02 370.03 700.41 199.87 M 164.81 822.12 C 321.34 637.6 480.25 455.1 705.4 200.23 M 164.81 822.12 C 288.93 678.82 413.44 535.43 705.4 200.23 M 165.2 827.76 C 327.68 641.25 487.38 456.21 711.04 199.84 M 165.2 827.76 C 372.99 588.7 579.4 350.82 711.04 199.84 M 164.94 834.16 C 290.44 687.64 417.99 542.73 716.03 200.2 M 164.94 834.16 C 339.05 635.54 513.02 435.36 716.03 200.2 M 164.68 840.55 C 307.46 677.94 448.12 517.22 721.67 199.81 M 164.68 840.55 C 341.78 637.61 520.25 431.98 721.67 199.81 M 165.07 846.2 C 285.04 709.3 403.43 574.01 726.66 200.17 M 165.07 846.2 C 286.82 702.73 409.7 560.87 726.66 200.17 M 166.13 851.09 C 310.73 686.59 453.38 522.27 732.3 199.77 M 166.13 851.09 C 382.77 604.04 599.38 354.69 732.3 199.77 M 171.77 850.69 C 307.81 690.15 446.35 530.87 737.29 200.13 M 171.77 850.69 C 346.35 653.01 520.21 452.95 737.29 200.13 M 176.76 851.05 C 388.7 603.58 602.49 357.8 742.93 199.74 M 176.76 851.05 C 291.33 716.32 407.4 582.78 742.93 199.74 M 182.4 850.66 C 401.43 594.35 624.46 339.01 747.92 200.1 M 182.4 850.66 C 404.52 599.04 625.22 345.29 747.92 200.1 M 187.39 851.02 C 396.57 611.23 607.37 368.32 753.56 199.7 M 187.39 851.02 C 341.69 675.88 493.17 501.3 753.56 199.7 M 192.37 851.38 C 402.9 607.95 615.68 364.49 758.55 200.06 M 192.37 851.38 C 372.42 642.59 555.03 433.21 758.55 200.06 M 198.02 850.98 C 330.23 702.38 461.84 551 764.19 199.67 M 198.02 850.98 C 367.67 655.08 538.05 459.77 764.19 199.67 M 203 851.34 C 412.78 614.08 619.52 377.09 769.18 200.03 M 203 851.34 C 317.69 720.26 432.79 587.73 769.18 200.03 M 208.65 850.95 C 326.27 717.34 442.26 583.62 774.82 199.63 M 208.65 850.95 C 363.13 674.15 516.6 497.65 774.82 199.63 M 213.63 851.31 C 436.34 594.74 661.28 338.07 779.81 199.99 M 213.63 851.31 C 422.77 608.01 633.69 365.12 779.81 199.99 M 219.28 850.91 C 339.74 713.78 456.75 578.93 784.8 200.35 M 219.28 850.91 C 441.2 594.86 663.62 338.25 784.8 200.35 M 224.26 851.27 C 422.7 621.08 623.67 390.16 790.44 199.96 M 224.26 851.27 C 348.69 706.54 472.19 563.91 790.44 199.96 M 229.91 850.88 C 343.57 720.22 458.72 588.23 795.43 200.32 M 229.91 850.88 C 414.46 638.71 599.26 426.78 795.43 200.32 M 234.89 851.24 C 455.29 599.45 673.56 347.6 801.07 199.92 M 234.89 851.24 C 442.2 607.78 652.7 366.17 801.07 199.92 M 240.54 850.84 C 358.13 713.03 478.83 576.14 806.06 200.28 M 240.54 850.84 C 453.39 610.58 663.49 368.81 806.06 200.28 M 245.52 851.2 C 406.45 663.8 568.97 477.71 811.7 199.89 M 245.52 851.2 C 417.38 656.74 588.31 460.16 811.7 199.89 M 251.17 850.81 C 428.52 644.87 606.08 440.39 816.69 200.25 M 251.17 850.81 C 406.06 672.2 561.07 494.03 816.69 200.25 M 256.15 851.17 C 435.35 644.24 614.62 437.21 822.33 199.86 M 256.15 851.17 C 440.78 638.2 627.07 424.33 822.33 199.86 M 261.8 850.77 C 400.92 691.1 537.53 531.64 826.66 200.97 M 261.8 850.77 C 387.28 706.63 512.73 562.56 826.66 200.97 M 266.78 851.14 C 482.75 599.53 699.65 349.5 826.4 207.37 M 266.78 851.14 C 384.59 713.63 503.19 576.94 826.4 207.37 M 272.43 850.74 C 487.89 601.01 703.79 350.56 826.14 213.77 M 272.43 850.74 C 408.76 692.22 546.16 534.12 826.14 213.77 M 277.41 851.1 C 426.37 681.17 572.82 511.49 826.53 219.41 M 277.41 851.1 C 471.74 624.96 667.13 400.4 826.53 219.41 M 283.06 850.71 C 394.29 723.34 505.41 594.66 826.27 225.81 M 283.06 850.71 C 407.03 708.89 532.08 565.93 826.27 225.81 M 288.04 851.07 C 493.87 613.06 700.01 375.29 826.67 231.45 M 288.04 851.07 C 402.14 720.67 515.89 590.03 826.67 231.45 M 293.69 850.67 C 500.92 612.43 706.26 376.14 826.41 237.85 M 293.69 850.67 C 446.62 675.26 598.67 500.46 826.41 237.85 M 298.67 851.03 C 409.64 720.29 523 589.76 826.15 244.25 M 298.67 851.03 C 438.18 691.43 579.54 529.02 826.15 244.25 M 303.66 851.39 C 456.84 676.33 610.71 498.57 826.54 249.89 M 303.66 851.39 C 505.77 622.95 704.87 393.26 826.54 249.89 M 309.3 851 C 464.22 674.81 618.59 497.75 826.28 256.29 M 309.3 851 C 444.37 697.22 579.41 542.55 826.28 256.29 M 314.29 851.36 C 492.09 648.78 669.37 443.85 826.67 261.93 M 314.29 851.36 C 480.39 661.5 647.16 470.48 826.67 261.93 M 319.93 850.96 C 436.55 718.47 553.82 583.99 826.41 268.33 M 319.93 850.96 C 508.99 636.39 697.76 419.26 826.41 268.33 M 324.92 851.32 C 431.15 727.06 537.32 604.52 826.15 274.72 M 324.92 851.32 C 506.46 641.18 689.32 430.75 826.15 274.72 M 330.56 850.93 C 458.89 702.66 588.62 554.83 826.54 280.37 M 330.56 850.93 C 440.89 725.04 550.93 597.81 826.54 280.37 M 335.55 851.29 C 448.86 723.97 559.59 596.79 826.28 286.77 M 335.55 851.29 C 435.82 736.66 534.86 623.74 826.28 286.77 M 341.19 850.89 C 480.76 686.77 622.78 523.85 826.68 292.41 M 341.19 850.89 C 476.26 690.9 613.62 533.5 826.68 292.41 M 346.18 851.25 C 523.08 650.88 698.27 448.47 826.42 298.81 M 346.18 851.25 C 522.4 648.77 698.85 445.91 826.42 298.81 M 351.82 850.86 C 490.47 692.71 628.57 533.76 826.15 305.2 M 351.82 850.86 C 473.51 709.45 596.58 566.93 826.15 305.2 M 356.81 851.22 C 484.38 701.86 612.34 554.77 826.55 310.85 M 356.81 851.22 C 473.16 716.5 590.98 580.87 826.55 310.85 M 362.45 850.82 C 491.8 703.93 620.41 556.23 826.29 317.24 M 362.45 850.82 C 506.29 685.09 650.91 519.19 826.29 317.24 M 367.44 851.18 C 482.71 718.72 596.64 588.22 826.68 322.89 M 367.44 851.18 C 495.17 704.89 621.52 559.44 826.68 322.89 M 373.08 850.79 C 519.85 683.17 664.92 514.5 826.42 329.29 M 373.08 850.79 C 479.55 729.52 585.65 607.82 826.42 329.29 M 378.07 851.15 C 485.52 725.93 593.43 602.39 826.16 335.68 M 378.07 851.15 C 518.36 689.89 658.29 528.2 826.16 335.68 M 383.71 850.76 C 543.48 665.5 702.29 482.38 826.55 341.33 M 383.71 850.76 C 502.57 713.22 621.74 575.56 826.55 341.33 M 388.7 851.12 C 504.16 718 619.13 584.9 826.29 347.72 M 388.7 851.12 C 509.78 712.43 629.88 573.55 826.29 347.72 M 394.34 850.72 C 555.65 664.77 717.62 477.96 826.69 353.37 M 394.34 850.72 C 526.97 700.47 658.24 549.35 826.69 353.37 M 399.33 851.08 C 562.24 666.08 723.99 479.84 826.43 359.77 M 399.33 851.08 C 537.63 694.7 674.77 536.76 826.43 359.77 M 404.97 850.69 C 496.57 744.49 587.75 639.92 826.16 366.16 M 404.97 850.69 C 516.77 721.05 630.49 591.16 826.16 366.16 M 409.96 851.05 C 540.53 703.09 669.61 554.34 826.56 371.81 M 409.96 851.05 C 514.49 728.86 620.2 607.99 826.56 371.81 M 415.6 850.65 C 571.56 670.06 726.7 491.98 826.3 378.2 M 415.6 850.65 C 553.84 691.43 691.42 533.51 826.3 378.2 M 420.59 851.01 C 515.63 740.16 611.98 628.79 826.69 383.85 M 420.59 851.01 C 548.36 703.26 675.74 555.85 826.69 383.85 M 425.58 851.37 C 512.81 748.11 600.83 647.29 826.43 390.24 M 425.58 851.37 C 554.29 703.26 682.7 555.36 826.43 390.24 M 431.22 850.98 C 584.7 672.91 740.57 494.57 826.17 396.64 M 431.22 850.98 C 585.6 672.17 741.87 492.4 826.17 396.64 M 436.21 851.34 C 574.63 690.24 713.47 531.43 826.56 402.29 M 436.21 851.34 C 547.42 722.91 659.83 593.59 826.56 402.29 M 441.85 850.94 C 546.05 732.97 648.96 615.73 826.3 408.68 M 441.85 850.94 C 530.66 749.18 618.5 648.63 826.3 408.68 M 446.84 851.3 C 540.14 742.94 635.85 633.25 826.7 414.33 M 446.84 851.3 C 573.93 704.73 702.07 557.73 826.7 414.33 M 452.48 850.91 C 530.64 759.25 607.78 669.48 826.44 420.72 M 452.48 850.91 C 599.94 683.39 745.99 515.11 826.44 420.72 M 457.47 851.27 C 545.17 753.21 630.08 653.14 826.17 427.12 M 457.47 851.27 C 539.19 756.5 620.21 662.71 826.17 427.12 M 463.11 850.87 C 541.97 759.67 622.41 667.2 826.57 432.77 M 463.11 850.87 C 572.26 724.16 682.08 598.53 826.57 432.77 M 468.1 851.23 C 569.76 735.6 670.7 617.71 826.31 439.16 M 468.1 851.23 C 585.56 715.35 703.97 579.31 826.31 439.16 M 473.74 850.84 C 599.18 703.73 727.22 557.54 826.7 444.81 M 473.74 850.84 C 551.91 759.78 631.33 669.12 826.7 444.81 M 478.73 851.2 C 562.47 756.62 644.71 661.05 826.44 451.2 M 478.73 851.2 C 582.92 731.24 687.3 611.01 826.44 451.2 M 484.37 850.81 C 603.76 714.42 723.27 578.02 826.18 457.6 M 484.37 850.81 C 576.66 744.43 668.6 639.09 826.18 457.6 M 489.36 851.17 C 620.77 700.23 752.12 549.66 826.57 463.24 M 489.36 851.17 C 560.64 768.86 631.14 687.57 826.57 463.24 M 495 850.77 C 609.95 716.29 725.25 583.73 826.31 469.64 M 495 850.77 C 621.41 703.84 748.36 558.16 826.31 469.64 M 499.99 851.13 C 594.58 739.99 689.98 630.19 826.71 475.29 M 499.99 851.13 C 626.9 705.39 753.19 560.32 826.71 475.29 M 505.63 850.74 C 631.58 703.36 759.73 556.74 826.45 481.68 M 505.63 850.74 C 623.73 715.04 740.86 580.75 826.45 481.68 M 510.62 851.1 C 619.45 722.09 730.48 595.4 826.18 488.08 M 510.62 851.1 C 634.06 709.6 758.38 567.18 826.18 488.08 M 516.26 850.7 C 633.61 717.02 749.04 583.76 826.58 493.72 M 516.26 850.7 C 594.7 759.68 673.45 669.56 826.58 493.72 M 521.25 851.06 C 592.14 772.6 661.65 693.31 826.32 500.12 M 521.25 851.06 C 593.87 765.49 667.15 681.8 826.32 500.12 M 526.89 850.67 C 592.77 772.12 659.04 696.78 826.71 505.77 M 526.89 850.67 C 624.9 735.9 724.46 621.55 826.71 505.77 M 531.88 851.03 C 602.94 769.27 671.73 687.06 826.45 512.16 M 531.88 851.03 C 645.18 719.69 758.28 589.79 826.45 512.16 M 536.87 851.39 C 633.68 737.72 731.22 625.06 826.19 518.56 M 536.87 851.39 C 631.7 743.68 724.22 636.22 826.19 518.56 M 542.51 850.99 C 646.78 731.69 748.53 613.27 826.58 524.2 M 542.51 850.99 C 635.24 745.35 726.67 640.15 826.58 524.2 M 547.5 851.35 C 650.49 730.68 754.08 611.17 826.32 530.6 M 547.5 851.35 C 602.21 787.09 658.09 723.01 826.32 530.6 M 553.14 850.96 C 617.6 777.1 680.4 703.24 826.72 536.24 M 553.14 850.96 C 661.8 725.36 771.73 598.85 826.72 536.24 M 558.13 851.32 C 625.05 777.52 689.26 703.72 826.45 542.64 M 558.13 851.32 C 659.77 734.49 761.12 618.09 826.45 542.64 M 563.77 850.92 C 648.63 749.12 737.46 650.24 826.19 549.04 M 563.77 850.92 C 667.43 729.95 772.46 609.68 826.19 549.04 M 568.76 851.28 C 648.6 761.78 724.95 672.62 826.59 554.68 M 568.76 851.28 C 649.48 758.85 730.2 665.77 826.59 554.68 M 574.4 850.89 C 624.83 791.48 676.44 731.66 826.33 561.08 M 574.4 850.89 C 664.62 750.08 752.2 648.64 826.33 561.08 M 579.39 851.25 C 674.57 742.91 768.38 633.85 826.72 566.72 M 579.39 851.25 C 652.84 763.15 729.03 676.51 826.72 566.72 M 585.03 850.85 C 644.03 780.42 706.15 709.04 826.46 573.12 M 585.03 850.85 C 663.22 759.6 741.49 667.97 826.46 573.12 M 590.02 851.22 C 674.5 753.78 758.66 655.47 826.2 579.52 M 590.02 851.22 C 661.57 770.04 733.08 687.59 826.2 579.52 M 595.66 850.82 C 675.56 762.58 750.57 673.65 826.59 585.16 M 595.66 850.82 C 654.25 786.17 710.83 721.14 826.59 585.16 M 600.65 851.18 C 685.25 755.93 766.12 663.65 826.33 591.56 M 600.65 851.18 C 666.83 776.93 732.44 701.15 826.33 591.56 M 606.29 850.79 C 686.62 759.55 764.94 670.46 826.73 597.2 M 606.29 850.79 C 665.67 783.07 724.81 713.82 826.73 597.2 M 611.28 851.15 C 696.7 755.08 779.37 658.64 826.46 603.6 M 611.28 851.15 C 676.55 774.83 742.12 699.85 826.46 603.6 M 616.92 850.75 C 680.11 781.04 740.12 709.38 826.2 610 M 616.92 850.75 C 658.29 800.98 700.45 752.03 826.2 610 M 621.91 851.11 C 680 785.69 739.86 718.17 826.6 615.64 M 621.91 851.11 C 667.01 798.19 712.3 746.47 826.6 615.64 M 627.55 850.72 C 700.95 767.7 775.3 684.05 826.34 622.04 M 627.55 850.72 C 684.64 783.95 742.19 716.96 826.34 622.04 M 632.54 851.08 C 698.91 772.01 768.07 692.61 826.73 627.68 M 632.54 851.08 C 701.78 770.42 771.84 688.87 826.73 627.68 M 638.18 850.68 C 686.35 795.13 735.26 738.69 826.47 634.08 M 638.18 850.68 C 681.32 801.72 724.25 752.75 826.47 634.08 M 643.17 851.04 C 708.03 777.22 770.78 703.94 826.21 640.48 M 643.17 851.04 C 694.73 791.39 747.31 729.87 826.21 640.48 M 648.81 850.65 C 704.72 789.26 760.76 723.42 826.6 646.12 M 648.81 850.65 C 711.33 779.84 773.32 708.22 826.6 646.12 M 653.8 851.01 C 704.01 794.89 752.32 734.86 826.34 652.52 M 653.8 851.01 C 689.7 810.75 725.66 769.25 826.34 652.52 M 658.78 851.37 C 709.04 791.2 763.46 730.65 826.74 658.16 M 658.78 851.37 C 698.44 806.08 737.92 760.4 826.74 658.16 M 664.43 850.97 C 703.88 804.19 745.45 757.3 826.47 664.56 M 664.43 850.97 C 723.04 780.57 783.96 711.97 826.47 664.56 M 669.41 851.33 C 718.16 794.05 768.57 740.41 826.21 670.96 M 669.41 851.33 C 718.52 794.93 766.44 739.94 826.21 670.96 M 675.06 850.94 C 730.65 786.2 784.81 722.59 826.61 676.6 M 675.06 850.94 C 718.16 804.88 759.67 755.2 826.61 676.6 M 680.04 851.3 C 711.58 815.15 743.19 778.26 826.35 683 M 680.04 851.3 C 714.52 810.98 748.47 772.52 826.35 683 M 685.69 850.9 C 714.91 819.95 743.57 783.86 826.74 688.64 M 685.69 850.9 C 724.2 809.01 759.48 766.13 826.74 688.64 M 690.67 851.26 C 746.31 786.77 797.13 726.79 826.48 695.04 M 690.67 851.26 C 736.23 799.48 779.53 748.4 826.48 695.04 M 696.32 850.87 C 724.17 817.44 754.66 786.27 826.22 701.44 M 696.32 850.87 C 735.19 805.49 776.15 759.25 826.22 701.44 M 701.31 851.23 C 734.45 813.8 765.63 773.59 826.61 707.08 M 701.31 851.23 C 744.66 803.98 787.35 754.68 826.61 707.08 M 706.95 850.84 C 742.37 807.02 775.46 769.47 826.35 713.48 M 706.95 850.84 C 736.84 818.7 765.59 784.17 826.35 713.48 M 711.94 851.2 C 744.87 811.88 780.04 775.44 826.75 719.12 M 711.94 851.2 C 743.71 816.64 775.52 779.47 826.75 719.12 M 717.58 850.8 C 739.01 826.43 761.33 802.33 826.48 725.52 M 717.58 850.8 C 753.64 807.15 790.78 765.14 826.48 725.52 M 722.57 851.16 C 745.13 825.35 767.3 799.21 826.22 731.92 M 722.57 851.16 C 759.6 807.62 796.65 765.75 826.22 731.92 M 728.21 850.77 C 762.38 813.54 797.5 775.83 826.62 737.56 M 728.21 850.77 C 758.24 815.98 787.21 780.98 826.62 737.56 M 733.2 851.13 C 755.19 828.35 773.6 802.6 826.36 743.96 M 733.2 851.13 C 762.55 819.59 789.94 787.84 826.36 743.96 M 738.84 850.73 C 773.85 812.36 803.74 774.15 826.75 749.6 M 738.84 850.73 C 765.32 820.77 793.4 790.23 826.75 749.6 M 743.83 851.09 C 774.72 818.03 804.55 781.73 826.49 756 M 743.83 851.09 C 761.38 830.59 778.54 810.61 826.49 756 M 749.47 850.7 C 767.3 828.76 782.01 812.47 826.23 762.4 M 749.47 850.7 C 774.66 821.44 800.03 793.59 826.23 762.4 M 754.46 851.06 C 777.33 822.86 801.16 798.49 826.62 768.04 M 754.46 851.06 C 775.31 828.26 795.91 804.99 826.62 768.04 M 760.1 850.66 C 776.58 830.86 796.49 808.91 826.36 774.44 M 760.1 850.66 C 776.03 831.35 791.97 814.43 826.36 774.44 M 765.09 851.02 C 779.4 830.88 795.99 815.46 826.76 780.08 M 765.09 851.02 C 784.87 829.6 803.58 806.87 826.76 780.08 M 770.07 851.38 C 789.14 826.53 810.26 807.04 826.49 786.48 M 770.07 851.38 C 786.79 831.52 804.52 812.32 826.49 786.48 M 775.72 850.99 C 794.93 827.31 815.29 804.97 826.23 792.88 M 775.72 850.99 C 793.29 829.98 811.69 809.63 826.23 792.88 M 780.7 851.35 C 798.26 832.36 813.2 812.78 826.63 798.52 M 780.7 851.35 C 794.09 837.21 807.06 822.48 826.63 798.52 M 786.35 850.95 C 800.6 833.93 817.67 814.71 826.37 804.92 M 786.35 850.95 C 799.16 835.15 813.53 818.44 826.37 804.92 M 791.33 851.31 C 800.91 843 805.96 834.05 826.1 811.31 M 791.33 851.31 C 802.82 837.88 813.82 825.13 826.1 811.31 M 796.98 850.92 C 806.77 836.77 818.37 825.68 826.5 816.96 M 796.98 850.92 C 803.4 842.52 809.43 836.74 826.5 816.96 M 801.96 851.28 C 810.76 842.48 819.61 828.31 826.24 823.36 M 801.96 851.28 C 808.49 843.06 815.87 836.67 826.24 823.36 M 807.61 850.89 C 816.3 842.38 821.28 836.38 826.63 829 M 807.61 850.89 C 813.49 844.16 821.07 836.23 826.63 829 M 812.59 851.25 C 816.73 848.97 817.88 842.36 826.37 835.4 M 812.59 851.25 C 818.87 845.18 823.72 839.29 826.37 835.4 M 818.24 850.85 C 819.95 848.01 822.95 846.13 826.11 841.79 M 818.24 850.85 C 819.48 848.91 821.62 847.49 826.11 841.79 M 823.22 851.21 C 824.17 850.08 825.9 848 826.5 847.44 M 823.22 851.21 C 824.16 850.15 825.35 848.48 826.5 847.44" fill="none" stroke="#e4d7eb" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 165 200 C 297.58 197.36 429.71 198.01 825 200 M 165 200 C 362.13 199.18 559.12 199.56 825 200 M 825 200 C 824.19 379.8 823.82 558.39 825 850 M 825 200 C 825.45 420.38 824.82 640.28 825 850 M 825 850 C 649.62 852.53 474.18 851.58 165 850 M 825 850 C 692.11 847.26 558.73 847.12 165 850 M 165 850 C 165.03 612.72 165.41 375.7 165 200 M 165 850 C 167.46 663.4 167.39 475.76 165 200" fill="none" stroke="rgb(0, 0, 0)" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 95 130 L 95 203.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 95 208.88 L 91.5 201.88 L 95 203.63 L 98.5 201.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 170px; margin-left: 95px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>Memo with value exists:</div><div>last verified in Rv with durability D<br /></div></div></div></div></foreignObject><text x="95" y="173" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Memo with value exists:...</text></switch></g><path d="M 155 110 L 285 110 L 285 205.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 285 210.88 L 281.5 203.88 L 285 205.63 L 288.5 203.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 110px; margin-left: 252px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>No previous memo, <br /></div><div>or memo has no value<br /></div></div></div></div></foreignObject><text x="252" y="113" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">No previous memo,...</text></switch></g><rect x="35" y="90" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 110px; margin-left: 36px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Load memo_map[K]<br /></div></div></div></div></foreignObject><text x="95" y="114" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Load memo_map[K]&#xa;</text></switch></g><path d="M 345 222 L 475 222 L 475 146.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 475 141.12 L 478.5 148.12 L 475 146.37 L 471.5 148.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 222px; margin-left: 382px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>Already</div><div>claimed<br /></div></div></div></div></foreignObject><text x="382" y="225" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Already...</text></switch></g><path d="M 285 252 L 285 323.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 285 328.88 L 281.5 321.88 L 285 323.63 L 288.5 321.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 291px; margin-left: 285px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Claimed</div></div></div></foreignObject><text x="285" y="294" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Claimed</text></switch></g><rect x="225" y="212" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 232px; margin-left: 226px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Claim sync_map[K]<br /></div></div></div></div></foreignObject><text x="285" y="236" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Claim sync_map[K]&#xa;</text></switch></g><path d="M 475 100 L 475 70 L 125 70 L 125 83.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 125 88.88 L 121.5 81.88 L 125 83.63 L 128.5 81.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 80px; margin-left: 475px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>Thread completed</div><div>normally<br /></div></div></div></div></foreignObject><text x="475" y="83" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Thread completed...</text></switch></g><path d="M 535 120 L 630.3 120 L 630.3 125.9 L 719.13 125.94" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 724.38 125.94 L 717.38 129.44 L 719.13 125.94 L 717.38 122.44 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 124px; margin-left: 599px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>Cycle detected</div><div>or thread panicked<br /></div></div></div></div></foreignObject><text x="599" y="127" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Cycle detected...</text></switch></g><rect x="415" y="100" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 120px; margin-left: 416px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Block until other thread completes</div></div></div></foreignObject><text x="475" y="124" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Block until other th...</text></switch></g><rect x="225" y="410" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 430px; margin-left: 226px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Load memo_map[K]<br /></div></div></div></div></foreignObject><text x="285" y="434" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Load memo_map[K]&#xa;</text></switch></g><path d="M 285 450 L 285 493.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 285 498.88 L 281.5 491.88 L 285 493.63 L 288.5 491.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 285 370 L 285 403.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 285 408.88 L 281.5 401.88 L 285 403.63 L 288.5 401.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="225" y="330" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 350px; margin-left: 226px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Push K onto stack<br /></div></div></div></div></foreignObject><text x="285" y="354" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Push K onto stack&#xa;</text></switch></g><path d="M 735 212 L 735 176 L 734.53 146.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 734.45 141.12 L 738.06 148.06 L 734.53 146.37 L 731.06 148.17 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="675" y="212" width="120" height="40" rx="6" ry="6" fill="#ff9999" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 232px; margin-left: 676px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Release claim.</div></div></div></foreignObject><text x="735" y="236" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Release claim.</text></switch></g><path d="M 735 330 L 735 258.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 735 253.12 L 738.5 260.12 L 735 258.37 L 731.5 260.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="675" y="330" width="120" height="40" rx="6" ry="6" fill="#ff9999" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 350px; margin-left: 676px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Pop stack frame.</div></div></div></foreignObject><text x="735" y="354" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Pop stack frame.</text></switch></g><rect x="725.5" y="102" width="19" height="38" fill="none" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><rect x="725.5" y="102" width="19" height="38" fill="none" stroke="none" pointer-events="all"/><path d="M 735.23 102.15 L 725.5 126.03 L 739.11 121.38 L 735.61 134.46 L 733.28 132.64 L 734.48 140 L 739.71 133.84 L 736.47 134.62 L 744.5 117.32 L 729.99 121.82 L 740.46 102 Z" fill="#000000" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><path d="M 735.23 102.15 L 725.5 126.03 L 739.11 121.38 L 735.61 134.46 L 733.28 132.64 L 734.48 140 L 739.71 133.84 L 736.47 134.62 L 744.5 117.32 L 729.99 121.82 L 740.46 102 Z" fill="#000000" stroke="none" pointer-events="all"/><path d="M 345 242 L 675 242" fill="none" stroke="rgb(0, 0, 0)" stroke-width="2" stroke-miterlimit="10" stroke-dasharray="2 6" pointer-events="stroke"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 242px; margin-left: 510px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">(Destructor)</div></div></div></foreignObject><text x="510" y="245" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">(Destructo...</text></switch></g><path d="M 345 350 L 675 350" fill="none" stroke="rgb(0, 0, 0)" stroke-width="2" stroke-miterlimit="10" stroke-dasharray="2 6" pointer-events="stroke"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 350px; margin-left: 510px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">(Destructor)</div></div></div></foreignObject><text x="510" y="353" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">(Destructo...</text></switch></g><path d="M 285 540 L 285 593.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 285 598.88 L 281.5 591.88 L 285 593.63 L 288.5 591.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 573px; margin-left: 286px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">False</div></div></div></foreignObject><text x="286" y="576" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">False</text></switch></g><path d="M 345 520 L 735 520 L 735 376.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 735 371.12 L 738.5 378.12 L 735 376.37 L 731.5 378.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 521px; margin-left: 396px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Panic</div></div></div></foreignObject><text x="396" y="524" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Panic</text></switch></g><path d="M 225 520 L 185 520 L 185 810 L 218.63 810" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 223.88 810 L 216.88 813.5 L 218.63 810 L 216.88 806.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 568px; margin-left: 186px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">True</div></div></div></foreignObject><text x="186" y="571" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">True</text></switch></g><rect x="225" y="500" width="120" height="40" rx="6" ry="6" fill="#99ccff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 520px; margin-left: 226px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Deep verify memo<br /></div></div></div></div></foreignObject><text x="285" y="524" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Deep verify memo&#xa;</text></switch></g><path d="M 155 232 L 218.63 232" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 223.88 232 L 216.88 235.5 L 218.63 232 L 216.88 228.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 233px; margin-left: 186px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">False</div></div></div></foreignObject><text x="186" y="236" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">False</text></switch></g><path d="M 95 252 L 95 272 L 95 270 L 95 283.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 95 288.88 L 91.5 281.88 L 95 283.63 L 98.5 281.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 269px; margin-left: 96px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">True</div></div></div></foreignObject><text x="96" y="272" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">True</text></switch></g><rect x="35" y="212" width="120" height="40" rx="6" ry="6" fill="#99ccff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 232px; margin-left: 36px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Shallow verify memo<br /></div></div></div></div></foreignObject><text x="95" y="236" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Shallow verify memo&#xa;</text></switch></g><rect x="35" y="290" width="120" height="40" rx="6" ry="6" fill="#ffcc99" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 310px; margin-left: 36px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Return changed_at &gt; revision  </div></div></div></foreignObject><text x="95" y="314" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Return changed_at &gt;...</text></switch></g><rect x="225" y="790" width="120" height="40" rx="6" ry="6" fill="#ffcc99" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 810px; margin-left: 226px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Return changed_at &gt; revision  </div></div></div></foreignObject><text x="285" y="814" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Return changed_at &gt;...</text></switch></g><path d="M 285 740 L 285 783.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 285 788.88 L 281.5 781.88 L 285 783.63 L 288.5 781.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 345 720 L 735 720 L 735 376.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 735 371.12 L 738.5 378.12 L 735 376.37 L 731.5 378.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 721px; margin-left: 396px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Panic</div></div></div></foreignObject><text x="396" y="724" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Panic</text></switch></g><rect x="225" y="700" width="120" height="40" rx="6" ry="6" fill="#99ccff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 720px; margin-left: 226px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Execute</div></div></div></foreignObject><text x="285" y="724" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Execute</text></switch></g><path d="M 285 640 L 285 693.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 285 698.88 L 281.5 691.88 L 285 693.63 L 288.5 691.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 666px; margin-left: 289px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Yes</div></div></div></foreignObject><text x="289" y="669" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Yes</text></switch></g><path d="M 345 620 L 438.63 620" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 443.88 620 L 436.88 623.5 L 438.63 620 L 436.88 616.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 621px; margin-left: 389px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">No</div></div></div></foreignObject><text x="389" y="624" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">No</text></switch></g><rect x="225" y="600" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 620px; margin-left: 226px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Have old memo?<br /></div></div></div></div></foreignObject><text x="285" y="624" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Have old memo?&#xa;</text></switch></g><rect x="445" y="600" width="120" height="40" rx="6" ry="6" fill="#ffcc99" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 620px; margin-left: 446px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Return true (maybe changed)</div></div></div></foreignObject><text x="505" y="624" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Return true (maybe c...</text></switch></g><path d="M 95 20 L 95 83.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 95 88.88 L 91.5 81.88 L 95 83.63 L 98.5 81.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="0" y="0" width="190" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 10px; margin-left: 95px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">maybe_changed_since(revision)</div></div></div></foreignObject><text x="95" y="14" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">maybe_changed_since(revision)</text></switch></g><rect x="655" y="820" width="170" height="20" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 830px; margin-left: 740px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;">maybe_changed_after_cold()</div></div></div></foreignObject><text x="740" y="834" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">maybe_changed_after_cold()</text></switch></g></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a transform="translate(0,-5)" xlink:href="https://www.diagrams.net/doc/faq/svg-export-text-problems" target="_blank"><text text-anchor="middle" font-size="10px" x="50%" y="100%">Text is not SVG - cannot display</text></a></switch></svg>
\ No newline at end of file
diff --git a/crates/salsa/book/src/derived-query-read.drawio.svg b/crates/salsa/book/src/derived-query-read.drawio.svg
new file mode 100644
index 000000000..53e9e1550
--- /dev/null
+++ b/crates/salsa/book/src/derived-query-read.drawio.svg
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- Do not edit this file with editors other than diagrams.net -->
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="1042px" height="1169px" viewBox="-0.5 -0.5 1042 1169" content="&lt;mxfile host=&quot;app.diagrams.net&quot; modified=&quot;2022-08-28T11:16:14.977Z&quot; agent=&quot;5.0 (X11)&quot; etag=&quot;O1FGR39M4P6WKzXTSgC4&quot; version=&quot;20.2.7&quot; type=&quot;device&quot;&gt;&lt;diagram id=&quot;C5RBs43oDa-KdzZeNtuy&quot; name=&quot;Page-1&quot;&gt;7V1bd9q4Fv41rDXz0Cxs49tjIEmn08vJTNqTzrxkKbYAnxiL2iIJ/fVHMhIYS4BIfBGpu1ZbLGzZ7G9rXz5tyT1rNHt+n4L59DMKYdwz++Fzz7romabtmeRf2rBcNQxMb9UwSaNw1WRsGm6in5A19lnrIgphtnUiRijG0Xy7MUBJAgO81QbSFD1tnzZG8fZd52AChYabAMRi620U4umq1TPdTfsfMJpM+Z0Nx199MwP8ZPZLsikI0VOhybrsWaMUIbz6NHsewZjKjsvl9sPyNv704Lz/86/sB/g2/Pj1y3/frTq7OuaS9U9IYYJf3LWfflhM//332/tJFr2Px9/vbBu8s1ddP4J4weTFfitecgGmaJGEkHbS71nDp2mE4c0cBPTbJ6IxpG2KZzE5MsjHcRTHIxSjNL/WuhxcuJdD0p49QBxM2UmKP4f97EeYYvhcAJP9vPcQzSBOl+QU/i3XuSU/dlnD0wZ532Zt023UWStg6jZZ974RKfnApHqEhA2rZhEbF/al25iIvZKIHVMU8cCQiHjg1ibhupW4UQmb/bKEHVHClitT4vokbNQr4aF17g+9piTslCXs+RIdNmU6bNQlYbchAU9ikGWsi0aEvZYjF7Zpi8J2ZMJe+93KhV2zRW5Wm8vyXVvoornwJPK1BrWZi7dkj62SfC2Jw1uLsnJz/J/biw8fR8FP5/PX5c3t5dw3P92/G0jk68TktsMweiQfJ/TjZzhD+VOSh+Tnmn34HGWYPM85v4I8QOEiST/EYOCVwKJxRBAjz5aQf/5+3HQeLlJwH8URpmK74H3cp+Vey/cq6QQMSeDODlGKp2iCEhBfblqH21qzOecTQnOmBv+DGC9ZFgIWGG1r0nFKkqFFGsA9QDCAMUgnEO85jxkc+gP3qlwKY4Cjx+3MpXL1MZT05wvVnnkKHyO0yGg6lOsTuWNfHWChUzKEeU/9KaDdJmijnfrqDVGXdPmdXn9m88N/WHf5wcXz1tGSHbWkb4aqwjEb965/Zjj8ImUlZN1doyjBhVPQeJyRpytr6fquL1fcvorefkIgZEp2NyOexB5+7NkvN0ob1TEUHBVKMNMhwyxHWzhFD2sKgp695hP6JR8XwjFY5A+3ukhspzcSW2sLMQblGM4QfaAhDZjrcoGOoArUXp28Q7EUB7itl0MRB+Y/MPuF4PCrhiO/9DxNwbJwwpwa2kxieXcxB5ZdYgSPvIB8WD1D45ZezNDyeDOiEUOwSHN4qTgfoyxCSc+66uy2it22rLbttoSrexumwq46NGvGdFui6X4TjlQVDrNy0/0qOMTR8SGZL6jR35Vr94MpSCZ5Xp5FSQBXqXlnENUM4qD1QNYXPR3EizQpcDa99QRku2j2TOvqajTyfW3w1NC/iXhKctTzOIUgXCrTJkEMohkd4xozJM8R/l74nLMjZ6bNDjf8CD2oiR4xVON1w1O0+ht+xLFNxmLry4+YIvE+4przy3Jmykph6xUKSOsGBMuQ40vFsEyCju6qyKuUp3zajxIMQzZBLGjD1yn1KzQoRLN5DPHGZRx0MQlKZyCOl1r7mI1FcY8yKdw5MUvE3VOjvslTNEP9o12Tr7tfMviPP2DLlkFM492QKG5wjO7ms0qY6/4cJFHwcIrRUrPB0vExkDVwtwwjn4h+qeaxntcVeeswvlxmsxo07DIZodmADosqPIxR8ECaFgmO6PUIT+GWJnIrLPJbnZs1TafsZk3fbM7NSgtX/F84TuaCPuigXKOtOFlebCRnMMXSBQmyn8A9jLfRAHE0ScjngEiVjGZrSBU6CkB8zr6YRWG4Ah5m0U9wn/dH8WDTM6Rze0hDcBlC+7ROGDnrmnh2k16x7HxXmtofvDJN5X1ZpUFWY9razetrkujYknr5ZhMdTrIUdOG6PJB5ERstRtqFvloBm2J8eXJlbs24lMNlb5WXKcht1cAv6bFTDiBX3m9PALmzJ18tFK1s4ttsRV/az4/5RFzztRavs1ci3/9tHgIMCxbnDlANw9RySWoXOsd0eF6nfQLOEtnYNzFPbqlOlFuuVuPOEmuY30YdiTogqvxNvUVnVtljusb+orNDF7RYdCZWX3RVZxVkFY5keV3D1vutlgu7isZioDqr0Iz15hzFvhVibxmN1hi0vc/dVZ01ZBDd1mkWS5zN6MrO1MsINfRw7UxdtM8bcIm2EC+/zgWKpHdHHFQ/Mts3tY4Ye76BWIeHMAeHnaPXUjVXHHbnq6t4xLOZJ9CHt19/d6i+qWiFGy6+VdYI5VykUHjieK8sNamfPXD1yGk0qCxyVCms9ioJ9mpwAcGrvLQMgmDKTQT5/8PZ2VnnfVUSHU+y10/D3tcQkDo9Z1t9Zbri7Kdd3sKm5tlP/kP3V4JcLzI6HD+Sv0S9UY4uoJV4XSlIhTXvrae0jkhLtUPabqKyYkxWrEE/KizT0xdrxkkafKH4iQXgTCnaYEKUofYrn8p90cyhXd65zj8wc+i7+y/Ynjmsyic5O9Zk00CwR3cJXt5TzmZDiIMxzsvA9SHEe6bl+6PR1ZW+7sZvfeWuK9sV7eRDR1c1K3f12pfCFXMxSSR4A+IMkLMuH3NpqW9qeBvlj3D5DIMFfvnOcy0N5ktbq8EsLOTQYDC/SdLVVV3K7OpFuvJXCBTXpQtr/fQJ9hpeeKOMKudANUHV4LuH6YHaoRA9I/LF5/SFEqQhQQnUgyxVRr/6qP11FlYsiF170/6PBcwfZbxIAqzLXKV+UXDZcZr91uucXRkDd/qOU3lGQq8iAVfMPYcgeOBlAqxQJxrTJ/6xALS/nA+l78hh3+sxU5HX8NA/2oy9cgaqwdjzWvan2+zmCZCbruqeGprV/rhK22HcYJTS4T3b2sj/FZuvJ/CpYBV0TnA1sxXlqiIdbIV1SrF3xePeUya19MqDfa8N0DRNfJRB1Czx8URmcpP4BIzWSGGAHiG7mwYGVffER/ZSqIYNqjjbfAXi+D4vLDj5BIhTR4c5JkerweaLg+2abu91SoFya1DqtVLeE+fXRlOYb6C1sZYE0pQktxNtDKdmkajIGLVepuOJycxVDCY9tm72htxGp1C1YXKf29PDo1Wv+huuVjtQ/ULDyDfgFpXRUbWlhZ24VlfoW7DuiXOk3CDzMHa8gpwS+LzGsj9OgWREd+ZZap5lL6BueufggU7mV7WQrs3EVHknIs0SU8lWRMlTlIQb8pCNa13Gru9rtKjX0y+0MlTeu93sYB64R41menQN04jIg26mWcdw9VV9uGGYVY/XHXWq3rYmbV5L0tAyCl/07H/DGIIsp6joGwM0mhXUygjwimKNdh4zjJanBVul+n3VPVV8zYgrkU68JpIvhdHdMFQdhq37Yl8sxRDAIxKe04+z5wnBanqWRZMkO8vAGOLl2ZQ85N0jijGYwDtjG8h8qQRM8zLmjIO7jVA//yMgxOZz+CbV+YbW1yiL8qor6+IeYYxmPXEXa0zNgLjZdfYAcTDlKsQV5vjMWx1q11OZCvBFpPmcfg11jQpRVwd1BVBLp9EbhZqHhB3UFRtwh4YNWyZc+naHZsFWWBTQgX082LZTXvYv89bNQi1yIb9dQCL3RYBR+rsYUCdhqUIiBNl0HYcVcKbt1wATWSd5i9m3hGjLFAJwOa3l7ue1XrzuuOIYXPkNesoxeEEvbEkQx9temYc75debD8qbuatuC++U31A0KMeZNWf061hXb4VulKe1K+dpm1FLwVwO7BeqpV9eQS30VJ1aSt9cI4ueVnWlc1q6uioqJT4ojtHTXb6x1vKOlrP+9nuh/rRwqqDGxAPhbXWt8v08lPXIWP68yy0XfThrqsuPmv1SyDRwJH7UrSnrlQIsWxMtADymAcfdFOEOVhmslgqZ4TeJqiwO3oFqgOKwg1UtxaHMvzhe+00iu3thQdEgs3cFn+VTAR26cgaynL4OJLbYahJbKVchgAtXtcgdqlJUB2WyUVKf4TUKqpKHDSGcd/HTIXQNgV+UUcmyyL4+eJVcbRchqyLMHex643Xbqi1CJocpQriYMVFK8DMK6TtDL/8P&lt;/diagram&gt;&lt;/mxfile&gt;"><defs/><g><rect x="90" y="0" width="950" height="1160" fill="none" stroke="none" pointer-events="all"/><path d="M 90.02 -0.02 C 90.02 -0.02 90.02 -0.02 90.02 -0.02 M 90.02 -0.02 C 90.02 -0.02 90.02 -0.02 90.02 -0.02 M 89.76 6.37 C 90.54 4.78 92.06 3.63 95.01 0.34 M 89.76 6.37 C 92.1 3.74 94.22 1.39 95.01 0.34 M 90.15 12.02 C 93.24 10.35 95.85 6.34 100.65 -0.06 M 90.15 12.02 C 93.45 7.1 97.79 3.4 100.65 -0.06 M 89.89 18.41 C 94.71 12.97 96.95 8.53 105.64 0.3 M 89.89 18.41 C 95.15 11.92 99.98 6.22 105.64 0.3 M 90.29 24.06 C 94.46 20.07 99.4 15.55 111.28 -0.09 M 90.29 24.06 C 96.56 15.28 104.77 7.62 111.28 -0.09 M 90.03 30.45 C 101.4 19.17 111.73 8.7 116.27 0.27 M 90.03 30.45 C 96.17 22.99 102.03 15.8 116.27 0.27 M 89.77 36.85 C 100.59 24.13 113.94 8.89 121.91 -0.13 M 89.77 36.85 C 95.36 30.1 103.54 21.09 121.91 -0.13 M 90.16 42.5 C 103.37 27.55 115.75 12.62 126.9 0.23 M 90.16 42.5 C 97.92 32.51 106.86 24.82 126.9 0.23 M 89.9 48.89 C 101.42 35.27 111.71 24.09 132.54 -0.16 M 89.9 48.89 C 98.84 37.1 108.72 26.27 132.54 -0.16 M 90.29 54.54 C 108.72 36.07 122.14 14.58 137.53 0.2 M 90.29 54.54 C 101.97 42.46 111.88 28.56 137.53 0.2 M 90.03 60.93 C 104.41 43.52 121.67 25 143.17 -0.2 M 90.03 60.93 C 107.72 39.56 126.44 18.03 143.17 -0.2 M 89.77 67.33 C 105.46 50.95 120.4 33.55 148.16 0.16 M 89.77 67.33 C 105.53 49.35 120.42 30.72 148.16 0.16 M 90.16 72.97 C 107.17 54.17 124.66 32.68 153.8 -0.23 M 90.16 72.97 C 103.75 56.98 115.95 42.48 153.8 -0.23 M 89.9 79.37 C 103.66 63.07 116.43 48.86 158.79 0.13 M 89.9 79.37 C 111.08 55.52 131.37 30.53 158.79 0.13 M 90.3 85.02 C 110.61 63.41 129.85 39.76 164.43 -0.27 M 90.3 85.02 C 117.49 53.08 145.72 19.59 164.43 -0.27 M 90.04 91.41 C 107.43 72.09 126.45 49.28 169.42 0.09 M 90.04 91.41 C 118.06 59.91 144.86 27.46 169.42 0.09 M 89.77 97.81 C 115.6 64.09 143.36 34.73 175.06 -0.3 M 89.77 97.81 C 119.76 62.76 149.85 29.19 175.06 -0.3 M 90.17 103.45 C 121.47 68.68 151.92 33.53 180.05 0.06 M 90.17 103.45 C 108.13 80.86 127.57 60.51 180.05 0.06 M 89.91 109.85 C 108.28 85.42 130.13 64.57 185.69 -0.34 M 89.91 109.85 C 120.71 73.82 152.56 38.44 185.69 -0.34 M 90.3 115.5 C 114.95 88.49 137.26 64.13 190.68 0.02 M 90.3 115.5 C 123.96 76.91 158.4 39.53 190.68 0.02 M 90.04 121.89 C 113.43 94.38 139.45 65.1 196.32 -0.37 M 90.04 121.89 C 114.44 94.53 138.12 67.97 196.32 -0.37 M 89.78 128.29 C 130.23 84.17 168.71 36.16 201.31 -0.01 M 89.78 128.29 C 129.52 81.46 170.03 35.01 201.31 -0.01 M 90.17 133.93 C 117.83 99.53 146.75 67.91 206.3 0.35 M 90.17 133.93 C 121.06 100.03 150.74 64.39 206.3 0.35 M 89.91 140.33 C 122.71 103.77 154.49 65.76 211.94 -0.04 M 89.91 140.33 C 134.27 90.78 178.7 39.04 211.94 -0.04 M 90.31 145.97 C 116.23 117.43 140.29 86.09 216.93 0.32 M 90.31 145.97 C 115.44 114.85 141.1 85.73 216.93 0.32 M 90.05 152.37 C 134.8 100.78 182.83 47.63 222.57 -0.08 M 90.05 152.37 C 120.65 118.89 149.64 84.65 222.57 -0.08 M 89.78 158.77 C 119.82 121.89 151.72 88.1 227.56 0.28 M 89.78 158.77 C 132.06 109.26 174.44 59.84 227.56 0.28 M 90.18 164.41 C 143.36 105.37 194.25 42.45 233.2 -0.11 M 90.18 164.41 C 122.71 126.05 154.94 89.27 233.2 -0.11 M 89.92 170.81 C 142.01 109.69 195.77 50.39 238.19 0.25 M 89.92 170.81 C 143.25 110.15 195.95 49.88 238.19 0.25 M 90.31 176.45 C 147.7 110.4 206.47 39.76 243.83 -0.15 M 90.31 176.45 C 135.9 125.49 182.32 72.77 243.83 -0.15 M 90.05 182.85 C 148.64 115.89 205.95 47.24 248.82 0.21 M 90.05 182.85 C 128.78 139.03 166.84 94.52 248.82 0.21 M 89.79 189.25 C 130.2 139.25 174.99 90.36 254.46 -0.18 M 89.79 189.25 C 148.59 121.21 207.36 54.49 254.46 -0.18 M 90.18 194.89 C 155.02 122.55 217.16 46.91 259.45 0.18 M 90.18 194.89 C 153.47 121.09 215.29 48.69 259.45 0.18 M 89.92 201.29 C 142.88 140.25 193.86 81.45 265.09 -0.22 M 89.92 201.29 C 150.59 129.08 211.97 59.18 265.09 -0.22 M 90.32 206.93 C 128.56 161.63 168.14 115.05 270.08 0.14 M 90.32 206.93 C 141.42 147.97 191.11 90.88 270.08 0.14 M 90.06 213.33 C 133.25 160.4 178.71 109.4 275.72 -0.25 M 90.06 213.33 C 132.9 162.49 177.83 112 275.72 -0.25 M 89.79 219.73 C 145.89 157.42 203.84 92.15 280.71 0.11 M 89.79 219.73 C 129.2 175.51 167.28 130.89 280.71 0.11 M 90.19 225.37 C 141.18 166.37 193.87 109.61 286.35 -0.29 M 90.19 225.37 C 165.9 135.63 244.82 46.44 286.35 -0.29 M 89.93 231.77 C 152.8 160.2 212.81 91.6 291.34 0.07 M 89.93 231.77 C 151.15 163.16 211.45 94.08 291.34 0.07 M 90.32 237.41 C 164.66 153.86 239.89 67.08 296.98 -0.32 M 90.32 237.41 C 134.21 185.56 177.36 135.5 296.98 -0.32 M 90.06 243.81 C 151.17 173.48 212.4 101.48 301.97 0.04 M 90.06 243.81 C 140.3 184.61 192.11 124.72 301.97 0.04 M 89.8 250.21 C 173.97 155.89 258.48 60.73 307.61 -0.35 M 89.8 250.21 C 154.94 178.37 218.83 104.61 307.61 -0.35 M 90.19 255.85 C 148.32 189.96 205.07 126.46 312.6 0.01 M 90.19 255.85 C 141.04 199.06 192.08 141.66 312.6 0.01 M 89.93 262.25 C 136.64 207.44 181.81 152.86 317.58 0.37 M 89.93 262.25 C 151.09 194.19 211.11 124.78 317.58 0.37 M 90.33 267.89 C 160.85 185.69 231.96 104.15 323.23 -0.03 M 90.33 267.89 C 172.61 175.21 253.9 81.91 323.23 -0.03 M 90.07 274.29 C 170.72 183.3 249.35 91.14 328.21 0.33 M 90.07 274.29 C 174.37 176.7 258.99 79.41 328.21 0.33 M 89.8 280.69 C 163.49 196.11 234.46 112.24 333.86 -0.06 M 89.8 280.69 C 147.56 213.58 204.71 148.12 333.86 -0.06 M 90.2 286.33 C 170.1 194.39 249.85 100.3 338.84 0.3 M 90.2 286.33 C 144.69 220.77 199.99 156.41 338.84 0.3 M 89.94 292.73 C 146.24 230.36 200.04 166.58 344.49 -0.1 M 89.94 292.73 C 143.23 228.77 198.39 164.97 344.49 -0.1 M 89.68 299.13 C 178.83 195.42 267.03 92.41 349.47 0.26 M 89.68 299.13 C 178.46 198.21 265.93 96.98 349.47 0.26 M 90.07 304.77 C 191.82 186.91 293.76 69.09 355.12 -0.13 M 90.07 304.77 C 182.92 199.32 274.98 93.65 355.12 -0.13 M 89.81 311.17 C 149.22 246.68 206.94 179.93 360.1 0.23 M 89.81 311.17 C 192.81 190.55 296.2 70.44 360.1 0.23 M 90.2 316.81 C 159.2 236.83 228.55 156.81 365.75 -0.17 M 90.2 316.81 C 198.22 191.56 306.94 67.99 365.75 -0.17 M 89.94 323.21 C 197.28 198.97 302.32 77.41 370.73 0.19 M 89.94 323.21 C 163.26 237.78 235.68 153.8 370.73 0.19 M 89.68 329.61 C 154.48 256.08 216.9 182.72 376.38 -0.2 M 89.68 329.61 C 157.37 252.92 225.22 175.62 376.38 -0.2 M 90.07 335.25 C 183.38 227.89 275.3 120.86 381.37 0.16 M 90.07 335.25 C 171.56 239.55 253.76 145.49 381.37 0.16 M 89.81 341.65 C 150.28 270.18 212.01 199.57 387.01 -0.24 M 89.81 341.65 C 170.5 248.22 252.87 154.47 387.01 -0.24 M 90.21 347.29 C 194.91 223.35 301.7 101.12 392 0.12 M 90.21 347.29 C 204.54 216.72 318.65 85.13 392 0.12 M 89.95 353.69 C 172.17 260.3 255.77 164.13 397.64 -0.27 M 89.95 353.69 C 158.34 274.78 227.91 194.56 397.64 -0.27 M 89.69 360.09 C 160.11 276.91 232.28 195.16 402.63 0.09 M 89.69 360.09 C 184.22 253.03 277.97 144.98 402.63 0.09 M 90.08 365.73 C 152.97 293.01 216.54 219.69 408.27 -0.31 M 90.08 365.73 C 191.81 250.15 292.75 133.85 408.27 -0.31 M 89.82 372.13 C 200.96 246.49 310.28 120.86 413.26 0.06 M 89.82 372.13 C 157.18 294.84 224.24 218.01 413.26 0.06 M 90.21 377.77 C 197.75 252.81 307.71 127.36 418.9 -0.34 M 90.21 377.77 C 186.41 267.09 282.48 156.17 418.9 -0.34 M 89.95 384.17 C 189.2 270.15 288.7 155.44 423.89 0.02 M 89.95 384.17 C 181.48 278.67 273.99 172.24 423.89 0.02 M 89.69 390.57 C 197.13 264.99 307.14 140.45 429.53 -0.37 M 89.69 390.57 C 164.05 307.37 236.47 223.73 429.53 -0.37 M 90.08 396.21 C 212.28 254.56 336.14 112.45 434.52 -0.01 M 90.08 396.21 C 193.68 274.96 298.39 154.77 434.52 -0.01 M 89.82 402.61 C 219.04 255.12 347.58 107.57 439.5 0.35 M 89.82 402.61 C 179.71 297.5 269.93 193.56 439.5 0.35 M 90.22 408.25 C 165.65 322.03 241.6 235.81 445.15 -0.05 M 90.22 408.25 C 194.43 285.85 300.07 164.34 445.15 -0.05 M 89.96 414.65 C 234.49 249.75 377.87 84.62 450.13 0.31 M 89.96 414.65 C 206.03 283.15 319.59 152.17 450.13 0.31 M 89.69 421.04 C 229.86 259.92 370.41 99.33 455.78 -0.08 M 89.69 421.04 C 193.21 302.48 296.4 184.27 455.78 -0.08 M 90.09 426.69 C 197.33 306.47 302.46 185.25 460.76 0.28 M 90.09 426.69 C 238.43 256.89 386.27 87.52 460.76 0.28 M 89.83 433.09 C 173.12 336.55 256.06 239.94 466.41 -0.12 M 89.83 433.09 C 203.7 303.41 315.73 174.36 466.41 -0.12 M 90.22 438.73 C 175.95 342.9 259.86 246.79 471.39 0.24 M 90.22 438.73 C 176.91 341.36 262.32 242.99 471.39 0.24 M 89.96 445.13 C 214.53 300.94 341.3 155.56 477.04 -0.15 M 89.96 445.13 C 167.39 356.12 245.53 265.61 477.04 -0.15 M 89.7 451.52 C 223.3 298.92 356.88 144.52 482.02 0.21 M 89.7 451.52 C 181.81 346.38 273.56 241.12 482.02 0.21 M 90.09 457.17 C 219.83 310.84 345.88 163.62 487.67 -0.19 M 90.09 457.17 C 195.97 335.05 302.07 212.66 487.67 -0.19 M 89.83 463.57 C 215.86 317.97 342.32 172.65 492.65 0.17 M 89.83 463.57 C 245.12 286.9 399.6 110.07 492.65 0.17 M 90.23 469.21 C 198.66 345.8 306.99 221.55 498.3 -0.22 M 90.23 469.21 C 243.49 291.08 397.34 113.52 498.3 -0.22 M 89.97 475.61 C 231.9 314.08 373.31 151.83 503.28 0.14 M 89.97 475.61 C 231.01 313.4 371.86 151.77 503.28 0.14 M 89.7 482 C 195.88 359.85 302.15 239.16 508.93 -0.26 M 89.7 482 C 190.29 367.55 289.86 253.08 508.93 -0.26 M 90.1 487.65 C 241.85 309.62 395.67 133.37 513.91 0.1 M 90.1 487.65 C 213.02 343.7 336.91 200.61 513.91 0.1 M 89.84 494.04 C 184.15 387.05 274.67 281.7 519.56 -0.29 M 89.84 494.04 C 248.74 312.56 406.1 131.21 519.56 -0.29 M 90.23 499.69 C 198.34 376.45 305.53 253.12 524.54 0.07 M 90.23 499.69 C 238.23 330.19 386.37 159.1 524.54 0.07 M 89.97 506.09 C 227.18 346.04 365.17 188.76 530.19 -0.32 M 89.97 506.09 C 223.76 354.45 354.73 203.33 530.19 -0.32 M 89.71 512.48 C 268.74 308.75 447.07 104.1 535.17 0.04 M 89.71 512.48 C 223.82 357.89 359.57 202.4 535.17 0.04 M 90.1 518.13 C 247.36 336.33 402.87 157.1 540.82 -0.36 M 90.1 518.13 C 262.14 320.81 435.27 121.99 540.82 -0.36 M 89.84 524.52 C 256.77 334.99 422.13 144.37 545.8 0 M 89.84 524.52 C 231.32 362.65 372.78 199.48 545.8 0 M 90.24 530.17 C 249.75 346.28 409.42 161.98 550.79 0.36 M 90.24 530.17 C 269.35 324.24 446.49 120.22 550.79 0.36 M 89.98 536.57 C 186.29 425.32 283.83 312.68 556.43 -0.03 M 89.98 536.57 C 188.11 422.63 287.76 307.42 556.43 -0.03 M 89.71 542.96 C 270.6 334.67 450.55 128.66 561.42 0.33 M 89.71 542.96 C 223.89 387.4 359.01 231.43 561.42 0.33 M 90.11 548.61 C 256.66 359.25 420.87 169.45 567.06 -0.07 M 90.11 548.61 C 269.82 342.57 447.89 138.13 567.06 -0.07 M 89.85 555 C 257.21 361.91 425.39 167.02 572.05 0.29 M 89.85 555 C 228.96 396.98 366.26 238.95 572.05 0.29 M 90.24 560.65 C 246.95 379.96 402.44 200.43 577.69 -0.1 M 90.24 560.65 C 224.05 406.92 356.24 254.77 577.69 -0.1 M 89.98 567.04 C 282.25 349.24 473.08 129.09 582.68 0.26 M 89.98 567.04 C 282.33 343.94 475.04 122.16 582.68 0.26 M 89.72 573.44 C 191.74 456.72 294.69 338.89 588.32 -0.14 M 89.72 573.44 C 241.39 400.54 392.01 228.16 588.32 -0.14 M 90.11 579.09 C 221.8 427.12 355.22 274.3 593.31 0.22 M 90.11 579.09 C 206.54 443.33 323.37 307.98 593.31 0.22 M 89.85 585.48 C 197.85 457.1 307.99 330.48 598.95 -0.17 M 89.85 585.48 C 282.21 365.59 472.72 146.01 598.95 -0.17 M 90.25 591.13 C 289.71 363.83 488.23 135.34 603.94 0.19 M 90.25 591.13 C 219.74 439.29 351.08 288.78 603.94 0.19 M 89.99 597.52 C 247.05 419.01 401.55 239.88 609.58 -0.21 M 89.99 597.52 C 253.96 407.06 419.47 215.94 609.58 -0.21 M 89.72 603.92 C 292.6 367.79 496.33 132.5 614.57 0.15 M 89.72 603.92 C 254.92 413.98 420.09 222.86 614.57 0.15 M 90.12 609.57 C 264.4 407.64 439.82 205.86 620.21 -0.24 M 90.12 609.57 C 235.03 440.61 381.33 272.69 620.21 -0.24 M 89.86 615.96 C 272.95 403.18 458.32 189.05 625.2 0.12 M 89.86 615.96 C 243.67 437.97 399.57 258.48 625.2 0.12 M 90.25 621.61 C 270.28 416.27 449.39 210.29 630.84 -0.27 M 90.25 621.61 C 254.06 435.31 416.76 248.88 630.84 -0.27 M 89.99 628 C 289.99 398.45 489.99 167.25 635.83 0.09 M 89.99 628 C 237.15 460.12 384.4 291.03 635.83 0.09 M 89.73 634.4 C 226.96 479.52 362.57 322.7 641.47 -0.31 M 89.73 634.4 C 294.23 400.41 497.75 166.49 641.47 -0.31 M 90.12 640.04 C 308.14 389.19 525.24 140.01 646.46 0.05 M 90.12 640.04 C 290.27 408.36 489.95 177.99 646.46 0.05 M 89.86 646.44 C 290.8 414.26 493.39 180.93 652.1 -0.34 M 89.86 646.44 C 297.39 406.45 505.31 166.65 652.1 -0.34 M 90.26 652.09 C 312.16 394.93 534.52 139 657.09 0.02 M 90.26 652.09 C 249.94 469.77 409.74 285.91 657.09 0.02 M 89.99 658.48 C 256.72 464.06 424.83 269.87 662.08 0.38 M 89.99 658.48 C 265.45 457.36 440.49 255.37 662.08 0.38 M 89.73 664.88 C 311.45 409.81 532.82 154.14 667.72 -0.02 M 89.73 664.88 C 306.1 417.79 521.53 170 667.72 -0.02 M 90.13 670.52 C 319.61 401.69 551.55 136.2 672.71 0.34 M 90.13 670.52 C 266.93 466.92 441.79 265.89 672.71 0.34 M 89.87 676.92 C 213.29 533.85 337.63 391.34 678.35 -0.05 M 89.87 676.92 C 317.79 412.42 545.69 150.51 678.35 -0.05 M 90.26 682.56 C 301.29 440.18 513.64 197.65 683.34 0.31 M 90.26 682.56 C 318.15 419.19 547.76 154.68 683.34 0.31 M 90 688.96 C 298.9 448.13 507.36 206.23 688.98 -0.09 M 90 688.96 C 262.55 487.23 437.58 286.08 688.98 -0.09 M 89.74 695.36 C 329.62 418.07 567.88 141.77 693.97 0.27 M 89.74 695.36 C 282.4 477.27 473.85 257.66 693.97 0.27 M 90.13 701 C 285.28 479.79 479.59 257.13 699.61 -0.12 M 90.13 701 C 257.52 507.16 424.08 316.02 699.61 -0.12 M 89.87 707.4 C 252.44 518.01 417.54 328.3 704.6 0.24 M 89.87 707.4 C 310.69 453.35 530.04 200.73 704.6 0.24 M 90.27 713.04 C 252.26 527.03 412.35 343.64 710.24 -0.16 M 90.27 713.04 C 296.33 476.93 499.97 242.47 710.24 -0.16 M 90 719.44 C 255.1 529.45 420.73 338.4 715.23 0.2 M 90 719.44 C 273.3 507.95 455.15 298.63 715.23 0.2 M 89.74 725.84 C 314.14 468.27 539.87 209.29 720.87 -0.19 M 89.74 725.84 C 263.97 528.13 438.17 328.31 720.87 -0.19 M 90.14 731.48 C 225.69 579.53 358.2 426.54 725.86 0.17 M 90.14 731.48 C 228.92 572.91 367.28 413.78 725.86 0.17 M 89.88 737.88 C 237.52 567.69 382.61 399.7 731.5 -0.23 M 89.88 737.88 C 308.38 483.45 528.23 230.19 731.5 -0.23 M 90.27 743.52 C 261.16 550.4 429.12 356.5 736.49 0.13 M 90.27 743.52 C 317.95 481.76 543.89 222.41 736.49 0.13 M 90.01 749.92 C 303.33 509.15 514.21 266.63 742.13 -0.26 M 90.01 749.92 C 335.93 463.99 583.93 178.32 742.13 -0.26 M 89.75 756.32 C 294.88 521.69 500.67 284.7 747.12 0.1 M 89.75 756.32 C 229.17 591.46 370.91 427.91 747.12 0.1 M 90.14 761.96 C 308.64 514.1 527.13 263.85 752.76 -0.29 M 90.14 761.96 C 253.5 571.2 418.03 381.86 752.76 -0.29 M 89.88 768.36 C 351.83 466.45 613.86 164.45 757.75 0.07 M 89.88 768.36 C 263.35 566.24 439.81 363.31 757.75 0.07 M 90.28 774 C 333.93 491.7 578.8 209.28 763.39 -0.33 M 90.28 774 C 238.89 598.82 390.19 425.02 763.39 -0.33 M 90.01 780.4 C 266.52 576.5 443.12 374 768.38 0.03 M 90.01 780.4 C 260.32 583.3 431.15 385.91 768.38 0.03 M 89.75 786.8 C 350.73 485.17 612.14 184.69 774.02 -0.36 M 89.75 786.8 C 231.73 627.9 371.36 466.86 774.02 -0.36 M 90.15 792.44 C 239.98 618.5 389.77 449.01 779.01 0 M 90.15 792.44 C 267.24 586.16 445.16 380.62 779.01 0 M 89.89 798.84 C 345.34 501.27 601.8 205.73 784 0.36 M 89.89 798.84 C 296.65 560.52 501.73 324.64 784 0.36 M 90.28 804.48 C 292.62 571.65 492.37 341.12 789.64 -0.04 M 90.28 804.48 C 279.19 581.86 471.4 361.25 789.64 -0.04 M 90.02 810.88 C 341.2 525.21 591.95 236.62 794.63 0.32 M 90.02 810.88 C 249.86 632.48 406.45 451.86 794.63 0.32 M 89.76 817.28 C 262.12 621.19 431.63 425.65 800.27 -0.07 M 89.76 817.28 C 239.29 648.22 386.95 477.96 800.27 -0.07 M 90.15 822.92 C 367.26 499.14 646.47 177.52 805.26 0.29 M 90.15 822.92 C 327.16 554.55 561.2 284.93 805.26 0.29 M 89.89 829.32 C 361.71 519.83 629.71 211.95 810.9 -0.11 M 89.89 829.32 C 290.43 596.07 493.8 361.58 810.9 -0.11 M 90.29 834.96 C 358.97 526.85 628.58 218.26 815.89 0.25 M 90.29 834.96 C 354.88 532.74 619.79 228.63 815.89 0.25 M 90.02 841.36 C 324.4 572.48 558.8 304.14 821.53 -0.14 M 90.02 841.36 C 264.98 646.04 437.06 447.8 821.53 -0.14 M 89.76 847.76 C 253.61 662.52 413.83 477.38 826.52 0.22 M 89.76 847.76 C 314.17 589.81 539.94 329.07 826.52 0.22 M 90.16 853.4 C 275.05 639.46 461.52 425.92 832.16 -0.18 M 90.16 853.4 C 329.2 580.03 569.11 304.19 832.16 -0.18 M 89.9 859.8 C 308.94 604.13 531.05 348.99 837.15 0.18 M 89.9 859.8 C 342.91 563.78 598.12 269.66 837.15 0.18 M 90.29 865.44 C 286.71 634.08 485.51 405.08 842.79 -0.21 M 90.29 865.44 C 326.15 590.16 563.39 317.61 842.79 -0.21 M 90.03 871.84 C 394.84 524.34 696.48 177.48 847.78 0.15 M 90.03 871.84 C 296.23 635.48 502.57 398.18 847.78 0.15 M 89.77 878.24 C 242.92 700.19 397.89 523.99 853.42 -0.24 M 89.77 878.24 C 317.05 617.72 543.22 356.72 853.42 -0.24 M 90.16 883.88 C 359.5 569.88 630.95 255.55 858.41 0.12 M 90.16 883.88 C 331.37 605.39 574.07 326.53 858.41 0.12 M 89.9 890.28 C 268.15 680.89 447.73 474.24 864.05 -0.28 M 89.9 890.28 C 297.31 651.39 506.69 410.36 864.05 -0.28 M 90.3 895.92 C 264.23 693.84 439.79 490.95 869.04 0.08 M 90.3 895.92 C 328.68 623.18 567.54 348.38 869.04 0.08 M 90.03 902.32 C 294.38 669.3 499.69 433.93 874.68 -0.31 M 90.03 902.32 C 369.23 585.16 645.73 267.18 874.68 -0.31 M 89.77 908.72 C 339.88 624.2 586.5 339.82 879.67 0.05 M 89.77 908.72 C 321.19 641.66 555.99 372.15 879.67 0.05 M 90.17 914.36 C 351.14 614.79 613.09 315.28 885.31 -0.35 M 90.17 914.36 C 389.05 570.8 688.44 227.11 885.31 -0.35 M 89.91 920.76 C 367.25 603.29 644.9 284.94 890.3 0.01 M 89.91 920.76 C 366.81 596.92 646.96 275.4 890.3 0.01 M 90.3 926.4 C 258.14 729.69 425.8 535.44 895.28 0.37 M 90.3 926.4 C 322.12 662.14 553.54 395.26 895.28 0.37 M 90.04 932.8 C 330.91 660.94 567.75 388.04 900.93 -0.02 M 90.04 932.8 C 371.54 611.11 653.53 287.07 900.93 -0.02 M 89.78 939.2 C 266.32 737.48 439.68 538.48 905.91 0.34 M 89.78 939.2 C 374.97 606.16 663.93 273.2 905.91 0.34 M 90.17 944.84 C 383.55 613.74 672.47 280.38 911.56 -0.06 M 90.17 944.84 C 407.36 579.33 723.83 214.1 911.56 -0.06 M 89.91 951.24 C 400.64 588.39 715.99 226.65 916.54 0.3 M 89.91 951.24 C 379.73 612.77 671.64 276.59 916.54 0.3 M 90.3 956.88 C 388.31 609.42 690.44 263.73 922.19 -0.09 M 90.3 956.88 C 408.69 595.49 722.78 233.61 922.19 -0.09 M 90.04 963.28 C 336.31 682.14 579.63 402.98 927.17 0.27 M 90.04 963.28 C 405.84 596.06 723.74 229.91 927.17 0.27 M 89.78 969.68 C 418.79 592.63 750.24 211.71 932.82 -0.13 M 89.78 969.68 C 303 728.11 515.95 483.41 932.82 -0.13 M 90.18 975.32 C 303.59 725.29 519.12 476.23 937.8 0.23 M 90.18 975.32 C 298.8 734.71 507.3 494.74 937.8 0.23 M 89.91 981.72 C 380.98 643.49 674.53 305.46 943.45 -0.16 M 89.91 981.72 C 386.76 633.91 686.15 289.32 943.45 -0.16 M 90.31 987.36 C 362.75 673.47 637.38 356.98 948.43 0.2 M 90.31 987.36 C 324.13 710.86 561.97 437.46 948.43 0.2 M 90.05 993.76 C 396.86 635.92 706.75 280.41 954.08 -0.19 M 90.05 993.76 C 294.46 758.96 497.64 525.9 954.08 -0.19 M 89.79 1000.16 C 325.36 732.24 555.98 466.33 959.06 0.17 M 89.79 1000.16 C 367.8 686.3 642.21 370.87 959.06 0.17 M 90.18 1005.8 C 272.24 798.83 452.82 590.74 964.71 -0.23 M 90.18 1005.8 C 335.32 723.78 577.96 445.18 964.71 -0.23 M 89.92 1012.2 C 276.37 796.87 459.67 585.75 969.69 0.13 M 89.92 1012.2 C 372.91 687.11 654.39 363.9 969.69 0.13 M 90.31 1017.84 C 350.62 720.21 612.18 418.89 975.34 -0.26 M 90.31 1017.84 C 328.66 743.27 566.9 469.23 975.34 -0.26 M 90.05 1024.24 C 441.6 617.31 795.2 209.88 980.33 0.1 M 90.05 1024.24 C 411.17 652.31 732.43 282.59 980.33 0.1 M 89.79 1030.64 C 327.57 753.06 567.26 477.09 985.97 -0.3 M 89.79 1030.64 C 284.19 810.02 478.66 586.02 985.97 -0.3 M 90.19 1036.28 C 285.19 811 478.98 590 990.96 0.06 M 90.19 1036.28 C 301.65 799.23 508.77 560.62 990.96 0.06 M 89.92 1042.68 C 271.12 831.69 451.62 621.79 996.6 -0.33 M 89.92 1042.68 C 400.73 685.39 711.45 327.27 996.6 -0.33 M 90.32 1048.32 C 435.44 648.41 780.86 250.98 1001.59 0.03 M 90.32 1048.32 C 304.23 804.19 514.83 562.34 1001.59 0.03 M 90.06 1054.72 C 271.24 838.88 456.96 624.41 1007.23 -0.37 M 90.06 1054.72 C 347.21 754.1 607.02 454.52 1007.23 -0.37 M 89.8 1061.11 C 408.79 694.14 725.01 329.3 1012.22 -0.01 M 89.8 1061.11 C 441.46 653.97 795.23 247.12 1012.22 -0.01 M 90.19 1066.76 C 291.19 836.85 493.28 605.23 1017.2 0.35 M 90.19 1066.76 C 363.05 758.91 633.56 447.9 1017.2 0.35 M 89.93 1073.16 C 364.98 757.34 640.63 440.07 1022.85 -0.04 M 89.93 1073.16 C 302.34 829.84 511.47 589.47 1022.85 -0.04 M 90.32 1078.8 C 301.35 835.04 513.67 591.22 1027.83 0.32 M 90.32 1078.8 C 313.6 825.45 535.36 571.11 1027.83 0.32 M 90.06 1085.2 C 420.32 701.43 754.69 316.3 1033.48 -0.08 M 90.06 1085.2 C 282.31 863.94 474.25 643.38 1033.48 -0.08 M 89.8 1091.59 C 313.34 830.8 543.14 568.27 1038.46 0.28 M 89.8 1091.59 C 284.19 869.52 475.64 648.5 1038.46 0.28 M 90.2 1097.24 C 448.38 683.01 807.71 270.1 1042.14 2.15 M 90.2 1097.24 C 368.38 776.47 644.05 459.45 1042.14 2.15 M 89.93 1103.63 C 387.88 766.8 682.94 426.12 1042.53 7.8 M 89.93 1103.63 C 368.34 786.84 642.67 471.36 1042.53 7.8 M 89.67 1110.03 C 424.05 724.55 761.48 338.02 1042.27 14.19 M 89.67 1110.03 C 432.06 715.23 779.05 316.21 1042.27 14.19 M 90.07 1115.68 C 393.7 770.87 693.99 425.87 1042.01 20.59 M 90.07 1115.68 C 293.17 884.93 493.64 655.01 1042.01 20.59 M 89.81 1122.07 C 288.26 890.12 486.22 661.06 1042.4 26.24 M 89.81 1122.07 C 305.59 876.23 520.92 628.61 1042.4 26.24 M 90.2 1127.72 C 445.78 721.34 802.03 310.76 1042.14 32.63 M 90.2 1127.72 C 371.08 799.18 656.27 471.66 1042.14 32.63 M 89.94 1134.11 C 282.94 912.1 473.41 693.55 1042.54 38.28 M 89.94 1134.11 C 458.21 705.93 828.54 280.37 1042.54 38.28 M 89.68 1140.51 C 315.92 880.47 540.96 620.43 1042.28 44.67 M 89.68 1140.51 C 380.85 809.56 669.12 478.24 1042.28 44.67 M 90.07 1146.16 C 400.58 797.03 706.03 445.16 1042.01 51.07 M 90.07 1146.16 C 356.6 838.65 625.24 530.57 1042.01 51.07 M 89.81 1152.55 C 363.07 835.05 639.48 519 1042.41 56.71 M 89.81 1152.55 C 452.9 733.1 816.52 315.22 1042.41 56.71 M 90.21 1158.2 C 376.79 830.73 661.76 502.42 1042.15 63.11 M 90.21 1158.2 C 324.88 880.09 563.45 606.02 1042.15 63.11 M 92.57 1161.58 C 425.28 780.26 757.62 396.6 1042.54 68.76 M 92.57 1161.58 C 394.85 820.78 694.02 477.21 1042.54 68.76 M 97.56 1161.94 C 470.4 733.08 846.15 302.05 1042.28 75.15 M 97.56 1161.94 C 432.88 773.37 769.1 385.93 1042.28 75.15 M 102.54 1162.3 C 355.71 867.11 613.5 570.52 1042.02 81.55 M 102.54 1162.3 C 383.21 838.88 661.63 518.37 1042.02 81.55 M 108.19 1161.9 C 303.56 934.11 499.91 706.78 1042.41 87.19 M 108.19 1161.9 C 455.5 757.55 806.02 354.42 1042.41 87.19 M 113.17 1162.26 C 439.89 791.93 764.85 417.82 1042.15 93.59 M 113.17 1162.26 C 419.99 803.43 730.73 445.97 1042.15 93.59 M 118.82 1161.87 C 363.8 871.67 612.7 585.74 1042.55 99.24 M 118.82 1161.87 C 483.63 740.44 851.55 316.78 1042.55 99.24 M 123.8 1162.23 C 398.27 848.89 672.77 531.6 1042.29 105.63 M 123.8 1162.23 C 361.73 891.8 594.87 622.91 1042.29 105.63 M 129.45 1161.83 C 351.7 907.19 570.88 655.95 1042.02 112.03 M 129.45 1161.83 C 347.21 914.62 561.17 667.85 1042.02 112.03 M 134.43 1162.19 C 387.51 867.12 643.02 573.63 1042.42 117.67 M 134.43 1162.19 C 407.55 853.06 677.72 542.42 1042.42 117.67 M 140.08 1161.8 C 431.59 829.68 720.66 497.65 1042.16 124.07 M 140.08 1161.8 C 327.87 948.57 514.86 734.22 1042.16 124.07 M 145.06 1162.16 C 398.77 869 655.06 573.5 1042.55 129.71 M 145.06 1162.16 C 427.23 833.98 712.53 505.89 1042.55 129.71 M 150.71 1161.76 C 367.53 913.4 586.29 661.73 1042.29 136.11 M 150.71 1161.76 C 468.3 797.73 783.75 434.86 1042.29 136.11 M 155.69 1162.12 C 457.5 821.69 757.2 475.98 1042.03 142.51 M 155.69 1162.12 C 499 767.49 844.08 370.6 1042.03 142.51 M 161.34 1161.73 C 406.09 873.23 654.32 587.46 1042.42 148.15 M 161.34 1161.73 C 368.29 930.01 570.71 696.55 1042.42 148.15 M 166.32 1162.09 C 426.09 860.34 688.37 557.26 1042.16 154.55 M 166.32 1162.09 C 515.41 759.01 863.18 358.4 1042.16 154.55 M 171.97 1161.69 C 372.31 929.8 577.14 696.66 1042.56 160.19 M 171.97 1161.69 C 437.51 854.16 704.72 547.18 1042.56 160.19 M 176.95 1162.05 C 407.77 895.87 637.22 632.31 1042.29 166.59 M 176.95 1162.05 C 389.45 915.66 603.11 669.78 1042.29 166.59 M 182.6 1161.66 C 387.28 924.36 591.73 690.84 1042.03 172.99 M 182.6 1161.66 C 497.52 796.96 813.68 433.19 1042.03 172.99 M 187.58 1162.02 C 499.33 799.8 810.8 440.04 1042.43 178.63 M 187.58 1162.02 C 402.5 908.84 620.69 657.87 1042.43 178.63 M 193.23 1161.62 C 498.71 807.04 807.76 451.48 1042.17 185.03 M 193.23 1161.62 C 463.61 856.06 731.57 547.29 1042.17 185.03 M 198.21 1161.98 C 504.57 811.24 808.19 460.31 1042.56 190.67 M 198.21 1161.98 C 496.2 817.9 797.92 471.3 1042.56 190.67 M 203.86 1161.59 C 386.02 948.46 568.81 737.58 1042.3 197.07 M 203.86 1161.59 C 512.63 805.52 820.87 450.54 1042.3 197.07 M 208.84 1161.95 C 418.55 920.48 627.37 680.93 1042.04 203.47 M 208.84 1161.95 C 460.16 870.23 711.56 581.03 1042.04 203.47 M 213.83 1162.31 C 495.34 835.71 778.08 509.58 1042.43 209.11 M 213.83 1162.31 C 423.24 918.62 635.67 674.24 1042.43 209.11 M 219.47 1161.92 C 435.08 910.84 654.59 659.27 1042.17 215.51 M 219.47 1161.92 C 427.34 919.13 637.85 677.08 1042.17 215.51 M 224.46 1162.28 C 391.33 969.29 560.42 774.37 1042.57 221.15 M 224.46 1162.28 C 409.9 947.25 597.67 731.47 1042.57 221.15 M 230.1 1161.88 C 451.38 908.67 674.52 651.77 1042.3 227.55 M 230.1 1161.88 C 557.75 791.54 881.49 418.57 1042.3 227.55 M 235.09 1162.24 C 416.87 956.55 598.13 748.01 1042.04 233.95 M 235.09 1162.24 C 440.47 928.58 643.7 694.96 1042.04 233.95 M 240.73 1161.85 C 543.28 815.03 844.95 465.93 1042.44 239.59 M 240.73 1161.85 C 503.83 859.94 767.3 557.2 1042.44 239.59 M 245.72 1162.21 C 517.03 852.48 785.24 543.07 1042.18 245.99 M 245.72 1162.21 C 406.69 979.93 566.96 795.63 1042.18 245.99 M 251.36 1161.81 C 492.32 882.38 736.69 602.28 1042.57 251.63 M 251.36 1161.81 C 458.64 926.37 661.98 692.43 1042.57 251.63 M 256.35 1162.17 C 430.77 959.34 605.32 759.53 1042.31 258.03 M 256.35 1162.17 C 474.62 914.23 691.32 664.95 1042.31 258.03 M 261.99 1161.78 C 446.45 948.32 633.01 733.38 1042.05 264.43 M 261.99 1161.78 C 430.3 970.68 596.25 779.49 1042.05 264.43 M 266.98 1162.14 C 495.08 906.63 719.2 648.2 1042.44 270.07 M 266.98 1162.14 C 566.17 820.15 863.49 478.27 1042.44 270.07 M 272.62 1161.74 C 561.73 828.65 849.04 499.29 1042.18 276.47 M 272.62 1161.74 C 453.15 950.58 637.14 739.77 1042.18 276.47 M 277.61 1162.1 C 501.52 910.76 721.33 656.43 1042.58 282.11 M 277.61 1162.1 C 548.31 854.48 818.06 544.57 1042.58 282.11 M 283.25 1161.71 C 544.91 858.22 809.72 554.75 1042.31 288.51 M 283.25 1161.71 C 583.58 815.67 882.89 471.11 1042.31 288.51 M 288.24 1162.07 C 515.19 906.26 740.08 648.23 1042.05 294.91 M 288.24 1162.07 C 531.75 880.42 774.96 600 1042.05 294.91 M 293.88 1161.67 C 469.26 960.76 646.25 757.19 1042.45 300.55 M 293.88 1161.67 C 557.39 856.3 823.11 550.96 1042.45 300.55 M 298.87 1162.03 C 548.32 879.24 795.3 594.62 1042.19 306.95 M 298.87 1162.03 C 559.18 857.11 822.39 554.59 1042.19 306.95 M 304.51 1161.64 C 561.91 865.52 817.62 571.71 1042.58 312.59 M 304.51 1161.64 C 459.02 986.19 613.65 807.97 1042.58 312.59 M 309.5 1162 C 561 871.03 812.61 582.54 1042.32 318.99 M 309.5 1162 C 471.68 974.76 632.66 789.94 1042.32 318.99 M 315.14 1161.61 C 474.22 980.71 632.97 797.37 1042.06 325.39 M 315.14 1161.61 C 508.79 939.21 702.77 716.22 1042.06 325.39 M 320.13 1161.97 C 470.31 988.19 625.51 810.41 1042.45 331.03 M 320.13 1161.97 C 467.75 987.51 617.26 816.32 1042.45 331.03 M 325.12 1162.33 C 488.49 973.67 652.91 783.69 1042.19 337.43 M 325.12 1162.33 C 503.04 960.35 679.92 757.34 1042.19 337.43 M 330.76 1161.93 C 583.95 870.19 839.43 575.19 1042.59 343.07 M 330.76 1161.93 C 559.11 899.46 788.37 636.34 1042.59 343.07 M 335.75 1162.29 C 611.62 847.26 886.84 529.63 1042.32 349.47 M 335.75 1162.29 C 536.4 932.94 737.57 701.66 1042.32 349.47 M 341.39 1161.9 C 576.85 890.44 810.93 620.98 1042.06 355.87 M 341.39 1161.9 C 542.2 934.1 740.27 705.53 1042.06 355.87 M 346.38 1162.26 C 588.82 888.2 828.94 611.42 1042.46 361.51 M 346.38 1162.26 C 578.34 893.76 813.23 622.79 1042.46 361.51 M 352.02 1161.86 C 509.96 980.82 668.88 799.21 1042.2 367.91 M 352.02 1161.86 C 575.65 899.29 801.52 638.62 1042.2 367.91 M 357.01 1162.22 C 613.83 867.4 869.19 573 1042.59 373.55 M 357.01 1162.22 C 612.23 870.15 867.21 576.54 1042.59 373.55 M 362.65 1161.83 C 538.06 961.21 714.07 758.23 1042.33 379.95 M 362.65 1161.83 C 506.03 997.66 646.77 835.7 1042.33 379.95 M 367.64 1162.19 C 624.61 861.05 885.41 562.06 1042.07 386.35 M 367.64 1162.19 C 617.42 875.23 868.61 585.92 1042.07 386.35 M 373.28 1161.79 C 632.5 869.86 887.43 575.56 1042.46 391.99 M 373.28 1161.79 C 635.86 863.88 894.99 565.31 1042.46 391.99 M 378.27 1162.15 C 598.29 910.25 819.43 655.88 1042.2 398.39 M 378.27 1162.15 C 604.27 903.91 828.98 645.74 1042.2 398.39 M 383.91 1161.76 C 576.37 941.21 767.78 721.7 1042.59 404.03 M 383.91 1161.76 C 551.95 969.24 718.35 778.07 1042.59 404.03 M 388.9 1162.12 C 647.56 864.49 907.28 566.23 1042.33 410.43 M 388.9 1162.12 C 572.74 949.49 760.09 733.94 1042.33 410.43 M 394.54 1161.72 C 526.67 1010.36 659.86 856.94 1042.07 416.83 M 394.54 1161.72 C 586.66 936.02 781.42 712.09 1042.07 416.83 M 399.53 1162.08 C 650.17 873.86 903.52 583.66 1042.47 422.47 M 399.53 1162.08 C 556.32 978.27 714.09 796.35 1042.47 422.47 M 405.17 1161.69 C 584.98 952.59 767.7 742.67 1042.21 428.87 M 405.17 1161.69 C 624.29 909.36 843.54 656.65 1042.21 428.87 M 410.16 1162.05 C 642.41 890.09 878.03 618.57 1042.6 434.51 M 410.16 1162.05 C 575.96 971.29 743.58 778.49 1042.6 434.51 M 415.8 1161.66 C 560.16 1000.72 701.28 837.75 1042.34 440.91 M 415.8 1161.66 C 613.23 938.18 809.17 711.71 1042.34 440.91 M 420.79 1162.02 C 557.69 1003.4 694.86 846.59 1042.08 447.31 M 420.79 1162.02 C 548.11 1015.3 676.29 867.9 1042.08 447.31 M 426.43 1161.62 C 584.71 983.94 740.52 804.38 1042.47 452.95 M 426.43 1161.62 C 582 979.57 738.49 799.5 1042.47 452.95 M 431.42 1161.98 C 591.19 982.3 749.91 799.69 1042.21 459.35 M 431.42 1161.98 C 643.11 918.75 854.47 675.68 1042.21 459.35 M 437.06 1161.59 C 634.75 932.98 834.53 703.2 1042.6 464.99 M 437.06 1161.59 C 636.42 934.62 834.27 706.66 1042.6 464.99 M 442.05 1161.95 C 587.19 996.35 730.46 831.32 1042.34 471.39 M 442.05 1161.95 C 672.05 902.01 900.07 639.63 1042.34 471.39 M 447.04 1162.31 C 654.91 919.31 864.3 679.42 1042.08 477.78 M 447.04 1162.31 C 572.47 1019.94 695.67 877.49 1042.08 477.78 M 452.68 1161.91 C 657.69 926.07 863.89 688.66 1042.48 483.43 M 452.68 1161.91 C 580.23 1013.56 706.74 867.97 1042.48 483.43 M 457.67 1162.27 C 663.12 926.59 866.23 691.1 1042.21 489.83 M 457.67 1162.27 C 625.43 966.22 793.46 771.56 1042.21 489.83 M 463.31 1161.88 C 588.42 1017.53 713.34 874.47 1042.61 495.47 M 463.31 1161.88 C 683.25 911.54 901.6 659.51 1042.61 495.47 M 468.3 1162.24 C 634.62 974.42 799.06 784.24 1042.35 501.87 M 468.3 1162.24 C 627.26 979.51 786.95 795.82 1042.35 501.87 M 473.94 1161.84 C 641.43 970.52 807.67 780.44 1042.09 508.26 M 473.94 1161.84 C 594.06 1025.88 712.13 889.78 1042.09 508.26 M 478.93 1162.2 C 627.9 988.92 777.99 816.95 1042.48 513.91 M 478.93 1162.2 C 705.2 902.91 929.21 644.69 1042.48 513.91 M 484.57 1161.81 C 633.82 988.7 785.59 814.5 1042.22 520.3 M 484.57 1161.81 C 632.09 995 778.61 826.93 1042.22 520.3 M 489.56 1162.17 C 663.33 958.49 838.59 757.23 1041.96 526.7 M 489.56 1162.17 C 704.25 916.38 918.73 669.93 1041.96 526.7 M 495.2 1161.77 C 647.19 986.45 799.74 811.35 1042.35 532.35 M 495.2 1161.77 C 668.28 963.52 839.07 766.47 1042.35 532.35 M 500.19 1162.13 C 615.1 1031.98 729.46 900.93 1042.09 538.74 M 500.19 1162.13 C 664.63 973.05 829.46 783.06 1042.09 538.74 M 505.83 1161.74 C 654.24 991.67 802.26 821.82 1042.49 544.39 M 505.83 1161.74 C 691.26 948.86 876.76 735.9 1042.49 544.39 M 510.82 1162.1 C 642.76 1010.99 775.34 858.57 1042.22 550.78 M 510.82 1162.1 C 678.7 968.55 845.37 776.3 1042.22 550.78 M 516.46 1161.7 C 651.33 1006.24 784.54 852.15 1041.96 557.18 M 516.46 1161.7 C 709.43 940.25 900.46 720.3 1041.96 557.18 M 521.45 1162.06 C 661.52 999.79 802.34 839.18 1042.36 562.83 M 521.45 1162.06 C 681.69 979.08 840.29 796.35 1042.36 562.83 M 527.09 1161.67 C 655.56 1017 784.35 869.92 1042.1 569.22 M 527.09 1161.67 C 728.06 932.59 927.2 703.31 1042.1 569.22 M 532.08 1162.03 C 655.84 1020.27 778.87 878.6 1042.49 574.87 M 532.08 1162.03 C 672.05 997.54 813.9 834.39 1042.49 574.87 M 537.72 1161.64 C 695.36 977.98 854.37 794.38 1042.23 581.26 M 537.72 1161.64 C 661.88 1016.31 786.99 872.42 1042.23 581.26 M 542.71 1162 C 679.02 1004.67 814.38 848.61 1041.97 587.66 M 542.71 1162 C 715.29 962.47 890.01 761.47 1041.97 587.66 M 548.35 1161.6 C 723.16 959.21 900.59 755.35 1042.36 593.3 M 548.35 1161.6 C 745.07 935.35 941.83 709.28 1042.36 593.3 M 553.34 1161.96 C 747.43 937.72 941.3 714.15 1042.1 599.7 M 553.34 1161.96 C 727.9 962.11 900.46 762.94 1042.1 599.7 M 558.32 1162.32 C 704.6 990.1 852.94 820.16 1042.5 605.35 M 558.32 1162.32 C 703.93 993.09 849.93 824.45 1042.5 605.35 M 563.97 1161.93 C 660.35 1050.48 757.33 939.58 1042.23 611.74 M 563.97 1161.93 C 677.02 1032.13 790.69 901.67 1042.23 611.74 M 568.95 1162.29 C 725.22 983.07 879.7 805.25 1041.97 618.14 M 568.95 1162.29 C 683.62 1030.85 797.87 898.85 1041.97 618.14 M 574.6 1161.89 C 754.66 956.46 934.41 749.32 1042.37 623.78 M 574.6 1161.89 C 698.91 1020.02 822.46 877.03 1042.37 623.78 M 579.58 1162.25 C 680.95 1044.44 783.91 924.55 1042.11 630.18 M 579.58 1162.25 C 725.44 995.53 869.67 828.93 1042.11 630.18 M 585.23 1161.86 C 764.75 955.78 943.92 750.4 1042.5 635.83 M 585.23 1161.86 C 685.77 1048.05 784.51 934.27 1042.5 635.83 M 590.21 1162.22 C 693.17 1045.18 795.53 927.69 1042.24 642.22 M 590.21 1162.22 C 693.9 1042.12 796.73 924.29 1042.24 642.22 M 595.86 1161.82 C 773.03 959.87 950.9 754.74 1041.98 648.62 M 595.86 1161.82 C 768.99 963.2 942.15 764.42 1041.98 648.62 M 600.84 1162.18 C 692.7 1055.82 783.62 948.7 1042.37 654.26 M 600.84 1162.18 C 741.52 1000.39 880.57 840.47 1042.37 654.26 M 606.49 1161.79 C 746.16 1002.16 886.08 842.77 1042.11 660.66 M 606.49 1161.79 C 774.72 968.59 944.02 775.1 1042.11 660.66 M 611.47 1162.15 C 729.73 1026.54 847.17 892.34 1042.51 666.3 M 611.47 1162.15 C 747.61 1005.5 884.25 847.63 1042.51 666.3 M 617.12 1161.75 C 702.18 1063.21 787.68 964.16 1042.24 672.7 M 617.12 1161.75 C 762.38 993.59 907.59 826.05 1042.24 672.7 M 622.1 1162.11 C 771.45 988.29 922.26 814.38 1041.98 679.1 M 622.1 1162.11 C 790.25 971.4 956.1 780.34 1041.98 679.1 M 627.75 1161.72 C 720.38 1053.7 813.16 946.95 1042.38 684.74 M 627.75 1161.72 C 749.46 1020.08 871.86 878.53 1042.38 684.74 M 632.73 1162.08 C 728.62 1050.23 826.43 938.23 1042.12 691.14 M 632.73 1162.08 C 764.19 1008.7 896.41 855.91 1042.12 691.14 M 638.38 1161.69 C 762.29 1021.68 884.92 879.97 1042.51 696.78 M 638.38 1161.69 C 722.1 1067.05 804.99 970.94 1042.51 696.78 M 643.36 1162.05 C 769.47 1014.32 897.46 869.91 1042.25 703.18 M 643.36 1162.05 C 758.91 1027.54 875.26 893.89 1042.25 703.18 M 649.01 1161.65 C 761.78 1033.5 874.43 903.38 1041.99 709.58 M 649.01 1161.65 C 784.48 1005.05 919.4 849.77 1041.99 709.58 M 653.99 1162.01 C 748.14 1053.76 842.41 947.43 1042.38 715.22 M 653.99 1162.01 C 774.08 1025.83 893.1 888.55 1042.38 715.22 M 659.64 1161.62 C 797.92 1004.16 934.1 846.73 1042.12 721.62 M 659.64 1161.62 C 773.9 1030.07 888.04 898.14 1042.12 721.62 M 664.62 1161.98 C 771.64 1040.23 878.34 918.15 1042.51 727.26 M 664.62 1161.98 C 812.32 991.07 959.37 821.63 1042.51 727.26 M 670.27 1161.58 C 759.85 1061.09 847.29 960.08 1042.25 733.66 M 670.27 1161.58 C 809.53 999.9 950.05 838.9 1042.25 733.66 M 675.25 1161.94 C 804.21 1013.41 932.61 864.79 1041.99 740.06 M 675.25 1161.94 C 812.96 1003.72 951.74 843.51 1041.99 740.06 M 680.24 1162.3 C 814.77 1007.17 950.71 851.82 1042.39 745.7 M 680.24 1162.3 C 825.88 994.73 970.41 828.57 1042.39 745.7 M 685.89 1161.91 C 826.79 1001.17 966.8 839.83 1042.13 752.1 M 685.89 1161.91 C 800.48 1028.38 916.38 895.83 1042.13 752.1 M 690.87 1162.27 C 817.32 1017.55 942.59 874.05 1042.52 757.74 M 690.87 1162.27 C 796.25 1040.88 901.4 920.62 1042.52 757.74 M 696.52 1161.87 C 831.8 1005.07 966.76 849.79 1042.26 764.14 M 696.52 1161.87 C 799.93 1042.86 902.8 923.92 1042.26 764.14 M 701.5 1162.23 C 808.86 1041.69 913.26 919.29 1042 770.54 M 701.5 1162.23 C 811.89 1035.18 922.98 906.98 1042 770.54 M 707.15 1161.84 C 825.91 1026.27 944.4 891.89 1042.39 776.18 M 707.15 1161.84 C 835.04 1014.49 963.79 866.42 1042.39 776.18 M 712.13 1162.2 C 806.14 1054.28 899.77 945.96 1042.13 782.58 M 712.13 1162.2 C 794.59 1064.98 878.19 968.77 1042.13 782.58 M 717.78 1161.8 C 824.79 1039.39 930.42 917.41 1042.52 788.22 M 717.78 1161.8 C 807.52 1056.22 898.97 950.86 1042.52 788.22 M 722.76 1162.16 C 810.54 1061.36 897.37 961.04 1042.26 794.62 M 722.76 1162.16 C 837.18 1030.04 952.32 898.17 1042.26 794.62 M 728.41 1161.77 C 853.91 1017.65 977.81 873.57 1042 801.02 M 728.41 1161.77 C 821.73 1052.08 917.72 942.67 1042 801.02 M 733.39 1162.13 C 856.58 1022.32 979.04 880.28 1042.4 806.66 M 733.39 1162.13 C 806.95 1076.65 881.48 991.03 1042.4 806.66 M 739.04 1161.73 C 823.37 1063.81 908.34 965.67 1042.13 813.06 M 739.04 1161.73 C 855.14 1028.01 971.62 893.54 1042.13 813.06 M 744.02 1162.1 C 836.63 1052.38 932.35 944.01 1042.53 818.7 M 744.02 1162.1 C 808.86 1087.81 872.82 1014.34 1042.53 818.7 M 749.67 1161.7 C 845.02 1051.31 941.46 940.45 1042.27 825.1 M 749.67 1161.7 C 829.63 1072.28 908.31 980.57 1042.27 825.1 M 754.65 1162.06 C 819.22 1087.84 884.46 1013.94 1042.01 831.5 M 754.65 1162.06 C 845.98 1060.31 935.28 956.97 1042.01 831.5 M 760.3 1161.67 C 851.89 1056.14 942.5 950.04 1042.4 837.14 M 760.3 1161.67 C 852.84 1058.34 943.48 953.63 1042.4 837.14 M 765.28 1162.03 C 835.16 1081.69 903.47 1000.59 1042.14 843.54 M 765.28 1162.03 C 842 1076.12 918.36 988.8 1042.14 843.54 M 770.93 1161.63 C 850.4 1072.96 927.83 982.92 1042.53 849.18 M 770.93 1161.63 C 856.04 1063.01 943.03 963.52 1042.53 849.18 M 775.91 1161.99 C 844.27 1083.03 913.44 1004.22 1042.27 855.58 M 775.91 1161.99 C 873.87 1049.36 970.83 937.66 1042.27 855.58 M 781.56 1161.6 C 853.76 1080.68 925.86 999.57 1042.01 861.98 M 781.56 1161.6 C 846.39 1085.31 912.47 1009.35 1042.01 861.98 M 786.54 1161.96 C 848.9 1092.47 909.53 1022.85 1042.41 867.62 M 786.54 1161.96 C 877.44 1057.74 968.12 952.49 1042.41 867.62 M 791.53 1162.32 C 884.47 1054.38 977.75 947.06 1042.14 874.02 M 791.53 1162.32 C 876.73 1063.75 960.69 967.07 1042.14 874.02 M 797.17 1161.92 C 876.74 1069.08 957.42 977.91 1042.54 879.66 M 797.17 1161.92 C 881.09 1063.17 965.85 966.09 1042.54 879.66 M 802.16 1162.28 C 875.07 1079.19 947.72 994.73 1042.28 886.06 M 802.16 1162.28 C 897.38 1053.83 992.81 945.31 1042.28 886.06 M 807.8 1161.89 C 897.43 1061.15 986.1 957.19 1042.02 892.46 M 807.8 1161.89 C 885.05 1070.9 964.69 980.28 1042.02 892.46 M 812.79 1162.25 C 865 1102.24 915.56 1044.27 1042.41 898.1 M 812.79 1162.25 C 873.46 1093 932.26 1024.34 1042.41 898.1 M 818.43 1161.85 C 866.94 1108.25 911.02 1055.68 1042.15 904.5 M 818.43 1161.85 C 875.78 1097.14 932.07 1030.85 1042.15 904.5 M 823.42 1162.21 C 894.89 1079.54 966.8 996.28 1042.54 910.14 M 823.42 1162.21 C 910.53 1059.56 998.87 959.49 1042.54 910.14 M 829.06 1161.82 C 902.36 1079.57 972.27 997.38 1042.28 916.54 M 829.06 1161.82 C 902.55 1077.78 975.34 995.11 1042.28 916.54 M 834.05 1162.18 C 882.45 1105.14 934.13 1048.9 1042.02 922.94 M 834.05 1162.18 C 892.69 1097.27 950.11 1030.57 1042.02 922.94 M 839.69 1161.78 C 889 1105.22 935.96 1050.31 1042.42 928.58 M 839.69 1161.78 C 908.69 1079.85 977.98 999.59 1042.42 928.58 M 844.68 1162.14 C 887.57 1111.2 929.64 1063.23 1042.15 934.98 M 844.68 1162.14 C 919.65 1076.4 995.58 988.43 1042.15 934.98 M 850.32 1161.75 C 910.06 1093.46 969.18 1024.34 1042.55 940.62 M 850.32 1161.75 C 914.46 1086.18 978.77 1012.65 1042.55 940.62 M 855.31 1162.11 C 920.54 1083.29 989.1 1003.65 1042.29 947.02 M 855.31 1162.11 C 896.05 1114.87 938.34 1067.32 1042.29 947.02 M 860.95 1161.72 C 915.11 1101.04 968.79 1038.01 1042.03 953.42 M 860.95 1161.72 C 917 1098.66 972.96 1033.49 1042.03 953.42 M 865.94 1162.08 C 901.5 1121.7 935.61 1082.02 1042.42 959.06 M 865.94 1162.08 C 922.11 1098.75 976.46 1036.87 1042.42 959.06 M 871.58 1161.68 C 918.31 1110.01 960.48 1057.52 1042.16 965.46 M 871.58 1161.68 C 931.36 1091.3 992.39 1022.1 1042.16 965.46 M 876.57 1162.04 C 925.18 1105.22 974.93 1048.77 1042.55 971.1 M 876.57 1162.04 C 940.59 1089.84 1003.94 1017.89 1042.55 971.1 M 882.21 1161.65 C 917.71 1122.1 950.7 1080.35 1042.29 977.5 M 882.21 1161.65 C 931.47 1105.35 977.9 1050.73 1042.29 977.5 M 887.2 1162.01 C 923.34 1119.86 958.5 1078.8 1042.03 983.9 M 887.2 1162.01 C 945.49 1092.37 1006.73 1023.24 1042.03 983.9 M 892.84 1161.61 C 939.18 1110.61 986.26 1057.21 1042.43 989.54 M 892.84 1161.61 C 933.23 1115.03 973.25 1069.75 1042.43 989.54 M 897.83 1161.97 C 935.14 1118.64 975.74 1073.66 1042.16 995.94 M 897.83 1161.97 C 939.76 1113.38 980.47 1065.21 1042.16 995.94 M 903.47 1161.58 C 955.51 1099.97 1012.67 1037.68 1042.56 1001.58 M 903.47 1161.58 C 946.76 1111.12 990.04 1060.25 1042.56 1001.58 M 908.46 1161.94 C 942.94 1124.23 974.64 1084.37 1042.3 1007.98 M 908.46 1161.94 C 944.7 1118.9 981.47 1076.98 1042.3 1007.98 M 913.45 1162.3 C 948.61 1119.75 986.11 1078.45 1042.04 1014.37 M 913.45 1162.3 C 965.19 1102.17 1015.77 1043.69 1042.04 1014.37 M 919.09 1161.9 C 954.15 1120.75 988.78 1078.47 1042.43 1020.02 M 919.09 1161.9 C 961.05 1113.89 1002.54 1066.03 1042.43 1020.02 M 924.08 1162.26 C 964.62 1119.38 1003.44 1071.66 1042.17 1026.42 M 924.08 1162.26 C 970.87 1106.4 1018.07 1053.14 1042.17 1026.42 M 929.72 1161.87 C 966.24 1123.92 999.77 1079.7 1042.56 1032.06 M 929.72 1161.87 C 960.88 1123.69 993.2 1086.74 1042.56 1032.06 M 934.71 1162.23 C 956.95 1135.18 981.97 1105.57 1042.3 1038.46 M 934.71 1162.23 C 969.63 1123.07 1002.49 1082.95 1042.3 1038.46 M 940.35 1161.83 C 970.17 1127.78 1001.46 1092.77 1042.04 1044.85 M 940.35 1161.83 C 978.7 1120.37 1014.75 1077.69 1042.04 1044.85 M 945.34 1162.19 C 980.85 1124.41 1015.35 1085.72 1042.43 1050.5 M 945.34 1162.19 C 970.69 1132.79 996.42 1104.76 1042.43 1050.5 M 950.98 1161.8 C 971.66 1134.37 993.81 1110.68 1042.17 1056.9 M 950.98 1161.8 C 987.18 1121.44 1021.43 1080.71 1042.17 1056.9 M 955.97 1162.16 C 976.27 1137.63 999.67 1111.12 1042.57 1062.54 M 955.97 1162.16 C 978.19 1136.9 999.22 1111.75 1042.57 1062.54 M 961.61 1161.77 C 991.76 1127.51 1024.18 1089.43 1042.31 1068.94 M 961.61 1161.77 C 981.47 1139.51 1000.25 1117.32 1042.31 1068.94 M 966.6 1162.13 C 985.34 1142.54 1005.96 1117.87 1042.05 1075.33 M 966.6 1162.13 C 985.16 1142.39 1002.43 1120.54 1042.05 1075.33 M 972.24 1161.73 C 984.71 1146.14 999.56 1127.16 1042.44 1080.98 M 972.24 1161.73 C 999.98 1129.46 1025.86 1099.6 1042.44 1080.98 M 977.23 1162.09 C 997.08 1137.86 1017.38 1116.18 1042.18 1087.37 M 977.23 1162.09 C 994.25 1141.33 1012.68 1121.85 1042.18 1087.37 M 982.87 1161.7 C 995.48 1147.94 1007.58 1134.33 1042.57 1093.02 M 982.87 1161.7 C 1001.82 1140.48 1021.83 1119.49 1042.57 1093.02 M 987.86 1162.06 C 999.6 1148.91 1010.63 1134.76 1042.31 1099.42 M 987.86 1162.06 C 1005.56 1142.02 1023.57 1120.21 1042.31 1099.42 M 993.5 1161.66 C 1010.11 1144.3 1025.59 1125.83 1042.05 1105.81 M 993.5 1161.66 C 1008.98 1142.61 1024.94 1124.21 1042.05 1105.81 M 998.49 1162.02 C 1010.47 1149.37 1020.06 1137.37 1042.44 1111.46 M 998.49 1162.02 C 1011.11 1146.03 1025.16 1131.24 1042.44 1111.46 M 1004.13 1161.63 C 1019.18 1146.23 1030.19 1129.99 1042.18 1117.85 M 1004.13 1161.63 C 1018.77 1144.81 1033.23 1128.11 1042.18 1117.85 M 1009.12 1161.99 C 1016.42 1154.08 1023.68 1146.54 1042.58 1123.5 M 1009.12 1161.99 C 1016.64 1154.64 1022.78 1147.46 1042.58 1123.5 M 1014.76 1161.59 C 1023.14 1152 1029.25 1142.62 1042.32 1129.9 M 1014.76 1161.59 C 1024.21 1151.02 1034.54 1137.89 1042.32 1129.9 M 1019.75 1161.95 C 1026.3 1156.56 1030.77 1148.05 1042.05 1136.29 M 1019.75 1161.95 C 1026.17 1154.02 1033.9 1145.38 1042.05 1136.29 M 1024.74 1162.31 C 1031.54 1156.83 1037.72 1145.97 1042.45 1141.94 M 1024.74 1162.31 C 1028.87 1157.3 1033.57 1151.58 1042.45 1141.94 M 1030.38 1161.92 C 1032.62 1158.1 1038.74 1155.91 1042.19 1148.33 M 1030.38 1161.92 C 1033.67 1156.64 1037.58 1153.23 1042.19 1148.33 M 1035.37 1162.28 C 1038.26 1159.41 1039.08 1156.89 1042.58 1153.98 M 1035.37 1162.28 C 1036.93 1160.96 1039.03 1158.65 1042.58 1153.98" fill="none" stroke="#e4d7eb" stroke-width="0.5" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 90 0 C 454.01 -0.92 818.73 -1.07 1040 0 M 90 0 C 455.6 1.4 820.17 1.34 1040 0 M 1040 0 C 1039.52 372.14 1040.34 744.2 1040 1160 M 1040 0 C 1037.9 297.59 1038.07 594.5 1040 1160 M 1040 1160 C 741.3 1160.9 441.95 1160.07 90 1160 M 1040 1160 C 718.3 1163.46 396.25 1163.82 90 1160 M 90 1160 C 90.1 751.91 89.23 342.69 90 0 M 90 1160 C 87.46 847.08 86.87 534.81 90 0" fill="none" stroke="rgb(0, 0, 0)" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><rect x="160" y="450" width="410" height="470" fill="none" stroke="none" pointer-events="all"/><path d="M 159.82 450.21 C 159.82 450.21 159.82 450.21 159.82 450.21 M 159.82 450.21 C 159.82 450.21 159.82 450.21 159.82 450.21 M 160.22 455.85 C 162.48 453.06 164.27 451.28 165.46 449.81 M 160.22 455.85 C 161.85 453.91 163.44 452.82 165.46 449.81 M 159.95 462.25 C 162.14 460.22 164.89 456.23 170.45 450.17 M 159.95 462.25 C 163.99 458.93 166.03 454.61 170.45 450.17 M 159.69 468.64 C 162.74 464.95 166.38 458.26 176.09 449.78 M 159.69 468.64 C 163.63 464.65 168.22 460.03 176.09 449.78 M 160.09 474.29 C 166.06 464.76 175.11 458.31 181.08 450.14 M 160.09 474.29 C 164.95 468.44 172.17 460.01 181.08 450.14 M 159.83 480.68 C 166.28 473.3 172.58 465.44 186.72 449.74 M 159.83 480.68 C 170 468.61 180.28 458.31 186.72 449.74 M 160.22 486.33 C 167.11 475.78 177.66 469.78 191.71 450.1 M 160.22 486.33 C 166.48 478.99 173.6 471.42 191.71 450.1 M 159.96 492.73 C 168.27 481.01 175.6 471.27 197.36 449.71 M 159.96 492.73 C 169.36 481.5 178.15 471.43 197.36 449.71 M 159.7 499.12 C 178.4 479.14 192.35 460.58 202.34 450.07 M 159.7 499.12 C 174.33 482.16 188.47 465.8 202.34 450.07 M 160.09 504.77 C 171.97 492.68 182.3 481.65 207.99 449.67 M 160.09 504.77 C 177.13 486.58 193.39 466.09 207.99 449.67 M 159.83 511.16 C 178.59 487.07 201.89 465.71 212.97 450.03 M 159.83 511.16 C 174.51 495.52 188.08 477.5 212.97 450.03 M 160.23 516.81 C 180.48 493.84 198.07 471.5 218.62 449.64 M 160.23 516.81 C 174.9 498.79 190.44 480.4 218.62 449.64 M 159.96 523.2 C 181.11 498.28 198.93 477.09 223.6 450 M 159.96 523.2 C 182.19 495.68 205.81 469.85 223.6 450 M 159.7 529.6 C 180.72 501.84 204.48 478.07 228.59 450.36 M 159.7 529.6 C 180.29 507.93 198.41 484.19 228.59 450.36 M 160.1 535.25 C 181.52 509.04 206.11 483.57 234.23 449.96 M 160.1 535.25 C 184.29 506.15 209.14 477.83 234.23 449.96 M 159.84 541.64 C 185.4 508.2 214.74 480.04 239.22 450.32 M 159.84 541.64 C 180.15 518.51 202.03 494.91 239.22 450.32 M 160.23 547.29 C 178.4 526.31 196.03 508.77 244.86 449.93 M 160.23 547.29 C 187.06 516.94 214.74 485.56 244.86 449.93 M 159.97 553.68 C 193.16 513.66 227.47 475.02 249.85 450.29 M 159.97 553.68 C 189.15 518.28 218.68 483.7 249.85 450.29 M 159.71 560.08 C 180.6 537.74 201.77 514.13 255.49 449.89 M 159.71 560.08 C 193.91 518.95 229.03 477.74 255.49 449.89 M 160.1 565.73 C 195.57 526.93 232.11 483.41 260.48 450.25 M 160.1 565.73 C 198.31 520.46 238.87 475.01 260.48 450.25 M 159.84 572.12 C 189.22 538.02 217.57 506.49 266.12 449.86 M 159.84 572.12 C 197.64 528.73 234.76 486.48 266.12 449.86 M 160.24 577.77 C 192.75 538.65 225.29 504.39 271.11 450.22 M 160.24 577.77 C 184.57 552.36 206.86 526.39 271.11 450.22 M 159.97 584.16 C 195.48 540.09 232.82 498.28 276.75 449.83 M 159.97 584.16 C 190.39 548.2 219.71 514.1 276.75 449.83 M 159.71 590.56 C 200.89 547.75 237.5 500.79 281.74 450.19 M 159.71 590.56 C 199.74 544.15 238.25 501.15 281.74 450.19 M 160.11 596.2 C 208.6 540.9 260.39 482.79 287.38 449.79 M 160.11 596.2 C 198.57 555.16 235.88 512.76 287.38 449.79 M 159.85 602.6 C 195.45 564.46 225.95 525.68 292.37 450.15 M 159.85 602.6 C 203.93 551.95 246.91 499.95 292.37 450.15 M 160.24 608.25 C 204.96 555.17 250.2 501.28 298.01 449.76 M 160.24 608.25 C 216.07 547.26 269.63 484.25 298.01 449.76 M 159.98 614.64 C 194.19 573.2 230.94 533.21 303 450.12 M 159.98 614.64 C 191.51 577.22 223.93 541.06 303 450.12 M 159.72 621.04 C 203.36 570.91 248.17 519.86 308.64 449.72 M 159.72 621.04 C 204.96 567.76 252.28 514.67 308.64 449.72 M 160.11 626.68 C 211.26 569.47 259.24 512.65 313.63 450.08 M 160.11 626.68 C 196.9 584.03 235.97 538.25 313.63 450.08 M 159.85 633.08 C 199.37 587.28 235.72 546.27 319.27 449.69 M 159.85 633.08 C 209.83 574.24 260.77 516.31 319.27 449.69 M 160.25 638.73 C 203.6 591.95 244.22 542.8 324.26 450.05 M 160.25 638.73 C 199.33 594.37 236.85 551.1 324.26 450.05 M 159.98 645.12 C 196.23 601.07 234.84 561.07 329.9 449.65 M 159.98 645.12 C 211.34 584.99 263.27 525.42 329.9 449.65 M 159.72 651.52 C 206.98 598.25 249.88 548.17 334.89 450.01 M 159.72 651.52 C 203.47 601.33 247.51 550.54 334.89 450.01 M 160.12 657.16 C 212.38 595.6 268.17 532.53 339.88 450.37 M 160.12 657.16 C 211.15 598.12 262.63 539.96 339.88 450.37 M 159.86 663.56 C 218.45 594.37 277.32 528.22 345.52 449.98 M 159.86 663.56 C 229.97 585.77 298.36 505.68 345.52 449.98 M 160.25 669.2 C 206.07 616.03 254.4 561.62 350.51 450.34 M 160.25 669.2 C 215.29 603.88 271.44 539.21 350.51 450.34 M 159.99 675.6 C 209.85 617 260.23 557.09 356.15 449.94 M 159.99 675.6 C 223.31 603.71 287 531.09 356.15 449.94 M 159.73 682 C 208.66 624.24 258.73 566.17 361.14 450.3 M 159.73 682 C 217.89 615.42 274.31 550 361.14 450.3 M 160.12 687.64 C 218.63 620.93 275.7 554.18 366.78 449.91 M 160.12 687.64 C 202.16 637.57 246.04 588.05 366.78 449.91 M 159.86 694.04 C 235.75 607.44 310.79 520.22 371.77 450.27 M 159.86 694.04 C 208.35 639.97 256.27 584.54 371.77 450.27 M 160.25 699.68 C 208.36 644.47 255.9 588.57 377.41 449.88 M 160.25 699.68 C 245.08 600.98 331.49 502.24 377.41 449.88 M 159.99 706.08 C 223.6 635 284.6 563.02 382.4 450.24 M 159.99 706.08 C 207.26 650.18 255.81 594.38 382.4 450.24 M 159.73 712.48 C 222.38 639.55 286.4 566.74 388.04 449.84 M 159.73 712.48 C 210.92 650.01 264.07 590.04 388.04 449.84 M 160.13 718.12 C 252.22 611.84 344.76 505.39 393.03 450.2 M 160.13 718.12 C 244.94 621.16 330.14 523.2 393.03 450.2 M 159.87 724.52 C 232.77 641.14 306.49 556.45 398.67 449.81 M 159.87 724.52 C 238.76 635.39 315.47 546.56 398.67 449.81 M 160.26 730.16 C 231.89 647.49 305.64 562 403.66 450.17 M 160.26 730.16 C 238.13 641.28 313.96 553.87 403.66 450.17 M 160 736.56 C 239.23 647.68 317.84 557.18 409.3 449.77 M 160 736.56 C 224.24 664.45 287.98 590.5 409.3 449.77 M 159.74 742.96 C 231.84 658.15 304.78 575.86 414.29 450.13 M 159.74 742.96 C 240.3 651.52 318.66 560.43 414.29 450.13 M 160.13 748.6 C 252.57 643.46 346.85 535.69 419.93 449.74 M 160.13 748.6 C 231.49 662.82 305.21 579.69 419.93 449.74 M 159.87 755 C 225.41 678.48 292.98 600.97 424.92 450.1 M 159.87 755 C 247.75 652.24 337.24 549.46 424.92 450.1 M 160.26 760.64 C 231.31 678.29 301.15 598.03 430.56 449.7 M 160.26 760.64 C 218.74 691.08 278.6 622.24 430.56 449.7 M 160 767.04 C 219.01 701.7 276.52 633.53 435.55 450.06 M 160 767.04 C 264.69 646.77 369.22 526.48 435.55 450.06 M 159.74 773.44 C 240.17 679.56 320.96 585.84 441.19 449.67 M 159.74 773.44 C 261.11 654.6 365.1 536.28 441.19 449.67 M 160.14 779.08 C 267.17 657.25 372.29 534.08 446.18 450.03 M 160.14 779.08 C 262.79 659.35 366.58 539.88 446.18 450.03 M 159.87 785.48 C 241.26 694.66 319.85 604.54 451.82 449.63 M 159.87 785.48 C 272.54 656.23 385.58 527.01 451.82 449.63 M 160.27 791.12 C 236.98 703.76 311.49 617.86 456.81 449.99 M 160.27 791.12 C 225.45 716.37 290.24 641.51 456.81 449.99 M 160.01 797.52 C 244.77 700.37 331.13 600.66 461.8 450.35 M 160.01 797.52 C 223.82 724.38 287.92 651.3 461.8 450.35 M 159.75 803.92 C 272.48 671.07 388.13 540.19 467.44 449.96 M 159.75 803.92 C 221.49 730.83 283.75 659.16 467.44 449.96 M 160.14 809.56 C 277.36 675.09 393.67 542.66 472.43 450.32 M 160.14 809.56 C 266.1 687.69 372.7 564.47 472.43 450.32 M 159.88 815.96 C 272.9 686.18 386.29 556.92 478.07 449.92 M 159.88 815.96 C 286.22 670.88 411.71 526.29 478.07 449.92 M 160.27 821.6 C 232.45 740.91 302.19 659.3 483.06 450.29 M 160.27 821.6 C 276.25 688.72 392.25 555.35 483.06 450.29 M 160.01 828 C 235.62 741.31 312.68 654.06 488.7 449.89 M 160.01 828 C 286.34 679.69 414.38 532.22 488.7 449.89 M 159.75 834.4 C 247.41 731.73 335.61 629.06 493.69 450.25 M 159.75 834.4 C 226.34 755.88 293.96 677.52 493.69 450.25 M 160.15 840.04 C 274.28 708.85 389.07 578.02 499.33 449.86 M 160.15 840.04 C 228.37 760.71 297.62 680.87 499.33 449.86 M 159.88 846.44 C 235.19 760.98 311.32 673.95 504.32 450.22 M 159.88 846.44 C 260.62 731.01 360.95 615.7 504.32 450.22 M 160.28 852.08 C 231.22 766.79 304.59 683.29 509.96 449.82 M 160.28 852.08 C 292.57 701.05 424.71 548.81 509.96 449.82 M 160.02 858.48 C 277.61 721.9 395.07 587.32 514.95 450.18 M 160.02 858.48 C 234.16 774.94 307.74 690.43 514.95 450.18 M 159.76 864.88 C 264.12 743.4 370.15 622.32 520.59 449.79 M 159.76 864.88 C 256.74 752.9 352.92 641.65 520.59 449.79 M 160.15 870.52 C 274.11 739.39 387.45 610.06 525.58 450.15 M 160.15 870.52 C 237.26 783.73 313.19 696.63 525.58 450.15 M 159.89 876.92 C 248.77 775.77 337.52 673.52 531.22 449.75 M 159.89 876.92 C 290.11 727.87 420.59 577.29 531.22 449.75 M 160.28 882.56 C 240.48 788.25 322.91 694.02 536.21 450.11 M 160.28 882.56 C 278.84 746.71 398.56 609.3 536.21 450.11 M 160.02 888.96 C 313.03 711.8 464.82 536.77 541.85 449.72 M 160.02 888.96 C 286.47 744.68 411.63 600.49 541.85 449.72 M 159.76 895.36 C 306.02 727.99 451.98 559.64 546.84 450.08 M 159.76 895.36 C 251.58 792.94 341.33 688.83 546.84 450.08 M 160.16 901 C 290.91 750.33 421.78 602.16 552.48 449.68 M 160.16 901 C 247.18 803.08 332.11 705.57 552.48 449.68 M 159.89 907.4 C 262.35 789.39 364.08 672.12 557.47 450.04 M 159.89 907.4 C 248.6 805.25 336.75 703.24 557.47 450.04 M 160.29 913.04 C 279.02 776.55 399.28 638.1 563.11 449.65 M 160.29 913.04 C 264.38 792.32 367.8 673.92 563.11 449.65 M 160.03 919.44 C 319.31 739.85 475.11 558.84 568.1 450.01 M 160.03 919.44 C 249.09 814.97 338.91 712.33 568.1 450.01 M 163.05 922.06 C 313.91 748.03 464.3 575.86 571.77 451.88 M 163.05 922.06 C 246.67 823.19 331.16 725.87 571.77 451.88 M 168.03 922.42 C 265.62 806.51 365.17 692.58 572.17 457.52 M 168.03 922.42 C 304.73 767.45 439.75 611.73 572.17 457.52 M 173.68 922.03 C 297.91 778.35 422.53 637.29 571.9 463.92 M 173.68 922.03 C 274.1 809.25 372.62 695.58 571.9 463.92 M 178.66 922.39 C 327.4 752.6 474.83 583.11 571.64 470.32 M 178.66 922.39 C 313.02 767.22 447.26 612.08 571.64 470.32 M 183.65 922.75 C 301.46 787.14 421.16 649.08 572.04 475.96 M 183.65 922.75 C 293.22 799.52 401.42 674.8 572.04 475.96 M 189.29 922.35 C 291.33 806.35 391.98 689.41 571.78 482.36 M 189.29 922.35 C 338.94 750.36 489.39 577.01 571.78 482.36 M 194.28 922.71 C 282.28 820.31 369.93 718.85 572.17 488 M 194.28 922.71 C 277.4 825.58 360.87 729.54 572.17 488 M 199.92 922.32 C 296.75 812 393.18 701.52 571.91 494.4 M 199.92 922.32 C 313.35 793.07 426.73 663.23 571.91 494.4 M 204.91 922.68 C 343.71 763 484.15 602.35 571.65 500.8 M 204.91 922.68 C 321.92 789.88 436.94 657.7 571.65 500.8 M 210.55 922.28 C 305.93 811.56 400.54 703.01 572.04 506.44 M 210.55 922.28 C 304.78 813.98 400.33 704.23 572.04 506.44 M 215.54 922.64 C 336.46 783.6 456.92 645.58 571.78 512.84 M 215.54 922.64 C 294.71 831.73 373.55 741.3 571.78 512.84 M 221.18 922.25 C 302.28 828.5 383.46 735.63 572.18 518.48 M 221.18 922.25 C 338 791.01 453.38 658.07 572.18 518.48 M 226.17 922.61 C 331.38 804.01 434.93 683.87 571.91 524.88 M 226.17 922.61 C 337.05 793.93 447.87 666.4 571.91 524.88 M 231.81 922.22 C 322.22 816.48 415.1 709.19 571.65 531.28 M 231.81 922.22 C 342.82 792.57 455.89 662.92 571.65 531.28 M 236.8 922.58 C 359.31 781.38 482.82 639.06 572.05 536.92 M 236.8 922.58 C 310.03 838.98 382.2 755.13 572.05 536.92 M 242.44 922.18 C 357.43 788.97 474.56 656.87 571.79 543.32 M 242.44 922.18 C 364.89 782.59 486.04 643.11 571.79 543.32 M 247.43 922.54 C 326.88 830.69 408.05 738.91 572.18 548.96 M 247.43 922.54 C 323.18 835.84 397.31 749.95 572.18 548.96 M 253.07 922.15 C 376.93 778.69 501.3 635.73 571.92 555.36 M 253.07 922.15 C 352.73 807.93 451.85 693.93 571.92 555.36 M 258.06 922.51 C 366.26 798.28 475.17 672.54 571.66 561.76 M 258.06 922.51 C 353.55 811.7 448.74 701.96 571.66 561.76 M 263.7 922.11 C 375.97 792.87 487.34 665.57 572.05 567.4 M 263.7 922.11 C 355.19 817.26 446.82 711.44 572.05 567.4 M 268.69 922.47 C 355.67 823.36 441.26 724.07 571.79 573.8 M 268.69 922.47 C 361.08 818.47 452.27 713.6 571.79 573.8 M 274.33 922.08 C 393.8 787.08 512.45 650.58 572.18 579.44 M 274.33 922.08 C 345.98 839.59 417.82 757.39 572.18 579.44 M 279.32 922.44 C 388.09 796.68 496.37 673.06 571.92 585.84 M 279.32 922.44 C 366.34 820.33 455.07 719.23 571.92 585.84 M 284.96 922.04 C 362.53 830.29 441.86 740.36 571.66 592.24 M 284.96 922.04 C 377.44 816.61 469.11 711.56 571.66 592.24 M 289.95 922.4 C 382.99 815.16 479.15 706.34 572.06 597.88 M 289.95 922.4 C 379.26 821.44 467.05 720.73 572.06 597.88 M 294.94 922.76 C 387.74 811.23 482.9 703.53 571.8 604.28 M 294.94 922.76 C 374.26 832.2 453.7 741.13 571.8 604.28 M 300.58 922.37 C 355.71 858 411.83 792.49 572.19 609.92 M 300.58 922.37 C 395.98 812.37 493.18 701.8 572.19 609.92 M 305.57 922.73 C 408.75 804.29 511.62 685.01 571.93 616.32 M 305.57 922.73 C 402.55 811.76 497.64 700.94 571.93 616.32 M 311.21 922.33 C 369.49 858.3 424.21 792.99 571.67 622.71 M 311.21 922.33 C 408.24 808.81 505.88 696.34 571.67 622.71 M 316.2 922.69 C 406.89 816.89 496.47 711.66 572.06 628.36 M 316.2 922.69 C 402.31 823.61 488.23 725.9 572.06 628.36 M 321.84 922.3 C 397.84 834.31 473.02 746.53 571.8 634.76 M 321.84 922.3 C 406.35 826.25 490.05 729.53 571.8 634.76 M 326.83 922.66 C 388.94 851.33 450.95 779.29 572.19 640.4 M 326.83 922.66 C 390.83 846.91 457.42 770.79 572.19 640.4 M 332.47 922.27 C 383.62 863.03 432.23 804.41 571.93 646.8 M 332.47 922.27 C 410.22 835.88 486.72 746.8 571.93 646.8 M 337.46 922.63 C 392.04 860.96 449.95 795.9 571.67 653.19 M 337.46 922.63 C 430.43 814.33 522.77 707.82 571.67 653.19 M 343.1 922.23 C 432.31 822.82 519.65 721.82 572.07 658.84 M 343.1 922.23 C 395.82 859.23 450.01 797.22 572.07 658.84 M 348.09 922.59 C 417.58 842.07 490.23 760.27 571.8 665.24 M 348.09 922.59 C 398.62 866.29 448.77 809.18 571.8 665.24 M 353.73 922.2 C 411.32 853.69 473.44 785.48 572.2 670.88 M 353.73 922.2 C 422.22 845.14 487.55 767.94 572.2 670.88 M 358.72 922.56 C 414.26 858.25 472.16 792.59 571.94 677.28 M 358.72 922.56 C 403.99 870.92 449.63 819.28 571.94 677.28 M 364.36 922.16 C 412.36 864.52 463.33 806.03 571.68 683.67 M 364.36 922.16 C 441.74 832.8 518.46 743.3 571.68 683.67 M 369.35 922.52 C 427.72 853.53 489.54 784.64 572.07 689.32 M 369.35 922.52 C 432.95 847.12 497.13 772.46 572.07 689.32 M 374.99 922.13 C 423.45 866.19 470.04 811.67 571.81 695.71 M 374.99 922.13 C 417.05 875.8 457.53 827.33 571.81 695.71 M 379.98 922.49 C 455.9 834.81 531.08 748.47 572.2 701.36 M 379.98 922.49 C 428.72 868.44 475.83 812.23 572.2 701.36 M 385.62 922.09 C 449.72 846.25 514.83 773.01 571.94 707.76 M 385.62 922.09 C 459.26 837.02 533.09 750.78 571.94 707.76 M 390.61 922.45 C 461.45 842.05 529.68 762.06 571.68 714.15 M 390.61 922.45 C 463.11 840.86 532.87 760.82 571.68 714.15 M 396.25 922.06 C 435.76 876.1 473.67 830.75 572.08 719.8 M 396.25 922.06 C 440.27 873.84 483.77 824.14 572.08 719.8 M 401.24 922.42 C 442.99 873.43 485.16 826.03 571.81 726.19 M 401.24 922.42 C 451.42 864.79 501.97 807.86 571.81 726.19 M 406.88 922.02 C 446.62 877.68 487.71 830.13 572.21 731.84 M 406.88 922.02 C 452.66 868.13 498.52 816.36 572.21 731.84 M 411.87 922.38 C 448.95 881.32 486.74 836.73 571.95 738.24 M 411.87 922.38 C 473.04 852.91 534.07 782.7 571.95 738.24 M 416.86 922.74 C 478.06 854.25 538.51 784.12 571.69 744.63 M 416.86 922.74 C 467.9 863.66 521.4 802.66 571.69 744.63 M 422.5 922.35 C 470.95 865.75 519.35 811.99 572.08 750.28 M 422.5 922.35 C 459.86 879.89 497.64 836.35 572.08 750.28 M 427.49 922.71 C 478.94 865.09 531.07 803.81 571.82 756.67 M 427.49 922.71 C 469.69 872.52 513.61 821.96 571.82 756.67 M 433.13 922.32 C 485.87 861.13 539.05 797.83 572.21 762.32 M 433.13 922.32 C 484.93 863.7 537.7 803.81 572.21 762.32 M 438.12 922.68 C 469 890.1 497.85 854.33 571.95 768.71 M 438.12 922.68 C 484.03 869.86 532.53 815.21 571.95 768.71 M 443.76 922.28 C 469.84 891.49 497.5 860.99 571.69 775.11 M 443.76 922.28 C 490.97 866.74 539.44 813.23 571.69 775.11 M 448.75 922.64 C 496.07 866.97 542.64 814.04 572.09 780.76 M 448.75 922.64 C 485.77 880.61 521.28 839.14 572.09 780.76 M 454.39 922.25 C 485.27 888.96 517.39 853.96 571.82 787.15 M 454.39 922.25 C 497.48 873.01 539.98 823.8 571.82 787.15 M 459.38 922.61 C 484.11 891.9 512.48 861.06 572.22 792.8 M 459.38 922.61 C 488.86 889.61 519.85 853.15 572.22 792.8 M 465.02 922.21 C 504.26 880.47 540.9 838.18 571.96 799.19 M 465.02 922.21 C 488.74 895.81 510.54 869.57 571.96 799.19 M 470.01 922.57 C 496.66 886.78 526.73 856.76 571.7 805.59 M 470.01 922.57 C 491.65 897.28 511.77 873.14 571.7 805.59 M 475.65 922.18 C 510.03 884.44 545.75 844.42 572.09 811.23 M 475.65 922.18 C 503.95 890.08 530.42 859.35 572.09 811.23 M 480.64 922.54 C 501.53 895.8 526.5 869.7 571.83 817.63 M 480.64 922.54 C 516.52 880.87 550.8 840.73 571.83 817.63 M 486.28 922.14 C 510.33 892.7 531.99 868.21 572.22 823.28 M 486.28 922.14 C 510.08 896.63 532.52 870.29 572.22 823.28 M 491.27 922.5 C 516.59 894.58 542.55 864.34 571.96 829.67 M 491.27 922.5 C 516.04 894.91 540.71 866.25 571.96 829.67 M 496.91 922.11 C 513.33 905.01 530.12 886.55 571.7 836.07 M 496.91 922.11 C 524.23 889.83 551.53 858.38 571.7 836.07 M 501.9 922.47 C 525.17 894.71 549.59 868.12 572.1 841.71 M 501.9 922.47 C 525.44 894.3 550.64 864.69 572.1 841.71 M 507.54 922.07 C 532.53 892.65 558.05 864.79 571.83 848.11 M 507.54 922.07 C 528.85 896.19 550.97 871.52 571.83 848.11 M 512.53 922.43 C 522.91 908.59 535.55 894.31 572.23 853.76 M 512.53 922.43 C 534.24 896.29 556.73 872.53 572.23 853.76 M 518.17 922.04 C 535.73 902.56 548.69 886.84 571.97 860.15 M 518.17 922.04 C 530.29 909.38 540.97 894.4 571.97 860.15 M 523.16 922.4 C 534.37 910.18 547.3 892.26 571.71 866.55 M 523.16 922.4 C 538.67 904.5 553.19 887.26 571.71 866.55 M 528.14 922.76 C 544.07 905.63 558.54 884.77 572.1 872.19 M 528.14 922.76 C 543.87 902.84 560.46 885.36 572.1 872.19 M 533.79 922.36 C 547.36 907.58 557.5 895.75 571.84 878.59 M 533.79 922.36 C 546.47 907.76 559.43 892.24 571.84 878.59 M 538.77 922.72 C 548.62 910.2 557.28 899.43 572.23 884.23 M 538.77 922.72 C 550.5 910.49 560.47 899.96 572.23 884.23 M 544.42 922.33 C 550.7 913.13 557.74 907.88 571.97 890.63 M 544.42 922.33 C 553.3 912.28 563.71 899.63 571.97 890.63 M 549.4 922.69 C 558.9 915.55 565.84 905.95 571.71 897.03 M 549.4 922.69 C 555.51 916.62 561.12 909.36 571.71 897.03 M 555.05 922.3 C 561.92 916.73 566.93 908.37 572.1 902.67 M 555.05 922.3 C 559.59 916.65 564.72 911.51 572.1 902.67 M 560.03 922.66 C 562.61 919.98 565.53 914.97 571.84 909.07 M 560.03 922.66 C 563.22 919.27 566.71 915.04 571.84 909.07 M 565.68 922.26 C 566.26 920.95 569.45 918.15 572.24 914.71 M 565.68 922.26 C 567.31 920.42 569.06 918.03 572.24 914.71" fill="none" stroke="#e1d5e7" stroke-width="0.5" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 160 450 C 282.51 449.32 404.18 450.3 570 450 M 160 450 C 267.82 448.57 374.78 448.83 570 450 M 570 450 C 567.82 625.46 568.89 801.72 570 920 M 570 450 C 571.04 613.61 571.01 777.66 570 920 M 570 920 C 415.89 918.34 262.5 919.55 160 920 M 570 920 C 442.16 919.93 313.63 919.51 160 920 M 160 920 C 161.75 801.94 160.68 682.96 160 450 M 160 920 C 157.98 782.9 157.86 646.07 160 450" fill="none" stroke="rgb(0, 0, 0)" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><rect x="180" y="490" width="370" height="170" fill="none" stroke="none" pointer-events="all"/><path d="M 179.87 490.15 C 179.87 490.15 179.87 490.15 179.87 490.15 M 179.87 490.15 C 179.87 490.15 179.87 490.15 179.87 490.15 M 180.26 495.8 C 181.93 493.3 184.42 492.18 185.51 489.76 M 180.26 495.8 C 182.67 493.06 184.13 490.67 185.51 489.76 M 180 502.2 C 181.56 498.37 182.85 496.07 190.5 490.12 M 180 502.2 C 182.94 498.92 186.04 495.39 190.5 490.12 M 179.74 508.59 C 182.77 503.33 186.52 499.14 196.14 489.73 M 179.74 508.59 C 185.03 500.9 191.35 493.9 196.14 489.73 M 180.13 514.24 C 186.83 506.65 191.9 503.97 201.13 490.09 M 180.13 514.24 C 186.88 506.87 191.98 499.47 201.13 490.09 M 179.87 520.63 C 187.19 510.23 195.45 502.04 206.77 489.69 M 179.87 520.63 C 186.13 514.9 190.74 508.07 206.77 489.69 M 180.27 526.28 C 187.33 515.86 196.56 509.85 211.76 490.05 M 180.27 526.28 C 187.3 518.56 192.68 511.06 211.76 490.05 M 180 532.67 C 190.98 518.08 204.37 502.37 217.4 489.66 M 180 532.67 C 189.47 522.83 199.04 511.56 217.4 489.66 M 179.74 539.07 C 191.86 526.45 205.35 510.13 222.39 490.02 M 179.74 539.07 C 193.2 525.59 205.2 510.39 222.39 490.02 M 180.14 544.72 C 198.38 523.13 213.52 504.87 227.37 490.38 M 180.14 544.72 C 190.67 532.19 200.36 520.08 227.37 490.38 M 179.88 551.11 C 192.87 535.99 202.22 524.11 233.02 489.98 M 179.88 551.11 C 199.64 526.61 220.25 502.67 233.02 489.98 M 180.27 556.76 C 199.64 532.86 217.52 513.25 238 490.34 M 180.27 556.76 C 196.92 537.35 212.37 518.35 238 490.34 M 180.01 563.15 C 204.8 537.69 225.17 507.2 243.65 489.95 M 180.01 563.15 C 200.57 538.78 220.89 515.65 243.65 489.95 M 179.75 569.55 C 202.91 546.76 222.87 520.47 248.63 490.31 M 179.75 569.55 C 196.6 548.26 214.84 528.29 248.63 490.31 M 180.14 575.2 C 209.51 543.9 237.16 509.79 254.28 489.91 M 180.14 575.2 C 200.85 551.7 221.1 528.13 254.28 489.91 M 179.88 581.59 C 208.98 546.95 236.35 514.13 259.26 490.27 M 179.88 581.59 C 205.45 551.53 231.75 522.33 259.26 490.27 M 180.27 587.24 C 209.51 554.86 238.58 517.76 264.91 489.88 M 180.27 587.24 C 197.13 566.69 215.81 545.67 264.91 489.88 M 180.01 593.63 C 203.27 566.91 227.1 538.93 269.89 490.24 M 180.01 593.63 C 213.34 558.67 243.94 522.29 269.89 490.24 M 179.75 600.03 C 211.43 561.46 247.11 518.49 275.54 489.84 M 179.75 600.03 C 205.58 568.83 231.83 538.31 275.54 489.84 M 180.15 605.67 C 218.21 558.34 258.78 514.67 280.52 490.2 M 180.15 605.67 C 217.93 561.34 255.01 517.41 280.52 490.2 M 179.89 612.07 C 211.61 575.8 245.17 535.59 286.17 489.81 M 179.89 612.07 C 218.61 565.02 258.8 518.82 286.17 489.81 M 180.28 617.72 C 202.46 591.21 228.35 567.03 291.15 490.17 M 180.28 617.72 C 214.04 578.13 248.73 538.69 291.15 490.17 M 180.02 624.11 C 208.47 590.3 236.9 559.16 296.8 489.77 M 180.02 624.11 C 228.49 570.6 274.08 516.81 296.8 489.77 M 179.76 630.51 C 230.6 573.56 275.66 520.04 301.78 490.14 M 179.76 630.51 C 208.41 598.97 235.7 567.02 301.78 490.14 M 180.15 636.15 C 221.38 588.41 261.36 543.05 307.43 489.74 M 180.15 636.15 C 228.1 579.21 278.83 521.18 307.43 489.74 M 179.89 642.55 C 225.97 592.53 267.04 541.27 312.41 490.1 M 179.89 642.55 C 220.64 599.61 257.82 554.88 312.41 490.1 M 180.28 648.19 C 228.01 593.1 279.11 537.47 318.06 489.71 M 180.28 648.19 C 208.37 616.9 236.78 584.23 318.06 489.71 M 180.02 654.59 C 237.67 589.34 295.35 527.52 323.04 490.07 M 180.02 654.59 C 213.12 617.99 246.72 579.34 323.04 490.07 M 180.42 660.24 C 224.91 610.6 266.25 560.7 328.69 489.67 M 180.42 660.24 C 212.69 624.68 243.61 588.93 328.69 489.67 M 185.4 660.6 C 221.73 616.5 263 571.07 333.67 490.03 M 185.4 660.6 C 224.25 616.64 262.43 571.96 333.67 490.03 M 191.05 660.2 C 248.43 591.67 308.38 523.06 339.32 489.64 M 191.05 660.2 C 223.82 620.75 258.72 582.54 339.32 489.64 M 196.03 660.56 C 228.81 621.84 262.21 586.33 344.3 490 M 196.03 660.56 C 247.44 603.23 296.46 546.11 344.3 490 M 201.68 660.17 C 257.68 593.6 313.76 528.26 349.29 490.36 M 201.68 660.17 C 256.04 597.85 312.07 533.75 349.29 490.36 M 206.66 660.53 C 245.9 617.42 280.97 574.3 354.93 489.96 M 206.66 660.53 C 254.32 605.1 301.24 551.34 354.93 489.96 M 212.31 660.13 C 262.74 602.07 312.33 544.07 359.92 490.32 M 212.31 660.13 C 272.07 594.12 331.33 526.31 359.92 490.32 M 217.3 660.49 C 266.66 602.5 316.39 545.03 365.56 489.93 M 217.3 660.49 C 253.36 620.73 290.13 578.9 365.56 489.93 M 222.94 660.1 C 275.41 596.63 329.66 533.81 370.55 490.29 M 222.94 660.1 C 276.55 598.07 331.18 533.55 370.55 490.29 M 227.93 660.46 C 284.04 597.71 337.46 535.58 376.19 489.89 M 227.93 660.46 C 287.17 595.05 343.91 530.52 376.19 489.89 M 233.57 660.06 C 286.71 598.36 338.42 539.87 381.18 490.25 M 233.57 660.06 C 292.7 590.78 351.53 524.46 381.18 490.25 M 238.56 660.42 C 272.61 620.56 306.11 582.24 386.82 489.86 M 238.56 660.42 C 272.68 621.14 308.37 582.12 386.82 489.86 M 244.2 660.03 C 278.05 621.22 310.12 584.56 391.81 490.22 M 244.2 660.03 C 287.59 611.03 331.43 561.16 391.81 490.22 M 249.19 660.39 C 292.21 606.72 341.38 552.99 397.45 489.82 M 249.19 660.39 C 296.38 606.34 345.62 549.74 397.45 489.82 M 254.83 659.99 C 294.91 617.47 329.68 574.72 402.44 490.18 M 254.83 659.99 C 300.6 608.82 344.32 559.21 402.44 490.18 M 259.82 660.35 C 290.57 623.51 322.38 589.7 408.08 489.79 M 259.82 660.35 C 315.46 595.83 370.61 532.13 408.08 489.79 M 265.46 659.96 C 321 598.41 376.54 534.58 413.07 490.15 M 265.46 659.96 C 324.23 595.25 380.67 528.95 413.07 490.15 M 270.45 660.32 C 299.15 627.39 330.51 589.13 418.71 489.76 M 270.45 660.32 C 326.09 595.79 384.25 529.09 418.71 489.76 M 275.43 660.68 C 312.15 616.04 352.88 570.19 423.7 490.12 M 275.43 660.68 C 326.75 603.49 377.02 544.94 423.7 490.12 M 281.08 660.29 C 312.21 626.33 341.49 590.62 429.34 489.72 M 281.08 660.29 C 326.91 607.84 373.56 554.57 429.34 489.72 M 286.06 660.65 C 326.03 614.29 362.67 572.05 434.33 490.08 M 286.06 660.65 C 329.86 610.89 371.61 561.97 434.33 490.08 M 291.71 660.25 C 321.67 625.7 351.48 588.8 439.97 489.69 M 291.71 660.25 C 350.92 593.7 408.6 527.8 439.97 489.69 M 296.69 660.61 C 331.75 617.92 366.78 579.36 444.96 490.05 M 296.69 660.61 C 348.14 601.6 399.49 542.25 444.96 490.05 M 302.34 660.22 C 361.98 592.02 419.6 528.12 450.61 489.65 M 302.34 660.22 C 337.81 619.73 374.49 578.26 450.61 489.65 M 307.32 660.58 C 357.86 601.48 409.74 541.04 455.59 490.01 M 307.32 660.58 C 365.32 593.42 423.14 526.12 455.59 490.01 M 312.97 660.18 C 356.21 612.26 394.19 568.06 460.58 490.37 M 312.97 660.18 C 363.53 603.43 412.92 545.13 460.58 490.37 M 317.95 660.54 C 359.23 613.87 396.74 569.67 466.22 489.98 M 317.95 660.54 C 361.42 607.88 406.1 555.78 466.22 489.98 M 323.6 660.15 C 376.37 602.6 425.74 542.11 471.21 490.34 M 323.6 660.15 C 374.88 601.21 426.09 540.27 471.21 490.34 M 328.58 660.51 C 377.31 604.01 427.32 545.34 476.85 489.94 M 328.58 660.51 C 370.74 611.09 413.69 561.57 476.85 489.94 M 334.23 660.11 C 365.01 622.78 395.82 586.98 481.84 490.3 M 334.23 660.11 C 363.93 623.32 394.19 588.97 481.84 490.3 M 339.21 660.47 C 375.1 618.11 410.13 579.14 487.48 489.91 M 339.21 660.47 C 394.19 596.77 449.55 533.69 487.48 489.91 M 344.86 660.08 C 387.63 612.2 428.33 564.6 492.47 490.27 M 344.86 660.08 C 374.7 624.44 405.89 589.22 492.47 490.27 M 349.84 660.44 C 399.78 602.43 449.19 546.24 498.11 489.87 M 349.84 660.44 C 396.8 606.43 445.13 550.87 498.11 489.87 M 355.49 660.04 C 391.14 617.06 429.84 571.73 503.1 490.23 M 355.49 660.04 C 403.66 603.5 453.73 545.97 503.1 490.23 M 360.47 660.4 C 406.36 608.23 450.76 560.54 508.74 489.84 M 360.47 660.4 C 406.22 607.69 451.74 554.73 508.74 489.84 M 366.12 660.01 C 401.7 618.62 435.94 578.01 513.73 490.2 M 366.12 660.01 C 418.73 601.68 467.78 543.63 513.73 490.2 M 371.1 660.37 C 411.25 610.68 453.74 561.41 519.37 489.81 M 371.1 660.37 C 404.25 621.03 438.51 580.51 519.37 489.81 M 376.75 659.98 C 413.08 617.65 446.5 578.16 524.36 490.17 M 376.75 659.98 C 415.49 616.99 452.6 574.01 524.36 490.17 M 381.73 660.34 C 440.32 593.55 496.75 528.21 530 489.77 M 381.73 660.34 C 412.73 623.81 445.6 586.04 530 489.77 M 387.38 659.94 C 426.03 612.7 466 566.97 534.99 490.13 M 387.38 659.94 C 426.85 614.09 466.66 568.24 534.99 490.13 M 392.36 660.3 C 443.69 597.58 498.71 538.71 540.63 489.74 M 392.36 660.3 C 438.97 604.44 486.92 550.29 540.63 489.74 M 397.35 660.66 C 432.75 619.86 470.01 579.34 545.62 490.1 M 397.35 660.66 C 435.49 616.91 473.17 572.43 545.62 490.1 M 402.99 660.27 C 445.4 611.82 491.55 561.84 550.61 490.46 M 402.99 660.27 C 432.5 626.86 462.11 592.58 550.61 490.46 M 407.98 660.63 C 444.88 616.61 485.57 571.92 550.35 496.85 M 407.98 660.63 C 446.73 617.05 484.48 573.73 550.35 496.85 M 413.62 660.23 C 463.13 603.91 509.54 549.33 550.74 502.5 M 413.62 660.23 C 449.92 618.9 484.09 577.53 550.74 502.5 M 418.61 660.59 C 467.43 603.58 513.19 549.77 550.48 508.9 M 418.61 660.59 C 447.99 627.78 477.45 594.04 550.48 508.9 M 424.25 660.2 C 455 628.05 481.64 593.45 550.87 514.54 M 424.25 660.2 C 463.08 613.86 504.56 565.85 550.87 514.54 M 429.24 660.56 C 469.3 612.38 511.47 565.82 550.61 520.94 M 429.24 660.56 C 454.2 631.43 479.14 603.06 550.61 520.94 M 434.88 660.16 C 463.28 625 496.91 586.22 550.35 527.33 M 434.88 660.16 C 470.37 620 506.96 578.35 550.35 527.33 M 439.87 660.52 C 474.9 617.45 510.19 579.47 550.74 532.98 M 439.87 660.52 C 483.63 610.81 528.04 560.64 550.74 532.98 M 445.51 660.13 C 465.61 634.74 488.81 609.39 550.48 539.37 M 445.51 660.13 C 469.35 635.46 490.21 609.58 550.48 539.37 M 450.5 660.49 C 473.78 633.87 495.15 606.9 550.88 545.02 M 450.5 660.49 C 482.22 624.3 514.17 586.83 550.88 545.02 M 456.14 660.09 C 492.65 617.33 526.53 579.1 550.62 551.42 M 456.14 660.09 C 485.37 627.85 514.08 594.14 550.62 551.42 M 461.13 660.45 C 484.19 633 512.38 604.63 550.36 557.81 M 461.13 660.45 C 494.83 619.79 529.55 579.5 550.36 557.81 M 466.77 660.06 C 488.94 630.04 516.02 602.8 550.75 563.46 M 466.77 660.06 C 492.32 632.19 518.02 601.89 550.75 563.46 M 471.76 660.42 C 494.7 633.91 514.84 610.34 550.49 569.85 M 471.76 660.42 C 487.89 640.76 505.16 621.01 550.49 569.85 M 477.4 660.02 C 501.88 633.32 522.27 606.39 550.88 575.5 M 477.4 660.02 C 494.91 640.87 511.64 619.33 550.88 575.5 M 482.39 660.38 C 509.74 628.3 536.02 601.5 550.62 581.89 M 482.39 660.38 C 499.26 644.1 513.31 625.72 550.62 581.89 M 488.03 659.99 C 511.69 632.78 532.47 610.16 550.36 588.29 M 488.03 659.99 C 511.47 632.61 534.03 605.64 550.36 588.29 M 493.02 660.35 C 510.04 639.75 526.61 618.76 550.75 593.94 M 493.02 660.35 C 508.01 642.54 523.75 623.97 550.75 593.94 M 498.66 659.96 C 520.06 637.21 539.35 612.42 550.49 600.33 M 498.66 659.96 C 513.71 643.07 529.52 623.86 550.49 600.33 M 503.65 660.32 C 515.42 646.09 528.65 631.52 550.89 605.98 M 503.65 660.32 C 515.84 646.5 528.81 632.24 550.89 605.98 M 508.64 660.68 C 520.26 646.73 535.32 630.85 550.63 612.37 M 508.64 660.68 C 517.78 650.05 525.42 640.2 550.63 612.37 M 514.28 660.28 C 523.24 649.8 533.67 636.41 550.36 618.77 M 514.28 660.28 C 522.93 649.91 532.93 639.36 550.36 618.77 M 519.27 660.64 C 529.76 647.67 540.86 639.85 550.76 624.42 M 519.27 660.64 C 526.27 651.23 533.71 644.22 550.76 624.42 M 524.91 660.25 C 532.06 649.27 540.16 640.68 550.5 630.81 M 524.91 660.25 C 530.6 653.14 537.01 646.22 550.5 630.81 M 529.9 660.61 C 535.15 652.41 543.14 648.01 550.89 636.46 M 529.9 660.61 C 536.71 652.44 544.22 644.02 550.89 636.46 M 535.54 660.21 C 541.02 655.19 542.67 652.06 550.63 642.85 M 535.54 660.21 C 539.4 654.41 544.77 649.35 550.63 642.85 M 540.53 660.57 C 544.17 658.41 543.88 655.85 550.37 649.25 M 540.53 660.57 C 544.37 656.53 548.58 652.33 550.37 649.25 M 546.17 660.18 C 547 659.6 548.68 658.51 550.76 654.89 M 546.17 660.18 C 547.4 658.74 548.59 656.85 550.76 654.89" fill="none" stroke="#e1d5e7" stroke-width="0.5" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 180 490 C 289.29 489.49 400.08 488.36 550 490 M 180 490 C 255.69 490.61 332.12 489.94 550 490 M 550 490 C 551.35 530.82 551.47 574.41 550 660 M 550 490 C 547.98 541.78 547.72 592.55 550 660 M 550 660 C 441.01 660.42 328.62 661.16 180 660 M 550 660 C 404.72 659.84 258.39 660.47 180 660 M 180 660 C 181.85 603.92 180.54 545.44 180 490 M 180 660 C 179.67 592.06 179.74 526.59 180 490" fill="none" stroke="rgb(0, 0, 0)" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><rect x="580" y="720" width="420" height="410" fill="none" stroke="none" pointer-events="all"/><path d="M 579.97 720.03 C 579.97 720.03 579.97 720.03 579.97 720.03 M 579.97 720.03 C 579.97 720.03 579.97 720.03 579.97 720.03 M 579.71 726.43 C 581.62 724.22 581.66 722.82 585.61 719.64 M 579.71 726.43 C 581.73 723.68 583.94 721.65 585.61 719.64 M 580.1 732.07 C 582.68 728.85 586.88 723.18 590.6 720 M 580.1 732.07 C 583.62 727.33 587.81 723.82 590.6 720 M 579.84 738.47 C 582.72 732.86 586.11 727.86 595.59 720.36 M 579.84 738.47 C 585.51 732.63 589.45 728.84 595.59 720.36 M 580.24 744.12 C 585.29 737.9 590.12 732.5 601.23 719.96 M 580.24 744.12 C 585.7 737.37 591.03 731.91 601.23 719.96 M 579.98 750.51 C 590.71 739.71 600.2 730.26 606.22 720.33 M 579.98 750.51 C 587.87 741.06 596.22 731.72 606.22 720.33 M 579.71 756.91 C 587.33 745.41 595.37 739.21 611.86 719.93 M 579.71 756.91 C 585.33 749.8 592.31 742.03 611.86 719.93 M 580.11 762.55 C 592.16 749.36 604.7 737.23 616.85 720.29 M 580.11 762.55 C 590.12 750.9 599.96 740.22 616.85 720.29 M 579.85 768.95 C 591.63 755.42 605.5 740.44 622.49 719.9 M 579.85 768.95 C 588.1 758.32 597.86 748.62 622.49 719.9 M 580.24 774.6 C 592 758.43 606.67 744.09 627.48 720.26 M 580.24 774.6 C 593.87 759.19 606.79 743.72 627.48 720.26 M 579.98 780.99 C 596.64 759.09 615.28 740.48 633.12 719.86 M 579.98 780.99 C 598.2 759.97 617.36 739.67 633.12 719.86 M 579.72 787.39 C 597.98 766.77 615.05 745.96 638.11 720.22 M 579.72 787.39 C 594.23 770.98 607.68 755.4 638.11 720.22 M 580.11 793.03 C 597.61 773.92 612.88 758.02 643.75 719.83 M 580.11 793.03 C 592.73 778.27 606.93 762.38 643.75 719.83 M 579.85 799.43 C 602.72 772.08 626.28 746.82 648.74 720.19 M 579.85 799.43 C 600.58 775.37 622.58 749.87 648.74 720.19 M 580.25 805.07 C 599.43 785.45 616.96 764.61 654.38 719.79 M 580.25 805.07 C 595.11 787.44 609.72 771.41 654.38 719.79 M 579.99 811.47 C 607.84 783.23 631.15 751.73 659.37 720.15 M 579.99 811.47 C 595.04 791.68 610.51 773.68 659.37 720.15 M 579.72 817.87 C 601.97 794.33 621.25 768.68 665.01 719.76 M 579.72 817.87 C 599.72 795.31 621.61 770.88 665.01 719.76 M 580.12 823.51 C 603.19 794.88 630.01 766.25 670 720.12 M 580.12 823.51 C 607.22 791.47 635.69 758.68 670 720.12 M 579.86 829.91 C 605.13 801.77 630.94 771.47 675.64 719.72 M 579.86 829.91 C 605.47 800.87 630.32 771.03 675.64 719.72 M 580.25 835.55 C 613.12 799.3 645.64 759.93 680.63 720.08 M 580.25 835.55 C 601.11 812.43 623.08 788.57 680.63 720.08 M 579.99 841.95 C 603.03 814.01 630.17 783.17 686.27 719.69 M 579.99 841.95 C 614.87 802.22 650.92 761.92 686.27 719.69 M 579.73 848.35 C 620.26 802.55 659.68 753.96 691.26 720.05 M 579.73 848.35 C 615.03 809.17 649.29 768.93 691.26 720.05 M 580.12 853.99 C 622.69 802 668.93 749.51 696.9 719.65 M 580.12 853.99 C 615.14 813.05 651.56 771.77 696.9 719.65 M 579.86 860.39 C 608.57 827.72 636.73 795.32 701.89 720.01 M 579.86 860.39 C 606.86 829.18 632.17 801.2 701.89 720.01 M 580.26 866.03 C 614.38 828.65 648.35 791.26 706.88 720.37 M 580.26 866.03 C 629.5 809.35 680.6 751.6 706.88 720.37 M 579.99 872.43 C 628.89 818.06 675.33 761.28 712.52 719.98 M 579.99 872.43 C 630.15 814.66 678.93 758.96 712.52 719.98 M 579.73 878.83 C 621.45 830.21 664.36 781.6 717.51 720.34 M 579.73 878.83 C 631.18 819.84 684.11 758.2 717.51 720.34 M 580.13 884.47 C 622.99 836.42 663.93 785.36 723.15 719.95 M 580.13 884.47 C 610.1 847.96 641.33 812.57 723.15 719.95 M 579.87 890.87 C 625.2 839.82 669.66 788.06 728.14 720.31 M 579.87 890.87 C 609.73 856.99 639.98 821.14 728.14 720.31 M 580.26 896.51 C 638.5 830.35 698.59 760.36 733.78 719.91 M 580.26 896.51 C 618.29 852.46 656.91 808.78 733.78 719.91 M 580 902.91 C 622.64 851.78 669.35 800.31 738.77 720.27 M 580 902.91 C 612.62 865.43 645.09 829.21 738.77 720.27 M 579.74 909.31 C 627.04 852.25 674.9 799.84 744.41 719.88 M 579.74 909.31 C 632.8 846 686.54 784.64 744.41 719.88 M 580.13 914.95 C 625.04 867.66 664.87 817.65 749.4 720.24 M 580.13 914.95 C 619.99 868.31 661.01 821.37 749.4 720.24 M 579.87 921.35 C 628.38 865.73 672.23 813.21 755.04 719.84 M 579.87 921.35 C 646.22 845.98 712.18 769.43 755.04 719.84 M 580.27 926.99 C 626.55 871.67 674.58 819.02 760.03 720.2 M 580.27 926.99 C 648.89 849.72 717.4 771.37 760.03 720.2 M 580 933.39 C 632.12 870.13 687.54 806.7 765.67 719.81 M 580 933.39 C 637.91 869.08 693.53 805.12 765.67 719.81 M 579.74 939.79 C 641.43 865.16 706.43 793.13 770.66 720.17 M 579.74 939.79 C 619.11 890.8 660.97 842.47 770.66 720.17 M 580.14 945.43 C 648.4 863.08 717.33 783.39 776.3 719.77 M 580.14 945.43 C 630.45 885.25 681.06 827.46 776.3 719.77 M 579.88 951.83 C 648.59 873.72 715.24 794.84 781.29 720.13 M 579.88 951.83 C 654.32 866.27 728.64 780.25 781.29 720.13 M 580.27 957.47 C 649.72 876.07 717.05 796.24 786.93 719.74 M 580.27 957.47 C 657.83 867.4 736.36 777.08 786.93 719.74 M 580.01 963.87 C 641.64 888.66 705.45 816.47 791.92 720.1 M 580.01 963.87 C 657.21 875.96 732.89 787.86 791.92 720.1 M 579.75 970.27 C 652.35 884.99 723.92 801.08 797.56 719.7 M 579.75 970.27 C 638.5 902.35 696.63 835.42 797.56 719.7 M 580.14 975.91 C 651.78 895.42 719.42 816.13 802.55 720.06 M 580.14 975.91 C 655.46 891.36 728.06 807 802.55 720.06 M 579.88 982.31 C 658.29 888.93 741.01 796.32 808.19 719.67 M 579.88 982.31 C 646.87 906.96 711.79 832.01 808.19 719.67 M 580.28 987.95 C 633.1 930.14 684.26 868.65 813.18 720.03 M 580.28 987.95 C 661.59 896.57 741.07 803.53 813.18 720.03 M 580.01 994.35 C 631.34 937.28 683.74 879.22 818.82 719.64 M 580.01 994.35 C 642.46 921.88 704.26 849.63 818.82 719.64 M 579.75 1000.75 C 661.15 906.3 743.37 812.15 823.81 720 M 579.75 1000.75 C 646.88 921.86 715.48 843.1 823.81 720 M 580.15 1006.39 C 633.98 944.61 690.66 880.68 828.79 720.36 M 580.15 1006.39 C 629.93 949.6 680.6 892.37 828.79 720.36 M 579.89 1012.79 C 658.72 923.77 735.1 833.76 834.44 719.96 M 579.89 1012.79 C 665.61 913.6 751.22 815.17 834.44 719.96 M 580.28 1018.43 C 660.65 926.27 742.29 830.52 839.42 720.32 M 580.28 1018.43 C 676.31 908.17 771.68 797.71 839.42 720.32 M 580.02 1024.83 C 648.2 947.28 717.51 866.51 845.07 719.93 M 580.02 1024.83 C 664.93 927.04 749.61 829.81 845.07 719.93 M 579.76 1031.23 C 668.34 927.7 758.7 827.08 850.05 720.29 M 579.76 1031.23 C 632.68 969.54 686.84 907.91 850.05 720.29 M 580.15 1036.87 C 654.85 950.37 728.86 863.82 855.7 719.89 M 580.15 1036.87 C 681.43 920.09 782.62 804.09 855.7 719.89 M 579.89 1043.27 C 666.66 945.11 752.66 847 860.68 720.25 M 579.89 1043.27 C 690.88 916.2 802.26 788.32 860.68 720.25 M 580.29 1048.91 C 659.89 959.18 740.07 865.41 866.33 719.86 M 580.29 1048.91 C 643.23 975.89 707.13 902.66 866.33 719.86 M 580.02 1055.31 C 695.48 922.32 808.62 790.61 871.31 720.22 M 580.02 1055.31 C 646.27 982.76 709.53 908.54 871.31 720.22 M 579.76 1061.71 C 689.01 934.35 800.43 806.73 876.96 719.82 M 579.76 1061.71 C 681.53 942.23 785.31 823.21 876.96 719.82 M 580.16 1067.35 C 688.96 943.41 797.15 818.41 881.94 720.18 M 580.16 1067.35 C 644.33 994.21 708.62 920.1 881.94 720.18 M 579.9 1073.75 C 674.2 967.89 766.68 860.96 887.59 719.79 M 579.9 1073.75 C 649.86 991.77 720.44 911.06 887.59 719.79 M 580.29 1079.39 C 660.34 985.89 740.83 892.63 892.57 720.15 M 580.29 1079.39 C 667.73 979.97 754.28 880.79 892.57 720.15 M 580.03 1085.79 C 698.52 947.65 818.26 809.97 898.22 719.75 M 580.03 1085.79 C 663.88 988.85 748.8 891.67 898.22 719.75 M 579.77 1092.19 C 703.65 950.93 825.15 808.83 903.2 720.11 M 579.77 1092.19 C 704.25 948.74 827.89 806.6 903.2 720.11 M 580.16 1097.83 C 699.86 960.11 820.52 822.3 908.85 719.72 M 580.16 1097.83 C 668.26 996.15 757.05 894.72 908.85 719.72 M 579.9 1104.23 C 678.28 990.66 775.77 876.66 913.83 720.08 M 579.9 1104.23 C 666.79 1002.34 755.15 901.12 913.83 720.08 M 580.29 1109.87 C 712.37 957.66 842.42 806.96 919.48 719.68 M 580.29 1109.87 C 706.88 964.69 834.27 818.32 919.48 719.68 M 580.03 1116.27 C 650.46 1037.09 719.64 958.86 924.46 720.04 M 580.03 1116.27 C 693.61 986.21 807.11 855.99 924.46 720.04 M 579.77 1122.67 C 658.03 1030.91 738.08 939.01 930.11 719.65 M 579.77 1122.67 C 698.11 986.73 815.57 851.13 930.11 719.65 M 580.17 1128.31 C 719.41 969.28 858.43 808.72 935.09 720.01 M 580.17 1128.31 C 704.57 987.81 828.38 845.78 935.09 720.01 M 582.53 1131.69 C 662.78 1036.73 743.72 943.34 940.08 720.37 M 582.53 1131.69 C 661.17 1041.41 738.31 952.72 940.08 720.37 M 587.52 1132.05 C 722.36 976.21 857.31 820.37 945.72 719.98 M 587.52 1132.05 C 714.63 986.2 842.35 838.58 945.72 719.98 M 593.16 1131.65 C 729.18 973.41 864.69 817.36 950.71 720.34 M 593.16 1131.65 C 700.25 1007.48 808.37 883.02 950.71 720.34 M 598.15 1132.01 C 730.69 980.71 864.07 827.76 956.35 719.94 M 598.15 1132.01 C 728.39 980.43 858.98 829.72 956.35 719.94 M 603.79 1131.62 C 690.97 1029.39 780.87 927.52 961.34 720.3 M 603.79 1131.62 C 747.43 967.26 888.68 804.37 961.34 720.3 M 608.78 1131.98 C 749.27 970.98 890.77 809.44 966.98 719.91 M 608.78 1131.98 C 695.81 1029.84 783.44 928.96 966.98 719.91 M 613.76 1132.34 C 700.57 1033.23 785.29 935.24 971.97 720.27 M 613.76 1132.34 C 727.85 1000.43 841.35 869.68 971.97 720.27 M 619.41 1131.94 C 752.27 977.48 884.86 825.29 977.61 719.87 M 619.41 1131.94 C 704.79 1034.73 788.99 937.23 977.61 719.87 M 624.39 1132.3 C 739.96 999.45 855.18 866.71 982.6 720.23 M 624.39 1132.3 C 698.02 1048.77 770.77 965.36 982.6 720.23 M 630.04 1131.91 C 717.78 1028.91 805.7 926.61 988.24 719.84 M 630.04 1131.91 C 720.38 1028.69 809.07 926.06 988.24 719.84 M 635.02 1132.27 C 754.83 994.31 873.35 859.1 993.23 720.2 M 635.02 1132.27 C 708.67 1049.36 781.56 966.03 993.23 720.2 M 640.67 1131.87 C 737.71 1024.75 832.3 914.65 998.87 719.8 M 640.67 1131.87 C 765.98 987.09 892.75 842.5 998.87 719.8 M 645.65 1132.23 C 733.44 1028.86 823.25 926.4 1002.55 721.67 M 645.65 1132.23 C 786.07 972.5 925.64 810.74 1002.55 721.67 M 651.3 1131.84 C 749.36 1020.95 847.02 909.02 1002.29 728.07 M 651.3 1131.84 C 754.07 1013.19 856.63 894.85 1002.29 728.07 M 656.28 1132.2 C 768.29 1005.16 880.96 874.86 1002.03 734.47 M 656.28 1132.2 C 746.41 1031.49 834.75 928.86 1002.03 734.47 M 661.93 1131.81 C 744.2 1037.41 827.47 941.06 1002.42 740.11 M 661.93 1131.81 C 789.08 984.37 918 836.37 1002.42 740.11 M 666.91 1132.17 C 787.11 993.32 905.83 856.86 1002.16 746.51 M 666.91 1132.17 C 735 1054.45 802.34 976.94 1002.16 746.51 M 672.56 1131.77 C 781.68 1004.22 893.13 877.39 1002.55 752.15 M 672.56 1131.77 C 798.81 987.15 925.73 840.7 1002.55 752.15 M 677.54 1132.13 C 742.87 1056.37 809.68 980.57 1002.29 758.55 M 677.54 1132.13 C 760.12 1037.55 841.35 944 1002.29 758.55 M 683.19 1131.74 C 756.05 1049.52 828.54 967.8 1002.03 764.95 M 683.19 1131.74 C 763.14 1038.65 844.45 944.67 1002.03 764.95 M 688.17 1132.1 C 778.36 1027.2 869.45 923 1002.43 770.59 M 688.17 1132.1 C 795.89 1009.13 902.85 886.12 1002.43 770.59 M 693.82 1131.7 C 755.22 1059.44 817.27 988.91 1002.16 776.99 M 693.82 1131.7 C 754.18 1060.91 816.35 989.67 1002.16 776.99 M 698.8 1132.06 C 783.73 1032.38 870.01 934.09 1002.56 782.63 M 698.8 1132.06 C 770.12 1051.83 840.94 970.73 1002.56 782.63 M 704.45 1131.67 C 779.91 1043.88 856.77 956.95 1002.3 789.03 M 704.45 1131.67 C 823.36 995.96 942.41 858.44 1002.3 789.03 M 709.43 1132.03 C 774.69 1057.21 840.84 982.31 1002.04 795.43 M 709.43 1132.03 C 824.37 998.01 939.96 864.33 1002.04 795.43 M 715.08 1131.63 C 824.46 1002.85 933.85 876.65 1002.43 801.07 M 715.08 1131.63 C 800.75 1033.41 886.08 934.89 1002.43 801.07 M 720.06 1131.99 C 833.9 1002.72 944.76 874.36 1002.17 807.47 M 720.06 1131.99 C 812.52 1027.93 903.97 922.42 1002.17 807.47 M 725.05 1132.35 C 808.99 1036.88 890.36 943.88 1002.56 813.11 M 725.05 1132.35 C 808.7 1035.3 892.16 938.74 1002.56 813.11 M 730.69 1131.96 C 800.97 1050.55 870.56 971.1 1002.3 819.51 M 730.69 1131.96 C 791.93 1062.77 852.15 992.48 1002.3 819.51 M 735.68 1132.32 C 819.06 1035.64 901.95 941.3 1002.04 825.91 M 735.68 1132.32 C 816.91 1040.98 896.66 949.22 1002.04 825.91 M 741.32 1131.92 C 821.73 1037.44 903.32 945.26 1002.44 831.55 M 741.32 1131.92 C 825.19 1035.65 908.63 938.86 1002.44 831.55 M 746.31 1132.28 C 809.84 1059.07 871.72 986.39 1002.17 837.95 M 746.31 1132.28 C 831.5 1034.41 915.42 937.17 1002.17 837.95 M 751.95 1131.89 C 806.04 1067.26 859.66 1005.74 1002.57 843.59 M 751.95 1131.89 C 842.29 1028.63 932.21 924.02 1002.57 843.59 M 756.94 1132.25 C 839.36 1038.05 921.83 942.32 1002.31 849.99 M 756.94 1132.25 C 832.58 1043.79 909.35 955.28 1002.31 849.99 M 762.58 1131.86 C 835.65 1047.97 910.02 962.54 1002.05 856.39 M 762.58 1131.86 C 836.18 1047.72 908.21 964.83 1002.05 856.39 M 767.57 1132.22 C 843.42 1045.88 918.54 957.96 1002.44 862.03 M 767.57 1132.22 C 845.56 1045.58 921.67 957.58 1002.44 862.03 M 773.21 1131.82 C 829.62 1063.18 888.03 997.41 1002.18 868.43 M 773.21 1131.82 C 822.4 1074.23 872.21 1016.51 1002.18 868.43 M 778.2 1132.18 C 854.09 1043.54 932.25 953.88 1002.57 874.07 M 778.2 1132.18 C 849.24 1050.67 920.28 968.58 1002.57 874.07 M 783.84 1131.79 C 826.84 1082.31 870.53 1029.59 1002.31 880.47 M 783.84 1131.79 C 829.09 1079.25 874.38 1027.1 1002.31 880.47 M 788.83 1132.15 C 847.12 1067.37 903.62 1001.99 1002.05 886.87 M 788.83 1132.15 C 833.31 1083.5 876.15 1033.68 1002.05 886.87 M 794.48 1131.75 C 841.96 1074.01 894.2 1017.03 1002.45 892.51 M 794.48 1131.75 C 853.27 1064.63 911.14 997.23 1002.45 892.51 M 799.46 1132.11 C 869.75 1050.03 940.46 969.32 1002.18 898.91 M 799.46 1132.11 C 873.77 1046.69 946.36 961.73 1002.18 898.91 M 805.11 1131.72 C 870.44 1056.95 933.73 982.48 1002.58 904.55 M 805.11 1131.72 C 857.76 1072.72 910.69 1011.74 1002.58 904.55 M 810.09 1132.08 C 879.39 1054.39 946.72 977.72 1002.32 910.95 M 810.09 1132.08 C 877.9 1054.06 945.06 974.99 1002.32 910.95 M 815.74 1131.68 C 884.64 1050.86 955.19 969.75 1002.06 917.35 M 815.74 1131.68 C 873.19 1065.79 930.59 999.58 1002.06 917.35 M 820.72 1132.04 C 866.53 1076.41 913.45 1020.67 1002.45 922.99 M 820.72 1132.04 C 890.64 1051.34 961.3 970.99 1002.45 922.99 M 826.37 1131.65 C 886.8 1060.75 949.78 990.75 1002.19 929.39 M 826.37 1131.65 C 893.07 1056.63 957.42 982.74 1002.19 929.39 M 831.35 1132.01 C 894.54 1060.97 956.13 990.23 1002.58 935.03 M 831.35 1132.01 C 872.29 1083.55 914.16 1035.14 1002.58 935.03 M 837 1131.61 C 901.25 1056.91 963.66 985.07 1002.32 941.43 M 837 1131.61 C 890.52 1067.64 946.06 1004.45 1002.32 941.43 M 841.98 1131.97 C 898.08 1067.15 954.94 1003.18 1002.06 947.83 M 841.98 1131.97 C 902.32 1061.31 963.73 991.48 1002.06 947.83 M 846.97 1132.33 C 887.61 1088.51 927.78 1043.11 1002.46 953.47 M 846.97 1132.33 C 891.81 1081.08 936.82 1028.03 1002.46 953.47 M 852.61 1131.94 C 888.78 1094.19 921.1 1052.66 1002.19 959.87 M 852.61 1131.94 C 885.49 1096.16 916.99 1058.23 1002.19 959.87 M 857.6 1132.3 C 904.52 1078.67 948.98 1026.07 1002.59 965.51 M 857.6 1132.3 C 897.13 1087.93 936.56 1043.62 1002.59 965.51 M 863.24 1131.91 C 918.34 1067.67 972.59 1007.01 1002.33 971.91 M 863.24 1131.91 C 893.8 1096.79 926.95 1059.46 1002.33 971.91 M 868.23 1132.27 C 915.19 1078.3 962.74 1021.94 1002.07 978.3 M 868.23 1132.27 C 905.48 1086.99 944.49 1043.73 1002.07 978.3 M 873.87 1131.87 C 924.04 1073.09 972.03 1017.52 1002.46 983.95 M 873.87 1131.87 C 912.39 1090.09 947.16 1049.96 1002.46 983.95 M 878.86 1132.23 C 922.36 1085.34 962.83 1035.63 1002.2 990.35 M 878.86 1132.23 C 916 1089.35 953.22 1046.32 1002.2 990.35 M 884.5 1131.84 C 920.29 1090.68 955.69 1051.25 1002.59 995.99 M 884.5 1131.84 C 917.47 1092.84 952.53 1054.25 1002.59 995.99 M 889.49 1132.2 C 919.38 1096.22 953.55 1057.76 1002.33 1002.39 M 889.49 1132.2 C 920.18 1099.18 950.82 1064.55 1002.33 1002.39 M 895.13 1131.8 C 935.93 1082.77 977.29 1035.15 1002.07 1008.78 M 895.13 1131.8 C 931.37 1090.34 967.37 1047.52 1002.07 1008.78 M 900.12 1132.16 C 936.6 1089.07 973.07 1048.85 1002.47 1014.43 M 900.12 1132.16 C 927.5 1099.27 956.67 1067.35 1002.47 1014.43 M 905.76 1131.77 C 934.53 1097.51 963.88 1065.07 1002.2 1020.82 M 905.76 1131.77 C 941.52 1088.95 980.52 1046.88 1002.2 1020.82 M 910.75 1132.13 C 931.39 1108.21 950.44 1088.46 1002.6 1026.47 M 910.75 1132.13 C 931.91 1107.24 953.79 1082.27 1002.6 1026.47 M 916.39 1131.73 C 947.54 1096.06 978.81 1062.18 1002.34 1032.87 M 916.39 1131.73 C 946.33 1096.64 975.84 1061.27 1002.34 1032.87 M 921.38 1132.09 C 938.49 1115.29 954.05 1096.02 1002.08 1039.26 M 921.38 1132.09 C 950.19 1100.27 977.24 1066.66 1002.08 1039.26 M 927.02 1131.7 C 953.54 1103.67 978.45 1074.72 1002.47 1044.91 M 927.02 1131.7 C 943.82 1112.06 960.83 1092.97 1002.47 1044.91 M 932.01 1132.06 C 945.54 1116.36 959.83 1096.85 1002.21 1051.3 M 932.01 1132.06 C 950.92 1109.92 969.7 1087.92 1002.21 1051.3 M 937.65 1131.66 C 956.14 1109.72 975.41 1087.28 1002.6 1056.95 M 937.65 1131.66 C 962.18 1105 985.03 1077.9 1002.6 1056.95 M 942.64 1132.02 C 954.01 1114.88 970.02 1102.87 1002.34 1063.35 M 942.64 1132.02 C 962.55 1108.86 982.96 1086.68 1002.34 1063.35 M 948.28 1131.63 C 964.46 1114.72 982.35 1093.44 1002.08 1069.74 M 948.28 1131.63 C 969.65 1108.76 990.35 1085.4 1002.08 1069.74 M 953.27 1131.99 C 968.22 1116.39 981.51 1095.88 1002.47 1075.39 M 953.27 1131.99 C 967.53 1114.35 982.99 1098.43 1002.47 1075.39 M 958.26 1132.35 C 971.69 1114.41 986.74 1096.18 1002.21 1081.78 M 958.26 1132.35 C 970.98 1117.77 983.75 1104.51 1002.21 1081.78 M 963.9 1131.95 C 974.39 1120.95 986.02 1105.08 1002.61 1087.43 M 963.9 1131.95 C 975.17 1119.88 986.07 1106.18 1002.61 1087.43 M 968.89 1132.31 C 974.63 1125.12 981.9 1117.87 1002.35 1093.82 M 968.89 1132.31 C 979.7 1120.26 990.27 1107.52 1002.35 1093.82 M 974.53 1131.92 C 981.65 1123.92 985.83 1117.07 1002.08 1100.22 M 974.53 1131.92 C 984.05 1119.71 993.92 1108.04 1002.08 1100.22 M 979.52 1132.28 C 986.8 1121.09 996.84 1111.94 1002.48 1105.87 M 979.52 1132.28 C 986.2 1124.81 993.59 1116.34 1002.48 1105.87 M 985.16 1131.89 C 990.63 1125.37 999.57 1118.42 1002.22 1112.26 M 985.16 1131.89 C 992.75 1124.88 999.06 1117.39 1002.22 1112.26 M 990.15 1132.25 C 993.73 1127.53 999.77 1120.62 1001.96 1118.66 M 990.15 1132.25 C 994.05 1126.64 998.26 1122.19 1001.96 1118.66 M 995.79 1131.85 C 997.69 1130.17 999.26 1128.72 1002.35 1124.3 M 995.79 1131.85 C 998.29 1129.06 1000.52 1126.7 1002.35 1124.3" fill="none" stroke="#b3a9b8" stroke-width="0.5" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 580 720 C 704.54 721.36 830.45 722.1 1000 720 M 580 720 C 713.74 721.05 847.31 721.07 1000 720 M 1000 720 C 1001.28 843.88 1001.65 970.4 1000 1130 M 1000 720 C 1001.11 883.15 1001.19 1046.81 1000 1130 M 1000 1130 C 894.48 1128.49 789.03 1128.07 580 1130 M 1000 1130 C 903.13 1128.87 805.83 1128.58 580 1130 M 580 1130 C 578.44 978.5 578.75 826.04 580 720 M 580 1130 C 582.29 970.61 581.96 811.65 580 720" fill="none" stroke="rgb(0, 0, 0)" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><rect x="400" y="80" width="620" height="220" fill="none" stroke="none" pointer-events="all"/><path d="M 400.02 79.98 C 400.02 79.98 400.02 79.98 400.02 79.98 M 400.02 79.98 C 400.02 79.98 400.02 79.98 400.02 79.98 M 399.76 86.37 C 400.99 83.97 404.26 82.27 405.01 80.34 M 399.76 86.37 C 401.14 84.14 402.89 82.51 405.01 80.34 M 400.15 92.02 C 402.61 88.35 403.77 86.02 410.65 79.94 M 400.15 92.02 C 403.96 86.93 407.76 84.03 410.65 79.94 M 399.89 98.41 C 404.71 95.08 407.04 89.14 415.64 80.3 M 399.89 98.41 C 403.27 93.95 408.59 87.59 415.64 80.3 M 400.29 104.06 C 405.39 96.76 414.54 87.19 421.28 79.91 M 400.29 104.06 C 407.96 95.76 414.05 87.13 421.28 79.91 M 400.03 110.46 C 406.98 102.77 413.97 98.05 426.27 80.27 M 400.03 110.46 C 407.61 102.65 415.15 92.78 426.27 80.27 M 399.76 116.85 C 410.76 104.26 422.79 89.03 431.91 79.87 M 399.76 116.85 C 406.14 109.72 412.58 100.76 431.91 79.87 M 400.16 122.5 C 409.47 109.21 420.49 96.84 436.9 80.23 M 400.16 122.5 C 414.49 105.42 429.56 90.07 436.9 80.23 M 399.9 128.89 C 413.36 113.67 427.72 94.92 442.54 79.84 M 399.9 128.89 C 416.19 110.77 432.46 91.28 442.54 79.84 M 400.29 134.54 C 414.69 120.32 427.63 102.31 447.53 80.2 M 400.29 134.54 C 415.14 117.94 428.17 101.29 447.53 80.2 M 400.03 140.94 C 420.5 120.26 438.43 98.99 453.17 79.8 M 400.03 140.94 C 415.4 124.94 428.53 107.69 453.17 79.8 M 399.77 147.33 C 413.45 128.61 428.91 113.67 458.16 80.16 M 399.77 147.33 C 417.04 127.75 434.02 108.3 458.16 80.16 M 400.16 152.98 C 420.81 129.63 440.85 102.84 463.8 79.77 M 400.16 152.98 C 423.35 127.48 444.98 101.05 463.8 79.77 M 399.9 159.37 C 425.58 126.82 452.34 98.25 468.79 80.13 M 399.9 159.37 C 418.94 137.91 439.35 114.68 468.79 80.13 M 400.3 165.02 C 426.84 134.32 449.15 106.03 474.43 79.73 M 400.3 165.02 C 425.7 138.68 449.33 109.95 474.43 79.73 M 400.04 171.41 C 420.96 146.89 442.02 127.42 479.42 80.09 M 400.04 171.41 C 415.62 153.24 432.95 133.46 479.42 80.09 M 399.77 177.81 C 423.69 152.2 445.94 122.8 485.06 79.7 M 399.77 177.81 C 419.71 154.65 440.73 129.51 485.06 79.7 M 400.17 183.46 C 421.54 157.97 441.5 133.49 490.05 80.06 M 400.17 183.46 C 420.21 161.3 440.71 137.16 490.05 80.06 M 399.91 189.85 C 435.26 149.19 467.63 112.99 495.69 79.67 M 399.91 189.85 C 422.34 163.76 445.31 137.06 495.69 79.67 M 400.3 195.5 C 427.55 165.95 449.88 137.44 500.68 80.03 M 400.3 195.5 C 431.23 159.86 464.18 121.98 500.68 80.03 M 400.04 201.89 C 429.77 168.22 457 138.25 506.32 79.63 M 400.04 201.89 C 425.36 170.87 452.11 142.37 506.32 79.63 M 399.78 208.29 C 429.84 172.85 461.62 138.97 511.31 79.99 M 399.78 208.29 C 426.7 175.09 457.37 140.76 511.31 79.99 M 400.17 213.94 C 444.04 163.01 487.32 115.3 516.3 80.35 M 400.17 213.94 C 423.8 184.98 448.42 156.48 516.3 80.35 M 399.91 220.33 C 442.37 171.19 486.61 118.62 521.94 79.96 M 399.91 220.33 C 432.89 181.21 466.11 142.53 521.94 79.96 M 400.31 225.98 C 440.33 175.8 481.97 128.03 526.93 80.32 M 400.31 225.98 C 439.79 181.04 478.79 136.36 526.93 80.32 M 400.04 232.37 C 428.78 197.02 460.86 161.86 532.57 79.92 M 400.04 232.37 C 449.29 176.11 500.77 116.86 532.57 79.92 M 399.78 238.77 C 432.82 199.87 467.05 160.81 537.56 80.28 M 399.78 238.77 C 443.64 187.26 486.65 136.48 537.56 80.28 M 400.18 244.41 C 444.71 191.98 491.41 140.13 543.2 79.89 M 400.18 244.41 C 434.27 205.14 467.68 167.6 543.2 79.89 M 399.92 250.81 C 453.05 190.84 503.54 132.48 548.19 80.25 M 399.92 250.81 C 438.77 206.81 476.98 161.94 548.19 80.25 M 400.31 256.46 C 450.6 201.94 500.64 144.47 553.83 79.85 M 400.31 256.46 C 446.34 205.2 491.53 152.07 553.83 79.85 M 400.05 262.85 C 449.01 204.72 502.44 143.39 558.82 80.21 M 400.05 262.85 C 455.92 198.89 512.25 134.57 558.82 80.21 M 399.79 269.25 C 436.41 226.66 474.14 184.1 564.46 79.82 M 399.79 269.25 C 443.31 219.99 486 171.19 564.46 79.82 M 400.18 274.89 C 459.42 205.96 517 140.49 569.45 80.18 M 400.18 274.89 C 440.91 228.38 481.2 180.92 569.45 80.18 M 399.92 281.29 C 451.63 222.61 501.66 163.1 575.09 79.78 M 399.92 281.29 C 437.98 237.01 477.45 192.88 575.09 79.78 M 400.32 286.93 C 447.75 232.6 495.09 178.71 580.08 80.14 M 400.32 286.93 C 469.78 206.39 538.38 125.03 580.08 80.14 M 400.05 293.33 C 446.68 234.46 495.59 180.74 585.72 79.75 M 400.05 293.33 C 456.63 227.49 512.8 162.39 585.72 79.75 M 399.79 299.73 C 440.18 252.83 481.63 207.98 590.71 80.11 M 399.79 299.73 C 453.57 238.95 507.63 177.77 590.71 80.11 M 402.81 302.35 C 473.31 220.11 542.77 139.11 596.35 79.72 M 402.81 302.35 C 453.09 243.93 502.23 185.82 596.35 79.72 M 407.8 302.71 C 449.22 253.36 491.04 207.49 601.34 80.08 M 407.8 302.71 C 447.74 256.47 488.44 208.46 601.34 80.08 M 413.44 302.32 C 472.36 235.14 530.47 165.97 606.98 79.68 M 413.44 302.32 C 460.05 249.4 505.29 197.67 606.98 79.68 M 418.43 302.68 C 487.41 222.65 553.16 146.05 611.97 80.04 M 418.43 302.68 C 478.09 233.69 537.36 164.29 611.97 80.04 M 424.07 302.29 C 477.28 242.54 528.57 182.76 617.61 79.65 M 424.07 302.29 C 465.25 251.35 508.77 201.78 617.61 79.65 M 429.06 302.65 C 472.71 250.85 516.31 202.3 622.6 80.01 M 429.06 302.65 C 488.75 233.72 548.52 164.02 622.6 80.01 M 434.7 302.25 C 497.08 228.53 560.26 157.33 627.58 80.37 M 434.7 302.25 C 474.26 255.44 513.89 209.37 627.58 80.37 M 439.69 302.61 C 491.7 241.16 546.65 178.31 633.23 79.97 M 439.69 302.61 C 510.83 218.11 583.35 136.86 633.23 79.97 M 445.33 302.22 C 490.05 249.22 536.99 197.55 638.21 80.33 M 445.33 302.22 C 485.21 255.34 527.35 207.58 638.21 80.33 M 450.32 302.58 C 501.37 242.28 550.56 184.66 643.86 79.94 M 450.32 302.58 C 500.88 244.92 552.01 186.03 643.86 79.94 M 455.96 302.18 C 496.82 254.76 538.97 205.12 648.84 80.3 M 455.96 302.18 C 509.4 239.52 561.84 177.68 648.84 80.3 M 460.95 302.54 C 536.68 213.15 611.44 126.06 654.49 79.9 M 460.95 302.54 C 536.31 213.96 611.17 127.62 654.49 79.9 M 466.59 302.15 C 541.89 218.19 616.41 130.74 659.47 80.26 M 466.59 302.15 C 513.69 246.37 562.66 190.9 659.47 80.26 M 471.58 302.51 C 544.34 219.6 615.19 135.61 665.12 79.87 M 471.58 302.51 C 542.92 223.46 611.71 144.18 665.12 79.87 M 477.22 302.11 C 543.38 225.06 610.16 149.75 670.1 80.23 M 477.22 302.11 C 517.1 257.11 556.1 211.26 670.1 80.23 M 482.21 302.47 C 558.24 214.36 633.92 126.11 675.75 79.83 M 482.21 302.47 C 521.71 255.14 560.77 209.97 675.75 79.83 M 487.85 302.08 C 557.06 224.23 627.12 143.72 680.73 80.19 M 487.85 302.08 C 534.13 249.94 579.42 197.13 680.73 80.19 M 492.84 302.44 C 556.15 232.89 616.02 161.15 686.38 79.8 M 492.84 302.44 C 565.33 219.06 638.2 135.83 686.38 79.8 M 498.48 302.04 C 573.89 214.85 647.92 127.11 691.36 80.16 M 498.48 302.04 C 548 246.13 594.75 190.12 691.36 80.16 M 503.47 302.4 C 558.38 239.13 612.77 176.04 697.01 79.77 M 503.47 302.4 C 571.39 226.26 638.86 149.12 697.01 79.77 M 508.46 302.76 C 561.75 240.41 616.29 178.9 701.99 80.13 M 508.46 302.76 C 581.86 220.14 654 136.21 701.99 80.13 M 514.1 302.37 C 578.06 229.58 642.32 153.27 707.64 79.73 M 514.1 302.37 C 590.04 213.99 667.19 125.56 707.64 79.73 M 519.09 302.73 C 585.74 227.38 653.61 151.91 712.62 80.09 M 519.09 302.73 C 588.74 222.25 658.75 141.22 712.62 80.09 M 524.73 302.34 C 598.69 218.13 673.2 134.01 718.27 79.7 M 524.73 302.34 C 571.46 247.4 619.54 192.21 718.27 79.7 M 529.72 302.7 C 603.09 218.9 676.75 133.19 723.25 80.06 M 529.72 302.7 C 602.69 215.53 677.58 131.38 723.25 80.06 M 535.36 302.3 C 612.88 212.33 689.85 126.04 728.9 79.66 M 535.36 302.3 C 578.54 253.64 618.84 206.37 728.9 79.66 M 540.35 302.66 C 593.38 242.41 643.39 185.15 733.88 80.02 M 540.35 302.66 C 581.56 254.28 622.98 206.28 733.88 80.02 M 545.99 302.27 C 597.49 243.39 649.84 181.35 739.53 79.63 M 545.99 302.27 C 594.53 247.59 640.51 193.44 739.53 79.63 M 550.98 302.63 C 623.72 218.5 697.79 135.49 744.51 79.99 M 550.98 302.63 C 601.39 242.02 652.82 182.9 744.51 79.99 M 556.62 302.23 C 624.56 226.69 689.95 149.98 749.5 80.35 M 556.62 302.23 C 615.62 237.18 674.86 169.44 749.5 80.35 M 561.61 302.59 C 627.33 224.69 696.39 143.64 755.14 79.95 M 561.61 302.59 C 632.43 221.55 700.74 142.48 755.14 79.95 M 567.25 302.2 C 618.82 242.78 670.19 182.56 760.13 80.31 M 567.25 302.2 C 639.28 220.94 710.25 139.15 760.13 80.31 M 572.24 302.56 C 631.21 231.17 691.46 163.51 765.77 79.92 M 572.24 302.56 C 635.59 228.61 700.6 154.99 765.77 79.92 M 577.88 302.16 C 645.17 224.36 709.79 149.05 770.76 80.28 M 577.88 302.16 C 627.46 248.27 674.42 193.07 770.76 80.28 M 582.87 302.52 C 636.38 240.76 689.26 181.36 776.4 79.88 M 582.87 302.52 C 629.22 245.64 678.66 189.9 776.4 79.88 M 588.51 302.13 C 659.37 222.03 730.85 140.33 781.39 80.24 M 588.51 302.13 C 657.57 222.26 725.65 143.84 781.39 80.24 M 593.5 302.49 C 655.93 232.08 714.94 164.88 787.03 79.85 M 593.5 302.49 C 667.03 216.44 743.24 129.35 787.03 79.85 M 599.14 302.09 C 645.33 250.8 690.4 199.58 792.02 80.21 M 599.14 302.09 C 661.85 226.42 726.35 153.43 792.02 80.21 M 604.13 302.45 C 641.55 257.85 682.44 211.99 797.66 79.81 M 604.13 302.45 C 652.58 246.95 701.39 191.53 797.66 79.81 M 609.77 302.06 C 663.93 239.42 721.2 174 802.65 80.17 M 609.77 302.06 C 656.23 248.37 701.9 196.49 802.65 80.17 M 614.76 302.42 C 653.87 257.63 692.95 212.2 808.3 79.78 M 614.76 302.42 C 684.03 223.59 750.41 146.83 808.3 79.78 M 619.74 302.78 C 694.71 220.37 765.92 135.26 813.28 80.14 M 619.74 302.78 C 684.76 227.54 751.21 150.67 813.28 80.14 M 625.39 302.39 C 672.68 250.7 716.99 199.74 818.93 79.75 M 625.39 302.39 C 667.78 253.77 710.38 205.09 818.93 79.75 M 630.37 302.75 C 673.26 254.22 717.38 204.49 823.91 80.11 M 630.37 302.75 C 697.64 223.39 765.03 146.39 823.91 80.11 M 636.02 302.35 C 697.08 232.64 757.13 161.15 829.56 79.71 M 636.02 302.35 C 678.97 253.89 719.68 205.81 829.56 79.71 M 641 302.71 C 684.45 251.53 729.33 200.48 834.54 80.07 M 641 302.71 C 710.88 222.74 781.42 141.76 834.54 80.07 M 646.65 302.32 C 712.07 228 775.93 156.15 840.19 79.68 M 646.65 302.32 C 705.7 232.41 767.74 162.5 840.19 79.68 M 651.63 302.68 C 706.91 240.49 760.58 178.27 845.17 80.04 M 651.63 302.68 C 712.15 230.26 774.81 159.25 845.17 80.04 M 657.28 302.28 C 709.11 240.8 761.06 182.12 850.82 79.64 M 657.28 302.28 C 716.08 236.45 775.57 169.12 850.82 79.64 M 662.27 302.64 C 726.06 228.41 792.45 151.04 855.8 80 M 662.27 302.64 C 735.16 219.23 806.55 135.26 855.8 80 M 667.91 302.25 C 740.72 218.2 815.46 132.09 860.79 80.36 M 667.91 302.25 C 745.74 214.31 821.36 126.44 860.79 80.36 M 672.9 302.61 C 722.78 246.25 772.8 187.93 866.43 79.97 M 672.9 302.61 C 728.37 235.98 784.91 171.58 866.43 79.97 M 678.54 302.21 C 717.22 257.73 758.67 211.45 871.42 80.33 M 678.54 302.21 C 721.24 254.13 762.68 204.89 871.42 80.33 M 683.53 302.57 C 754.89 220.52 822.54 140.57 877.06 79.93 M 683.53 302.57 C 734.57 245.18 784.59 186.19 877.06 79.93 M 689.17 302.18 C 760.58 223.46 829.89 140.89 882.05 80.29 M 689.17 302.18 C 730.57 252.74 772.84 204.11 882.05 80.29 M 694.16 302.54 C 745.37 243.73 794.57 183.66 887.69 79.9 M 694.16 302.54 C 750.01 237.16 807.6 171.97 887.69 79.9 M 699.8 302.14 C 767.55 221.57 836.47 143.14 892.68 80.26 M 699.8 302.14 C 750.85 242.89 802.4 185.44 892.68 80.26 M 704.79 302.5 C 754.63 244.99 805.12 188.67 898.32 79.86 M 704.79 302.5 C 744.7 255.53 785.72 208.06 898.32 79.86 M 710.43 302.11 C 779.12 221.79 849.49 144.39 903.31 80.22 M 710.43 302.11 C 757.3 247.22 803.62 194.45 903.31 80.22 M 715.42 302.47 C 771.77 233.12 831.51 165.9 908.95 79.83 M 715.42 302.47 C 765.66 246.12 814.71 189.94 908.95 79.83 M 721.06 302.07 C 767.86 246.97 813.08 194.72 913.94 80.19 M 721.06 302.07 C 771.38 245.43 820.19 189.69 913.94 80.19 M 726.05 302.43 C 779.05 243.41 830.13 184.47 919.58 79.8 M 726.05 302.43 C 784.21 236.81 842.36 169.7 919.58 79.8 M 731.69 302.04 C 797.14 227.81 863.92 151.15 924.57 80.16 M 731.69 302.04 C 774.41 250.18 817.68 199.93 924.57 80.16 M 736.68 302.4 C 791.39 239.88 847.41 176.67 930.21 79.76 M 736.68 302.4 C 777.55 255.23 819.99 206.84 930.21 79.76 M 741.66 302.76 C 796.46 240.37 851.54 175.39 935.2 80.12 M 741.66 302.76 C 799.74 234.52 857.61 168.51 935.2 80.12 M 747.31 302.37 C 815.49 224.39 886.72 142.03 940.84 79.73 M 747.31 302.37 C 808.3 233 868.39 162.73 940.84 79.73 M 752.29 302.73 C 828.52 216.66 904.4 131.49 945.83 80.09 M 752.29 302.73 C 796.74 251.63 840.37 201.28 945.83 80.09 M 757.94 302.33 C 832.75 213.82 912.09 124.49 951.47 79.69 M 757.94 302.33 C 817.75 235.16 875.99 167.5 951.47 79.69 M 762.92 302.69 C 806.38 253.2 851.09 201.28 956.46 80.05 M 762.92 302.69 C 803.46 258.77 842.42 212.94 956.46 80.05 M 768.57 302.3 C 840.29 218.47 915.95 134.43 962.1 79.66 M 768.57 302.3 C 834.12 227.75 899.18 153.12 962.1 79.66 M 773.55 302.66 C 826.97 240.76 883.28 179.75 967.09 80.02 M 773.55 302.66 C 814.19 254.22 855.33 207.16 967.09 80.02 M 779.2 302.26 C 847.25 224.85 918.53 143.32 972.73 79.62 M 779.2 302.26 C 849.79 221.3 919.03 140.84 972.73 79.62 M 784.18 302.62 C 837.8 239.09 895.24 173.05 977.72 79.98 M 784.18 302.62 C 836.37 242.04 890.39 180.33 977.72 79.98 M 789.83 302.23 C 843.23 240.23 897.35 175.96 982.71 80.34 M 789.83 302.23 C 856.86 222.29 925.58 143.97 982.71 80.34 M 794.81 302.59 C 851.05 236.53 909.24 171.13 988.35 79.95 M 794.81 302.59 C 839.81 252.16 884.7 201 988.35 79.95 M 800.46 302.19 C 872.73 220.29 942.69 139.44 993.34 80.31 M 800.46 302.19 C 862.05 232.07 922.01 161.22 993.34 80.31 M 805.44 302.55 C 845.97 253.68 885.68 207.79 998.98 79.91 M 805.44 302.55 C 868.33 228.31 931.91 155.27 998.98 79.91 M 811.09 302.16 C 872.84 230.83 933.75 160.89 1003.97 80.27 M 811.09 302.16 C 860.27 247.05 908.43 190.45 1003.97 80.27 M 816.07 302.52 C 856.89 254.35 900.43 206.34 1009.61 79.88 M 816.07 302.52 C 863.94 249.29 911.35 195.28 1009.61 79.88 M 821.72 302.12 C 886.91 230.65 949.02 159.35 1014.6 80.24 M 821.72 302.12 C 897.31 213.3 973.86 124.46 1014.6 80.24 M 826.7 302.48 C 864.97 255.88 905.59 208.63 1020.24 79.85 M 826.7 302.48 C 878.07 241.5 930.05 182.95 1020.24 79.85 M 832.35 302.09 C 878.96 247.8 924.85 195.37 1019.98 86.24 M 832.35 302.09 C 870.46 255.64 908.48 210.85 1019.98 86.24 M 837.33 302.45 C 897.05 234.29 958.95 165.39 1020.37 91.89 M 837.33 302.45 C 893.91 238.72 951.27 173.27 1020.37 91.89 M 842.98 302.06 C 885.16 255.17 928.54 204.08 1020.11 98.28 M 842.98 302.06 C 906.47 229.72 967.42 158.94 1020.11 98.28 M 847.96 302.42 C 884.57 258.96 919.19 217.04 1019.85 104.68 M 847.96 302.42 C 901.17 244.06 953.36 183.27 1019.85 104.68 M 852.95 302.78 C 907.29 238.77 959.68 176.84 1020.25 110.32 M 852.95 302.78 C 904.31 245.1 956.24 185.39 1020.25 110.32 M 858.59 302.38 C 921.97 229.41 985.86 154.2 1019.98 116.72 M 858.59 302.38 C 920.55 231.67 981.96 159.48 1019.98 116.72 M 863.58 302.74 C 898.87 262.54 932.01 222.38 1020.38 122.37 M 863.58 302.74 C 925.24 230.43 987.81 158.85 1020.38 122.37 M 869.22 302.35 C 908.87 254.75 947.06 210.38 1020.12 128.76 M 869.22 302.35 C 920.06 245.32 972.29 185.54 1020.12 128.76 M 874.21 302.71 C 917.16 253.09 962.5 202.33 1019.86 135.16 M 874.21 302.71 C 922.65 246.93 972.92 191.01 1019.86 135.16 M 879.85 302.31 C 922.12 254.22 961.28 205.57 1020.25 140.8 M 879.85 302.31 C 925.36 247.87 972.75 193.3 1020.25 140.8 M 884.84 302.67 C 919.53 263.48 954.19 222.17 1019.99 147.2 M 884.84 302.67 C 922.1 260.21 958.25 216.96 1019.99 147.2 M 890.48 302.28 C 927.83 260.08 963.22 220.26 1020.38 152.84 M 890.48 302.28 C 940.59 246.05 990.49 187.74 1020.38 152.84 M 895.47 302.64 C 924.6 270.89 951.45 237.4 1020.12 159.24 M 895.47 302.64 C 941.41 250.37 988.78 196.8 1020.12 159.24 M 901.11 302.24 C 926.48 270.84 954.86 240.68 1019.86 165.64 M 901.11 302.24 C 938.21 257.45 975.99 215.43 1019.86 165.64 M 906.1 302.6 C 937.93 266.84 966.57 234.04 1020.26 171.28 M 906.1 302.6 C 929.75 273.76 955.3 245.5 1020.26 171.28 M 911.74 302.21 C 942.27 269.24 971.93 232.41 1019.99 177.68 M 911.74 302.21 C 950.93 257.6 989.44 213.29 1019.99 177.68 M 916.73 302.57 C 945.37 272.04 970.28 238.3 1020.39 183.32 M 916.73 302.57 C 938.22 276.65 958.3 251.82 1020.39 183.32 M 922.37 302.17 C 948.32 276.21 970.5 245.78 1020.13 189.72 M 922.37 302.17 C 960.52 259.57 997.86 217.31 1020.13 189.72 M 927.36 302.53 C 950.84 276.18 970.27 253.03 1019.87 196.12 M 927.36 302.53 C 960.58 262.94 994.41 224.73 1019.87 196.12 M 933 302.14 C 951.08 278.38 972.82 259.06 1020.26 201.76 M 933 302.14 C 955.2 274.65 978.46 248.74 1020.26 201.76 M 937.99 302.5 C 960.6 275.65 979.87 251.39 1020 208.16 M 937.99 302.5 C 964.81 271.22 990.88 240.24 1020 208.16 M 943.63 302.1 C 969.7 272.08 996.14 241.55 1019.74 214.56 M 943.63 302.1 C 966.19 276.82 988.51 250.94 1019.74 214.56 M 948.62 302.47 C 971.16 279.64 990.32 253.53 1020.13 220.2 M 948.62 302.47 C 972.39 275.4 997.49 245.79 1020.13 220.2 M 954.26 302.07 C 976.8 279.25 994.41 255.04 1019.87 226.6 M 954.26 302.07 C 966.06 286.92 980.22 272.12 1019.87 226.6 M 959.25 302.43 C 981.89 274.8 1002.55 249.19 1020.26 232.24 M 959.25 302.43 C 976.62 282.03 995.91 260.48 1020.26 232.24 M 964.89 302.04 C 974.62 287.14 988.03 275.73 1020 238.64 M 964.89 302.04 C 982.47 281.33 1000.44 261.58 1020 238.64 M 969.88 302.4 C 978.35 291.2 989.73 276.23 1019.74 245.04 M 969.88 302.4 C 983.11 285.17 998.17 268.44 1019.74 245.04 M 974.87 302.76 C 987.2 287.74 1001.6 274.35 1020.14 250.68 M 974.87 302.76 C 992.53 282.61 1009.89 262.35 1020.14 250.68 M 980.51 302.36 C 990.63 291.82 1000.84 280.14 1019.88 257.08 M 980.51 302.36 C 988.48 292.15 998.71 283.33 1019.88 257.08 M 985.5 302.72 C 993.14 296.4 999.02 288.34 1020.27 262.72 M 985.5 302.72 C 999.68 287.24 1012.67 271.81 1020.27 262.72 M 991.14 302.33 C 1001.56 290.12 1008.93 278.55 1020.01 269.12 M 991.14 302.33 C 997 295.46 1004.96 287.13 1020.01 269.12 M 996.13 302.69 C 1003.68 294.06 1014.34 282.81 1019.75 275.52 M 996.13 302.69 C 1004.6 293.52 1012.16 284.77 1019.75 275.52 M 1001.77 302.29 C 1005.39 297.62 1009.4 291.78 1020.14 281.16 M 1001.77 302.29 C 1007.4 296.41 1012.18 290.67 1020.14 281.16 M 1006.76 302.65 C 1008.62 301.23 1012.43 294.34 1019.88 287.56 M 1006.76 302.65 C 1011.56 296.8 1017.09 290.78 1019.88 287.56 M 1012.4 302.26 C 1014.63 300.04 1017.07 298.39 1020.27 293.2 M 1012.4 302.26 C 1014.79 299.39 1017.8 297.01 1020.27 293.2 M 1017.39 302.62 C 1018.43 301.45 1018.58 300.75 1020.01 299.6 M 1017.39 302.62 C 1017.89 301.88 1018.81 301.27 1020.01 299.6" fill="none" stroke="#b3a9b8" stroke-width="0.5" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 400 80 C 638.05 79.09 875.19 79.1 1020 80 M 400 80 C 603.37 77.38 807.61 77.49 1020 80 M 1020 80 C 1019.42 166.78 1022.68 250.78 1020 300 M 1020 80 C 1019.81 125.78 1020.01 171.87 1020 300 M 1020 300 C 872.48 300.8 724.79 301.17 400 300 M 1020 300 C 883.53 298.31 746.54 298.58 400 300 M 400 300 C 399.81 249.86 398.84 196.96 400 80 M 400 300 C 399.18 218.79 399.91 135.4 400 80" fill="none" stroke="rgb(0, 0, 0)" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><rect x="0" y="10" width="380" height="340" fill="none" stroke="none" pointer-events="all"/><path d="M -0.25 10.28 C -0.25 10.28 -0.25 10.28 -0.25 10.28 M -0.25 10.28 C -0.25 10.28 -0.25 10.28 -0.25 10.28 M 0.15 15.93 C 1.41 14.05 2.23 13.83 5.4 9.89 M 0.15 15.93 C 1.6 14.1 3.05 13.04 5.4 9.89 M -0.11 22.32 C 3.6 19.25 7.66 13.55 10.38 10.25 M -0.11 22.32 C 4.27 17.58 7.56 13.09 10.38 10.25 M 0.28 27.97 C 4.74 24.09 10.88 17.16 16.03 9.85 M 0.28 27.97 C 3.9 25.07 7.09 19.66 16.03 9.85 M 0.02 34.36 C 7.47 28.86 12.39 20.56 21.01 10.21 M 0.02 34.36 C 6.42 26.69 12.73 19.99 21.01 10.21 M -0.24 40.76 C 6.52 32.22 15.14 21.78 26.66 9.82 M -0.24 40.76 C 9.36 29.32 21.04 16.49 26.66 9.82 M 0.15 46.41 C 11.3 33.84 25.71 18.89 31.64 10.18 M 0.15 46.41 C 13.14 32.94 25.22 18.78 31.64 10.18 M -0.11 52.8 C 10.68 40.46 21.24 31.22 37.29 9.78 M -0.11 52.8 C 7.73 44.03 16.03 33.38 37.29 9.78 M 0.29 58.45 C 17.17 41.75 31.67 20.62 42.27 10.14 M 0.29 58.45 C 12.22 44.24 24.06 30.47 42.27 10.14 M 0.03 64.84 C 8.07 51.89 20.67 41.64 47.92 9.75 M 0.03 64.84 C 17.12 44.14 33.61 23.86 47.92 9.75 M -0.24 71.24 C 13.27 57.08 29.86 41.31 52.9 10.11 M -0.24 71.24 C 12.37 56.72 24.05 43.12 52.9 10.11 M 0.16 76.88 C 12.5 61.69 26.93 45.81 58.55 9.72 M 0.16 76.88 C 13.76 60.51 28.55 42.7 58.55 9.72 M -0.1 83.28 C 13.25 70.29 28.2 54.09 63.53 10.08 M -0.1 83.28 C 16.61 64.13 32.12 44.94 63.53 10.08 M 0.29 88.93 C 15.9 73.04 28.47 57.34 69.18 9.68 M 0.29 88.93 C 23.19 62.69 45.37 35.93 69.18 9.68 M 0.03 95.32 C 27.22 61.76 58.23 25.68 74.16 10.04 M 0.03 95.32 C 17.88 74.85 35.88 53.65 74.16 10.04 M -0.23 101.72 C 17.76 83.44 34.89 65.13 79.81 9.65 M -0.23 101.72 C 22.72 76.93 45.29 49.87 79.81 9.65 M 0.16 107.36 C 29.69 71.5 62.73 34.48 84.8 10.01 M 0.16 107.36 C 22.97 80.55 44.89 54.37 84.8 10.01 M -0.1 113.76 C 21.08 86.37 44.04 61.24 89.78 10.37 M -0.1 113.76 C 35.75 73.84 70.11 32.61 89.78 10.37 M 0.3 119.41 C 22.88 89.37 49.21 62.04 95.43 9.97 M 0.3 119.41 C 20.17 95.63 41.6 71.77 95.43 9.97 M 0.04 125.8 C 39.85 80.25 78.21 36.94 100.41 10.33 M 0.04 125.8 C 36.12 84.27 70.04 45.38 100.41 10.33 M -0.23 132.2 C 20.82 106.85 41.64 82.26 106.06 9.94 M -0.23 132.2 C 42.5 81.92 86.37 32.86 106.06 9.94 M 0.17 137.84 C 24.55 109.1 51.27 80.8 111.04 10.3 M 0.17 137.84 C 28.26 105.48 58.13 70.77 111.04 10.3 M -0.09 144.24 C 34.78 101.73 72.76 63.26 116.69 9.9 M -0.09 144.24 C 36.25 102.83 73.2 59.81 116.69 9.9 M 0.3 149.88 C 47.58 95.67 95.06 44.44 121.67 10.26 M 0.3 149.88 C 31.46 115.72 62.53 79.2 121.67 10.26 M 0.04 156.28 C 36.28 116.03 72.29 75.78 127.32 9.87 M 0.04 156.28 C 38.35 111.61 76.18 66.69 127.32 9.87 M -0.22 162.68 C 31.32 122.97 65.19 85.89 132.3 10.23 M -0.22 162.68 C 33.71 123.87 66.71 84.14 132.3 10.23 M 0.17 168.32 C 27.21 135.9 56.78 103.86 137.95 9.83 M 0.17 168.32 C 42.63 120.82 82.61 72.75 137.95 9.83 M -0.09 174.72 C 29.66 138.5 63.1 104.37 142.93 10.19 M -0.09 174.72 C 30.87 139.76 61.92 103.74 142.93 10.19 M 0.31 180.36 C 51.36 118.98 104.96 55.32 148.58 9.8 M 0.31 180.36 C 36.74 136.33 74.29 94.77 148.58 9.8 M 0.04 186.76 C 40.17 141.12 76.98 99.36 153.56 10.16 M 0.04 186.76 C 46.87 136.08 91.17 83.77 153.56 10.16 M -0.22 193.16 C 33.36 153.74 66.25 114.14 159.21 9.77 M -0.22 193.16 C 53.34 133.68 105.09 73.88 159.21 9.77 M 0.18 198.8 C 47.44 144.87 95.86 89.88 164.19 10.13 M 0.18 198.8 C 42.78 150.06 84.53 103.5 164.19 10.13 M -0.08 205.2 C 33.5 165.03 69.71 124.43 169.84 9.73 M -0.08 205.2 C 52.09 147.15 103.42 86.92 169.84 9.73 M 0.31 210.84 C 54.32 147.67 106.05 86.68 174.82 10.09 M 0.31 210.84 C 49.94 153.97 98.03 98.83 174.82 10.09 M 0.05 217.24 C 68.52 136.53 139.65 55.62 180.47 9.7 M 0.05 217.24 C 65.77 139.77 132.74 63.77 180.47 9.7 M -0.21 223.64 C 42.8 176.64 81.77 131.41 185.45 10.06 M -0.21 223.64 C 67.56 145.08 136.85 66.48 185.45 10.06 M 0.18 229.28 C 71.99 145.71 143.44 63.01 191.1 9.66 M 0.18 229.28 C 63.4 157.69 125.18 85.71 191.1 9.66 M -0.08 235.68 C 69.31 155.87 137.62 76.39 196.08 10.02 M -0.08 235.68 C 62.64 160.53 128.47 86.17 196.08 10.02 M 0.32 241.32 C 76.74 149.41 156.22 59.99 201.73 9.63 M 0.32 241.32 C 79.27 150.82 156.02 61.16 201.73 9.63 M 0.05 247.72 C 44 197.03 88.16 147.54 206.71 9.99 M 0.05 247.72 C 79.47 155.87 158.69 65.01 206.71 9.99 M -0.21 254.12 C 46.64 198.13 96.64 143.94 211.7 10.35 M -0.21 254.12 C 78.74 161.09 159.7 68.52 211.7 10.35 M 0.19 259.76 C 64.96 185.87 129.6 113.23 217.34 9.95 M 0.19 259.76 C 78.92 169.17 157.59 77.67 217.34 9.95 M -0.07 266.16 C 62.68 193.53 126.05 120.06 222.33 10.31 M -0.07 266.16 C 74.07 179.09 150.5 91.79 222.33 10.31 M 0.32 271.8 C 62.72 199.58 126.56 125.26 227.97 9.92 M 0.32 271.8 C 72.51 190.9 144.27 107.86 227.97 9.92 M 0.06 278.2 C 75.32 190.88 154.21 100.73 232.96 10.28 M 0.06 278.2 C 75.41 191.1 152.26 104 232.96 10.28 M -0.2 284.6 C 55.65 219.66 113.18 153.88 238.6 9.88 M -0.2 284.6 C 69.14 205.14 137.84 125.42 238.6 9.88 M 0.19 290.24 C 80.78 196.83 162.25 102.32 243.59 10.24 M 0.19 290.24 C 51.54 233.51 99.89 177.11 243.59 10.24 M -0.07 296.64 C 58.23 231.38 116.41 163.45 249.23 9.85 M -0.07 296.64 C 90.11 189.92 182.47 83.41 249.23 9.85 M 0.33 302.28 C 60.85 232.9 122.64 161.59 254.22 10.21 M 0.33 302.28 C 59.79 231.92 120.87 160.98 254.22 10.21 M 0.06 308.68 C 80.78 217.71 158.85 128.78 259.86 9.81 M 0.06 308.68 C 60.65 239.8 120.34 170.73 259.86 9.81 M -0.2 315.08 C 104.2 196.19 207.87 75.12 264.85 10.18 M -0.2 315.08 C 89.69 212.75 176.94 110.39 264.85 10.18 M 0.2 320.72 C 77.14 232.1 153.21 144.99 270.49 9.78 M 0.2 320.72 C 99.95 207.97 198.73 95.08 270.49 9.78 M -0.06 327.12 C 88 225.99 175.99 125.45 275.48 10.14 M -0.06 327.12 C 104.55 206.42 209.92 86.08 275.48 10.14 M -0.33 333.52 C 108.38 204.48 219.07 78.02 281.12 9.75 M -0.33 333.52 C 78.66 239.37 159.93 146.37 281.12 9.75 M 0.07 339.16 C 94.5 232.09 189.05 122.49 286.11 10.11 M 0.07 339.16 C 85.11 240.66 169.11 143.96 286.11 10.11 M -0.19 345.56 C 69.25 262.66 139.78 182.64 291.75 9.71 M -0.19 345.56 C 93.59 239.01 185.71 133.39 291.75 9.71 M 0.86 350.45 C 98.47 239.66 194.6 128.01 296.74 10.07 M 0.86 350.45 C 61.55 281.15 123.06 211.13 296.74 10.07 M 5.85 350.81 C 69.79 275.56 136.92 198.79 302.38 9.68 M 5.85 350.81 C 120.84 219.73 235.02 88.49 302.38 9.68 M 11.49 350.41 C 130.3 215.92 249.46 80.11 307.37 10.04 M 11.49 350.41 C 85.07 263.26 159.96 177.47 307.37 10.04 M 16.48 350.77 C 110.09 242.71 205.56 134.27 313.01 9.64 M 16.48 350.77 C 85.38 270.66 155.17 190.25 313.01 9.64 M 22.12 350.38 C 86.83 273.24 153.54 197.25 318 10 M 22.12 350.38 C 136.34 218.81 250.84 87.58 318 10 M 27.11 350.74 C 116.91 248.64 206.6 146.69 322.99 10.36 M 27.11 350.74 C 94.13 272.23 162.27 194.25 322.99 10.36 M 32.75 350.34 C 109.84 259.92 189.18 169.41 328.63 9.97 M 32.75 350.34 C 144.37 224.87 254.73 97.54 328.63 9.97 M 37.74 350.7 C 135.31 240.11 231.67 128.18 333.62 10.33 M 37.74 350.7 C 136.65 236.7 236.19 121.3 333.62 10.33 M 43.38 350.31 C 153.85 224.17 264.44 96.9 339.26 9.93 M 43.38 350.31 C 159.4 220.78 273 89.16 339.26 9.93 M 48.37 350.67 C 149.2 234.16 249.62 120.06 344.25 10.29 M 48.37 350.67 C 150.63 234.7 251.99 118.7 344.25 10.29 M 54.01 350.27 C 169.55 217.59 283.73 85.74 349.89 9.9 M 54.01 350.27 C 118.12 276.77 181.71 203.13 349.89 9.9 M 59 350.63 C 141.62 257.67 221.08 164.02 354.88 10.26 M 59 350.63 C 128.49 269.04 198.6 188.58 354.88 10.26 M 63.98 350.99 C 163.97 236.13 263.48 122.24 360.52 9.86 M 63.98 350.99 C 141.41 260.67 220.57 169.15 360.52 9.86 M 69.63 350.6 C 144.44 266.12 216.78 180.01 365.51 10.22 M 69.63 350.6 C 139.7 272.92 207.81 194.03 365.51 10.22 M 74.61 350.96 C 141.6 273.87 209.3 195.92 371.15 9.83 M 74.61 350.96 C 178.89 231.83 282.77 112.71 371.15 9.83 M 80.26 350.56 C 192.33 224.02 302.67 97.43 376.14 10.19 M 80.26 350.56 C 183.38 232.74 286.51 115.18 376.14 10.19 M 85.24 350.92 C 164.34 258.78 244.27 167.47 381.13 10.55 M 85.24 350.92 C 170.46 251.13 256.59 151.65 381.13 10.55 M 90.89 350.53 C 187.83 237.82 288.59 124.55 380.86 16.95 M 90.89 350.53 C 153.29 277.73 215.5 205.39 380.86 16.95 M 95.87 350.89 C 167.18 269.19 237.89 189.64 380.6 23.35 M 95.87 350.89 C 190.85 240.7 286.04 131.08 380.6 23.35 M 101.52 350.5 C 168.85 274.3 234.51 199.03 381 28.99 M 101.52 350.5 C 179.3 260.82 258.38 170.57 381 28.99 M 106.5 350.86 C 198.43 244.33 292.92 136.05 380.74 35.39 M 106.5 350.86 C 195.53 246.31 285.43 143.51 380.74 35.39 M 112.15 350.46 C 202.8 249.67 289.87 148.32 381.13 41.03 M 112.15 350.46 C 168.84 285.14 224.74 221.75 381.13 41.03 M 117.13 350.82 C 198.78 258.8 279.13 165.13 380.87 47.43 M 117.13 350.82 C 204.79 247.58 293.03 146.22 380.87 47.43 M 122.78 350.43 C 193.8 270.45 263.51 189.77 380.61 53.83 M 122.78 350.43 C 187.18 274.72 252.69 199.32 380.61 53.83 M 127.76 350.79 C 204.05 262.23 280.42 173.29 381 59.47 M 127.76 350.79 C 188.16 280.52 248.74 211.25 381 59.47 M 133.41 350.39 C 213.36 260.35 292.13 171.14 380.74 65.87 M 133.41 350.39 C 209.59 259.63 287.95 169.52 380.74 65.87 M 138.39 350.75 C 200.87 277.93 264.89 203.75 381.14 71.51 M 138.39 350.75 C 216.02 262.83 292.76 173.58 381.14 71.51 M 144.04 350.36 C 210.51 270.13 281.13 189.61 380.87 77.91 M 144.04 350.36 C 212.41 272.31 279.05 195.84 380.87 77.91 M 149.02 350.72 C 221.79 265.03 297.03 180.49 380.61 84.3 M 149.02 350.72 C 214.49 272.97 280.64 197.92 380.61 84.3 M 154.67 350.32 C 203.77 292.22 254.96 234.31 381.01 89.95 M 154.67 350.32 C 216.39 283.47 275.1 214.6 381.01 89.95 M 159.65 350.68 C 246.71 250.6 331.81 154.96 380.75 96.35 M 159.65 350.68 C 213.74 287.74 267.91 225.61 380.75 96.35 M 165.3 350.29 C 232.45 272.44 298.33 194.67 381.14 101.99 M 165.3 350.29 C 246.39 255.53 328.96 160.93 381.14 101.99 M 170.28 350.65 C 248.07 264.02 322.27 177.49 380.88 108.39 M 170.28 350.65 C 239.6 271.38 309.27 189.81 380.88 108.39 M 175.93 350.25 C 248.13 267.68 320.22 184.12 380.62 114.78 M 175.93 350.25 C 248.77 264.52 321.99 180.16 380.62 114.78 M 180.91 350.61 C 245.26 275.27 310.5 199.05 381.01 120.43 M 180.91 350.61 C 236.43 285.96 294.19 220.91 381.01 120.43 M 185.9 350.97 C 251.68 276.52 316.76 202.18 380.75 126.83 M 185.9 350.97 C 254.41 273.21 323.5 193.62 380.75 126.83 M 191.54 350.58 C 261.35 269.83 330.49 187.88 381.14 132.47 M 191.54 350.58 C 238.88 296.67 285.73 242.88 381.14 132.47 M 196.53 350.94 C 235.66 304.6 278.41 255.66 380.88 138.87 M 196.53 350.94 C 255.43 284.82 313.59 217.17 380.88 138.87 M 202.17 350.54 C 265.57 278.23 329.7 204.92 380.62 145.26 M 202.17 350.54 C 271.64 267.91 341.3 188.17 380.62 145.26 M 207.16 350.9 C 270.3 276.9 336.83 199.71 381.02 150.91 M 207.16 350.9 C 246.91 304.88 286.06 260.54 381.02 150.91 M 212.8 350.51 C 264.68 289.58 322.21 225.83 380.75 157.3 M 212.8 350.51 C 263.65 293.62 313.17 236.58 380.75 157.3 M 217.79 350.87 C 272.15 287.52 324.74 226.29 381.15 162.95 M 217.79 350.87 C 260.46 302.73 302.4 256.13 381.15 162.95 M 223.43 350.48 C 273.64 290.29 324.88 232.41 380.89 169.35 M 223.43 350.48 C 276.52 288.49 329.82 228.02 380.89 169.35 M 228.42 350.84 C 266.2 309.11 302.07 267.63 380.63 175.74 M 228.42 350.84 C 259.31 313.46 290.13 279.18 380.63 175.74 M 234.06 350.44 C 291.63 285.43 345.31 222.32 381.02 181.39 M 234.06 350.44 C 283.73 293.35 332.25 236.72 381.02 181.39 M 239.05 350.8 C 267.89 319.33 296.06 284.94 380.76 187.78 M 239.05 350.8 C 280.38 304 319.8 258.84 380.76 187.78 M 244.69 350.41 C 283.75 303.05 327.67 253.83 381.15 193.43 M 244.69 350.41 C 284.71 303.99 324.9 258.85 381.15 193.43 M 249.68 350.77 C 294.72 297.24 338.54 246.38 380.89 199.83 M 249.68 350.77 C 290.08 305.78 331.54 257.88 380.89 199.83 M 255.32 350.37 C 291.39 307.3 327.61 263.49 380.63 206.22 M 255.32 350.37 C 284.01 317.38 314.83 282.15 380.63 206.22 M 260.31 350.73 C 302.52 302.77 345.91 252.32 381.03 211.87 M 260.31 350.73 C 297.79 307.18 336.42 263.1 381.03 211.87 M 265.95 350.34 C 304.37 305.53 345.33 258.23 380.76 218.26 M 265.95 350.34 C 289.51 324.43 312.32 296.82 380.76 218.26 M 270.94 350.7 C 305.85 313.94 337.32 272.01 381.16 223.91 M 270.94 350.7 C 309.91 305.75 349.6 261.6 381.16 223.91 M 276.58 350.3 C 300.33 321.5 324.31 293.89 380.9 230.3 M 276.58 350.3 C 303.06 321.51 329.23 289.71 380.9 230.3 M 281.57 350.66 C 309.53 320.4 336.73 288.67 380.64 236.7 M 281.57 350.66 C 309.56 320.07 336.7 288.72 380.64 236.7 M 287.21 350.27 C 318.46 318.18 345.95 283.33 381.03 242.35 M 287.21 350.27 C 310.9 325.64 334.14 298.78 381.03 242.35 M 292.2 350.63 C 323.08 317.78 349.41 287.43 380.77 248.74 M 292.2 350.63 C 322.62 315.44 353.22 280.91 380.77 248.74 M 297.19 350.99 C 325.88 317.38 357.5 286.24 381.16 254.39 M 297.19 350.99 C 320.15 327.5 342.06 300.57 381.16 254.39 M 302.83 350.59 C 323.53 324.16 348.58 298.38 380.9 260.78 M 302.83 350.59 C 322.99 327.45 342.76 305.54 380.9 260.78 M 307.82 350.95 C 326.18 329.93 349.85 304.7 380.64 267.18 M 307.82 350.95 C 337.05 319.07 364.16 286.34 380.64 267.18 M 313.46 350.56 C 326.79 333.35 341.73 317.07 381.04 272.82 M 313.46 350.56 C 335.22 327.1 354.49 304.25 381.04 272.82 M 318.45 350.92 C 330.67 336.47 345.25 320.58 380.77 279.22 M 318.45 350.92 C 337.24 328.99 358.11 304.91 380.77 279.22 M 324.09 350.53 C 340.71 328.23 361.59 309.38 381.17 284.87 M 324.09 350.53 C 345.85 324.47 369.07 299.41 381.17 284.87 M 329.08 350.89 C 343.33 335.05 359.74 317.1 380.91 291.26 M 329.08 350.89 C 348.28 327.32 367.1 306.41 380.91 291.26 M 334.72 350.49 C 351.03 329.32 370.09 307.86 380.65 297.66 M 334.72 350.49 C 346.7 338.86 357.35 324.45 380.65 297.66 M 339.71 350.85 C 354.61 331.97 370.49 317.07 381.04 303.3 M 339.71 350.85 C 352.08 337.4 363.34 323.16 381.04 303.3 M 345.35 350.46 C 354.26 340.04 360.4 330.17 380.78 309.7 M 345.35 350.46 C 359.85 335.97 371.94 319.51 380.78 309.7 M 350.34 350.82 C 361.77 335.21 373.27 324.61 381.17 315.35 M 350.34 350.82 C 361.74 336.61 374.63 322.58 381.17 315.35 M 355.98 350.42 C 363.07 344.61 368.45 336.85 380.91 321.74 M 355.98 350.42 C 365.25 340.8 373.46 329.06 380.91 321.74 M 360.97 350.78 C 365.67 345.39 367.67 339.63 380.65 328.14 M 360.97 350.78 C 364.89 344.56 370.85 339.32 380.65 328.14 M 366.61 350.39 C 373.11 342.43 379.32 336.68 381.05 333.78 M 366.61 350.39 C 371.66 345.28 377.53 338.09 381.05 333.78 M 371.6 350.75 C 375.27 348.65 377.1 343.43 380.78 340.18 M 371.6 350.75 C 375.41 346.17 379.2 341.89 380.78 340.18 M 377.24 350.35 C 377.72 349.4 378.85 348.07 381.18 345.82 M 377.24 350.35 C 378.4 348.77 379.42 347.38 381.18 345.82" fill="none" stroke="#b3a9b8" stroke-width="0.5" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 0 10 C 146.31 11.41 291.35 10.95 380 10 M 0 10 C 91.72 9 182.63 8.65 380 10 M 380 10 C 378.56 95.26 378.78 179.74 380 350 M 380 10 C 378.95 113.44 378.04 218.41 380 350 M 380 350 C 230.2 350.82 81.14 350.17 0 350 M 380 350 C 282.17 350.75 185.27 351.43 0 350 M 0 350 C 1.09 258.92 1.59 166.16 0 10 M 0 350 C -2.19 224.88 -2.07 100.96 0 10" fill="none" stroke="rgb(0, 0, 0)" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><rect x="10" y="150" width="340" height="170" fill="none" stroke="none" pointer-events="all"/><path d="M 9.82 150.21 C 9.82 150.21 9.82 150.21 9.82 150.21 M 9.82 150.21 C 9.82 150.21 9.82 150.21 9.82 150.21 M 10.21 155.85 C 11.96 153.68 13.67 152.81 15.46 149.81 M 10.21 155.85 C 11.95 153.52 13.77 151.75 15.46 149.81 M 9.95 162.25 C 14.3 157.98 16.61 153.8 20.45 150.17 M 9.95 162.25 C 11.49 160.09 14.82 157.22 20.45 150.17 M 9.69 168.65 C 14.33 162.46 20.56 156.82 26.09 149.78 M 9.69 168.65 C 13.36 163.53 18.24 158.57 26.09 149.78 M 10.09 174.29 C 16.32 163.26 25.23 155.19 31.08 150.14 M 10.09 174.29 C 16.6 168.13 21.02 160.41 31.08 150.14 M 9.82 180.69 C 15.72 174.63 22.38 164.52 36.72 149.74 M 9.82 180.69 C 17.96 171.09 27.92 160.98 36.72 149.74 M 10.22 186.33 C 21.19 173.01 36.92 158.06 41.71 150.1 M 10.22 186.33 C 22.43 173.24 34.25 159.02 41.71 150.1 M 9.96 192.73 C 24.69 178.67 36.68 162.79 47.35 149.71 M 9.96 192.73 C 18.58 182.58 28.11 171.12 47.35 149.71 M 9.7 199.13 C 20.89 184.6 35.55 170.75 52.34 150.07 M 9.7 199.13 C 23.96 183.23 40.14 166.08 52.34 150.07 M 10.09 204.77 C 22.19 191.52 35.32 177.76 57.98 149.68 M 10.09 204.77 C 23.96 189.6 37.3 172.11 57.98 149.68 M 9.83 211.17 C 21.25 199.2 33.16 186.18 62.97 150.04 M 9.83 211.17 C 24.75 193.27 42.02 175.38 62.97 150.04 M 10.22 216.81 C 24.57 199.96 38.49 185.61 68.61 149.64 M 10.22 216.81 C 23.67 202.04 36.36 185.04 68.61 149.64 M 9.96 223.21 C 32.4 196.12 53.52 170.57 73.6 150 M 9.96 223.21 C 29.79 202.18 48.61 180.29 73.6 150 M 9.7 229.61 C 23.16 212.75 39.53 191.56 78.59 150.36 M 9.7 229.61 C 34.33 200.98 60.39 172.47 78.59 150.36 M 10.1 235.25 C 35.05 206.78 59 179.34 84.23 149.97 M 10.1 235.25 C 33.43 209.18 56.03 183.22 84.23 149.97 M 9.83 241.65 C 40.03 208.04 70.88 172.29 89.22 150.33 M 9.83 241.65 C 27.33 220.41 45.31 201.16 89.22 150.33 M 10.23 247.29 C 28.69 226.83 46.29 205.35 94.86 149.93 M 10.23 247.29 C 42.97 208.98 75.87 172.45 94.86 149.93 M 9.97 253.69 C 41.08 217 74.52 181.21 99.85 150.29 M 9.97 253.69 C 43.74 215.33 77.03 175.89 99.85 150.29 M 9.71 260.09 C 40.83 224.05 67.97 189.84 105.49 149.9 M 9.71 260.09 C 38.09 224.3 68.54 189.59 105.49 149.9 M 10.1 265.73 C 43.32 226.72 81.65 183.55 110.48 150.26 M 10.1 265.73 C 46.61 223.25 82.01 180.85 110.48 150.26 M 9.84 272.13 C 49.8 228.49 86.67 180.13 116.12 149.86 M 9.84 272.13 C 49.2 225.51 89.99 180.4 116.12 149.86 M 10.23 277.77 C 44.95 238.62 78.32 200.26 121.11 150.22 M 10.23 277.77 C 51.08 229.86 90.72 185.11 121.11 150.22 M 9.97 284.17 C 51.9 233.74 94.78 184.59 126.75 149.83 M 9.97 284.17 C 53.61 233.44 97.65 185.25 126.75 149.83 M 9.71 290.56 C 44.78 250.21 84.06 205.24 131.74 150.19 M 9.71 290.56 C 52.41 243.35 94.86 193.57 131.74 150.19 M 10.1 296.21 C 57.61 241.85 101.42 192.84 137.38 149.79 M 10.1 296.21 C 36.01 267.43 60.42 238.15 137.38 149.79 M 9.84 302.61 C 57.41 244.28 107.22 189.2 142.37 150.15 M 9.84 302.61 C 49.85 256.67 88.65 211.45 142.37 150.15 M 10.24 308.25 C 64.62 246.14 115.89 187.68 148.01 149.76 M 10.24 308.25 C 48.31 262.75 87.66 216.04 148.01 149.76 M 9.98 314.65 C 51.24 271.82 88.87 226.62 153 150.12 M 9.98 314.65 C 39.38 280.6 69.24 245.34 153 150.12 M 10.37 320.29 C 66.74 257.75 120.18 196.59 158.64 149.73 M 10.37 320.29 C 61.28 261.31 113.32 202.64 158.64 149.73 M 15.36 320.65 C 60.99 267.89 104.92 218.22 163.63 150.09 M 15.36 320.65 C 57.27 272.02 99.59 221.86 163.63 150.09 M 21 320.26 C 58.48 275.24 95.77 231.51 169.27 149.69 M 21 320.26 C 54.9 283.75 85.89 246.6 169.27 149.69 M 25.99 320.62 C 71.91 262.49 122.35 207.12 174.26 150.05 M 25.99 320.62 C 76.98 261.19 127.59 201.44 174.26 150.05 M 31.63 320.22 C 65.69 279.23 101.43 240.83 179.9 149.66 M 31.63 320.22 C 67.4 279.72 101.23 239.35 179.9 149.66 M 36.62 320.58 C 83.75 267.88 128 213.91 184.89 150.02 M 36.62 320.58 C 68.38 285.1 99.55 249.08 184.89 150.02 M 42.26 320.19 C 93.14 261.63 145.23 200.92 189.87 150.38 M 42.26 320.19 C 81 278.4 118.98 233.22 189.87 150.38 M 47.25 320.55 C 105.82 251.05 166.81 182.97 195.52 149.98 M 47.25 320.55 C 91.73 269.93 135.42 218.86 195.52 149.98 M 52.89 320.15 C 90.89 277.89 129.69 234.45 200.5 150.34 M 52.89 320.15 C 89.42 278.58 126.14 236.9 200.5 150.34 M 57.88 320.51 C 94.98 278.91 130.64 235.23 206.15 149.95 M 57.88 320.51 C 97.88 276.19 137.88 229.8 206.15 149.95 M 63.52 320.12 C 104.84 271.59 145.57 225.06 211.13 150.31 M 63.52 320.12 C 103.86 273.83 143.71 228.07 211.13 150.31 M 68.51 320.48 C 108.12 275.93 146.85 231.41 216.78 149.91 M 68.51 320.48 C 121.42 257.46 174.36 196.01 216.78 149.91 M 74.15 320.08 C 128.72 259.62 180.26 195.71 221.76 150.27 M 74.15 320.08 C 119.5 267.66 166.03 215.61 221.76 150.27 M 79.14 320.44 C 110.3 286.13 141.23 248.85 227.41 149.88 M 79.14 320.44 C 112.06 279.49 147.47 240.27 227.41 149.88 M 84.78 320.05 C 132.04 267.85 178.6 213.99 232.39 150.24 M 84.78 320.05 C 123.36 277.36 161.61 233.26 232.39 150.24 M 89.77 320.41 C 142.33 260.54 193.78 198.52 238.04 149.84 M 89.77 320.41 C 145.12 255.94 199.48 194.31 238.04 149.84 M 95.41 320.01 C 148.21 259.83 198.89 198.31 243.02 150.2 M 95.41 320.01 C 142.41 268.4 187.16 216.42 243.02 150.2 M 100.4 320.37 C 154.13 262.05 204.38 203.72 248.67 149.81 M 100.4 320.37 C 135.86 281.68 170.02 242.64 248.67 149.81 M 106.04 319.98 C 160.69 258.13 215.3 195.74 253.66 150.17 M 106.04 319.98 C 159.62 258.17 215.06 195.75 253.66 150.17 M 111.03 320.34 C 162.13 261.53 211.02 201.83 259.3 149.77 M 111.03 320.34 C 159.69 265.38 205.92 212.24 259.3 149.77 M 116.67 319.94 C 156.39 273.18 192.6 229.14 264.29 150.13 M 116.67 319.94 C 157.37 274.27 195.98 230.08 264.29 150.13 M 121.66 320.3 C 161.39 275 200.46 231.58 269.93 149.74 M 121.66 320.3 C 168.45 266.23 215.8 212.93 269.93 149.74 M 126.65 320.66 C 156.36 285.84 187.67 252.51 274.92 150.1 M 126.65 320.66 C 174.88 265.95 222.31 212.3 274.92 150.1 M 132.29 320.27 C 183.86 262.41 234.82 202.12 280.56 149.71 M 132.29 320.27 C 183.45 262.1 234.17 202.5 280.56 149.71 M 137.28 320.63 C 193.18 256.9 252.27 191.5 285.55 150.07 M 137.28 320.63 C 193.09 258.21 247.37 195.91 285.55 150.07 M 142.92 320.24 C 173.99 283.44 206.4 246.82 291.19 149.67 M 142.92 320.24 C 189.68 264.58 236.96 210.97 291.19 149.67 M 147.91 320.6 C 182.54 280.63 217.77 239.35 296.18 150.03 M 147.91 320.6 C 201.43 259.06 253.97 199.09 296.18 150.03 M 153.55 320.2 C 208.38 260.59 260.26 196.25 301.82 149.64 M 153.55 320.2 C 204.9 261.03 256.17 200.71 301.82 149.64 M 158.54 320.56 C 196.19 277.35 230.84 236.4 306.81 150 M 158.54 320.56 C 208.84 264.09 259.6 206.58 306.81 150 M 164.18 320.17 C 207.36 271.84 253.63 222.54 311.79 150.36 M 164.18 320.17 C 221.98 255.8 278.13 189.9 311.79 150.36 M 169.17 320.53 C 219.31 265.92 266.92 208.3 317.44 149.96 M 169.17 320.53 C 209.22 272.43 250.69 224.68 317.44 149.96 M 174.81 320.13 C 207.66 284.5 238.01 248.1 322.42 150.32 M 174.81 320.13 C 231.31 256.26 286.31 194.65 322.42 150.32 M 179.8 320.49 C 217.13 280.98 252.72 235.73 328.07 149.93 M 179.8 320.49 C 216.23 277.2 255.66 234.18 328.07 149.93 M 185.44 320.1 C 223.63 275.39 262.11 231.28 333.05 150.29 M 185.44 320.1 C 222.28 277.89 259.5 234.16 333.05 150.29 M 190.43 320.46 C 248.64 251.14 308.87 185.75 338.7 149.89 M 190.43 320.46 C 227.76 275.96 264.32 233.19 338.7 149.89 M 196.07 320.06 C 247.33 261 298.82 198.46 343.68 150.25 M 196.07 320.06 C 253.68 253.2 312.59 185.99 343.68 150.25 M 201.06 320.42 C 235.78 281.16 268.11 242.92 349.33 149.86 M 201.06 320.42 C 253.42 258.57 305.49 197.75 349.33 149.86 M 206.7 320.03 C 252.61 266.22 298.61 210.66 352.34 152.48 M 206.7 320.03 C 261.72 256.95 317.88 193.94 352.34 152.48 M 211.69 320.39 C 238.4 284.45 269.34 250.38 352.74 158.13 M 211.69 320.39 C 265.15 259.88 316.87 198.97 352.74 158.13 M 217.33 319.99 C 260.5 267.82 306.05 216.31 352.48 164.52 M 217.33 319.99 C 267.93 259.45 318.6 201.87 352.48 164.52 M 222.32 320.35 C 258.92 279.88 293.25 238.66 352.87 170.17 M 222.32 320.35 C 250.06 288.08 276.98 255.48 352.87 170.17 M 227.96 319.96 C 267.78 273.56 306.98 226.93 352.61 176.56 M 227.96 319.96 C 273.66 266.62 321.29 210.66 352.61 176.56 M 232.95 320.32 C 277.6 269.32 323.42 217.07 352.35 182.96 M 232.95 320.32 C 269.87 277.85 304.33 237.75 352.35 182.96 M 237.93 320.68 C 275.12 276.46 313.4 232.83 352.74 188.61 M 237.93 320.68 C 284 270.59 328.26 217.93 352.74 188.61 M 243.58 320.29 C 276.85 281.64 312.81 241.94 352.48 195 M 243.58 320.29 C 282.43 276.61 322.14 229.94 352.48 195 M 248.56 320.65 C 286.12 275.89 321.27 235.8 352.88 200.65 M 248.56 320.65 C 271.86 293.13 295.71 266.1 352.88 200.65 M 254.21 320.25 C 291.71 279.91 323.88 239.15 352.62 207.04 M 254.21 320.25 C 278.35 293.19 301.3 267.62 352.62 207.04 M 259.19 320.61 C 291.81 281.53 326.78 243.85 352.35 213.44 M 259.19 320.61 C 286.41 287.73 314.83 256.59 352.35 213.44 M 264.84 320.22 C 296.88 284.55 331.03 245.83 352.75 219.09 M 264.84 320.22 C 289.42 292.67 312.56 264.18 352.75 219.09 M 269.82 320.58 C 302.41 283.8 334.08 246.73 352.49 225.48 M 269.82 320.58 C 289.27 297.34 309.19 274.88 352.49 225.48 M 275.47 320.18 C 297.88 296.51 317.51 272.47 352.88 231.13 M 275.47 320.18 C 300.89 291.21 326.47 261.64 352.88 231.13 M 280.45 320.54 C 301.1 296.49 323.47 273.81 352.62 237.52 M 280.45 320.54 C 300.02 297.29 320.51 275.71 352.62 237.52 M 286.1 320.15 C 303.25 301.78 318.65 282.62 352.36 243.92 M 286.1 320.15 C 311.6 289.88 337.2 260.96 352.36 243.92 M 291.08 320.51 C 304.37 303.68 319.29 289.64 352.75 249.56 M 291.08 320.51 C 307.34 300.51 322.71 283.44 352.75 249.56 M 296.73 320.11 C 312.48 302.05 327.21 283.4 352.49 255.96 M 296.73 320.11 C 314.02 301.95 330.6 281.7 352.49 255.96 M 301.71 320.47 C 317.22 305.05 330.65 287.66 352.89 261.61 M 301.71 320.47 C 315.82 303.66 329.71 289.47 352.89 261.61 M 307.36 320.08 C 317.69 306.58 330.66 292.65 352.63 268 M 307.36 320.08 C 320.65 305.9 332.01 292.37 352.63 268 M 312.34 320.44 C 325.64 307.16 334.58 295.45 352.36 274.4 M 312.34 320.44 C 325.39 304.51 339.57 289.87 352.36 274.4 M 317.99 320.04 C 324.21 311.05 330.62 303.4 352.76 280.04 M 317.99 320.04 C 331.02 304.6 344.07 289.25 352.76 280.04 M 322.97 320.4 C 329.97 311.46 339.95 300.33 352.5 286.44 M 322.97 320.4 C 333.3 307.84 344.77 295.78 352.5 286.44 M 328.62 320.01 C 335.4 310.17 342.03 304.83 352.89 292.09 M 328.62 320.01 C 334.48 312.7 340.24 305.75 352.89 292.09 M 333.6 320.37 C 340.97 315.38 346.86 308.34 352.63 298.48 M 333.6 320.37 C 338.87 315.36 341.77 310.65 352.63 298.48 M 339.25 319.97 C 341.77 313.56 346.48 311.15 352.37 304.88 M 339.25 319.97 C 345.31 314.24 348.82 308.44 352.37 304.88 M 344.23 320.34 C 346.74 318.21 350.77 314.19 352.76 310.52 M 344.23 320.34 C 346.72 318.33 348.08 316.53 352.76 310.52 M 349.88 319.94 C 350.53 319.06 351.17 318.29 352.5 316.92 M 349.88 319.94 C 350.67 319.19 350.95 318.56 352.5 316.92" fill="none" stroke="#e1d5e7" stroke-width="0.5" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 10 150 C 139.87 151.15 271.03 150.36 350 150 M 10 150 C 110.92 151.47 211.78 152.12 350 150 M 350 150 C 352.01 214.49 350.61 280.8 350 320 M 350 150 C 352.06 210.09 350.9 270.45 350 320 M 350 320 C 258.43 318.62 166.89 318.57 10 320 M 350 320 C 221.91 320.91 95.15 320.48 10 320 M 10 320 C 7.19 255.38 10.89 188.58 10 150 M 10 320 C 8.48 274.57 8.33 231.09 10 150" fill="none" stroke="rgb(0, 0, 0)" stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" pointer-events="all"/><path d="M 280 80 L 280 153.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 280 158.88 L 276.5 151.88 L 280 153.63 L 283.5 151.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 120px; margin-left: 280px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>Memo with value exists:</div><div>last verified in Rv with durability D<br /></div></div></div></div></foreignObject><text x="280" y="123" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Memo with value exists:...</text></switch></g><path d="M 340 60 L 470 60 L 470 233.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 470 238.88 L 466.5 231.88 L 470 233.63 L 473.5 231.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 60px; margin-left: 470px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>No previous memo, <br /></div><div>or memo has no value<br /></div></div></div></div></foreignObject><text x="470" y="63" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">No previous memo,...</text></switch></g><rect x="220" y="40" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 60px; margin-left: 221px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Load memo_map[K]<br /></div></div></div></div></foreignObject><text x="280" y="64" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Load memo_map[K]&#xa;</text></switch></g><path d="M 280 200 L 280 233.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 280 238.88 L 276.5 231.88 L 280 233.63 L 283.5 231.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 220px; margin-left: 280px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">No</div></div></div></foreignObject><text x="280" y="223" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">No</text></switch></g><path d="M 220 180 L 180 180 L 146.37 180" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 141.12 180 L 148.12 176.5 L 146.37 180 L 148.12 183.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 180px; margin-left: 180px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Yes</div></div></div></foreignObject><text x="180" y="183" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Yes</text></switch></g><rect x="220" y="160" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 180px; margin-left: 221px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Rv is current revision?</div></div></div></foreignObject><text x="280" y="184" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Rv is current revisi...</text></switch></g><path d="M 340 260 L 403.63 260" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 408.88 260 L 401.88 263.5 L 403.63 260 L 401.88 256.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 260px; margin-left: 375px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Yes</div></div></div></foreignObject><text x="375" y="263" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Yes</text></switch></g><path d="M 220 260 L 146.37 260" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 141.12 260 L 148.12 256.5 L 146.37 260 L 148.12 263.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 260px; margin-left: 180px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">No</div></div></div></foreignObject><text x="180" y="263" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">No</text></switch></g><rect x="220" y="240" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 260px; margin-left: 221px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Inputs with durability D changed since Rv?</div></div></div></foreignObject><text x="280" y="264" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Inputs with durabili...</text></switch></g><rect x="20" y="160" width="120" height="40" rx="6" ry="6" fill="#ffcc99" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 180px; margin-left: 21px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Return value  </div></div></div></foreignObject><text x="80" y="184" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Return value  </text></switch></g><path d="M 530 250 L 670 250 L 670 168.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 670 163.12 L 673.5 170.12 L 670 168.37 L 666.5 170.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 250px; margin-left: 570px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>Already</div><div>claimed<br /></div></div></div></div></foreignObject><text x="570" y="253" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Already...</text></switch></g><path d="M 470 280 L 470 313.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 470 318.88 L 466.5 311.88 L 470 313.63 L 473.5 311.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 300px; margin-left: 470px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Claimed</div></div></div></foreignObject><text x="470" y="303" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Claimed</text></switch></g><rect x="410" y="240" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 260px; margin-left: 411px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Claim sync_map[K]<br /></div></div></div></div></foreignObject><text x="470" y="264" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Claim sync_map[K]&#xa;</text></switch></g><path d="M 670 122 L 670 20 L 310 20 L 310 33.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 310 38.88 L 306.5 31.88 L 310 33.63 L 313.5 31.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 98px; margin-left: 670px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>Thread completed</div><div>normally<br /></div></div></div></div></foreignObject><text x="670" y="101" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Thread completed...</text></switch></g><path d="M 730 142 L 830 142 L 830 140 L 923.63 140" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 928.88 140 L 921.88 143.5 L 923.63 140 L 921.88 136.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 146px; margin-left: 796px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;"><div>Cycle detected</div><div>or thread panicked<br /></div></div></div></div></foreignObject><text x="796" y="149" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Cycle detected...</text></switch></g><rect x="610" y="122" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 142px; margin-left: 611px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Block until other thread completes</div></div></div></foreignObject><text x="670" y="146" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Block until other th...</text></switch></g><path d="M 530 420 L 670 420 L 670 753.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 670 758.88 L 666.5 751.88 L 670 753.63 L 673.5 751.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 421px; margin-left: 596px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">No previous memo</div></div></div></foreignObject><text x="596" y="424" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">No previous memo</text></switch></g><rect x="410" y="400" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 420px; margin-left: 411px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Load memo_map[K]<br /></div></div></div></div></foreignObject><text x="470" y="424" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Load memo_map[K]&#xa;</text></switch></g><path d="M 470 440 L 470 513.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 470 518.88 L 466.5 511.88 L 470 513.63 L 473.5 511.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 480px; margin-left: 470px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Previous memo exists,<br /><div>last verified in Rv</div><div>with durability D<br /></div></div></div></div></foreignObject><text x="470" y="483" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Previous memo exists,...</text></switch></g><path d="M 80 240 L 80 206.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 80 201.12 L 83.5 208.12 L 80 206.37 L 76.5 208.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="20" y="240" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 260px; margin-left: 21px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Update verified_at to current revision</div></div></div></foreignObject><text x="80" y="264" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Update verified_at t...</text></switch></g><path d="M 470 560 L 470 593.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 470 598.88 L 466.5 591.88 L 470 593.63 L 473.5 591.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 580px; margin-left: 470px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">No</div></div></div></foreignObject><text x="470" y="583" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">No</text></switch></g><path d="M 410 540 L 370 540 L 336.37 540" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 331.12 540 L 338.12 536.5 L 336.37 540 L 338.12 543.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 540px; margin-left: 370px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Yes</div></div></div></foreignObject><text x="370" y="543" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Yes</text></switch></g><rect x="410" y="520" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 540px; margin-left: 411px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Rv is current revision?</div></div></div></foreignObject><text x="470" y="544" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Rv is current revisi...</text></switch></g><path d="M 410 620 L 336.37 620" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 331.12 620 L 338.12 616.5 L 336.37 620 L 338.12 623.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 620px; margin-left: 370px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">No</div></div></div></foreignObject><text x="370" y="623" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">No</text></switch></g><path d="M 470 640 L 470 673.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 470 678.88 L 466.5 671.88 L 470 673.63 L 473.5 671.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="410" y="600" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 620px; margin-left: 411px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Inputs with durability D changed since Rv?</div></div></div></foreignObject><text x="470" y="624" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Inputs with durabili...</text></switch></g><rect x="210" y="520" width="120" height="40" rx="6" ry="6" fill="#ffcc99" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 540px; margin-left: 211px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Return value  </div></div></div></foreignObject><text x="270" y="544" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Return value  </text></switch></g><path d="M 270 600 L 270 566.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 270 561.12 L 273.5 568.12 L 270 566.37 L 266.5 568.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="210" y="600" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 620px; margin-left: 211px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Update verified_at to current revision</div></div></div></foreignObject><text x="270" y="624" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Update verified_at t...</text></switch></g><path d="M 470 720 L 470 753.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 470 758.88 L 466.5 751.88 L 470 753.63 L 473.5 751.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 410 690 L 270 690 L 270 646.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 270 641.12 L 273.5 648.12 L 270 646.37 L 266.5 648.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 690px; margin-left: 350px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">All inputs verified</div></div></div></foreignObject><text x="350" y="693" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">All inputs verified</text></switch></g><path d="M 530 780 L 603.63 780" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 608.88 780 L 601.88 783.5 L 603.63 780 L 601.88 776.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="410" y="680" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 700px; margin-left: 411px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">For each input I...</div></div></div></foreignObject><text x="470" y="704" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">For each input I...</text></switch></g><path d="M 470 360 L 470 393.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 470 398.88 L 466.5 391.88 L 470 393.63 L 473.5 391.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="410" y="320" width="120" height="40" rx="6" ry="6" fill="rgb(255, 255, 255)" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 340px; margin-left: 411px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Push K onto stack<br /></div></div></div></div></foreignObject><text x="470" y="344" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Push K onto stack&#xa;</text></switch></g><path d="M 410 780 L 390 780 L 390 710 L 403.63 710" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 408.88 710 L 401.88 713.5 L 403.63 710 L 401.88 706.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 745px; margin-left: 390px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">No</div></div></div></foreignObject><text x="390" y="748" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">No</text></switch></g><path d="M 500 760 L 500 740 L 950 740 L 950 366.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 950 361.12 L 953.5 368.12 L 950 366.37 L 946.5 368.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="410" y="760" width="120" height="40" rx="6" ry="6" fill="#99ccff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 780px; margin-left: 411px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Input I maybe changed after Rv?</div></div></div></foreignObject><text x="470" y="784" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Input I maybe change...</text></switch></g><path d="M 670 800 L 670 833.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 670 838.88 L 666.5 831.88 L 670 833.63 L 673.5 831.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="610" y="760" width="120" height="40" rx="6" ry="6" fill="#e5ccff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 780px; margin-left: 611px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Salsa Event:</div><div>Will Execute<br /></div></div></div></div></foreignObject><text x="670" y="784" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Salsa Event:...</text></switch></g><path d="M 610 860 L 536.37 860" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 531.12 860 L 538.12 856.5 L 536.37 860 L 538.12 863.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 670 880 L 670 913.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 670 918.88 L 666.5 911.88 L 670 913.63 L 673.5 911.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 900px; margin-left: 670px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Cycle detected</div></div></div></foreignObject><text x="670" y="903" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Cycle detected</text></switch></g><path d="M 730 860 L 950 860 L 950 366.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 950 361.12 L 953.5 368.12 L 950 366.37 L 946.5 368.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="610" y="840" width="120" height="40" rx="6" ry="6" fill="#99ccff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 860px; margin-left: 611px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Execute query function</div></div></div></foreignObject><text x="670" y="864" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Execute query functi...</text></switch></g><path d="M 410 860 L 336.37 860" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 331.12 860 L 338.12 856.5 L 336.37 860 L 338.12 863.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="410" y="840" width="120" height="40" rx="6" ry="6" fill="#ffffff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 860px; margin-left: 411px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Backdate value if equal to old value.</div></div></div></foreignObject><text x="470" y="864" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Backdate value if eq...</text></switch></g><path d="M 210 860 L 190 860 L 190 540 L 203.63 540" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 208.88 540 L 201.88 543.5 L 203.63 540 L 201.88 536.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="210" y="840" width="120" height="40" rx="6" ry="6" fill="#ffffff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 860px; margin-left: 211px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;"><div>Store memo with <br /></div><div>new value.</div></div></div></div></foreignObject><text x="270" y="864" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Store memo with...</text></switch></g><path d="M 610 1100 L 470 1100 L 470 886.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 470 881.12 L 473.5 888.12 L 470 886.37 L 466.5 888.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><path d="M 730 1100 L 950 1100 L 950 366.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 950 361.12 L 953.5 368.12 L 950 366.37 L 946.5 368.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="610" y="1080" width="120" height="40" rx="6" ry="6" fill="#99ccff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 1100px; margin-left: 611px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Execute cycle recovery</div></div></div></foreignObject><text x="670" y="1104" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Execute cycle recove...</text></switch></g><path d="M 670 960 L 670 993.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 670 998.88 L 666.5 991.88 L 670 993.63 L 673.5 991.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 980px; margin-left: 670px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Fallback</div></div></div></foreignObject><text x="670" y="983" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Fallback</text></switch></g><path d="M 730 940 L 803.63 940" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 808.88 940 L 801.88 943.5 L 803.63 940 L 801.88 936.5 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 940px; margin-left: 770px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Panic</div></div></div></foreignObject><text x="770" y="943" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Panic</text></switch></g><rect x="610" y="920" width="120" height="40" rx="6" ry="6" fill="#ffffff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 940px; margin-left: 611px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Check recovery strategy</div></div></div></foreignObject><text x="670" y="944" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Check recovery strat...</text></switch></g><path d="M 670 1040 L 670 1073.63" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 670 1078.88 L 666.5 1071.88 L 670 1073.63 L 673.5 1071.88 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 1060px; margin-left: 670px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Flag is Some</div></div></div></foreignObject><text x="670" y="1063" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Flag is Some</text></switch></g><path d="M 730 1020 L 870 1020 L 870 966.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 870 961.12 L 873.5 968.12 L 870 966.37 L 866.5 968.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 1020px; margin-left: 770px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">Flag is None</div></div></div></foreignObject><text x="770" y="1023" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">Flag is None</text></switch></g><rect x="610" y="1000" width="120" height="40" rx="6" ry="6" fill="#ffffff" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 1020px; margin-left: 611px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Check cycle flag on stack frame</div></div></div></foreignObject><text x="670" y="1024" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Check cycle flag on...</text></switch></g><path d="M 930 940 L 950 940 L 950 366.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 950 361.12 L 953.5 368.12 L 950 366.37 L 946.5 368.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="810" y="920" width="120" height="40" rx="6" ry="6" fill="#ff9999" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 940px; margin-left: 811px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Unwind with cycle</div></div></div></foreignObject><text x="870" y="944" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Unwind with cycle</text></switch></g><path d="M 950 240 L 950 200 L 949.52 166.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 949.45 161.12 L 953.05 168.07 L 949.52 166.37 L 946.05 168.17 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="890" y="240" width="120" height="40" rx="6" ry="6" fill="#ff9999" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 260px; margin-left: 891px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Release claim.</div></div></div></foreignObject><text x="950" y="264" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Release claim.</text></switch></g><path d="M 950 320 L 950 286.37" fill="none" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="stroke"/><path d="M 950 281.12 L 953.5 288.12 L 950 286.37 L 946.5 288.12 Z" fill="rgb(0, 0, 0)" stroke="rgb(0, 0, 0)" stroke-miterlimit="10" pointer-events="all"/><rect x="890" y="320" width="120" height="40" rx="6" ry="6" fill="#ff9999" stroke="rgb(0, 0, 0)" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 118px; height: 1px; padding-top: 340px; margin-left: 891px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: normal; overflow-wrap: normal;">Pop stack frame.</div></div></div></foreignObject><text x="950" y="344" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">Pop stack frame.</text></switch></g><rect x="760" y="1080" width="19" height="38" fill="none" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><rect x="760" y="1080" width="19" height="38" fill="none" stroke="none" pointer-events="all"/><path d="M 769.73 1080.15 L 760 1104.03 L 773.61 1099.38 L 770.11 1112.46 L 767.78 1110.64 L 768.98 1118 L 774.21 1111.84 L 770.97 1112.62 L 779 1095.32 L 764.49 1099.82 L 774.96 1080 Z" fill="#000000" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><path d="M 769.73 1080.15 L 760 1104.03 L 773.61 1099.38 L 770.11 1112.46 L 767.78 1110.64 L 768.98 1118 L 774.21 1111.84 L 770.97 1112.62 L 779 1095.32 L 764.49 1099.82 L 774.96 1080 Z" fill="#000000" stroke="none" pointer-events="all"/><rect x="760" y="840" width="19" height="38" fill="none" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><rect x="760" y="840" width="19" height="38" fill="none" stroke="none" pointer-events="all"/><path d="M 769.73 840.15 L 760 864.03 L 773.61 859.38 L 770.11 872.46 L 767.78 870.64 L 768.98 878 L 774.21 871.84 L 770.97 872.62 L 779 855.32 L 764.49 859.82 L 774.96 840 Z" fill="#000000" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><path d="M 769.73 840.15 L 760 864.03 L 773.61 859.38 L 770.11 872.46 L 767.78 870.64 L 768.98 878 L 774.21 871.84 L 770.97 872.62 L 779 855.32 L 764.49 859.82 L 774.96 840 Z" fill="#000000" stroke="none" pointer-events="all"/><rect x="940.5" y="122" width="19" height="38" fill="none" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><rect x="940.5" y="122" width="19" height="38" fill="none" stroke="none" pointer-events="all"/><path d="M 950.23 122.15 L 940.5 146.03 L 954.11 141.38 L 950.61 154.46 L 948.28 152.64 L 949.48 160 L 954.71 153.84 L 951.47 154.62 L 959.5 137.32 L 944.99 141.82 L 955.46 122 Z" fill="#000000" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><path d="M 950.23 122.15 L 940.5 146.03 L 954.11 141.38 L 950.61 154.46 L 948.28 152.64 L 949.48 160 L 954.71 153.84 L 951.47 154.62 L 959.5 137.32 L 944.99 141.82 L 955.46 122 Z" fill="#000000" stroke="none" pointer-events="all"/><rect x="540" y="720" width="19" height="38" fill="none" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><rect x="540" y="720" width="19" height="38" fill="none" stroke="none" pointer-events="all"/><path d="M 549.73 720.15 L 540 744.03 L 553.61 739.38 L 550.11 752.46 L 547.78 750.64 L 548.98 758 L 554.21 751.84 L 550.97 752.62 L 559 735.32 L 544.49 739.82 L 554.96 720 Z" fill="#000000" stroke="none" pointer-events="all" transform="translate(2,3)" opacity="0.25"/><path d="M 549.73 720.15 L 540 744.03 L 553.61 739.38 L 550.11 752.46 L 547.78 750.64 L 548.98 758 L 554.21 751.84 L 550.97 752.62 L 559 735.32 L 544.49 739.82 L 554.96 720 Z" fill="#000000" stroke="none" pointer-events="all"/><path d="M 530 270 L 890 270" fill="none" stroke="rgb(0, 0, 0)" stroke-width="2" stroke-miterlimit="10" stroke-dasharray="2 6" pointer-events="stroke"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 270px; margin-left: 710px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">(Destructor)</div></div></div></foreignObject><text x="710" y="273" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">(Destructo...</text></switch></g><path d="M 530 340 L 890 340" fill="none" stroke="rgb(0, 0, 0)" stroke-width="2" stroke-miterlimit="10" stroke-dasharray="2 6" pointer-events="stroke"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 340px; margin-left: 710px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); "><div style="display: inline-block; font-size: 11px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; background-color: rgb(255, 255, 255); white-space: nowrap;">(Destructor)</div></div></div></foreignObject><text x="710" y="343" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="11px" text-anchor="middle">(Destructo...</text></switch></g><rect x="185" y="290" width="170" height="40" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 310px; margin-left: 270px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;"><pre>shallow_verify_memo()</pre></div></div></div></foreignObject><text x="270" y="314" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">shallow_verify_memo()</text></switch></g><rect x="290" y="320" width="90" height="40" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 340px; margin-left: 335px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;"><pre>fetch_hot()</pre></div></div></div></foreignObject><text x="335" y="344" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">fetch_hot()</text></switch></g><rect x="940.5" y="1128" width="100" height="40" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 1148px; margin-left: 991px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;"><pre>fetch_cold()</pre></div></div></div></foreignObject><text x="991" y="1152" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">fetch_cold()</text></switch></g><rect x="895" y="70" width="130" height="40" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 90px; margin-left: 960px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;"><pre>sync_map.claim()</pre></div></div></div></foreignObject><text x="960" y="94" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">sync_map.claim()</text></switch></g><rect x="920" y="1100" width="80" height="40" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 1120px; margin-left: 960px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;"><pre>execute()</pre></div></div></div></foreignObject><text x="960" y="1124" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">execute()</text></switch></g><rect x="160" y="880" width="150" height="40" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 900px; margin-left: 235px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;"><pre>deep_verify_memo()</pre></div></div></div></foreignObject><text x="235" y="904" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">deep_verify_memo()</text></switch></g><rect x="178" y="483" width="170" height="40" fill="none" stroke="none" pointer-events="all"/><g transform="translate(-0.5 -0.5)"><switch><foreignObject style="overflow: visible; text-align: left;" pointer-events="none" width="100%" height="100%" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; align-items: unsafe center; justify-content: unsafe center; width: 1px; height: 1px; padding-top: 503px; margin-left: 263px;"><div style="box-sizing: border-box; font-size: 0px; text-align: center;" data-drawio-colors="color: rgb(0, 0, 0); "><div style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; pointer-events: all; white-space: nowrap;"><pre>shallow_verify_memo()</pre></div></div></div></foreignObject><text x="263" y="507" fill="rgb(0, 0, 0)" font-family="Helvetica" font-size="12px" text-anchor="middle">shallow_verify_memo()</text></switch></g></g><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a transform="translate(0,-5)" xlink:href="https://www.diagrams.net/doc/faq/svg-export-text-problems" target="_blank"><text text-anchor="middle" font-size="10px" x="50%" y="100%">Text is not SVG - cannot display</text></a></switch></svg>
\ No newline at end of file
diff --git a/crates/salsa/book/src/how_salsa_works.md b/crates/salsa/book/src/how_salsa_works.md
new file mode 100644
index 000000000..813b34597
--- /dev/null
+++ b/crates/salsa/book/src/how_salsa_works.md
@@ -0,0 +1,51 @@
+# How Salsa works
+
+## Video available
+
+To get the most complete introduction to Salsa's inner workings, check
+out [the "How Salsa Works" video](https://youtu.be/_muY4HjSqVw). If
+you'd like a deeper dive, [the "Salsa in more depth"
+video](https://www.youtube.com/watch?v=i_IhACacPRY) digs into the
+details of the incremental algorithm.
+
+> If you're in China, watch videos on ["How Salsa Works"](https://www.bilibili.com/video/BV1Df4y1A7t3/), ["Salsa In More Depth"](https://www.bilibili.com/video/BV1AM4y1G7E4/).
+
+## Key idea
+
+The key idea of `salsa` is that you define your program as a set of
+**queries**. Every query is used like a function `K -> V` that maps from
+some key of type `K` to a value of type `V`. Queries come in two basic
+varieties:
+
+- **Inputs**: the base inputs to your system. You can change these
+  whenever you like.
+- **Functions**: pure functions (no side effects) that transform your
+  inputs into other values. The results of queries are memoized to
+  avoid recomputing them a lot. When you make changes to the inputs,
+  we'll figure out (fairly intelligently) when we can re-use these
+  memoized values and when we have to recompute them.
+
+## How to use Salsa in three easy steps
+
+Using Salsa is as easy as 1, 2, 3...
+
+1. Define one or more **query groups** that contain the inputs
+   and queries you will need. We'll start with one such group, but
+   later on you can use more than one to break up your system into
+   components (or spread your code across crates).
+2. Define the **query functions** where appropriate.
+3. Define the **database**, which contains the storage for all
+   the inputs/queries you will be using. The query struct will contain
+   the storage for all of the inputs/queries and may also contain
+   anything else that your code needs (e.g., configuration data).
+
+To see an example of this in action, check out [the `hello_world`
+example][hello_world], which has a number of comments explaining how
+things work.
+
+[hello_world]: https://github.com/salsa-rs/salsa/blob/master/examples/hello_world/main.rs
+
+## Digging into the plumbing
+
+Check out the [plumbing](plumbing.md) chapter to see a deeper explanation of the
+code that Salsa generates and how it connects to the Salsa library.
diff --git a/crates/salsa/book/src/meta.md b/crates/salsa/book/src/meta.md
new file mode 100644
index 000000000..19b458b67
--- /dev/null
+++ b/crates/salsa/book/src/meta.md
@@ -0,0 +1,17 @@
+# Meta: about the book itself
+
+## Linking policy
+
+We try to avoid links that easily become fragile. 
+
+**Do:**
+
+* Link to `docs.rs` types to document the public API, but modify the link to use `latest` as the version.
+* Link to modules in the source code.
+* Create ["named anchors"] and embed source code directly.
+
+["named anchors"]: https://rust-lang.github.io/mdBook/format/mdbook.html?highlight=ANCHOR#including-portions-of-a-file
+
+**Don't:**
+
+* Link to direct lines on github, even within a specific commit, unless you are trying to reference a historical piece of code ("how things were at the time").
\ No newline at end of file
diff --git a/crates/salsa/book/src/overview.md b/crates/salsa/book/src/overview.md
new file mode 100644
index 000000000..df468d2fa
--- /dev/null
+++ b/crates/salsa/book/src/overview.md
@@ -0,0 +1,306 @@
+# Salsa overview
+
+This page contains a brief overview of the pieces of a Salsa program.
+For a more detailed look, check out the [tutorial](./tutorial.md), which walks through the creation of an entire project end-to-end.
+
+## Goal of Salsa
+
+The goal of Salsa is to support efficient **incremental recomputation**.
+Salsa is used in rust-analyzer, for example, to help it recompile your program quickly as you type.
+
+The basic idea of a Salsa program is like this:
+
+```rust
+let mut input = ...;
+loop {
+    let output = your_program(&input);
+    modify(&mut input);
+}
+```
+
+You start out with an input that has some value.
+You invoke your program to get back a result.
+Some time later, you modify the input and invoke your program again.
+**Our goal is to make this second call faster by re-using some of the results from the first call.**
+
+In reality, of course, you can have many inputs and "your program" may be many different methods and functions defined on those inputs.
+But this picture still conveys a few important concepts:
+
+- Salsa separates out the "incremental computation" (the function `your_program`) from some outer loop that is defining the inputs.
+- Salsa gives you the tools to define `your_program`.
+- Salsa assumes that `your_program` is a purely deterministic function of its inputs, or else this whole setup makes no sense.
+- The mutation of inputs always happens outside of `your_program`, as part of this master loop.
+
+## Database
+
+Each time you run your program, Salsa remembers the values of each computation in a **database**.
+When the inputs change, it consults this database to look for values that can be reused.
+The database is also used to implement interning (making a canonical version of a value that can be copied around and cheaply compared for equality) and other convenient Salsa features.
+
+## Inputs
+
+Every Salsa program begins with an **input**.
+Inputs are special structs that define the starting point of your program.
+Everything else in your program is ultimately a deterministic function of these inputs.
+
+For example, in a compiler, there might be an input defining the contents of a file on disk:
+
+```rust
+#[salsa::input]
+pub struct ProgramFile {
+    pub path: PathBuf,
+    pub contents: String,
+}
+```
+
+You create an input by using the `new` method.
+Because the values of input fields are stored in the database, you also give an `&`-reference to the database:
+
+```rust
+let file: ProgramFile = ProgramFile::new(
+    &db,
+    PathBuf::from("some_path.txt"),
+    String::from("fn foo() { }"),
+);
+```
+
+Mutable access is not needed since creating a new input cannot affect existing tracked data in the database.
+
+### Salsa structs are just integers
+
+The `ProgramFile` struct generated by the `salsa::input` macro doesn't actually store any data. It's just a newtyped integer id:
+
+```rust
+// Generated by the `#[salsa::input]` macro:
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
+pub struct ProgramFile(salsa::Id);
+```
+
+This means that, when you have a `ProgramFile`, you can easily copy it around and put it wherever you like.
+To actually read any of its fields, however, you will need to use the database and a getter method.
+
+### Reading fields and `returns(ref)`
+
+You can access the value of an input's fields by using the getter method.
+As this is only reading the field, it just needs a `&`-reference to the database:
+
+```rust
+let contents: String = file.contents(&db);
+```
+
+Invoking the accessor clones the value from the database.
+Sometimes this is not what you want, so you can annotate fields with `#[returns(ref)]` to indicate that they should return a reference into the database instead:
+
+```rust
+#[salsa::input]
+pub struct ProgramFile {
+    pub path: PathBuf,
+    #[returns(ref)]
+    pub contents: String,
+}
+```
+
+Now `file.contents(&db)` will return an `&String`.
+
+You can also use the `data` method to access the entire struct:
+
+```rust
+file.data(&db)
+```
+
+### Writing input fields
+
+Finally, you can also modify the value of an input field by using the setter method.
+Since this is modifying the input, and potentially invalidating data derived from it,
+the setter takes an `&mut`-reference to the database:
+
+```rust
+file.set_contents(&mut db).to(String::from("fn foo() { /* add a comment */ }"));
+```
+
+Note that the setter method `set_contents` returns a "builder".
+This gives the ability to set the [durability](./reference/durability.md) and other advanced concepts.
+
+## Tracked functions
+
+Once you've defined your inputs, the next thing to define are **tracked functions**:
+
+```rust
+#[salsa::tracked]
+fn parse_file(db: &dyn crate::Db, file: ProgramFile) -> Ast {
+    let contents: &str = file.contents(db);
+    ...
+}
+```
+
+When you call a tracked function, Salsa will track which inputs it accesses (in this example, `file.contents(db)`).
+It will also memoize the return value (the `Ast`, in this case).
+If you call a tracked function twice, Salsa checks if the inputs have changed; if not, it can return the memoized value.
+The algorithm Salsa uses to decide when a tracked function needs to be re-executed is called the [red-green algorithm](./reference/algorithm.md), and it's where the name Salsa comes from.
+
+Tracked functions have to follow a particular structure:
+
+- They must take a `&`-reference to the database as their first argument.
+  - Note that because this is an `&`-reference, it is not possible to modify inputs during a tracked function!
+- They must take a "Salsa struct" as the second argument -- in our example, this is an input struct, but there are other kinds of Salsa structs we'll describe shortly.
+- They _can_ take additional arguments, but it's faster and better if they don't.
+
+Tracked functions can return any clone-able type. A clone is required since, when the value is cached, the result will be cloned out of the database. Tracked functions can also be annotated with `#[returns(ref)]` if you would prefer to return a reference into the database instead (if `parse_file` were so annotated, then callers would actually get back an `&Ast`, for example).
+
+## Tracked structs
+
+**Tracked structs** are intermediate structs created during your computation.
+Like inputs, their fields are stored inside the database, and the struct itself just wraps an id.
+Unlike inputs, they can only be created inside a tracked function, and their fields can never change once they are created (until the next revision, at least).
+Getter methods are provided to read the fields, but there are no setter methods.
+Example:
+
+```rust
+#[salsa::tracked]
+struct Ast<'db> {
+    #[returns(ref)]
+    top_level_items: Vec<Item>,
+}
+```
+
+Just as with an input, new values are created by invoking `Ast::new`. The `new` function on a tracked struct only requires a `&`-reference to the database:
+
+```rust
+#[salsa::tracked]
+fn parse_file(db: &dyn crate::Db, file: ProgramFile) -> Ast {
+    let contents: &str = file.contents(db);
+    let parser = Parser::new(contents);
+    let mut top_level_items = vec![];
+    while let Some(item) = parser.parse_top_level_item() {
+        top_level_items.push(item);
+    }
+    Ast::new(db, top_level_items) // <-- create an Ast!
+}
+```
+
+### `#[id]` fields
+
+When a tracked function is re-executed because its inputs have changed, the tracked structs it creates in the new execution are matched against those from the old execution, and the values of their fields are compared.
+If the field values have not changed, then other tracked functions that only read those fields will not be re-executed.
+
+Normally, tracked structs are matched up by the order in which they are created.
+For example, the first `Ast` that is created by `parse_file` in the old execution will be matched against the first `Ast` created by `parse_file` in the new execution.
+In our example, `parse_file` only ever creates a single `Ast`, so this works great.
+Sometimes, however, it doesn't work so well.
+For example, imagine that we had a tracked struct for items in the file:
+
+```rust
+#[salsa::tracked]
+struct Item {
+    name: Word, // we'll define Word in a second!
+    ...
+}
+```
+
+Maybe our parser first creates an `Item` with the name `foo` and then later a second `Item` with the name `bar`.
+Then the user changes the input to reorder the functions.
+Although we are still creating the same number of items, we are now creating them in the reverse order, so the naive algorithm will match up the _old_ `foo` struct with the new `bar` struct.
+This will look to Salsa as though the `foo` function was renamed to `bar` and the `bar` function was renamed to `foo`.
+We'll still get the right result, but we might do more recomputation than we needed to do if we understood that they were just reordered.
+
+To address this, you can tag fields in a tracked struct as `#[id]`. These fields are then used to "match up" struct instances across executions:
+
+```rust
+#[salsa::tracked]
+struct Item {
+    #[id]
+    name: Word, // we'll define Word in a second!
+    ...
+}
+```
+
+### Specify the result of tracked functions for particular structs
+
+Sometimes it is useful to define a tracked function but specify its value for some particular struct specially.
+For example, maybe the default way to compute the representation for a function is to read the AST, but you also have some built-in functions in your language and you want to hard-code their results.
+This can also be used to simulate a field that is initialized after the tracked struct is created.
+
+To support this use case, you can use the `specify` method associated with tracked functions.
+To enable this method, you need to add the `specify` flag to the function to alert users that its value may sometimes be specified externally.
+
+```rust
+#[salsa::tracked(specify)] // <-- specify flag required
+fn representation(db: &dyn crate::Db, item: Item) -> Representation {
+    // read the user's input AST by default
+    let ast = ast(db, item);
+    // ...
+}
+
+fn create_builtin_item(db: &dyn crate::Db) -> Item {
+    let i = Item::new(db, ...);
+    let r = hardcoded_representation();
+    representation::specify(db, i, r); // <-- use the method!
+    i
+}
+```
+
+Specifying is only possible for tracked functions that take a single tracked struct as an argument (besides the database).
+
+## Interned structs
+
+The final kind of Salsa struct are **interned structs**.
+Interned structs are useful for quick equality comparison.
+They are commonly used to represent strings or other primitive values.
+
+Most compilers, for example, will define a type to represent a user identifier:
+
+```rust
+#[salsa::interned]
+struct Word {
+    #[returns(ref)]
+    pub text: String,
+}
+```
+
+As with input and tracked structs, the `Word` struct itself is just a newtyped integer, and the actual data is stored in the database.
+
+You can create a new interned struct using `new`, just like with input and tracked structs:
+
+```rust
+let w1 = Word::new(db, "foo".to_string());
+let w2 = Word::new(db, "bar".to_string());
+let w3 = Word::new(db, "foo".to_string());
+```
+
+When you create two interned structs with the same field values, you are guaranteed to get back the same integer id. So here, we know that `assert_eq!(w1, w3)` is true and `assert_ne!(w1, w2)`.
+
+You can access the fields of an interned struct using a getter, like `word.text(db)`. These getters respect the `#[returns(ref)]` annotation. Like tracked structs, the fields of interned structs are immutable.
+
+## Accumulators
+
+The final Salsa concept are **accumulators**. Accumulators are a way to report errors or other "side channel" information that is separate from the main return value of your function.
+
+To create an accumulator, you declare a type as an _accumulator_:
+
+```rust
+#[salsa::accumulator]
+pub struct Diagnostics(String);
+```
+
+It must be a newtype of something, like `String`. Now, during a tracked function's execution, you can push those values:
+
+```rust
+Diagnostics::push(db, "some_string".to_string())
+```
+
+Then later, from outside the execution, you can ask for the set of diagnostics that were accumulated by some particular tracked function. For example, imagine that we have a type-checker and, during type-checking, it reports some diagnostics:
+
+```rust
+#[salsa::tracked]
+fn type_check(db: &dyn Db, item: Item) {
+    // ...
+    Diagnostics::push(db, "some error message".to_string())
+    // ...
+}
+```
+
+we can then later invoke the associated `accumulated` function to get all the `String` values that were pushed:
+
+```rust
+let v: Vec<String> = type_check::accumulated::<Diagnostics>(db);
+```
diff --git a/crates/salsa/book/src/plumbing.md b/crates/salsa/book/src/plumbing.md
new file mode 100644
index 000000000..f6eaab739
--- /dev/null
+++ b/crates/salsa/book/src/plumbing.md
@@ -0,0 +1,17 @@
+# Plumbing
+
+This chapter documents the code that salsa generates and its "inner workings".
+We refer to this as the "plumbing".
+
+## Overview
+
+The plumbing section is broken up into chapters:
+
+- The [jars and ingredients](./plumbing/jars_and_ingredients.md) covers how each salsa item (like a tracked function) specifies what data it needs and runtime, and how links between items work.
+- The [database and runtime](./plumbing/database_and_runtime.md) covers the data structures that are used at runtime to coordinate workers, trigger cancellation, track which functions are active and what dependencies they have accrued, and so forth.
+- The [query operations](./plumbing/query_ops.md) chapter describes how the major operations on function ingredients work. This text was written for an older version of salsa but the logic is the same:
+  - The [maybe changed after](./plumbing/maybe_changed_after.md) operation determines when a memoized value for a tracked function is out of date.
+  - The [fetch](./plumbing/fetch.md) operation computes the most recent value.
+  - The [derived queries flowchart](./plumbing/derived_flowchart.md) depicts the logic in flowchart form.
+  - The [cycle handling](./plumbing/cycles.md) handling chapter describes what happens when cycles occur.
+- The [terminology](./plumbing/terminology.md) section describes various words that appear throughout.
diff --git a/crates/salsa/book/src/plumbing/cycles.md b/crates/salsa/book/src/plumbing/cycles.md
new file mode 100644
index 000000000..39a8f8201
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/cycles.md
@@ -0,0 +1,17 @@
+# Cycles
+
+## Cross-thread blocking
+
+The interface for blocking across threads now works as follows:
+
+* When one thread `T1` wishes to block on a query `Q` being executed by another thread `T2`, it invokes `Runtime::try_block_on`. This will check for cycles. Assuming no cycle is detected, it will block `T1` until `T2` has completed with `Q`. At that point, `T1` reawakens. However, we don't know the result of executing `Q`, so `T1` now has to "retry". Typically, this will result in successfully reading the cached value.
+* While `T1` is blocking, the runtime moves its query stack (a `Vec`) into the shared dependency graph data structure. When `T1` reawakens, it recovers ownership of its query stack before returning from `try_block_on`.
+
+## Cycle detection
+
+When a thread `T1` attempts to execute a query `Q`, it will try to load the value for `Q` from the memoization tables. If it finds an `InProgress` marker, that indicates that `Q` is currently being computed. This indicates a potential cycle. `T1` will then try to block on the query `Q`:
+
+* If `Q` is also being computed by `T1`, then there is a cycle.
+* Otherwise, if `Q` is being computed by some other thread `T2`, we have to check whether `T2` is (transitively) blocked on `T1`. If so, there is a cycle.
+
+These two cases are handled internally by the `Runtime::try_block_on` function. Detecting the intra-thread cycle case is easy; to detect cross-thread cycles, the runtime maintains a dependency DAG between threads (identified by `RuntimeId`). Before adding an edge `T1 -> T2` (i.e., `T1` is blocked waiting for `T2`) into the DAG, it checks whether a path exists from `T2` to `T1`. If so, we have a cycle and the edge cannot be added (then the DAG would not longer be acyclic).
diff --git a/crates/salsa/book/src/plumbing/database.md b/crates/salsa/book/src/plumbing/database.md
new file mode 100644
index 000000000..88cf3bcf8
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/database.md
@@ -0,0 +1,81 @@
+# Database
+
+Continuing our dissection, the other thing which a user must define is a
+**database**, which looks something like this:
+
+```rust,ignore
+{{#include ../../../examples/hello_world/main.rs:database}}
+```
+
+The `salsa::database` procedural macro takes a list of query group
+structs (like `HelloWorldStorage`) and generates the following items:
+
+* a copy of the database struct it is applied to
+* a struct `__SalsaDatabaseStorage` that contains all the storage structs for
+  each query group. Note: these are the structs full of hashmaps etc that are
+  generaetd by the query group procdural macro, not the `HelloWorldStorage`
+  struct itself.
+* an impl of `HasQueryGroup<G>` for each query group `G`
+* an impl of `salsa::plumbing::DatabaseStorageTypes` for the database struct
+* an impl of `salsa::plumbing::DatabaseOps` for the database struct
+
+## Key constraint: we do not know the names of individual queries
+
+There is one key constraint in the design here. None of this code knows the
+names of individual queries. It only knows the name of the query group storage
+struct. This means that we often delegate things to the group -- e.g., the
+database key is composed of group keys. This is similar to how none of the code
+in the query group knows the full set of query groups, and so it must use
+associated types from the `Database` trait whenever it needs to put something in
+a "global" context.
+
+## The database storage struct
+
+The `__SalsaDatabaseStorage` struct concatenates all of the query group storage
+structs. In the hello world example, it looks something like:
+
+```rust,ignore
+struct __SalsaDatabaseStorage {
+    hello_world: <HelloWorldStorage as salsa::plumbing::QueryGroup<DatabaseStruct>>::GroupStorage
+}
+```
+
+We also generate a `Default` impl for `__SalsaDatabaseStorage`. It invokes
+a `new` method on each group storage with the unique index assigned to that group.
+This invokes the [inherent `new` method generated by the `#[salsa::query_group]` macro][new].
+
+[new]: query_groups.md#group-storage
+
+## The `HasQueryGroup` impl
+
+The `HasQueryGroup` trait allows a given query group to access its definition
+within the greater database. The impl is generated here:
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/database_storage.rs:HasQueryGroup}}
+```
+
+The `HasQueryGroup` impl combines with [the blanket impl] from the
+`#[salsa::query_group]` macro so that the database can implement the query group
+trait (e.g., the `HelloWorld` trait) but without knowing all the names of the
+query methods and the like.
+
+[the blanket impl]: query_groups.md#impl-of-the-hello-world-trait
+
+## The `DatabaseStorageTypes` impl
+
+Then there are a variety of other impls, like this one for `DatabaseStorageTypes`:
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/database_storage.rs:DatabaseStorageTypes}}
+```
+
+## The `DatabaseOps` impl
+
+Or this one for `DatabaseOps`, which defines the for-each method to
+invoke an operation on every kind of query in the database. It ultimately
+delegates to the `for_each` methods for the groups:
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/database_storage.rs:DatabaseOps}}
+```
diff --git a/crates/salsa/book/src/plumbing/database_and_runtime.md b/crates/salsa/book/src/plumbing/database_and_runtime.md
new file mode 100644
index 000000000..cc889c546
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/database_and_runtime.md
@@ -0,0 +1,70 @@
+# Database and runtime
+
+A salsa database struct is declared by the user with the `#[salsa::db]` annotation.
+It contains all the data that the program needs to execute:
+
+```rust,ignore
+#[salsa::db(jar0...jarn)]
+struct MyDatabase {
+    storage: Storage<Self>,
+    maybe_other_fields: u32,
+}
+```
+
+This data is divided into two categories:
+
+- Salsa-governed storage, contained in the `Storage<Self>` field. This data is mandatory.
+- Other fields (like `maybe_other_fields`) defined by the user. This can be anything. This allows for you to give access to special resources or whatever.
+
+## Parallel handles
+
+When used across parallel threads, the database type defined by the user must support a "snapshot" operation.
+This snapshot should create a clone of the database that can be used by the parallel threads.
+The `Storage` operation itself supports `snapshot`.
+The `Snapshot` method returns a `Snapshot<DB>` type, which prevents these clones from being accessed via an `&mut` reference.
+
+## The Storage struct
+
+The salsa `Storage` struct contains all the data that salsa itself will use and work with.
+There are three key bits of data:
+
+- The `Shared` struct, which contains the data stored across all snapshots. This is primarily the ingredients described in the [jars and ingredients chapter](./jars_and_ingredients.md), but it also contains some synchronization information (a cond var). This is used for cancellation, as described below.
+  - The data in the `Shared` struct is only shared across threads when other threads are active. Some operations, like mutating an input, require an `&mut` handle to the `Shared` struct. This is obtained by using the `Arc::get_mut` methods; obviously this is only possible when all snapshots and threads have ceased executing, since there must be a single handle to the `Arc`.
+- The `Routes` struct, which contains the information to find any particular ingredient -- this is also shared across all handles, and its construction is also described in the [jars and ingredients chapter](./jars_and_ingredients.md). The routes are separated out from the `Shared` struct because they are truly immutable at all times, and we want to be able to hold a handle to them while getting `&mut` access to the `Shared` struct.
+- The `Runtime` struct, which is specific to a particular database instance. It contains the data for a single active thread, along with some links to shared data of its own.
+
+## Incrementing the revision counter and getting mutable access to the jars
+
+Salsa's general model is that there is a single "master" copy of the database and, potentially, multiple snapshots.
+The snapshots are not directly owned, they are instead enclosed in a `Snapshot<DB>` type that permits only `&`-deref,
+and so the only database that can be accessed with an `&mut`-ref is the master database.
+Each of the snapshots however onlys another handle on the `Arc` in `Storage` that stores the ingredients.
+
+Whenever the user attempts to do an `&mut`-operation, such as modifying an input field, that needs to
+first cancel any parallel snapshots and wait for those parallel threads to finish.
+Once the snapshots have completed, we can use `Arc::get_mut` to get an `&mut` reference to the ingredient data.
+This allows us to get `&mut` access without any unsafe code and
+guarantees that we have successfully managed to cancel the other worker threads
+(or gotten ourselves into a deadlock).
+
+The code to acquire `&mut` access to the database is the `jars_mut` method:
+
+```rust
+{{#include ../../../src/storage.rs:jars_mut}}
+```
+
+The key initial point is that it invokes `cancel_other_workers` before proceeding:
+
+```rust
+{{#include ../../../src/storage.rs:cancel_other_workers}}
+```
+
+## The Salsa runtime
+
+The salsa runtime offers helper methods that are accessed by the ingredients.
+It tracks, for example, the active query stack, and contains methods for adding dependencies between queries (e.g., `report_tracked_read`) or [resolving cycles](./cycles.md).
+It also tracks the current revision and information about when values with low or high durability last changed.
+
+Basically, the ingredient structures store the "data at rest" -- like memoized values -- and things that are "per ingredient".
+
+The runtime stores the "active, in-progress" data, such as which queries are on the stack, and/or the dependencies accessed by the currently active query.
diff --git a/crates/salsa/book/src/plumbing/db_lifetime.md b/crates/salsa/book/src/plumbing/db_lifetime.md
new file mode 100644
index 000000000..541f3d3a5
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/db_lifetime.md
@@ -0,0 +1,238 @@
+# The `'db` lifetime
+
+[Tracked](./tracked_structs.md) and interned structs are both declared with a `'db` lifetime.
+This lifetime is linked to the `db: &DB` reference used to create them.
+The `'db` lifetime has several implications:
+
+* It ensures that the user does not create a new salsa revision while a tracked/interned struct is in active use. Creating a new salsa revision requires modifying an input which requires an `&mut DB` reference, therefore it cannot occur during `'db`.
+    * The struct may not even exist in the new salsa revision so allowing access would be confusing.
+* It permits the structs to be implemented using a pointer rather than a `salsa::Id`, which in turn means more efficient field access (no read locks required).
+
+This section discusses the unsafe code used for pointer-based access along with the reasoning behind it. To be concrete, we'll focus on tracked structs -- interned structs are very similar.
+
+## A note on UB
+
+When we say in this page "users cannot do X", we mean without Undefined Behavior (e.g., by transmuting integers around etc).
+
+## Proof obligations
+
+Here is a typical sequence of operations for a tracked struct along with the user operations that will require us to prove unsafe assertions:
+
+* A tracked function `f` executes in revision R0 and creates a tracked struct with `#[id]` fields `K` for the first time.
+    * `K` will be stored in the interning hashmap and mapped to a fresh identifier `id`.
+    * The identifier `id` will be used as the key in the `StructMap` and point to a freshly created allocation `alloc : Alloc`.
+    * A `ts: TS<'db>` is created from the raw pointer `alloc` and returned to the user.
+* The value of the field `field` is accessed on the tracked struct instance `ts` by invoking the method `ts.field(db)`
+    * *Unsafe:* This accesses the raw pointer to `alloc`.* A new revision R1 begins.
+* The tracked function `f` does not re-execute in R1.
+* The value of the field `field` is accessed on the tracked struct instance `ts` by invoking the method `ts.field(db)`
+    * *Unsafe:* This accesses the raw pointer to `alloc`.* A new revision R2 begins.
+* The tracked function `f` does reexecute in R2 and it again creates a tracked struct with key `K` and with (Some) distinct field values.
+    * The fields for `ts` are updated.
+* The value of the field `field` is accessed on the tracked struct instance `ts` by invoking the method `ts.field(db)`
+    * *Unsafe:* This accesses the raw pointer to `alloc`.
+* A new revision R3 begins.
+* When `f` executes this time it does NOT create a tracked struct with key `K`. The tracked struct `ts` is placed in the "to be deleted" list.
+* A new revision R4 begins:
+    * The allocation `alloc` is freed.
+
+As noted in the list, the core "unsafe" operation that users can perform is to access the fields of a tracked struct.
+Tracked structs store a raw pointer to the `alloc`, owned by the ingredient, that contains their field data.
+Accessing the fields of a tracked struct returns a `&`-reference to fields stored in that `alloc`, which means we must ensure Rust's two core constraints are satisfied for the lifetime of that reference:
+
+* The allocation `alloc` will not be freed (i.e., not be dropped)
+* The contents of the fields will not be mutated
+
+As the sequence above illustrates, we have to show that those two constraints are true in a variety of circumstances:
+
+* newly created tracked structs
+* tracked structs that were created in prior revisions and re-validated in this revision
+* tracked structs whose fields were updated in this revision
+* tracked structs that were *not* created in this revision
+
+## Definitions
+
+For every tracked struct `ts` we say that it has a **defining query** `f(..)`. 
+This refers to a particular invocation of the tracked function `f` with a particular set of arguments `..`.
+This defining query is unique within a revision, meaning that `f` executes at most once with that same set of arguments.
+
+We say that a query has *executed in a revision R* if its function body was executed. When this occurs, all tracked structs defined (created) by that query will be recorded along with the query's result.
+
+We say that a query has been *validated in a revision R* if the salsa system determined that its inputs did not change and so skipped executing it. This also triggers the tracked structs defined by that query to be considered validated (in particular, we execute a function on them which updates some internal fields, as described below).
+
+When we talk about `ts`, we mean 
+
+## Theorem: At the start of a new revision, all references to `ts` are within salsa's database
+
+After `ts` is deleted, there may be other memoized values still reference `ts`, but they must have a red input query.
+**Is this true even if there are user bugs like non-deterministic functions?**
+Argument: yes, because of non-forgery, those memoized values could not be accessed.
+How did those memoized values obtain the `TS<'db>` value in the first place?
+It must have come from a function argument (XX: what about thread-local state).
+Therefore, to access the value, they would have to provide those function arguments again.
+But how did they get them?
+
+Potential holes:
+
+* Thread-local APIs that let you thread `'db` values down in an "invisible" way, so that you can return them without them showing up in your arguments -- e.g. a tracked function `() -> S<'db>` that obtains its value from thread-local state.
+    * We might be able to sanity check against this with enough effort by defining some traits that guarantee that every lifetime tagged thing in your result *could have* come from one of your arguments, but I don't think we can prove it altogether. We either have to tell users "don't do that" or we need to have some kind of dynamic check, e.g. with a kind of versioned pointer. Note that it does require unsafe code at present but only because of the limits of our existing APIs.
+    * Alternatively we can do a better job cleaning up deleted stuff. This we could do.
+* what about weird `Eq` implementations and the like? Do we have to make those unsafe?
+
+## Theorem: To access a tracked struct `ts` in revision R, the defining query `f(..)` must have either *executed* or been *validated* in the revision R.
+
+This is the core bit of reasoning underlying most of what follows.
+The idea is that users cannot "forge" a tracked struct instance `ts`.
+They must have gotten it through salsa's internal mechanisms.
+This is important because salsa will provide `&`-references to fields within that remain valid during a revision.
+But at the start of a new revision salsa may opt to modify those fields or even free the allocation.
+This is safe because users cannot have references to `ts` at the start of a new revision.
+
+
+### Lemma
+
+
+We will prove it by proceeding through the revisions in the life cycle above (this can be considered a proof by induction).
+
+### Before `ts` is first created in R0
+
+Users must have originally obtained `ts: TS<'db>` by invoking `TS::new(&db, ...)`.
+This is because creating an instance of `TS` requires providing a `NonNull<salsa::tracked_struct::ValueStruct>` pointer 
+to an unsafe function whose contract requires the pointer's validity.
+
+**FIXME:** This is not strictly true, I think the constructor is just a private tuple ctor, we should fix that.
+
+### During R0 
+
+
+### 
+
+
+### Inductive case: Consider some revision R
+
+We start by showing some circumstances that cannot occur:
+
+* accessing the field of a tracked struct `ts` that was never created
+* accessing the field of a tracked struct `ts` after it is freed
+
+### Lemma (no forgery): Users cannot forge a tracked struct
+
+The first observation is that users cannot "forge" an instance of a tracked struct `ts`.
+They are required to produce a pointer to an `Alloc`.
+This implies that every tracked struct `ts` originated in the ingredient.
+The same is not true for input structs, for example, because they are created from integer identifiers and users could just make those up.
+
+### Lemma (within one rev): Users cannot hold a tracked struct `ts` across revisions
+
+The lifetime `'db` of the tracked struct `ts: TS<'db>` is created from a `db: &'db dyn Db` handle.
+Beginning a new revision requires an `&mut` reference.
+Therefore so long as users are actively using the value `ts` the database cannot start a new revision.
+
+*Check:* What if users had two databases and invoked internal methods? Maybe they could then. We may have to add some assertions.
+
+### Theorem: In order to get a tracked struct `ts` in revision R0, the tracked fn `f` that creates it must either *execute* or *be validated* first
+
+The two points above combine to 
+
+
+## Creating new values
+
+Each new value is stored in a `salsa::alloc::Alloc` created by `StructMap::insert`.
+`Alloc` is a variant of the standard Rust `Box` that carries no uniqueness implications.
+This means that every tracked struct has its own allocation.
+This allocation is owned by the tracked struct ingredient
+and thus stays live until the tracked struct ingredient is dropped
+or until it is removed (see later for safety conditions around removal).
+
+## The user type uses a raw pointer
+
+The `#[salsa::tracked]` macro creates a user-exposed struct that looks roughly like this:
+
+```rust
+// This struct is a wrapper around the actual fields that adds
+// some revision metadata. You can think of it as a newtype'd
+// version of the fields of the tracked struct.
+use salsa::tracked_struct::ValueStruct;
+
+struct MyTrackedStruct<'db> {
+    value: *const ValueStruct<..>,
+    phantom: PhantomData<&'db ValueStruct<...>>
+}
+```
+
+Key observations:
+
+* The actual pointer to the `ValueStruct` used at runtime is not a Rust reference but a raw pointer. This is needed for stacked borrows.
+* A `PhantomData` is used to keep the `'db` lifetime alive.
+
+The reason we use a raw pointer in the struct is because instances of this struct will outlive the `'db` lifetime. Consider this example:
+
+```rust
+let mut db = MyDatabase::default();
+let input = MyInput::new(&db, ...);
+
+// Revision 1:
+let result1 = tracked_fn(&db, input);
+
+// Revision 2:
+input.set_field(&mut db).to(...);
+let result2 = tracked_fn(&db, input);
+```
+
+Tracked structs created by `tracked_fn` during Revision 1
+may be reused during Revision 2, but the original `&db` reference
+used to create them has expired.
+If we stored a true Rust reference, that would be a violation of
+the stacked borrows rules.
+
+Instead, we store a raw pointer and,
+whenever users invoke the accessor methods for particular fields,
+we create a new reference to the contents:
+
+```rust
+impl<'db> MyTrackedStruct<'db> {
+    fn field(self, db: &'db dyn DB) -> &'db FieldType {
+        ...
+    }
+}
+```
+
+This reference is linked to `db` and remains valid so long as the 
+
+## The `'db` lifetime at rest
+
+## Updating tracked struct fields across revisions
+
+### The `XX`
+
+## Safety lemmas
+
+These lemmas are used to justify the safety of the system.
+
+### Using `MyTracked<'db>` within some revision R always "happens after' a call to `MyTracked::new`
+
+Whenever a tracked struct instance `TS<'db>` is created for the first time in revision R1,
+the result is a fresh allocation and hence there cannot be any
+pre-existing aliases of that struct.
+
+`TS<'db>` will at that time be stored into the salsa database.
+In later revisions, we assert that 
+
+### `&'db T` references are never stored in the database
+
+
+We maintain the invariant that, in any later revision R2, 
+
+However in some later revision R2, how 
+
+## Ways this could go wrong and how we prevent them
+
+### 
+
+### Storing an `&'db T` into a field
+
+
+### Freeing the memory while a tracked struct remains live
+
+
+### Aliases of a tracked struct
diff --git a/crates/salsa/book/src/plumbing/derived_flowchart.md b/crates/salsa/book/src/plumbing/derived_flowchart.md
new file mode 100644
index 000000000..8423c173b
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/derived_flowchart.md
@@ -0,0 +1,14 @@
+# Derived queries flowchart
+
+Derived queries are by far the most complex. This flowchart documents the flow of the [maybe changed after] and [fetch] operations. This flowchart can be edited on [draw.io]:
+
+[draw.io]: https://draw.io
+[fetch]: ./fetch.md
+[maybe changed after]: ./maybe_changed_after.md
+
+<!-- The explicit div is there because, otherwise, the flowchart is unreadable when using "dark mode" -->
+<div style="background-color:white;">
+
+![Flowchart](../derived-query-read.drawio.svg)
+
+</div>
diff --git a/crates/salsa/book/src/plumbing/diagram.md b/crates/salsa/book/src/plumbing/diagram.md
new file mode 100644
index 000000000..971378243
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/diagram.md
@@ -0,0 +1,50 @@
+# Diagram
+
+This diagram shows the items that get generated from the Hello World query group and database struct. You can click on each item to be taken to the explanation of its purpose. The diagram is wide so be sure to scroll over!
+
+```mermaid
+graph LR
+    classDef diagramNode text-align:left;
+    subgraph query group
+        HelloWorldTrait["trait HelloWorld: Database + HasQueryGroup(HelloWorldStorage)"]
+        HelloWorldImpl["impl&lt;DB&gt; HelloWorld for DB<br>where DB: HasQueryGroup(HelloWorldStorage)"]
+        click HelloWorldImpl "http:query_groups.html#impl-of-the-hello-world-trait" "more info"
+        HelloWorldStorage["struct HelloWorldStorage"]
+        click HelloWorldStorage "http:query_groups.html#the-group-struct-and-querygroup-trait" "more info"
+        QueryGroupImpl["impl QueryGroup for HelloWorldStorage<br>&nbsp;&nbsp;type DynDb = dyn HelloWorld<br>&nbsp;&nbsp;type Storage = HelloWorldGroupStorage__;"]
+        click QueryGroupImpl "http:query_groups.html#the-group-struct-and-querygroup-trait" "more info"
+        HelloWorldGroupStorage["struct HelloWorldGroupStorage__"]
+        click HelloWorldGroupStorage "http:query_groups.html#group-storage" "more info"
+        subgraph for each query...
+            LengthQuery[struct LengthQuery]
+            LengthQueryImpl["impl Query for LengthQuery<br>&nbsp;&nbsp;type Key = ()<br>&nbsp;&nbsp;type Value = usize<br>&nbsp;&nbsp;type Storage = salsa::DerivedStorage(Self)<br>&nbsp;&nbsp;type QueryGroup = HelloWorldStorage"]
+            LengthQueryFunctionImpl["impl QueryFunction for LengthQuery<br>&nbsp;&nbsp;fn execute(db: &dyn HelloWorld, key: ()) -> usize"]
+            click LengthQuery "http:query_groups.html#for-each-query-a-query-struct" "more info"
+            click LengthQueryImpl "http:query_groups.html#for-each-query-a-query-struct" "more info"
+            click LengthQueryFunctionImpl "http:query_groups.html#for-each-query-a-query-struct" "more info"
+        end
+        class HelloWorldTrait,HelloWorldImpl,HelloWorldStorage,QueryGroupImpl,HelloWorldGroupStorage diagramNode;
+        class LengthQuery,LengthQueryImpl,LengthQueryFunctionImpl diagramNode;
+    end
+    subgraph database
+        DatabaseStruct["struct Database { .. storage: Storage(Self) .. }"]
+        subgraph for each group...
+            HasQueryGroup["impl plumbing::HasQueryGroup(HelloWorldStorage) for DatabaseStruct"]
+            click HasQueryGroup "http:database.html#the-hasquerygroup-impl" "more info"
+        end
+        DatabaseStorageTypes["impl plumbing::DatabaseStorageTypes for DatabaseStruct<br>&nbsp;&nbsp;type DatabaseStorage = __SalsaDatabaseStorage"]
+        click DatabaseStorageTypes "http:database.html#the-databasestoragetypes-impl" "more info"
+        DatabaseStorage["struct __SalsaDatabaseStorage"]
+        click DatabaseStorage "http:database.html#the-database-storage-struct" "more info"
+        DatabaseOps["impl plumbing::DatabaseOps for DatabaseStruct"]
+        click DatabaseOps "http:database.html#the-databaseops-impl" "more info"
+        class DatabaseStruct,DatabaseStorage,DatabaseStorageTypes,DatabaseOps,HasQueryGroup diagramNode;
+    end
+    subgraph salsa crate
+        DerivedStorage["DerivedStorage"]
+        class DerivedStorage diagramNode;
+    end
+    LengthQueryImpl --> DerivedStorage;
+    DatabaseStruct -- "used by" --> HelloWorldImpl
+    HasQueryGroup -- "used by" --> HelloWorldImpl
+```
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/fetch.md b/crates/salsa/book/src/plumbing/fetch.md
new file mode 100644
index 000000000..e0319d1c8
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/fetch.md
@@ -0,0 +1,42 @@
+# Fetch
+
+```rust,no_run,noplayground
+{{#include ../../../src/plumbing.rs:fetch}}
+```
+
+The `fetch` operation computes the value of a query. It prefers to reuse memoized values when it can.
+
+## Input queries
+
+Input queries simply load the result from the table.
+
+## Interned queries
+
+Interned queries map the input into a hashmap to find an existing integer. If none is present, a new value is created.
+
+## Derived queries
+
+The logic for derived queries is more complex. We summarize the high-level ideas here, but you may find the [flowchart](./derived_flowchart.md) useful to dig deeper. The [terminology](./terminology.md) section may also be useful; in some cases, we link to that section on the first usage of a word.
+
+* If an existing [memo] is found, then we check if the memo was [verified] in the current [revision]. If so, we can directly return the memoized value.
+* Otherwise, if the memo contains a memoized value, we must check whether [dependencies] have been modified:
+    * Let R be the revision in which the memo was last verified; we wish to know if any of the dependencies have changed since revision R.
+    * First, we check the [durability]. For each memo, we track the minimum durability of the memo's dependencies. If the memo has durability D, and there have been no changes to an input with durability D since the last time the memo was verified, then we can consider the memo verified without any further work.
+    * If the durability check is not sufficient, then we must check the dependencies individually. For this, we iterate over each dependency D and invoke the [maybe changed after](./maybe_changed_after.md) operation to check whether D has changed since the revision R.
+    * If no dependency was modified:
+        * We can mark the memo as verified and return its memoized value.
+* Assuming dependencies have been modified or the memo does not contain a memoized value:
+    * Then we execute the user's query function.
+    * Next, we compute the revision in which the memoized value last changed:
+        * *Backdate:* If there was a previous memoized value, and the new value is equal to that old value, then we can *backdate* the memo, which means to use the 'changed at' revision from before.
+            * Thanks to backdating, it is possible for a dependency of the query to have changed in some revision R1 but for the *output* of the query to have changed in some revision R2 where R2 predates R1.
+        * Otherwise, we use the current revision.
+    * Construct a memo for the new value and return it.
+
+[durability]: ./terminology/durability.md
+[backdate]: ./terminology/backdate.md
+[dependency]: ./terminology/dependency.md
+[dependencies]: ./terminology/dependency.md
+[memo]: ./terminology/memo.md
+[revision]: ./terminology/revision.md
+[verified]: ./terminology/verified.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/generated_code.md b/crates/salsa/book/src/plumbing/generated_code.md
new file mode 100644
index 000000000..ae7742f54
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/generated_code.md
@@ -0,0 +1,28 @@
+# Generated code
+
+This page walks through the ["Hello, World!"] example and explains the code that
+it generates. Please take it with a grain of salt: while we make an effort to
+keep this documentation up to date, this sort of thing can fall out of date
+easily. See the page history below for major updates.
+
+["Hello, World!"]: https://github.com/salsa-rs/salsa/blob/master/examples/hello_world/main.rs
+
+If you'd like to see for yourself, you can set the environment variable
+`SALSA_DUMP` to 1 while the procedural macro runs, and it will dump the full
+output to stdout. I recommend piping the output through rustfmt.
+
+## Sources
+
+The main parts of the source that we are focused on are as follows.
+
+### Query group
+
+```rust,ignore
+{{#include ../../../examples/hello_world/main.rs:trait}}
+```
+
+### Database
+
+```rust,ignore
+{{#include ../../../examples/hello_world/main.rs:database}}
+```
diff --git a/crates/salsa/book/src/plumbing/jars_and_ingredients.md b/crates/salsa/book/src/plumbing/jars_and_ingredients.md
new file mode 100644
index 000000000..065c41277
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/jars_and_ingredients.md
@@ -0,0 +1,208 @@
+# Jars and ingredients
+
+This page covers how data is organized in Salsa and how links between Salsa items (e.g., dependency tracking) work.
+
+## Salsa items and ingredients
+
+A **Salsa item** is some item annotated with a Salsa annotation that can be included in a jar.
+For example, a tracked function is a Salsa item:
+
+```rust
+#[salsa::tracked]
+fn foo(db: &dyn Db, input: MyInput) { }
+```
+
+...and so is a Salsa input...
+
+```rust
+#[salsa::input]
+struct MyInput { }
+```
+
+...or a tracked struct:
+
+```rust
+#[salsa::tracked]
+struct MyStruct { }
+```
+
+Each Salsa item needs certain bits of data at runtime to operate.
+These bits of data are called **ingredients**.
+Most Salsa items generate a single ingredient, but sometimes they make more than one.
+For example, a tracked function generates a [`FunctionIngredient`].
+A tracked struct, however, generates several ingredients, one for the struct itself (a [`TrackedStructIngredient`],
+and one [`FunctionIngredient`] for each value field.
+
+[`FunctionIngredient`]: https://github.com/salsa-rs/salsa/blob/becaade31e6ebc58cd0505fc1ee4b8df1f39f7de/components/salsa-2022/src/function.rs#L42
+[`TrackedStructIngredient`]: https://github.com/salsa-rs/salsa/blob/becaade31e6ebc58cd0505fc1ee4b8df1f39f7de/components/salsa-2022/src/tracked_struct.rs#L18
+
+### Ingredients define the core logic of Salsa
+
+Most of the interesting Salsa code lives in these ingredients.
+For example, when you create a new tracked struct, the method [`TrackedStruct::new_struct`] is invoked;
+it is responsible for determining the tracked struct's id.
+Similarly, when you call a tracked function, that is translated into a call to [`TrackedFunction::fetch`],
+which decides whether there is a valid memoized value to return,
+or whether the function must be executed.
+
+[`TrackedStruct::new_struct`]: https://github.com/salsa-rs/salsa/blob/becaade31e6ebc58cd0505fc1ee4b8df1f39f7de/components/salsa-2022/src/tracked_struct.rs#L76
+[`TrackedFunction::fetch`]: https://github.com/salsa-rs/salsa/blob/becaade31e6ebc58cd0505fc1ee4b8df1f39f7de/components/salsa-2022/src/function/fetch.rs#L15
+
+### The `Ingredient` trait
+
+Each ingredient implements the [`Ingredient<DB>`] trait, which defines generic operations supported by any kind of ingredient.
+For example, the method `maybe_changed_after` can be used to check whether some particular piece of data stored in the ingredient may have changed since a given revision:
+
+[`Ingredient<DB>`]: https://github.com/salsa-rs/salsa/blob/becaade31e6ebc58cd0505fc1ee4b8df1f39f7de/components/salsa-2022/src/ingredient.rs#L15
+[`maybe_changed_after`]: https://github.com/salsa-rs/salsa/blob/becaade31e6ebc58cd0505fc1ee4b8df1f39f7de/components/salsa-2022/src/ingredient.rs#L21-L22
+
+We'll see below that each database `DB` is able to take an `IngredientIndex` and use that to get an `&dyn Ingredient<DB>` for the corresponding ingredient.
+This allows the database to perform generic operations on an indexed ingredient without knowing exactly what the type of that ingredient is.
+
+### Jars are a collection of ingredients
+
+When you declare a Salsa jar, you list out each of the Salsa items that are included in that jar:
+
+```rust,ignore
+#[salsa::jar]
+struct Jar(
+    foo,
+    MyInput,
+    MyStruct
+);
+```
+
+This expands to a struct like so:
+
+```rust
+struct Jar(
+    <foo as IngredientsFor>::Ingredient,
+    <MyInput as IngredientsFor>::Ingredient,
+    <MyStruct as IngredientsFor>::Ingredient,
+)
+```
+
+The `IngredientsFor` trait is used to define the ingredients needed by some Salsa item, such as the tracked function `foo` or the tracked struct `MyInput`.
+Each Salsa item defines a type `I` so that `<I as IngredientsFor>::Ingredient` gives the ingredients needed by `I`.
+
+### A database is a tuple of jars
+
+Salsa's database storage ultimately boils down to a tuple of jar structs
+where each jar struct (as we just saw) itself contains the ingredients
+for the Salsa items within that jar.
+The database can thus be thought of as a list of ingredients,
+although that list is organized into a 2-level hierarchy.
+
+The reason for this 2-level hierarchy is that it permits separate compilation and privacy.
+The crate that lists the jars doesn't have to know the contents of the jar to embed the jar struct in the database.
+And some of the types that appear in the jar may be private to another struct.
+
+### The `HasJars` trait and the `Jars` type
+
+Each Salsa database implements the `HasJars` trait,
+generated by the `salsa::db` procedural macro.
+The `HarJars` trait, among other things, defines a `Jars` associated type that maps to a tuple of the jars in the trait.
+
+For example, given a database like this...
+
+```rust,ignore
+#[salsa::db(Jar1, ..., JarN)]
+struct MyDatabase {
+    storage: salsa::Storage<Self>
+}
+```
+
+...the `salsa::db` macro would generate a `HasJars` impl that (among other things) contains `type Jars = (Jar1, ..., JarN)`:
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/db.rs:HasJars}}
+```
+
+In turn, the `salsa::Storage<DB>` type ultimately contains a struct `Shared` that embeds `DB::Jars`, thus embedding all the data for each jar.
+
+### Ingredient indices
+
+During initialization, each ingredient in the database is assigned a unique index called the [`IngredientIndex`].
+This is a 32-bit number that identifies a particular ingredient from a particular jar.
+
+[`IngredientIndex`]: https://github.com/salsa-rs/salsa/blob/becaade31e6ebc58cd0505fc1ee4b8df1f39f7de/components/salsa-2022/src/routes.rs#L5-L9
+
+### Routes
+
+In addition to an index, each ingredient in the database also has a corresponding _route_.
+A route is a closure that, given a reference to the `DB::Jars` tuple,
+returns a `&dyn Ingredient<DB>` reference.
+The route table allows us to go from the `IngredientIndex` for a particular ingredient
+to its `&dyn Ingredient<DB>` trait object.
+The route table is created while the database is being initialized,
+as described shortly.
+
+### Database keys and dependency keys
+
+A `DatabaseKeyIndex` identifies a specific value stored in some specific ingredient.
+It combines an [`IngredientIndex`] with a `key_index`, which is a `salsa::Id`:
+
+```rust,ignore
+{{#include ../../../src/key.rs:DatabaseKeyIndex}}
+```
+
+These kinds of indices are used to store connetions between ingredients.
+For example, each memoized value has to track its inputs.
+Those inputs are stored as dependency indices.
+We can then do things like ask, "did this input change since revision R?" by
+
+- using the ingredient index to find the route and get a `&dyn Ingredient<DB>`
+- and then invoking the `maybe_changed_since` method on that trait object.
+
+### `HasJarsDyn`
+
+There is one catch in the above setup.
+The user's code always interacts with a `dyn crate::Db` value, where `crate::Db` is the trait defined by the jar; the `crate::Db` trait extends `salsa::HasJar` which in turn extends `salsa::Database`.
+Ideally, we would have `salsa::Database` extend `salsa::HasJars`, which is the main trait that gives access to the jars data.
+But we don't want to do that because `HasJars` defines an associated type `Jars`, and that would mean that every reference to `dyn crate::Db` would have to specify the jars type using something like `dyn crate::Db<Jars = J>`.
+This would be unergonomic, but what's worse, it would actually be impossible: the final Jars type combines the jars from multiple crates, and so it is not known to any individual jar crate.
+To workaround this, `salsa::Database` in fact extends _another_ trait, `HasJarsDyn`, that doesn't reveal the `Jars` or ingredient types directly, but just has various method that can be performed on an ingredient, given its `IngredientIndex`.
+Traits like `Ingredient<DB>` require knowing the full `DB` type.
+If we had one function ingredient directly invoke a method on `Ingredient<DB>`, that would imply that it has to be fully generic and only instantiated at the final crate, when the full database type is available.
+
+We solve this via the `HasJarsDyn` trait. The `HasJarsDyn` trait exports a method that combines the "find ingredient, invoking method" steps into one method:
+
+```rust,ignore aasaaasdfijjAasdfa
+{{#include ../../../src/storage.rs:HasJarsDyn}}
+```
+
+So, technically, to check if an input has changed, an ingredient:
+
+- Invokes `HasJarsDyn::maybe_changed_after` on the `dyn Database`
+- The impl for this method (generated by `#[salsa::db]`):
+  - gets the route for the ingredient from the ingredient index
+  - uses the route to get a `&dyn Ingredient`
+  - invokes `maybe_changed_after` on that ingredient
+
+### Initializing the database
+
+The last thing to discuss is how the database is initialized.
+The `Default` implementation for `Storage<DB>` does the work:
+
+```rust,ignore
+{{#include ../../../src/storage.rs:default}}
+```
+
+First, it creates an empty `Routes` instance.
+Then it invokes the `DB::create_jars` method.
+The implementation of this method is defined by the `#[salsa::db]` macro; it invokes `salsa::plumbing::create_jars_inplace` to allocate memory for the jars, and then invokes the `Jar::init_jar` method on each of the jars to initialize them:
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/db.rs:create_jars}}
+```
+
+This implementation for `init_jar` is generated by the `#[salsa::jar]` macro, and simply walks over the representative type for each salsa item and asks _it_ to create its ingredients
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/jar.rs:init_jar}}
+```
+
+The code to create the ingredients for any particular item is generated by their associated macros (e.g., `#[salsa::tracked]`, `#[salsa::input]`), but it always follows a particular structure.
+To create an ingredient, we first invoke `Routes::push`, which creates the routes to that ingredient and assigns it an `IngredientIndex`.
+We can then invoke a function such as `FunctionIngredient::new` to create the structure.
+The _routes_ to an ingredient are defined as closures that, given the `DB::Jars`, can find the data for a particular ingredient.
diff --git a/crates/salsa/book/src/plumbing/maybe_changed_after.md b/crates/salsa/book/src/plumbing/maybe_changed_after.md
new file mode 100644
index 000000000..754ebd269
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/maybe_changed_after.md
@@ -0,0 +1,40 @@
+# Maybe changed after
+
+```rust,no_run,noplayground
+{{#include ../../../src/plumbing.rs:maybe_changed_after}}
+```
+
+The `maybe_changed_after` operation computes whether a query's value *may have changed* **after** the given revision. In other words, `Q.maybe_change_since(R)` is true if the value of the query `Q` may have changed in the revisions `(R+1)..R_now`, where `R_now` is the current revision. Note that it doesn't make sense to ask `maybe_changed_after(R_now)`.
+
+## Input queries
+
+Input queries are set explicitly by the user. `maybe_changed_after` can therefore just check when the value was last set and compare.
+
+## Interned queries
+
+## Derived queries
+
+The logic for derived queries is more complex. We summarize the high-level ideas here, but you may find the [flowchart](./derived_flowchart.md) useful to dig deeper. The [terminology](./terminology.md) section may also be useful; in some cases, we link to that section on the first usage of a word.
+
+* If an existing [memo] is found, then we check if the memo was [verified] in the current [revision]. If so, we can compare its [changed at] revision and return true or false appropriately.
+* Otherwise, we must check whether [dependencies] have been modified:
+    * Let R be the revision in which the memo was last verified; we wish to know if any of the dependencies have changed since revision R.
+    * First, we check the [durability]. For each memo, we track the minimum durability of the memo's dependencies. If the memo has durability D, and there have been no changes to an input with durability D since the last time the memo was verified, then we can consider the memo verified without any further work.
+    * If the durability check is not sufficient, then we must check the dependencies individually. For this, we iterate over each dependency D and invoke the [maybe changed after](./maybe_changed_after.md) operation to check whether D has changed since the revision R.
+    * If no dependency was modified:
+        * We can mark the memo as verified and use its [changed at] revision to return true or false.
+* Assuming dependencies have been modified:
+    * Then we execute the user's query function (same as in [fetch]), which potentially [backdates] the resulting value.
+    * Compare the [changed at] revision in the resulting memo and return true or false.
+
+[changed at]: ./terminology/changed_at.md
+[durability]: ./terminology/durability.md
+[backdate]: ./terminology/backdate.md
+[backdates]: ./terminology/backdate.md
+[dependency]: ./terminology/dependency.md
+[dependencies]: ./terminology/dependency.md
+[memo]: ./terminology/memo.md
+[revision]: ./terminology/revision.md
+[verified]: ./terminology/verified.md
+[fetch]: ./fetch.md
+[LRU]: ./terminology/LRU.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/query_groups.md b/crates/salsa/book/src/plumbing/query_groups.md
new file mode 100644
index 000000000..fdbbad855
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/query_groups.md
@@ -0,0 +1,195 @@
+# Query groups and query group structs
+
+When you define a query group trait:
+
+```rust,ignore
+{{#include ../../../examples/hello_world/main.rs:trait}}
+```
+
+the `salsa::query_group` macro generates a number of things, shown in the sample
+generated code below (details in the sections to come).
+
+and associated storage struct) that represent things which don't have "public"
+Note that there are a number of structs and types (e.g., the group descriptor
+names. We currently generate mangled names with `__` afterwards, but those names
+are not meant to be exposed to the user (ideally we'd use hygiene to enforce
+this).
+
+```rust,ignore
+// First, a copy of the trait, though with extra supertraits and
+// sometimes with some extra methods (e.g., `set_input_string`)
+trait HelloWorld: 
+    salsa::Database + 
+    salsa::plumbing::HasQueryGroup<HelloWorldStorage>
+{
+    fn input_string(&self, key: ()) -> Arc<String>;
+    fn set_input_string(&mut self, key: (), value: Arc<String>);
+    fn length(&self, key: ()) -> usize;
+}
+
+// Next, the "query group struct", whose name was given by the
+// user. This struct implements the `QueryGroup` trait which
+// defines a few associated types common to the entire group.
+struct HelloWorldStorage { }
+impl salsa::plumbing::QueryGroup for HelloWorldStorage {
+    type DynDb = dyn HelloWorld;
+    type GroupStorage = HelloWorldGroupStorage__;
+}
+
+// Next, a blanket impl of the `HelloWorld` trait. This impl
+// works for any database `DB` that implements the
+// appropriate `HasQueryGroup`.
+impl<DB> HelloWorld for DB
+where
+  DB: salsa::Database,
+  DB: salsa::plumbing::HasQueryGroup<HelloWorldStorage>,
+{
+  ...
+}
+
+// Next, for each query, a "query struct" that represents it.
+// The query struct has inherent methods like `in_db` and
+// implements the `Query` trait, which defines various
+// details about the query (e.g., its key, value, etc).
+pub struct InputQuery { }
+impl InputQuery { /* definition for `in_db`, etc */ }
+impl salsa::Query for InputQuery {
+    /* associated types */
+}
+
+// Same as above, but for the derived query `length`.
+// For derived queries, we also implement `QueryFunction`
+// which defines how to execute the query.
+pub struct LengthQuery { }
+impl salsa::Query for LengthQuery {
+    ...
+}
+impl salsa::QueryFunction for LengthQuery {
+    ...
+}
+
+// Finally, the group storage, which contains the actual
+// hashmaps and other data used to implement the queries.
+struct HelloWorldGroupStorage__ { .. }
+```
+
+## The group struct and `QueryGroup` trait
+
+The group struct is the only thing we generate whose name is known to the user.
+For a query group named `Foo`, it is conventionally called `FooStorage`, hence
+the name `HelloWorldStorage` in our example.
+
+Despite the name "Storage", the struct itself has no fields. It exists only to
+implement the `QueryGroup` trait. This *trait* has a number of associated types
+that reference various bits of the query group, including the actual "group
+storage" struct:
+
+```rust,ignore
+struct HelloWorldStorage { }
+impl salsa::plumbing::QueryGroup for HelloWorldStorage {
+    type DynDb = dyn HelloWorld;
+    type GroupStorage = HelloWorldGroupStorage__; // generated struct
+}
+```
+
+We'll go into detail on these types below and the role they play, but one that
+we didn't mention yet is `GroupData`. That is a kind of hack used to manage
+send/sync around slots, and it gets covered in the section on slots.
+
+## Impl of the hello world trait
+
+Ultimately, every salsa query group is going to be implemented by your final
+database type, which is not currently known to us (it is created by combining
+multiple salsa query groups). In fact, this salsa query group could be composed
+into multiple database types. However, we want to generate the impl of the query-group
+trait here in this crate, because this is the point where the trait definition is visible
+and known to us (otherwise, we'd have to duplicate the method definitions).
+
+So what we do is that we define a different trait, called `plumbing::HasQueryGroup<G>`,
+that can be implemented by the database type. `HasQueryGroup` is generic over
+the query group struct. So then we can provide an impl of `HelloWorld` for any
+database type `DB` where `DB: HasQueryGroup<HelloWorldStorage>`. This
+`HasQueryGroup` defines a few methods that, given a `DB`, give access to the
+data for the query group and a few other things.
+
+Thus we can generate an impl that looks like:
+
+```rust,ignore
+impl<DB> HelloWorld for DB
+where
+    DB: salsa::Database,
+    DB: salsa::plumbing::HasQueryGroup<HelloWorld>
+{
+    ...
+    fn length(&self, key: ()) -> Arc<String> {
+      <Self as salsa::plumbing::GetQueryTable<HelloWorldLength__>>::get_query_table(self).get(())
+    }
+}
+```
+
+You can see that the various methods just hook into generic functions in the
+`salsa::plumbing` module. These functions are generic over the query types
+(`HelloWorldLength__`) that will be described shortly. The details of the "query
+table" are covered in a future section, but in short this code pulls out the
+hasmap for storing the `length` results and invokes the generic salsa logic to
+check for a valid result, etc.
+
+## For each query, a query struct
+
+As we referenced in the previous section, each query in the trait gets a struct
+that represents it. This struct is named after the query, converted into snake
+case and with the word `Query` appended. In typical Salsa workflows, these
+structs are not meant to be named or used, but in some cases it may be required.
+For e.g. the `length` query, this structs might look something like:
+
+```rust,ignore
+struct LengthQuery { }
+```
+
+The struct also implements the `plumbing::Query` trait, which defines
+a bunch of metadata about the query (and repeats, for convenience,
+some of the data about the group that the query is in):
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/query_group.rs:Query_impl}}
+```
+
+Depending on the kind of query, we may also generate other impls, such as an
+impl of `salsa::plumbing::QueryFunction`, which defines the methods for
+executing the body of a query. This impl would then include a call to the user's
+actual function.
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/query_group.rs:QueryFunction_impl}}
+```
+
+## Group storage
+
+The "group storage" is the actual struct that contains all the hashtables and
+so forth for each query. The types of these are ultimately defined by the
+`Storage` associated type for each query type. The struct is generic over the
+final database type:
+
+```rust,ignore
+struct HelloWorldGroupStorage__ {
+    input: <InputQuery as Query::Storage,
+    length: <LengthQuery as Query>::Storage,
+}
+```
+
+We also generate some inherent methods. First, a `new` method that takes
+the group index as a parameter and passes it along to each of the query
+storage `new` methods:
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/query_group.rs:group_storage_new}}
+```
+
+And then various methods that will dispatch from a `DatabaseKeyIndex` that
+corresponds to this query group into the appropriate query within the group.
+Each has a similar structure of matching on the query index and then delegating
+to some method defined by the query storage:
+
+```rust,ignore
+{{#include ../../../components/salsa-macros/src/query_group.rs:group_storage_methods}}
+```
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/query_ops.md b/crates/salsa/book/src/plumbing/query_ops.md
new file mode 100644
index 000000000..f94d0f28f
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/query_ops.md
@@ -0,0 +1,14 @@
+# Query operations
+
+Each of the query storage struct implements the `QueryStorageOps` trait found in the [`plumbing`] module:
+
+```rust,no_run,noplayground
+{{#include ../../../src/plumbing.rs:QueryStorageOps}}
+```
+
+ which defines the basic operations that all queries support. The most important are these two:
+
+* [maybe changed after](./maybe_changed_after.md): Returns true if the value of the query (for the given key) may have changed since the given revision.
+* [Fetch](./fetch.md): Returns the up-to-date value for the given K (or an error in the case of an "unrecovered" cycle).
+
+[`plumbing`]: https://github.com/salsa-rs/salsa/blob/master/src/plumbing.rs
diff --git a/crates/salsa/book/src/plumbing/salsa_crate.md b/crates/salsa/book/src/plumbing/salsa_crate.md
new file mode 100644
index 000000000..373a098ec
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/salsa_crate.md
@@ -0,0 +1,45 @@
+# Runtime
+
+This section documents the contents of the salsa crate. The salsa crate contains code that interacts with the [generated code] to create the complete "salsa experience". 
+
+[generated code]: ./generated_code.md
+
+## Major types
+
+The crate has a few major types.
+
+### The [`salsa::Storage`] struct
+
+The [`salsa::Storage`] struct is what users embed into their database. It consists of two main parts:
+
+* The "query store", which is the [generated storage struct](./database.md#the-database-storage-struct).
+* The [`salsa::Runtime`].
+
+### The [`salsa::Runtime`] struct
+
+The [`salsa::Runtime`] struct stores the data that is used to track which queries are being executed and to coordinate between them. The `Runtime` is embedded within the [`salsa::Storage`] struct. 
+
+**Important**. The `Runtime` does **not** store the actual data from the queries; they live alongside it in the [`salsa::Storage`] struct. This ensures that the type of `Runtime` is not generic which is needed to ensure dyn safety.
+
+#### Threading
+
+There is one [`salsa::Runtime`] for each active thread, and each of them has a unique [`RuntimeId`]. The `Runtime` state itself is divided into;
+
+* `SharedState`, accessible from all runtimes;
+* `LocalState`, accessible only from this runtime.
+
+[`salsa::Runtime`]: https://docs.rs/salsa/latest/salsa/struct.Runtime.html 
+[`salsa::Storage`]: https://docs.rs/salsa/latest/salsa/struct.Storage.html
+[`RuntimeId`]: https://docs.rs/salsa/0.16.1/salsa/struct.RuntimeId.html
+
+### Query storage implementations and support code
+
+For each kind of query (input, derived, interned, etc) there is a corresponding "storage struct" that contains the code to implement it. For example, derived queries are implemented by the `DerivedStorage` struct found in the [`salsa::derived`] module.
+
+[`salsa::derived`]: https://github.com/salsa-rs/salsa/blob/master/src/derived.rs
+
+Storage structs like `DerivedStorage` are generic over a query type `Q`, which corresponds to the [query structs] in the generated code. The query structs implement the `Query` trait which gives basic info such as the key and value type of the query and its ability to recover from cycles. In some cases, the `Q` type is expected to implement additional traits: derived queries, for example, implement `QueryFunction`, which defines the code that will execute when the query is called.
+
+[query structs]: ./query_groups.md#for-each-query-a-query-struct
+
+The storage structs, in turn, implement key traits from the plumbing module. The most notable is the `QueryStorageOps`, which defines the [basic operations that can be done on a query](./query_ops.md).
diff --git a/crates/salsa/book/src/plumbing/terminology.md b/crates/salsa/book/src/plumbing/terminology.md
new file mode 100644
index 000000000..e2e2597f4
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology.md
@@ -0,0 +1 @@
+# Terminology
diff --git a/crates/salsa/book/src/plumbing/terminology/LRU.md b/crates/salsa/book/src/plumbing/terminology/LRU.md
new file mode 100644
index 000000000..ce420b928
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/LRU.md
@@ -0,0 +1,6 @@
+# LRU
+
+The [`set_lru_capacity`](https://docs.rs/salsa/0.16.1/salsa/struct.QueryTableMut.html#method.set_lru_capacity) method can be used to fix the maximum capacity for a query at a specific number of values. If more values are added after that point, then salsa will drop the values from older [memos] to conserve memory (we always retain the [dependency] information for those memos, however, so that we can still compute whether values may have changed, even if we don't know what that value is).
+
+[memos]: ./memo.md
+[dependency]: ./dependency.md
diff --git a/crates/salsa/book/src/plumbing/terminology/backdate.md b/crates/salsa/book/src/plumbing/terminology/backdate.md
new file mode 100644
index 000000000..5d1a00c0e
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/backdate.md
@@ -0,0 +1,7 @@
+# Backdate
+
+*Backdating* is when we mark a value that was computed in revision R as having last changed in some earlier revision. This is done when we have an older [memo] M and we can compare the two values to see that, while the [dependencies] to M may have changed, the result of the [query function] did not.
+
+[memo]: ./memo.md
+[dependencies]: ./dependency.md
+[query function]: ./query_function.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/changed_at.md b/crates/salsa/book/src/plumbing/terminology/changed_at.md
new file mode 100644
index 000000000..e73fa6269
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/changed_at.md
@@ -0,0 +1,8 @@
+# Changed at
+
+The *changed at* revision for a [memo] is the [revision] in which that memo's value last changed. Typically, this is the same as the revision in which the [query function] was last executed, but it may be an earlier revision if the memo was [backdated].
+
+[query function]: ./query_function.md
+[backdated]: ./backdate.md
+[revision]: ./revision.md
+[memo]: ./memo.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/dependency.md b/crates/salsa/book/src/plumbing/terminology/dependency.md
new file mode 100644
index 000000000..2c921410b
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/dependency.md
@@ -0,0 +1,6 @@
+# Dependency
+
+A *dependency* of a [query] Q is some other query Q1 that was invoked as part of computing the value for Q (typically, invoking by Q's [query function]).
+
+[query]: ./query.md
+[query function]: ./query_function.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/derived_query.md b/crates/salsa/book/src/plumbing/terminology/derived_query.md
new file mode 100644
index 000000000..158801f60
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/derived_query.md
@@ -0,0 +1,7 @@
+# Derived query
+
+A *derived query* is a [query] whose value is defined by the result of a user-provided [query function]. That function is executed to get the result of the query. Unlike [input queries], the result of a derived queries can always be recomputed whenever needed simply by re-executing the function.
+
+[query]: ./query.md
+[query function]: ./query_function.md
+[input queries]: ./input_query.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/durability.md b/crates/salsa/book/src/plumbing/terminology/durability.md
new file mode 100644
index 000000000..364575f60
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/durability.md
@@ -0,0 +1,6 @@
+# Durability
+
+*Durability* is an optimization that we use to avoid checking the [dependencies] of a [query] individually.
+
+[dependencies]: ./dependency.md
+[query]: ./query.md
diff --git a/crates/salsa/book/src/plumbing/terminology/ingredient.md b/crates/salsa/book/src/plumbing/terminology/ingredient.md
new file mode 100644
index 000000000..18ed541b0
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/ingredient.md
@@ -0,0 +1,4 @@
+# Ingredient
+
+An *ingredient* is an individual piece of storage used to create a [salsa item](./salsa_item.md)
+See the [jars and ingredients](../jars_and_ingredients.md) chapter for more details.
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/input_query.md b/crates/salsa/book/src/plumbing/terminology/input_query.md
new file mode 100644
index 000000000..27665e244
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/input_query.md
@@ -0,0 +1,6 @@
+# Input query
+
+An *input query* is a [query] whose value is explicitly set by the user. When that value is set, a [durability] can also be provided.
+
+[query]: ./query.md
+[durability]: ./durability.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/memo.md b/crates/salsa/book/src/plumbing/terminology/memo.md
new file mode 100644
index 000000000..dce9d9179
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/memo.md
@@ -0,0 +1,21 @@
+# Memo
+
+A *memo* stores information about the last time that a [query function] for some [query] Q was executed:
+
+* Typically, it contains the value that was returned from that function, so that we don't have to execute it again.
+    * However, this is not always true: some queries don't cache their result values, and values can also be dropped as a result of [LRU] collection. In those cases, the memo just stores [dependency] information, which can still be useful to determine if other queries that have Q as a [dependency] may have changed.
+* The revision in which the memo last [verified].
+* The [changed at] revision in which the memo's value last changed. (Note that it may be [backdated].)
+* The minimum durability of the memo's [dependencies].
+* The complete set of [dependencies], if available, or a marker that the memo has an [untracked dependency].
+
+[revision]: ./revision.md
+[backdated]: ./backdate.md
+[dependencies]: ./dependency.md
+[dependency]: ./dependency.md
+[untracked dependency]: ./untracked.md
+[verified]: ./verified.md
+[query]: ./query.md
+[query function]: ./query_function.md
+[changed at]: ./changed_at.md
+[LRU]: ./LRU.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/query.md b/crates/salsa/book/src/plumbing/terminology/query.md
new file mode 100644
index 000000000..f0c52077d
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/query.md
@@ -0,0 +1 @@
+# Query
diff --git a/crates/salsa/book/src/plumbing/terminology/query_function.md b/crates/salsa/book/src/plumbing/terminology/query_function.md
new file mode 100644
index 000000000..d320b279f
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/query_function.md
@@ -0,0 +1,7 @@
+# Query function
+
+The *query function* is the user-provided function that we execute to compute the value of a [derived query]. Salsa assumed that all query functions are a 'pure' function of their [dependencies] unless the user reports an [untracked read]. Salsa always assumes that functions have no important side-effects (i.e., that they don't send messages over the network whose results you wish to observe) and thus that it doesn't have to re-execute functions unless it needs their return value.
+
+[derived query]: ./derived_query.md
+[dependencies]: ./dependency.md
+[untracked read]: ./untracked.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/revision.md b/crates/salsa/book/src/plumbing/terminology/revision.md
new file mode 100644
index 000000000..dc9222719
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/revision.md
@@ -0,0 +1,5 @@
+# Revision
+
+A *revision* is a monotonically increasing integer that we use to track the "version" of the database. Each time the value of an [input query] is modified, we create a new revision.
+
+[input query]: ./input_query.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/salsa_item.md b/crates/salsa/book/src/plumbing/terminology/salsa_item.md
new file mode 100644
index 000000000..cff09c762
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/salsa_item.md
@@ -0,0 +1,4 @@
+# Salsa item
+
+A salsa item is something that is decorated with a `#[salsa::foo]` macro, like a tracked function or struct.
+See the [jars and ingredients](../jars_and_ingredients.md) chapter for more details.
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/salsa_struct.md b/crates/salsa/book/src/plumbing/terminology/salsa_struct.md
new file mode 100644
index 000000000..69bebba7f
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/salsa_struct.md
@@ -0,0 +1,9 @@
+# Salsa struct
+
+A salsa struct is a struct decorated with one of the salsa macros:
+
+* `#[salsa::tracked]`
+* `#[salsa::input]`
+* `#[salsa::interned]`
+
+See the [salsa overview](../../overview.md) for more details.
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/terminology/untracked.md b/crates/salsa/book/src/plumbing/terminology/untracked.md
new file mode 100644
index 000000000..15da6ae2e
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/untracked.md
@@ -0,0 +1,7 @@
+# Untracked dependency
+
+An *untracked dependency* is an indication that the result of a [derived query] depends on something not visible to the salsa database. Untracked dependencies are created by invoking [`report_untracked_read`](https://docs.rs/salsa/0.16.1/salsa/struct.Runtime.html#method.report_untracked_read) or [`report_synthetic_read`](https://docs.rs/salsa/0.16.1/salsa/struct.Runtime.html#method.report_synthetic_read). When an untracked dependency is present, [derived queries] are always re-executed if the durability check fails (see the description of the [fetch operation] for more details).
+
+[derived query]: ./derived_query.md
+[derived queries]: ./derived_query.md
+[fetch operation]: ../fetch.md#derived-queries
diff --git a/crates/salsa/book/src/plumbing/terminology/verified.md b/crates/salsa/book/src/plumbing/terminology/verified.md
new file mode 100644
index 000000000..bd6103b29
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/terminology/verified.md
@@ -0,0 +1,8 @@
+# Verified
+
+A [memo] is *verified* in a revision R if we have checked that its value is still up-to-date (i.e., if we were to reexecute the [query function], we are guaranteed to get the same result). Each memo tracks the revision in which it was last verified to avoid repeatedly checking whether dependencies have changed during the [fetch] and [maybe changed after] operations.
+
+[query function]: ./query_function.md
+[fetch]: ../fetch.md
+[maybe changed after]: ../maybe_changed_after.md
+[memo]: ./memo.md
\ No newline at end of file
diff --git a/crates/salsa/book/src/plumbing/tracked_structs.md b/crates/salsa/book/src/plumbing/tracked_structs.md
new file mode 100644
index 000000000..15bdf4217
--- /dev/null
+++ b/crates/salsa/book/src/plumbing/tracked_structs.md
@@ -0,0 +1,50 @@
+# Tracked structs
+
+Tracked structs are stored in a special way to reduce their costs.
+
+Tracked structs are created via a `new` operation.
+
+## The tracked struct and tracked field ingredients
+
+For a single tracked struct we create multiple ingredients.
+The **tracked struct ingredient** is the ingredient created first.
+It offers methods to create new instances of the struct and therefore
+has unique access to the interner and hashtables used to create the struct id.
+It also shares access to a hashtable that stores the `ValueStruct` that
+contains the field data.
+
+For each field, we create a **tracked field ingredient** that moderates access
+to a particular field. All of these ingredients use that same shared hashtable
+to access the `ValueStruct` instance for a given id. The `ValueStruct`
+contains both the field values but also the revisions when they last changed value.
+
+## Each tracked struct has a globally unique id
+
+This will begin by creating a _globally unique, 32-bit id_ for the tracked struct. It is created by interning a combination of
+
+- the currently executing query;
+- a u64 hash of the `#[id]` fields;
+- a _disambiguator_ that makes this hash unique within the current query. i.e., when a query starts executing, it creates an empty map, and the first time a tracked struct with a given hash is created, it gets disambiguator 0. The next one will be given 1, etc.
+
+## Each tracked struct has a `ValueStruct` storing its data
+
+The struct and field ingredients share access to a hashmap that maps
+each field id to a value struct:
+
+```rust,ignore
+{{#include ../../../src/tracked_struct.rs:ValueStruct}}
+```
+
+The value struct stores the values of the fields but also the revisions when
+that field last changed. Each time the struct is recreated in a new revision,
+the old and new values for its fields are compared and a new revision is created.
+
+## The macro generates the tracked struct `Configuration`
+
+The "configuration" for a tracked struct defines not only the types of the fields,
+but also various important operations such as extracting the hashable id fields
+and updating the "revisions" to track when a field last changed:
+
+```rust,ignore
+{{#include ../../../src/tracked_struct.rs:Configuration}}
+```
diff --git a/crates/salsa/book/src/reference.md b/crates/salsa/book/src/reference.md
new file mode 100644
index 000000000..cf5aa0741
--- /dev/null
+++ b/crates/salsa/book/src/reference.md
@@ -0,0 +1 @@
+# Reference
diff --git a/crates/salsa/book/src/reference/algorithm.md b/crates/salsa/book/src/reference/algorithm.md
new file mode 100644
index 000000000..3dc190974
--- /dev/null
+++ b/crates/salsa/book/src/reference/algorithm.md
@@ -0,0 +1,84 @@
+# The "red-green" algorithm
+
+This page explains the basic Salsa incremental algorithm.
+The algorithm is called the "red-green" algorithm, which is where the name Salsa comes from.
+
+### Database revisions
+
+The Salsa database always tracks a single **revision**. Each time you set an input, the revision is incremented. So we start in revision `R1`, but when a `set` method is called, we will go to `R2`, then `R3`, and so on. For each input, we also track the revision in which it was last changed.
+
+### Basic rule: when inputs change, re-execute!
+
+When you invoke a tracked function, in addition to storing the value that was returned, we also track what _other_ tracked functions it depends on, and the revisions when their value last changed. When you invoke the function again, if the database is in a new revision, then we check whether any of the inputs to this function have changed in that new revision. If not, we can just return our cached value. But if the inputs _have_ changed (or may have changed), we will re-execute the function to find the most up-to-date answer.
+
+Here is a simple example, where the `parse_module` function invokes the `module_text` function:
+
+```rust
+#[salsa::tracked]
+fn parse_module(db: &dyn Db, module: Module) -> Ast {
+    let module_text: &String = module_text(db, module);
+    Ast::parse_text(module_text)
+}
+
+#[salsa::tracked(returns(ref))]
+fn module_text(db: &dyn Db, module: Module) -> String {
+    panic!("text for module `{module:?}` not set")
+}
+```
+
+If we invoke `parse_module` twice, but change the module text in between, then we will have to re-execute `parse_module`:
+
+```rust
+module_text::set(
+    db,
+    module,
+    "fn foo() { }".to_string(),
+);
+parse_module(db, module); // executes
+
+// ...some time later...
+
+module_text::set(
+    db,
+    module,
+    "fn foo() { /* add a comment */ }".to_string(),
+);
+parse_module(db, module); // executes again!
+```
+
+### Backdating: sometimes we can be smarter
+
+Often, though, tracked functions don't depend directly on the inputs. Instead, they'll depend on some other tracked function. For example, perhaps we have a `type_check` function that reads the AST:
+
+```rust
+#[salsa::tracked]
+fn type_check(db: &dyn Db, module: Module) {
+    let ast = parse_module(db, module);
+    ...
+}
+```
+
+If the module text is changed, we saw that we have to re-execute `parse_module`, but there are many changes to the source text that still produce the same AST. For example, suppose we simply add a comment? In that case, if `type_check` is called again, we will:
+
+- First re-execute `parse_module`, since its input changed.
+- We will then compare the resulting AST. If it's the same as last time, we can _backdate_ the result, meaning that we say that, even though the inputs changed, the output didn't.
+
+## Durability: an optimization
+
+As an optimization, Salsa includes the concept of **durability**, which is the notion of how often some piece of tracked data changes. 
+
+For example, when compiling a Rust program, you might mark the inputs from crates.io as _high durability_ inputs, since they are unlikely to change. The current workspace could be marked as _low durability_, since changes to it are happening all the time.
+
+When you set the value of a tracked function, you can also set it with a given _durability_:
+
+```rust
+module_text::set_with_durability(
+    db,
+    module,
+    "fn foo() { }".to_string(),
+    salsa::Durability::HIGH
+);
+```
+
+For each durability, we track the revision in which _some input_ with that durability changed. If a tracked function depends (transitively) only on high durability inputs, and you change a low durability input, then we can very easily determine that the tracked function result is still valid, avoiding the need to traverse the input edges one by one.
+
diff --git a/crates/salsa/book/src/reference/durability.md b/crates/salsa/book/src/reference/durability.md
new file mode 100644
index 000000000..7ca511adf
--- /dev/null
+++ b/crates/salsa/book/src/reference/durability.md
@@ -0,0 +1,13 @@
+# Durability
+
+"Durability" is an optimization that can greatly improve the performance of your salsa programs.
+Durability specifies the probability that an input's value will change.
+The default is "low durability".
+But when you set the value of an input, you can manually specify a higher durability,
+typically `Durability::HIGH`.
+Salsa tracks when tracked functions only consume values of high durability
+and, if no high durability input has changed, it can skip traversing their
+dependencies.
+
+Typically "high durability" values are things like data read from the standard library
+or other inputs that aren't actively being edited by the end user.
\ No newline at end of file
diff --git a/crates/salsa/book/src/tuning.md b/crates/salsa/book/src/tuning.md
new file mode 100644
index 000000000..05b0a8d5b
--- /dev/null
+++ b/crates/salsa/book/src/tuning.md
@@ -0,0 +1,42 @@
+# Tuning Salsa
+
+## LRU Cache
+
+You can specify an LRU cache size for any non-input query:
+
+```rs
+let lru_capacity: usize = 128;
+base_db::ParseQuery.in_db_mut(self).set_lru_capacity(lru_capacity);
+```
+
+The default is `0`, which disables LRU-caching entirely.
+
+Note that there is no garbage collection for keys and
+results of old queries, so LRU caches are currently the
+only knob available for avoiding unbounded memory usage
+for long-running apps built on Salsa.
+
+## Intern Queries
+
+Intern queries can make key lookup cheaper, save memory, and
+avoid the need for [`Arc`](https://doc.rust-lang.org/std/sync/struct.Arc.html).
+
+Interning is especially useful for queries that involve nested,
+tree-like data structures.
+
+See:
+
+- The [`compiler` example](https://github.com/salsa-rs/salsa/blob/master/examples/compiler/main.rs),
+  which uses interning.
+
+## Cancellation
+
+Queries that are no longer needed due to concurrent writes or changes in dependencies are cancelled
+by Salsa. Each access of an intermediate query is a potential cancellation point. Cancellation is
+implemented via panicking, and Salsa internals are intended to be panic-safe.
+
+If you have a query that contains a long loop which does not execute any intermediate queries,
+salsa won't be able to cancel it automatically. You may wish to check for cancellation yourself
+by invoking `db.unwind_if_cancelled()`.
+
+For more details on cancellation, see the tests for cancellation behavior in the Salsa repo.
diff --git a/crates/salsa/book/src/tutorial.md b/crates/salsa/book/src/tutorial.md
new file mode 100644
index 000000000..b59c5471e
--- /dev/null
+++ b/crates/salsa/book/src/tutorial.md
@@ -0,0 +1,21 @@
+# Tutorial: calc
+
+This tutorial walks through an end-to-end example of using Salsa.
+It does not assume you know anything about salsa,
+but reading the [overview](./overview.md) first is probably a good idea to get familiar with the basic concepts.
+
+Our goal is define a compiler/interpreter for a simple language called `calc`.
+The `calc` compiler takes programs like the following and then parses and executes them:
+
+```
+fn area_rectangle(w, h) = w * h
+fn area_circle(r) = 3.14 * r * r
+print area_rectangle(3, 4)
+print area_circle(1)
+print 11 * 2
+```
+
+When executed, this program prints `12`, `3.14`, and `22`.
+
+If the program contains errors (e.g., a reference to an undefined function), it prints those out too.
+And, of course, it will be reactive, so small changes to the input don't require recompiling (or rexecuting, necessarily) the entire thing.
diff --git a/crates/salsa/book/src/tutorial/accumulators.md b/crates/salsa/book/src/tutorial/accumulators.md
new file mode 100644
index 000000000..0df25ed4e
--- /dev/null
+++ b/crates/salsa/book/src/tutorial/accumulators.md
@@ -0,0 +1,39 @@
+# Defining the parser: reporting errors
+
+The last interesting case in the parser is how to handle a parse error.
+Because Salsa functions are memoized and may not execute, they should not have side-effects,
+so we don't just want to call `eprintln!`.
+If we did so, the error would only be reported the first time the function was called, but not
+on subsequent calls in the situation where the simply returns its memoized value.
+
+Salsa defines a mechanism for managing this called an **accumulator**.
+In our case, we define an accumulator struct called `Diagnostics` in the `ir` module:
+
+```rust
+{{#include ../../../examples/calc/ir.rs:diagnostic}}
+```
+
+Accumulator structs are always newtype structs with a single field, in this case of type `Diagnostic`.
+Memoized functions can _push_ `Diagnostic` values onto the accumulator.
+Later, you can invoke a method to find all the values that were pushed by the memoized functions
+or any functions that they called
+(e.g., we could get the set of `Diagnostic` values produced by the `parse_statements` function).
+
+The `Parser::report_error` method contains an example of pushing a diagnostic:
+
+```rust
+{{#include ../../../examples/calc/parser.rs:report_error}}
+```
+
+To get the set of diagnostics produced by `parse_errors`, or any other memoized function,
+we invoke the associated `accumulated` function:
+
+```rust
+let accumulated: Vec<Diagnostic> =
+    parse_statements::accumulated::<Diagnostics>(db);
+                      //            -----------
+                      //     Use turbofish to specify
+                      //     the diagnostics type.
+```
+
+`accumulated` takes the database `db` as argument and returns a `Vec`.
diff --git a/crates/salsa/book/src/tutorial/checker.md b/crates/salsa/book/src/tutorial/checker.md
new file mode 100644
index 000000000..71e316339
--- /dev/null
+++ b/crates/salsa/book/src/tutorial/checker.md
@@ -0,0 +1 @@
+# Defining the checker
diff --git a/crates/salsa/book/src/tutorial/db.md b/crates/salsa/book/src/tutorial/db.md
new file mode 100644
index 000000000..04a77e92e
--- /dev/null
+++ b/crates/salsa/book/src/tutorial/db.md
@@ -0,0 +1,44 @@
+# Defining the database struct
+
+Now that we have defined a [jar](./jar.md), we need to create the **database struct**.
+The database struct is where all the jars come together.
+Typically it is only used by the "driver" of your application;
+the one which starts up the program, supplies the inputs, and relays the outputs.
+
+In `calc`, the database struct is in the [`db`] module, and it looks like this:
+
+[`db`]: https://github.com/salsa-rs/salsa/blob/master/examples/calc/db.rs
+
+```rust
+{{#include ../../../examples/calc/db.rs:db_struct}}
+```
+
+The `#[salsa::db(...)]` attribute takes a list of all the jars to include.
+The struct must have a field named `storage` whose type is `salsa::Storage<Self>`, but it can also contain whatever other fields you want.
+The `storage` struct owns all the data for the jars listed in the `db` attribute.
+
+The `salsa::db` attribute autogenerates a bunch of impls for things like the `salsa::HasJar<crate::Jar>` trait that we saw earlier.
+
+## Implementing the `salsa::Database` trait
+
+In addition to the struct itself, we must add an impl of `salsa::Database`:
+
+```rust
+{{#include ../../../examples/calc/db.rs:db_impl}}
+```
+
+## Implementing the `salsa::ParallelDatabase` trait
+
+If you want to permit accessing your database from multiple threads at once, then you also need to implement the `ParallelDatabase` trait:
+
+```rust
+{{#include ../../../examples/calc/db.rs:par_db_impl}}
+```
+
+## Implementing the traits for each jar
+
+The `Database` struct also needs to implement the [database traits for each jar](./jar.md#database-trait-for-the-jar).
+In our case, though, we already wrote that impl as a [blanket impl alongside the jar itself](./jar.md#implementing-the-database-trait-for-the-jar),
+so no action is needed.
+This is the recommended strategy unless your trait has custom members that depend on fields of the `Database` itself
+(for example, sometimes the `Database` holds some kind of custom resource that you want to give access to).
diff --git a/crates/salsa/book/src/tutorial/debug.md b/crates/salsa/book/src/tutorial/debug.md
new file mode 100644
index 000000000..c3a5253ff
--- /dev/null
+++ b/crates/salsa/book/src/tutorial/debug.md
@@ -0,0 +1,44 @@
+# Defining the parser: debug impls and testing
+
+As the final part of the parser, we need to write some tests.
+To do so, we will create a database, set the input source text, run the parser, and check the result.
+Before we can do that, though, we have to address one question: how do we inspect the value of an interned type like `Expression`?
+
+## The `DebugWithDb` trait
+
+Because an interned type like `Expression` just stores an integer, the traditional `Debug` trait is not very useful.
+To properly print a `Expression`, you need to access the Salsa database to find out what its value is.
+To solve this, `salsa` provides a `DebugWithDb` trait that acts like the regular `Debug`, but takes a database as argument.
+For types that implement this trait, you can invoke the `debug` method.
+This returns a temporary that implements the ordinary `Debug` trait, allowing you to write something like
+
+```rust
+eprintln!("Expression = {:?}", expr.debug(db));
+```
+
+and get back the output you expect.
+
+The `DebugWithDb` trait is automatically derived for all `#[input]`, `#[interned]`, and `#[tracked]` structs.
+
+## Forwarding to the ordinary `Debug` trait
+
+For consistency, it is sometimes useful to have a `DebugWithDb` implementation even for types, like `Op`, that are just ordinary enums. You can do that like so:
+
+```rust
+{{#include ../../../examples/calc/ir.rs:op_debug_impl}}
+```
+
+## Writing the unit test
+
+Now that we have our `DebugWithDb` impls in place, we can write a simple unit test harness.
+The `parse_string` function below creates a database, sets the source text, and then invokes the parser:
+
+```rust
+{{#include ../../../examples/calc/parser.rs:parse_string}}
+```
+
+Combined with the [`expect-test`](https://crates.io/crates/expect-test) crate, we can then write unit tests like this one:
+
+```rust
+{{#include ../../../examples/calc/parser.rs:parse_print}}
+```
diff --git a/crates/salsa/book/src/tutorial/interpreter.md b/crates/salsa/book/src/tutorial/interpreter.md
new file mode 100644
index 000000000..0142e288b
--- /dev/null
+++ b/crates/salsa/book/src/tutorial/interpreter.md
@@ -0,0 +1 @@
+# Defining the interpreter
diff --git a/crates/salsa/book/src/tutorial/ir.md b/crates/salsa/book/src/tutorial/ir.md
new file mode 100644
index 000000000..6b6c8b671
--- /dev/null
+++ b/crates/salsa/book/src/tutorial/ir.md
@@ -0,0 +1,182 @@
+# Defining the IR
+
+Before we can define the [parser](./parser.md), we need to define the intermediate representation (IR) that we will use for `calc` programs.
+In the [basic structure](./structure.md), we defined some "pseudo-Rust" structures like `Statement` and `Expression`;
+now we are going to define them for real.
+
+## "Salsa structs"
+
+In addition to regular Rust types, we will make use of various **Salsa structs**.
+A Salsa struct is a struct that has been annotated with one of the Salsa annotations:
+
+- [`#[salsa::input]`](#input-structs), which designates the "base inputs" to your computation;
+- [`#[salsa::tracked]`](#tracked-structs), which designate intermediate values created during your computation;
+- [`#[salsa::interned]`](#interned-structs), which designate small values that are easy to compare for equality.
+
+All Salsa structs store the actual values of their fields in the Salsa database.
+This permits us to track when the values of those fields change to figure out what work will need to be re-executed.
+
+When you annotate a struct with one of the above Salsa attributes, Salsa actually generates a bunch of code to link that struct into the database.
+This code must be connected to some [jar](./jar.md).
+By default, this is `crate::Jar`, but you can specify a different jar with the `jar=` attribute (e.g., `#[salsa::input(jar = MyJar)]`).
+You must also list the struct in the jar definition itself, or you will get errors.
+
+## Input structs
+
+The first thing we will define is our **input**.
+Every Salsa program has some basic inputs that drive the rest of the computation.
+The rest of the program must be some deterministic function of those base inputs,
+such that when those inputs change, we can try to efficiently recompute the new result of that function.
+
+Inputs are defined as Rust structs with a `#[salsa::input]` annotation:
+
+```rust
+{{#include ../../../examples/calc/ir.rs:input}}
+```
+
+In our compiler, we have just one simple input, the `SourceProgram`, which has a `text` field (the string).
+
+### The data lives in the database
+
+Although they are declared like other Rust structs, Salsa structs are implemented quite differently.
+The values of their fields are stored in the Salsa database and the struct themselves just reference it.
+This means that the struct instances are copy (no matter what fields they contain).
+Creating instances of the struct and accessing fields is done by invoking methods like `new` as well as getters and setters.
+
+In the case of `#[salsa::input]`, the struct contains a `salsa::Id`, which is a non-zero integer.
+Therefore, the generated `SourceProgram` struct looks something like this:
+
+```rust
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
+pub struct SourceProgram(salsa::Id);
+```
+
+It will also generate a method `new` that lets you create a `SourceProgram` in the database.
+For an input, a `&db` reference is required, along with the values for each field:
+
+```rust
+let source = SourceProgram::new(&db, "print 11 + 11".to_string());
+```
+
+You can read the value of the field with `source.text(&db)`,
+and you can set the value of the field with `source.set_text(&mut db, "print 11 * 2".to_string())`.
+
+### Database revisions
+
+Whenever a function takes an `&mut` reference to the database,
+that means that it can only be invoked from outside the incrementalized part of your program,
+as explained in [the overview](../overview.md#goal-of-salsa).
+When you change the value of an input field, that increments a 'revision counter' in the database,
+indicating that some inputs are different now.
+When we talk about a "revision" of the database, we are referring to the state of the database in between changes to the input values.
+
+### Representing the parsed program
+
+Next we will define a **tracked struct**.
+Whereas inputs represent the _start_ of a computation, tracked structs represent intermediate values created during your computation.
+
+In this case, the parser is going to take in the `SourceProgram` struct that we saw and return a `Program` that represents the fully parsed program:
+
+```rust
+{{#include ../../../examples/calc/ir.rs:program}}
+```
+
+Like with an input, the fields of a tracked struct are also stored in the database.
+Unlike an input, those fields are immutable (they cannot be "set"), and Salsa compares them across revisions to know when they have changed.
+In this case, if parsing the input produced the same `Program` result
+(e.g., because the only change to the input was some trailing whitespace, perhaps),
+then subsequent parts of the computation won't need to re-execute.
+(We'll revisit the role of tracked structs in reuse more in future parts of the IR.)
+
+Apart from the fields being immutable, the API for working with a tracked struct is quite similar to an input:
+
+- You can create a new value by using `new`: e.g., `Program::new(&db, some_statements)`
+- You use a getter to read the value of a field, just like with an input (e.g., `my_func.statements(db)` to read the `statements` field).
+  - In this case, the field is tagged as `#[returns(ref)]`, which means that the getter will return a `&Vec<Statement>`, instead of cloning the vector.
+
+### The `'db` lifetime
+
+Unlike inputs, tracked structs carry a `'db` lifetime.
+This lifetime is tied to the `&db` used to create them and
+ensures that, so long as you are using the struct,
+the database remains immutable:
+in other words, you cannot change the values of a `salsa::Input`.
+
+The `'db` lifetime also allows tracked structs to be implemented
+using a pointer (versus the numeric id found in `salsa::input` structs).
+This doesn't really effect you as a user except that it allows accessing fields from tracked structs
+a very common operationto be optimized.
+
+## Representing functions
+
+We will also use a tracked struct to represent each function:
+The `Function` struct is going to be created by the parser to represent each of the functions defined by the user:
+
+```rust
+{{#include ../../../examples/calc/ir.rs:functions}}
+```
+
+If we had created some `Function` instance `f`, for example, we might find that `the f.body` field changes
+because the user changed the definition of `f`.
+This would mean that we have to re-execute those parts of the code that depended on `f.body`
+(but not those parts of the code that depended on the body of _other_ functions).
+
+Apart from the fields being immutable, the API for working with a tracked struct is quite similar to an input:
+
+- You can create a new value by using `new`: e.g., `Function::new(&db, some_name, some_args, some_body)`
+- You use a getter to read the value of a field, just like with an input (e.g., `my_func.args(db)` to read the `args` field).
+
+### id fields
+
+To get better reuse across revisions, particularly when things are reordered, you can mark some entity fields with `#[id]`.
+Normally, you would do this on fields that represent the "name" of an entity.
+This indicates that, across two revisions R1 and R2, if two functions are created with the same name, they refer to the same entity, so we can compare their other fields for equality to determine what needs to be re-executed.
+Adding `#[id]` attributes is an optimization and never affects correctness.
+For more details, see the [algorithm](../reference/algorithm.md) page of the reference.
+
+## Interned structs
+
+The final kind of Salsa struct are _interned structs_.
+As with input and tracked structs, the data for an interned struct is stored in the database.
+Unlike those structs, if you intern the same data twice, you get back the **same integer**.
+
+A classic use of interning is for small strings like function names and variables.
+It's annoying and inefficient to pass around those names with `String` values which must be cloned;
+it's also inefficient to have to compare them for equality via string comparison.
+Therefore, we define two interned structs, `FunctionId` and `VariableId`, each with a single field that stores the string:
+
+```rust
+{{#include ../../../examples/calc/ir.rs:interned_ids}}
+```
+
+When you invoke e.g. `FunctionId::new(&db, "my_string".to_string())`, you will get back a `FunctionId` that is just a newtype'd integer.
+But if you invoke the same call to `new` again, you get back the same integer:
+
+```rust
+let f1 = FunctionId::new(&db, "my_string".to_string());
+let f2 = FunctionId::new(&db, "my_string".to_string());
+assert_eq!(f1, f2);
+```
+
+### Interned values carry a `'db` lifetime
+
+Like tracked structs, interned values carry a `'db` lifetime that prevents them from being used across salsa revisions.
+It also permits them to be implemented using a pointer "under the hood", permitting efficient field access.
+Interned values are guaranteed to be consistent within a single revision.
+Across revisions, they may be cleared, reallocated, or reassigned -- but you cannot generally observe this,
+since the `'db` lifetime prevents you from changing inputs (and hence creating a new revision)
+while an interned value is in active use.
+
+### Expressions and statements
+
+We won't use any special "Salsa structs" for expressions and statements:
+
+```rust
+{{#include ../../../examples/calc/ir.rs:statements_and_expressions}}
+```
+
+Since statements and expressions are not tracked, this implies that we are only attempting to get incremental re-use at the granularity of functions --
+whenever anything in a function body changes, we consider the entire function body dirty and re-execute anything that depended on it.
+It usually makes sense to draw some kind of "reasonably coarse" boundary like this.
+
+One downside of the way we have set things up: we inlined the position into each of the structs.
diff --git a/crates/salsa/book/src/tutorial/jar.md b/crates/salsa/book/src/tutorial/jar.md
new file mode 100644
index 000000000..9f453ae92
--- /dev/null
+++ b/crates/salsa/book/src/tutorial/jar.md
@@ -0,0 +1,72 @@
+# Jars and databases
+
+Before we can define the interesting parts of our Salsa program, we have to setup a bit of structure that defines the Salsa **database**.
+The database is a struct that ultimately stores all of Salsa's intermediate state, such as the memoized return values from [tracked functions].
+
+[tracked functions]: ../overview.md#tracked-functions
+
+The database itself is defined in terms of intermediate structures, called **jars**[^jar], which themselves contain the data for each function.
+This setup allows Salsa programs to be divided amongst many crates.
+Typically, you define one jar struct per crate, and then when you construct the final database, you simply list the jar structs.
+This permits the crates to define private functions and other things that are members of the jar struct, but not known directly to the database.
+
+[^jar]: Jars of salsa -- get it? Get it??[^java]
+
+[^java]: OK, maybe it also brings to mind Java `.jar` files, but there's no real relationship. A jar is just a Rust struct, not a packaging format.
+
+## Defining a jar struct
+
+To define a jar struct, you create a tuple struct with the `#[salsa::jar]` annotation:
+
+```rust
+{{#include ../../../examples/calc/main.rs:jar_struct}}
+```
+
+Although it's not required, it's highly recommended to put the `jar` struct at the root of your crate, so that it can be referred to as `crate::Jar`.
+All of the other Salsa annotations reference a jar struct, and they all default to the path `crate::Jar`.
+If you put the jar somewhere else, you will have to override that default.
+
+## Defining the database trait
+
+The `#[salsa::jar]` annotation also includes a `db = Db` field.
+The value of this field (normally `Db`) is the name of a trait that represents the database.
+Salsa programs never refer _directly_ to the database; instead, they take a `&dyn Db` argument.
+This allows for separate compilation, where you have a database that contains the data for two jars, but those jars don't depend on one another.
+
+The database trait for our `calc` crate is very simple:
+
+```rust
+{{#include ../../../examples/calc/main.rs:jar_db}}
+```
+
+When you define a database trait like `Db`, the one thing that is required is that it must have a supertrait `salsa::DbWithJar<Jar>`,
+where `Jar` is the jar struct. If your jar depends on other jars, you can have multiple such supertraits (e.g., `salsa::DbWithJar<other_crate::Jar>`).
+
+Typically the `Db` trait has no other members or supertraits, but you are also free to add whatever other things you want in the trait.
+When you define your final database, it will implement the trait, and you can then define the implementation of those other things.
+This allows you to create a way for your jar to request context or other info from the database that is not moderated through Salsa,
+should you need that.
+
+## Implementing the database trait for the jar
+
+The `Db` trait must be implemented by the database struct.
+We're going to define the database struct in a [later section](./db.md),
+and one option would be to simply implement the jar `Db` trait there.
+However, since we don't define any custom logic in the trait,
+a common choice is to write a blanket impl for any type that implements `DbWithJar<Jar>`,
+and that's what we do here:
+
+```rust
+{{#include ../../../examples/calc/main.rs:jar_db_impl}}
+```
+
+## Summary
+
+If the concept of a jar seems a bit abstract to you, don't overthink it. The TL;DR is that when you create a Salsa program, you need to perform the following steps:
+
+- In each of your crates:
+  - Define a `#[salsa::jar(db = Db)]` struct, typically at `crate::Jar`, and list each of your various Salsa-annotated things inside of it.
+  - Define a `Db` trait, typically at `crate::Db`, that you will use in memoized functions and elsewhere to refer to the database struct.
+- Once, typically in your final crate:
+  - Define a database `D`, as described in the [next section](./db.md), that will contain a list of each of the jars for each of your crates.
+  - Implement the `Db` traits for each jar for your database type `D` (often we do this through blanket impls in the jar crates).
diff --git a/crates/salsa/book/src/tutorial/parser.md b/crates/salsa/book/src/tutorial/parser.md
new file mode 100644
index 000000000..271d77a19
--- /dev/null
+++ b/crates/salsa/book/src/tutorial/parser.md
@@ -0,0 +1,72 @@
+# Defining the parser: memoized functions and inputs
+
+The next step in the `calc` compiler is to define the parser.
+The role of the parser will be to take the `ProgramSource` input,
+read the string from the `text` field,
+and create the `Statement`, `Function`, and `Expression` structures that [we defined in the `ir` module](./ir.md).
+
+To minimize dependencies, we are going to write a [recursive descent parser][rd].
+Another option would be to use a [Rust parsing framework](https://rustrepo.com/catalog/rust-parsing_newest_1).
+We won't cover the parsing itself in this tutorial -- you can read the code if you want to see how it works.
+We're going to focus only on the Salsa-related aspects.
+
+[rd]: https://en.wikipedia.org/wiki/Recursive_descent_parser
+
+## The `parse_statements` function
+
+The starting point for the parser is the `parse_statements` function:
+
+```rust
+{{#include ../../../examples/calc/parser.rs:parse_statements}}
+```
+
+This function is annotated as `#[salsa::tracked]`.
+That means that, when it is called, Salsa will track what inputs it reads as well as what value it returns.
+The return value is _memoized_,
+which means that if you call this function again without changing the inputs,
+Salsa will just clone the result rather than re-execute it.
+
+### Tracked functions are the unit of reuse
+
+Tracked functions are the core part of how Salsa enables incremental reuse.
+The goal of the framework is to avoid re-executing tracked functions and instead to clone their result.
+Salsa uses the [red-green algorithm](../reference/algorithm.md) to decide when to re-execute a function.
+The short version is that a tracked function is re-executed if either (a) it directly reads an input, and that input has changed,
+or (b) it directly invokes another tracked function and that function's return value has changed.
+In the case of `parse_statements`, it directly reads `ProgramSource::text`, so if the text changes, then the parser will re-execute.
+
+By choosing which functions to mark as `#[tracked]`, you control how much reuse you get.
+In our case, we're opting to mark the outermost parsing function as tracked, but not the inner ones.
+This means that if the input changes, we will always re-parse the entire input and re-create the resulting statements and so forth.
+We'll see later that this _doesn't_ mean we will always re-run the type checker and other parts of the compiler.
+
+This trade-off makes sense because (a) parsing is very cheap, so the overhead of tracking and enabling finer-grained reuse doesn't pay off
+and because (b) since strings are just a big blob-o-bytes without any structure, it's rather hard to identify which parts of the IR need to be reparsed.
+Some systems do choose to do more granular reparsing, often by doing a "first pass" over the string to give it a bit of structure,
+e.g. to identify the functions,
+but deferring the parsing of the body of each function until later.
+Setting up a scheme like this is relatively easy in Salsa and uses the same principles that we will use later to avoid re-executing the type checker.
+
+### Parameters to a tracked function
+
+The **first** parameter to a tracked function is **always** the database, `db: &dyn crate::Db`.
+It must be a `dyn` value of whatever database is associated with the jar.
+
+The **second** parameter to a tracked function is **always** some kind of Salsa struct.
+The first parameter to a memoized function is always the database,
+which should be a `dyn Trait` value for the database trait associated with the jar
+(the default jar is `crate::Jar`).
+
+Tracked functions may take other arguments as well, though our examples here do not.
+Functions that take additional arguments are less efficient and flexible.
+It's generally better to structure tracked functions as functions of a single Salsa struct if possible.
+
+### The `returns(ref)` annotation
+
+You may have noticed that `parse_statements` is tagged with `#[salsa::tracked(returns(ref))]`.
+Ordinarily, when you call a tracked function, the result you get back is cloned out of the database.
+The `returns(ref)` attribute means that a reference into the database is returned instead.
+So, when called, `parse_statements` will return an `&Vec<Statement>` rather than cloning the `Vec`.
+This is useful as a performance optimization.
+(You may recall the `returns(ref)` annotation from the [ir](./ir.md) section of the tutorial,
+where it was placed on struct fields, with roughly the same meaning.)
diff --git a/crates/salsa/book/src/tutorial/structure.md b/crates/salsa/book/src/tutorial/structure.md
new file mode 100644
index 000000000..b56f77f5e
--- /dev/null
+++ b/crates/salsa/book/src/tutorial/structure.md
@@ -0,0 +1,83 @@
+# Basic structure
+
+Before we do anything with Salsa, let's talk about the basic structure of the calc compiler.
+Part of Salsa's design is that you are able to write programs that feel 'pretty close' to what a natural Rust program looks like.
+
+## Example program
+
+This is our example calc program:
+
+```
+x = 5
+y = 10
+z = x + y * 3
+print z
+```
+
+## Parser
+
+The calc compiler takes as input a program, represented by a string:
+
+```rust
+struct ProgramSource {
+    text: String
+}
+```
+
+The first thing it does it to parse that string into a series of statements that look something like the following pseudo-Rust:[^lexer]
+
+```rust
+enum Statement {
+    /// Defines `fn <name>(<args>) = <body>`
+    Function(Function),
+    /// Defines `print <expr>`
+    Print(Expression),
+}
+
+/// Defines `fn <name>(<args>) = <body>`
+struct Function {
+    name: FunctionId,
+    args: Vec<VariableId>,
+    body: Expression
+}
+```
+
+where an expression is something like this (pseudo-Rust, because the `Expression` enum is recursive):
+
+```rust
+enum Expression {
+    Op(Expression, Op, Expression),
+    Number(f64),
+    Variable(VariableId),
+    Call(FunctionId, Vec<Expression>),
+}
+
+enum Op {
+    Add,
+    Subtract,
+    Multiply,
+    Divide,
+}
+```
+
+Finally, for function/variable names, the `FunctionId` and `VariableId` types will be interned strings:
+
+```rust
+type FunctionId = /* interned string */;
+type VariableId = /* interned string */;
+```
+
+[^lexer]: Because calc is so simple, we don't have to bother separating out the lexer from the parser.
+
+## Checker
+
+The "checker" has the job of ensuring that the user only references variables that have been defined.
+We're going to write the checker in a "context-less" style,
+which is a bit less intuitive but allows for more incremental re-use.
+The idea is to compute, for a given expression, which variables it references.
+Then there is a function `check` which ensures that those variables are a subset of those that are already defined.
+
+## Interpreter
+
+The interpreter will execute the program and print the result. We don't bother with much incremental re-use here,
+though it's certainly possible.
diff --git a/crates/salsa/book/src/videos.md b/crates/salsa/book/src/videos.md
new file mode 100644
index 000000000..8abd040fa
--- /dev/null
+++ b/crates/salsa/book/src/videos.md
@@ -0,0 +1,19 @@
+# Videos
+
+There is currently one video available on the newest version of Salsa:
+
+- [Salsa Architecture Walkthrough](https://www.youtube.com/watch?v=vrnNvAAoQFk),
+  which covers many aspects of the redesigned architecture.
+
+There are also two videos on the older version Salsa, but they are rather
+outdated:
+
+- [How Salsa Works](https://youtu.be/_muY4HjSqVw), which gives a high-level
+  introduction to the key concepts involved and shows how to use Salsa;
+- [Salsa In More Depth](https://www.youtube.com/watch?v=i_IhACacPRY), which digs
+  into the incremental algorithm and explains -- at a high-level -- how Salsa is
+  implemented.
+
+> If you're in China, watch videos on
+> [How Salsa Works](https://www.bilibili.com/video/BV1Df4y1A7t3/),
+> [Salsa In More Depth](https://www.bilibili.com/video/BV1AM4y1G7E4/).
diff --git a/crates/salsa/components/salsa-macro-rules/CHANGELOG.md b/crates/salsa/components/salsa-macro-rules/CHANGELOG.md
new file mode 100644
index 000000000..56f430ae2
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/CHANGELOG.md
@@ -0,0 +1,47 @@
+# Changelog
+
+All notable changes to this project will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+## [Unreleased]
+
+## [0.21.1](https://github.com/salsa-rs/salsa/compare/salsa-macro-rules-v0.21.0...salsa-macro-rules-v0.21.1) - 2025-04-30
+
+### Other
+
+- better debug name for interned query arguments ([#837](https://github.com/salsa-rs/salsa/pull/837))
+
+## [0.21.0](https://github.com/salsa-rs/salsa/compare/salsa-macro-rules-v0.20.0...salsa-macro-rules-v0.21.0) - 2025-04-29
+
+### Fixed
+
+- correct debug output for tracked fields ([#826](https://github.com/salsa-rs/salsa/pull/826))
+- allow unused lifetimes in tracked_struct expansion ([#824](https://github.com/salsa-rs/salsa/pull/824))
+
+### Other
+
+- Implement a query stack `Backtrace` analog ([#827](https://github.com/salsa-rs/salsa/pull/827))
+- Simplify ID conversions ([#822](https://github.com/salsa-rs/salsa/pull/822))
+- Remove unnecessary `Array` abstraction ([#821](https://github.com/salsa-rs/salsa/pull/821))
+- Add a compile-fail test for a `'static` `!Update` struct ([#820](https://github.com/salsa-rs/salsa/pull/820))
+- squelch most clippy warnings in generated code ([#809](https://github.com/salsa-rs/salsa/pull/809))
+
+## [0.20.0](https://github.com/salsa-rs/salsa/compare/salsa-macro-rules-v0.19.0...salsa-macro-rules-v0.20.0) - 2025-04-22
+
+### Added
+
+- Drop `Debug` requirements and flip implementation defaults ([#756](https://github.com/salsa-rs/salsa/pull/756))
+
+### Other
+
+- Reduce memory usage by deduplicating type information ([#803](https://github.com/salsa-rs/salsa/pull/803))
+- Inline/Outline more cold and slow paths ([#805](https://github.com/salsa-rs/salsa/pull/805))
+- rewrite cycle handling to support fixed-point iteration ([#603](https://github.com/salsa-rs/salsa/pull/603))
+
+## [0.19.0](https://github.com/salsa-rs/salsa/compare/salsa-macro-rules-v0.18.0...salsa-macro-rules-v0.19.0) - 2025-03-10
+
+### Other
+
+- Store view downcaster in function ingredients directly ([#720](https://github.com/salsa-rs/salsa/pull/720))
diff --git a/crates/salsa/components/salsa-macro-rules/Cargo.toml b/crates/salsa/components/salsa-macro-rules/Cargo.toml
new file mode 100644
index 000000000..4997495b0
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/Cargo.toml
@@ -0,0 +1,11 @@
+[package]
+name = "salsa-macro-rules"
+version = "0.21.1"
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+rust-version.workspace = true
+description = "Declarative macros for the salsa crate"
+
+[dependencies]
diff --git a/crates/salsa/components/salsa-macro-rules/src/lib.rs b/crates/salsa/components/salsa-macro-rules/src/lib.rs
new file mode 100644
index 000000000..45f75355d
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/lib.rs
@@ -0,0 +1,25 @@
+//! This crate defines various `macro_rules` macros
+//! used as part of Salsa's internal plumbing.
+//! These macros are re-exported under `salsa::plumbing``.
+//! The procedural macros emit calls to these
+//! `macro_rules` macros after doing error checking.
+//!
+//! Using `macro_rules` macro definitions is generally
+//! more ergonomic and also permits true hygiene for local variables
+//! (sadly not items).
+//!
+//! Currently the only way to have a macro that is re-exported
+//! from a submodule is to use multiple crates, hence the existence
+//! of this crate.
+
+mod macro_if;
+mod maybe_backdate;
+mod maybe_default;
+mod return_mode;
+mod setup_accumulator_impl;
+mod setup_input_struct;
+mod setup_interned_struct;
+mod setup_method_body;
+mod setup_tracked_fn;
+mod setup_tracked_struct;
+mod unexpected_cycle_recovery;
diff --git a/crates/salsa/components/salsa-macro-rules/src/macro_if.rs b/crates/salsa/components/salsa-macro-rules/src/macro_if.rs
new file mode 100644
index 000000000..e7d05beff
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/macro_if.rs
@@ -0,0 +1,25 @@
+#[macro_export]
+macro_rules! macro_if {
+    (true => $($t:tt)*) => {
+        $($t)*
+    };
+
+    (false => $($t:tt)*) => {
+    };
+
+    (if true { $($t:tt)* } else { $($f:tt)*}) => {
+        $($t)*
+    };
+
+    (if false { $($t:tt)* } else { $($f:tt)*}) => {
+        $($f)*
+    };
+
+    (if0 0 { $($t:tt)* } else { $($f:tt)*}) => {
+        $($t)*
+    };
+
+    (if0 $n:literal { $($t:tt)* } else { $($f:tt)*}) => {
+        $($f)*
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/maybe_backdate.rs b/crates/salsa/components/salsa-macro-rules/src/maybe_backdate.rs
new file mode 100644
index 000000000..bdbb3aa54
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/maybe_backdate.rs
@@ -0,0 +1,38 @@
+/// Conditionally update field value and backdate revisions
+#[macro_export]
+macro_rules! maybe_backdate {
+    (
+        ($return_mode:ident, no_backdate, $maybe_default:ident),
+        $field_ty:ty,
+        $old_field_place:expr,
+        $new_field_place:expr,
+        $revision_place:expr,
+        $current_revision:expr,
+        $zalsa:ident,
+
+    ) => {
+        $zalsa::always_update(
+            &mut $revision_place,
+            $current_revision,
+            &mut $old_field_place,
+            $new_field_place,
+        );
+    };
+
+    (
+        ($return_mode:ident, backdate, $maybe_default:ident),
+        $field_ty:ty,
+        $old_field_place:expr,
+        $new_field_place:expr,
+        $revision_place:expr,
+        $current_revision:expr,
+        $zalsa:ident,
+     ) => {
+        if $zalsa::UpdateDispatch::<$field_ty>::maybe_update(
+            std::ptr::addr_of_mut!($old_field_place),
+            $new_field_place,
+        ) {
+            $revision_place = $current_revision;
+        }
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/maybe_default.rs b/crates/salsa/components/salsa-macro-rules/src/maybe_default.rs
new file mode 100644
index 000000000..1786ffcc4
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/maybe_default.rs
@@ -0,0 +1,32 @@
+/// Generate either `field_ref_expr` or `field_ty::default`
+///
+/// Used when generating an input's builder.
+#[macro_export]
+macro_rules! maybe_default {
+    (
+        ($return_mode:ident, $maybe_backdate:ident, default),
+        $field_ty:ty,
+        $field_ref_expr:expr,
+    ) => {
+        <$field_ty>::default()
+    };
+
+    (
+        ($return_mode:ident, $maybe_backdate:ident, required),
+        $field_ty:ty,
+        $field_ref_expr:expr,
+    ) => {
+        $field_ref_expr
+    };
+}
+
+#[macro_export]
+macro_rules! maybe_default_tt {
+    (($return_mode:ident, $maybe_backdate:ident, default) => $($t:tt)*) => {
+        $($t)*
+    };
+
+    (($return_mode:ident, $maybe_backdate:ident, required) => $($t:tt)*) => {
+
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/return_mode.rs b/crates/salsa/components/salsa-macro-rules/src/return_mode.rs
new file mode 100644
index 000000000..32d0e9950
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/return_mode.rs
@@ -0,0 +1,104 @@
+/// Generate the expression for the return type, depending on the return mode defined in [`salsa-macros::options::Options::returns`]
+///
+/// Used when generating field getters.
+#[macro_export]
+macro_rules! return_mode_expression {
+    (
+        (copy, $maybe_backdate:ident, $maybe_default:ident),
+        $field_ty:ty,
+        $field_ref_expr:expr,
+    ) => {
+        *$field_ref_expr
+    };
+
+    (
+        (clone, $maybe_backdate:ident, $maybe_default:ident),
+        $field_ty:ty,
+        $field_ref_expr:expr,
+    ) => {
+        ::core::clone::Clone::clone($field_ref_expr)
+    };
+
+    (
+        (ref, $maybe_backdate:ident, $maybe_default:ident),
+        $field_ty:ty,
+        $field_ref_expr:expr,
+    ) => {
+        $field_ref_expr
+    };
+
+    (
+        (deref, $maybe_backdate:ident, $maybe_default:ident),
+        $field_ty:ty,
+        $field_ref_expr:expr,
+    ) => {
+        ::core::ops::Deref::deref($field_ref_expr)
+    };
+
+    (
+        (as_ref, $maybe_backdate:ident, $maybe_default:ident),
+        $field_ty:ty,
+        $field_ref_expr:expr,
+    ) => {
+        ::salsa::SalsaAsRef::as_ref($field_ref_expr)
+    };
+
+    (
+        (as_deref, $maybe_backdate:ident, $maybe_default:ident),
+        $field_ty:ty,
+        $field_ref_expr:expr,
+    ) => {
+        ::salsa::SalsaAsDeref::as_deref($field_ref_expr)
+    };
+}
+
+#[macro_export]
+macro_rules! return_mode_ty {
+    (
+        (copy, $maybe_backdate:ident, $maybe_default:ident),
+        $db_lt:lifetime,
+        $field_ty:ty
+    ) => {
+        $field_ty
+    };
+
+    (
+        (clone, $maybe_backdate:ident, $maybe_default:ident),
+        $db_lt:lifetime,
+        $field_ty:ty
+    ) => {
+        $field_ty
+    };
+
+    (
+        (ref, $maybe_backdate:ident, $maybe_default:ident),
+        $db_lt:lifetime,
+        $field_ty:ty
+    ) => {
+        & $db_lt $field_ty
+    };
+
+    (
+        (deref, $maybe_backdate:ident, $maybe_default:ident),
+        $db_lt:lifetime,
+        $field_ty:ty
+    ) => {
+        & $db_lt <$field_ty as ::core::ops::Deref>::Target
+    };
+
+    (
+        (as_ref, $maybe_backdate:ident, $maybe_default:ident),
+        $db_lt:lifetime,
+        $field_ty:ty
+    ) => {
+        <$field_ty as ::salsa::SalsaAsRef>::AsRef<$db_lt>
+    };
+
+    (
+        (as_deref, $maybe_backdate:ident, $maybe_default:ident),
+        $db_lt:lifetime,
+        $field_ty:ty
+    ) => {
+        <$field_ty as ::salsa::SalsaAsDeref>::AsDeref<$db_lt>
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/setup_accumulator_impl.rs b/crates/salsa/components/salsa-macro-rules/src/setup_accumulator_impl.rs
new file mode 100644
index 000000000..bb41e61b3
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/setup_accumulator_impl.rs
@@ -0,0 +1,50 @@
+/// Macro for setting up a function that must intern its arguments.
+#[macro_export]
+macro_rules! setup_accumulator_impl {
+    (
+        // Name of the struct
+        Struct: $Struct:ident,
+
+        // Annoyingly macro-rules hygiene does not extend to items defined in the macro.
+        // We have the procedural macro generate names for those items that are
+        // not used elsewhere in the user's code.
+        unused_names: [
+            $zalsa:ident,
+            $zalsa_struct:ident,
+            $CACHE:ident,
+            $ingredient:ident,
+        ]
+    ) => {
+        #[allow(clippy::all)]
+        #[allow(dead_code)]
+        const _: () = {
+            use salsa::plumbing as $zalsa;
+            use salsa::plumbing::accumulator as $zalsa_struct;
+
+            // Suppress the lint against `cfg(loom)`.
+            #[allow(unexpected_cfgs)]
+            fn $ingredient(zalsa: &$zalsa::Zalsa) -> &$zalsa_struct::IngredientImpl<$Struct> {
+                $zalsa::__maybe_lazy_static! {
+                    static $CACHE: $zalsa::IngredientCache<$zalsa_struct::IngredientImpl<$Struct>> =
+                        $zalsa::IngredientCache::new();
+                }
+
+                $CACHE.get_or_create(zalsa, || {
+                    zalsa.add_or_lookup_jar_by_type::<$zalsa_struct::JarImpl<$Struct>>()
+                })
+            }
+
+            impl $zalsa::Accumulator for $Struct {
+                const DEBUG_NAME: &'static str = stringify!($Struct);
+
+                fn accumulate<Db>(self, db: &Db)
+                where
+                    Db: ?Sized + $zalsa::Database,
+                {
+                    let (zalsa, zalsa_local) = db.zalsas();
+                    $ingredient(zalsa).push(zalsa_local, self);
+                }
+            }
+        };
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/setup_input_struct.rs b/crates/salsa/components/salsa-macro-rules/src/setup_input_struct.rs
new file mode 100644
index 000000000..380dcc118
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/setup_input_struct.rs
@@ -0,0 +1,348 @@
+/// Macro for setting up a function that must intern its arguments.
+#[macro_export]
+macro_rules! setup_input_struct {
+    (
+        // Attributes on the struct
+        attrs: [$(#[$attr:meta]),*],
+
+        // Visibility of the struct
+        vis: $vis:vis,
+
+        // Name of the struct
+        Struct: $Struct:ident,
+
+        // Name user gave for `new`
+        new_fn: $new_fn:ident,
+
+        // A series of option tuples; see `setup_tracked_struct` macro
+        field_options: [$($field_option:tt),*],
+
+        // Field names
+        field_ids: [$($field_id:ident),*],
+
+        // Names for field getter methods (typically `foo`)
+        field_getters: [$($field_getter_vis:vis $field_getter_id:ident),*],
+
+        // Names for field setter methods (typically `set_foo`)
+        field_setters: [$($field_setter_vis:vis $field_setter_id:ident),*],
+
+        // Field types
+        field_tys: [$($field_ty:ty),*],
+
+        // Indices for each field from 0..N -- must be unsuffixed (e.g., `0`, `1`).
+        field_indices: [$($field_index:tt),*],
+
+        // Fields that are required (have no default value). Each item is the fields name and type.
+        required_fields: [$($required_field_id:ident $required_field_ty:ty),*],
+
+        // Names for the field durability methods on the builder (typically `foo_durability`)
+        field_durability_ids: [$($field_durability_id:ident),*],
+
+        // Number of fields
+        num_fields: $N:literal,
+
+        // If true, this is a singleton input.
+        is_singleton: $is_singleton:tt,
+
+        // If true, generate a debug impl.
+        generate_debug_impl: $generate_debug_impl:tt,
+
+        // Annoyingly macro-rules hygiene does not extend to items defined in the macro.
+        // We have the procedural macro generate names for those items that are
+        // not used elsewhere in the user's code.
+        unused_names: [
+            $zalsa:ident,
+            $zalsa_struct:ident,
+            $Configuration:ident,
+            $Builder:ident,
+            $CACHE:ident,
+            $Db:ident,
+        ]
+    ) => {
+        $(#[$attr])*
+        #[derive(Copy, Clone, PartialEq, Eq, Hash)]
+        $vis struct $Struct(salsa::Id);
+
+        #[allow(clippy::all)]
+        #[allow(dead_code)]
+        const _: () = {
+            use salsa::plumbing as $zalsa;
+            use $zalsa::input as $zalsa_struct;
+
+            type $Configuration = $Struct;
+
+            impl $zalsa_struct::Configuration for $Configuration {
+                const LOCATION: $zalsa::Location = $zalsa::Location {
+                    file: file!(),
+                    line: line!(),
+                };
+                const DEBUG_NAME: &'static str = stringify!($Struct);
+                const FIELD_DEBUG_NAMES: &'static [&'static str] = &[$(stringify!($field_id)),*];
+                type Singleton = $zalsa::macro_if! {if $is_singleton {$zalsa::input::Singleton} else {$zalsa::input::NotSingleton}};
+
+                /// The input struct (which wraps an `Id`)
+                type Struct = $Struct;
+
+                /// A (possibly empty) tuple of the fields for this struct.
+                type Fields = ($($field_ty,)*);
+
+                /// A array of [`StampedValue<()>`](`StampedValue`) tuples, one per each of the value fields.
+                type Stamps = [$zalsa::Stamp; $N];
+            }
+
+            impl $Configuration {
+                pub fn ingredient(db: &dyn $zalsa::Database) -> &$zalsa_struct::IngredientImpl<Self> {
+                    Self::ingredient_(db.zalsa())
+                }
+
+                // Suppress the lint against `cfg(loom)`.
+                #[allow(unexpected_cfgs)]
+                fn ingredient_(zalsa: &$zalsa::Zalsa) -> &$zalsa_struct::IngredientImpl<Self> {
+                    zalsa_::__maybe_lazy_static! {
+                        static CACHE: $zalsa::IngredientCache<$zalsa_struct::IngredientImpl<$Configuration>> =
+                            $zalsa::IngredientCache::new();
+                    }
+
+                    CACHE.get_or_create(zalsa, || {
+                        zalsa.add_or_lookup_jar_by_type::<$zalsa_struct::JarImpl<$Configuration>>()
+                    })
+                }
+
+                pub fn ingredient_mut(db: &mut dyn $zalsa::Database) -> (&mut $zalsa_struct::IngredientImpl<Self>, &mut $zalsa::Runtime) {
+                    let zalsa_mut = db.zalsa_mut();
+                    zalsa_mut.new_revision();
+                    let index = zalsa_mut.add_or_lookup_jar_by_type::<$zalsa_struct::JarImpl<$Configuration>>();
+                    let (ingredient, runtime) = zalsa_mut.lookup_ingredient_mut(index);
+                    let ingredient = ingredient.assert_type_mut::<$zalsa_struct::IngredientImpl<Self>>();
+                    (ingredient, runtime)
+                }
+            }
+
+            impl $zalsa::FromId for $Struct {
+                fn from_id(id: salsa::Id) -> Self {
+                    Self(id)
+                }
+            }
+
+            impl $zalsa::AsId for $Struct {
+                fn as_id(&self) -> salsa::Id {
+                    self.0
+                }
+            }
+
+            unsafe impl $zalsa::Update for $Struct {
+                unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool {
+                    if unsafe { *old_pointer } != new_value {
+                        unsafe { *old_pointer = new_value };
+                        true
+                    } else {
+                        false
+                    }
+                }
+            }
+
+            $zalsa::macro_if! { $generate_debug_impl =>
+                impl std::fmt::Debug for $Struct {
+                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+                        Self::default_debug_fmt(*self, f)
+                    }
+                }
+            }
+
+            impl $zalsa::SalsaStructInDb for $Struct {
+                type MemoIngredientMap = $zalsa::MemoIngredientSingletonIndex;
+
+                fn lookup_or_create_ingredient_index(aux: &$zalsa::Zalsa) -> $zalsa::IngredientIndices {
+                    aux.add_or_lookup_jar_by_type::<$zalsa_struct::JarImpl<$Configuration>>().into()
+                }
+
+                #[inline]
+                fn cast(id: $zalsa::Id, type_id: $zalsa::TypeId) -> $zalsa::Option<Self> {
+                    if type_id == $zalsa::TypeId::of::<$Struct>() {
+                        $zalsa::Some($Struct(id))
+                    } else {
+                        $zalsa::None
+                    }
+                }
+            }
+
+            impl $Struct {
+                #[inline]
+                pub fn $new_fn<$Db>(db: &$Db, $($required_field_id: $required_field_ty),*) -> Self
+                where
+                    // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                    $Db: ?Sized + salsa::Database,
+                {
+                    Self::builder($($required_field_id,)*).new(db)
+                }
+
+                pub fn builder($($required_field_id: $required_field_ty),*) -> <Self as $zalsa_struct::HasBuilder>::Builder
+                {
+                    builder::new_builder($($zalsa::maybe_default!($field_option, $field_ty, $field_id,)),*)
+                }
+
+                $(
+                    $field_getter_vis fn $field_getter_id<'db, $Db>(self, db: &'db $Db) -> $zalsa::return_mode_ty!($field_option, 'db, $field_ty)
+                    where
+                        // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                        $Db: ?Sized + $zalsa::Database,
+                    {
+                        let fields = $Configuration::ingredient_(db.zalsa()).field(
+                            db.as_dyn_database(),
+                            self,
+                            $field_index,
+                        );
+                        $zalsa::return_mode_expression!(
+                            $field_option,
+                            $field_ty,
+                            &fields.$field_index,
+                        )
+                    }
+                )*
+
+                $(
+                    #[must_use]
+                    $field_setter_vis fn $field_setter_id<'db, $Db>(self, db: &'db mut $Db) -> impl salsa::Setter<FieldTy = $field_ty> + 'db
+                    where
+                        // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                        $Db: ?Sized + $zalsa::Database,
+                    {
+                        let (ingredient, revision) = $Configuration::ingredient_mut(db.as_dyn_database_mut());
+                        $zalsa::input::SetterImpl::new(
+                            revision,
+                            self,
+                            $field_index,
+                            ingredient,
+                            |fields, f| std::mem::replace(&mut fields.$field_index, f),
+                        )
+                    }
+                )*
+
+                $zalsa::macro_if! { $is_singleton =>
+                    pub fn try_get<$Db>(db: &$Db) -> Option<Self>
+                    where
+                        // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                        $Db: ?Sized + salsa::Database,
+                    {
+                        let zalsa = db.zalsa();
+                        $Configuration::ingredient_(zalsa).get_singleton_input(zalsa)
+                    }
+
+                    #[track_caller]
+                    pub fn get<$Db>(db: &$Db) -> Self
+                    where
+                        // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                        $Db: ?Sized + salsa::Database,
+                    {
+                        Self::try_get(db).unwrap()
+                    }
+                }
+
+                /// Default debug formatting for this struct (may be useful if you define your own `Debug` impl)
+                pub fn default_debug_fmt(this: Self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result
+                where
+                    // rustc rejects trivial bounds, but it cannot see through higher-ranked bounds
+                    // with its check :^)
+                    $(for<'__trivial_bounds> $field_ty: std::fmt::Debug),*
+                {
+                    $zalsa::with_attached_database(|db| {
+                        let fields = $Configuration::ingredient(db).leak_fields(db, this);
+                        let mut f = f.debug_struct(stringify!($Struct));
+                        let f = f.field("[salsa id]", &$zalsa::AsId::as_id(&this));
+                        $(
+                            let f = f.field(stringify!($field_id), &fields.$field_index);
+                        )*
+                        f.finish()
+                    }).unwrap_or_else(|| {
+                        f.debug_struct(stringify!($Struct))
+                            .field("[salsa id]", &this.0)
+                            .finish()
+                    })
+                }
+            }
+
+            impl $zalsa_struct::HasBuilder for $Struct {
+                type Builder = builder::$Builder;
+            }
+
+            // Implement `new` here instead of inside the builder module
+            // because $Configuration can't be named in `builder`.
+            impl builder::$Builder {
+                /// Creates the new input with the set values.
+                #[must_use]
+                pub fn new<$Db>(self, db: &$Db) -> $Struct
+                where
+                    // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                    $Db: ?Sized + salsa::Database
+                {
+                    let zalsa = db.zalsa();
+                    let current_revision = zalsa.current_revision();
+                    let ingredient = $Configuration::ingredient_(zalsa);
+                    let (fields, stamps) = builder::builder_into_inner(self, current_revision);
+                    ingredient.new_input(db.as_dyn_database(), fields, stamps)
+                }
+            }
+
+            mod builder {
+                use super::*;
+
+                use salsa::plumbing as $zalsa;
+                use $zalsa::input as $zalsa_struct;
+
+                // These are standalone functions instead of methods on `Builder` to prevent
+                // that the enclosing module can call them.
+                pub(super) fn new_builder($($field_id: $field_ty),*) -> $Builder {
+                    $Builder {
+                        fields: ($($field_id,)*),
+                        durabilities: [salsa::Durability::default(); $N],
+                    }
+                }
+
+                pub(super) fn builder_into_inner(builder: $Builder, revision: $zalsa::Revision) -> (($($field_ty,)*), [$zalsa::Stamp; $N]) {
+                    let stamps = [$($zalsa::stamp(revision, builder.durabilities[$field_index])),*];
+
+                    (builder.fields, stamps)
+                }
+
+                #[must_use]
+                pub struct $Builder {
+                    /// The field values.
+                    fields: ($($field_ty,)*),
+
+                    /// The durabilities per field.
+                    durabilities: [salsa::Durability; $N],
+                }
+
+                impl $Builder {
+                    /// Sets the durability of all fields.
+                    ///
+                    /// Overrides any previously set durabilities.
+                    pub fn durability(mut self, durability: salsa::Durability) -> Self {
+                        self.durabilities = [durability; $N];
+                        self
+                    }
+
+                    $($zalsa::maybe_default_tt! { $field_option =>
+                        /// Sets the value of the field `$field_id`.
+                        #[must_use]
+                        pub fn $field_id(mut self, value: $field_ty) -> Self
+                        {
+                            self.fields.$field_index = value;
+                            self
+                        }
+                    })*
+
+                    $(
+                        /// Sets the durability for the field `$field_id`.
+                        #[must_use]
+                        pub fn $field_durability_id(mut self, durability: salsa::Durability) -> Self
+                        {
+                            self.durabilities[$field_index] = durability;
+                            self
+                        }
+                    )*
+                }
+            }
+        };
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/setup_interned_struct.rs b/crates/salsa/components/salsa-macro-rules/src/setup_interned_struct.rs
new file mode 100644
index 000000000..d51926226
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/setup_interned_struct.rs
@@ -0,0 +1,250 @@
+/// Macro for setting up a function that must intern its arguments.
+#[macro_export]
+macro_rules! setup_interned_struct {
+    (
+        // Attributes on the struct
+        attrs: [$(#[$attr:meta]),*],
+
+        // Visibility of the struct
+        vis: $vis:vis,
+
+        // Name of the struct
+        Struct: $Struct:ident,
+
+        // Name of the struct data. This is a parameter because `std::concat_idents`
+        // is unstable and taking an additional dependency is unnecessary.
+        StructData: $StructDataIdent:ident,
+
+        // Name of the struct type with a `'static` argument (unless this type has no db lifetime,
+        // in which case this is the same as `$Struct`)
+        StructWithStatic: $StructWithStatic:ty,
+
+        // Name of the `'db` lifetime that the user gave
+        db_lt: $db_lt:lifetime,
+
+        // optional db lifetime argument.
+        db_lt_arg: $($db_lt_arg:lifetime)?,
+
+        // the salsa ID
+        id: $Id:path,
+
+        // the lifetime used in the desugared interned struct.
+        // if the `db_lt_arg`, is present, this is `db_lt_arg`, but otherwise,
+        // it is `'static`.
+        interior_lt: $interior_lt:lifetime,
+
+        // Name user gave for `new`
+        new_fn: $new_fn:ident,
+
+        // A series of option tuples; see `setup_tracked_struct` macro
+        field_options: [$($field_option:tt),*],
+
+        // Field names
+        field_ids: [$($field_id:ident),*],
+
+        // Names for field setter methods (typically `set_foo`)
+        field_getters: [$($field_getter_vis:vis $field_getter_id:ident),*],
+
+        // Field types
+        field_tys: [$($field_ty:ty),*],
+
+        // Indices for each field from 0..N -- must be unsuffixed (e.g., `0`, `1`).
+        field_indices: [$($field_index:tt),*],
+
+        // Indexed types for each field (T0, T1, ...)
+        field_indexed_tys: [$($indexed_ty:ident),*],
+
+        // Number of fields
+        num_fields: $N:literal,
+
+        // If true, generate a debug impl.
+        generate_debug_impl: $generate_debug_impl:tt,
+
+        // Annoyingly macro-rules hygiene does not extend to items defined in the macro.
+        // We have the procedural macro generate names for those items that are
+        // not used elsewhere in the user's code.
+        unused_names: [
+            $zalsa:ident,
+            $zalsa_struct:ident,
+            $Configuration:ident,
+            $CACHE:ident,
+            $Db:ident,
+        ]
+    ) => {
+        $(#[$attr])*
+        #[derive(Copy, Clone, PartialEq, Eq, Hash)]
+        $vis struct $Struct< $($db_lt_arg)? >(
+            $Id,
+            std::marker::PhantomData < & $interior_lt salsa::plumbing::interned::Value <$StructWithStatic> >
+        );
+
+        #[allow(clippy::all)]
+        #[allow(dead_code)]
+        const _: () = {
+            use salsa::plumbing as $zalsa;
+            use $zalsa::interned as $zalsa_struct;
+
+            type $Configuration = $StructWithStatic;
+
+            type $StructDataIdent<$db_lt> = ($($field_ty,)*);
+
+            /// Key to use during hash lookups. Each field is some type that implements `Lookup<T>`
+            /// for the owned type. This permits interning with an `&str` when a `String` is required and so forth.
+            #[derive(Hash)]
+            struct StructKey<$db_lt, $($indexed_ty),*>(
+                $($indexed_ty,)*
+                std::marker::PhantomData<&$db_lt ()>,
+            );
+
+            impl<$db_lt, $($indexed_ty,)*> $zalsa::interned::HashEqLike<StructKey<$db_lt, $($indexed_ty),*>>
+                for $StructDataIdent<$db_lt>
+                where
+                $($field_ty: $zalsa::interned::HashEqLike<$indexed_ty>),*
+                {
+
+                fn hash<H: std::hash::Hasher>(&self, h: &mut H) {
+                    $($zalsa::interned::HashEqLike::<$indexed_ty>::hash(&self.$field_index, &mut *h);)*
+                }
+
+                fn eq(&self, data: &StructKey<$db_lt, $($indexed_ty),*>) -> bool {
+                    ($($zalsa::interned::HashEqLike::<$indexed_ty>::eq(&self.$field_index, &data.$field_index) && )* true)
+                }
+            }
+
+            impl<$db_lt, $($indexed_ty: $zalsa::interned::Lookup<$field_ty>),*> $zalsa::interned::Lookup<$StructDataIdent<$db_lt>>
+                for StructKey<$db_lt, $($indexed_ty),*> {
+
+                #[allow(unused_unit)]
+                fn into_owned(self) -> $StructDataIdent<$db_lt> {
+                    ($($zalsa::interned::Lookup::into_owned(self.$field_index),)*)
+                }
+            }
+
+            impl salsa::plumbing::interned::Configuration for $StructWithStatic {
+                const LOCATION: $zalsa::Location = $zalsa::Location {
+                    file: file!(),
+                    line: line!(),
+                };
+                const DEBUG_NAME: &'static str = stringify!($Struct);
+                type Fields<'a> = $StructDataIdent<'a>;
+                type Struct<'db> = $Struct< $($db_lt_arg)? >;
+            }
+
+            impl $Configuration {
+                // Suppress the lint against `cfg(loom)`.
+                #[allow(unexpected_cfgs)]
+                pub fn ingredient<Db>(db: &Db) -> &$zalsa_struct::IngredientImpl<Self>
+                where
+                    Db: ?Sized + $zalsa::Database,
+                {
+                    $zalsa::__maybe_lazy_static! {
+                        static CACHE: $zalsa::IngredientCache<$zalsa_struct::IngredientImpl<$Configuration>> =
+                            $zalsa::IngredientCache::new();
+                    }
+
+                    let zalsa = db.zalsa();
+                    CACHE.get_or_create(zalsa, || {
+                        zalsa.add_or_lookup_jar_by_type::<$zalsa_struct::JarImpl<$Configuration>>()
+                    })
+                }
+            }
+
+            impl< $($db_lt_arg)? > $zalsa::AsId for $Struct< $($db_lt_arg)? > {
+                fn as_id(&self) -> salsa::Id {
+                    self.0.as_id()
+                }
+            }
+
+            impl< $($db_lt_arg)? > $zalsa::FromId for $Struct< $($db_lt_arg)? > {
+                fn from_id(id: salsa::Id) -> Self {
+                    Self(<$Id>::from_id(id), std::marker::PhantomData)
+                }
+            }
+
+            unsafe impl< $($db_lt_arg)? > Send for $Struct< $($db_lt_arg)? > {}
+
+            unsafe impl< $($db_lt_arg)? > Sync for $Struct< $($db_lt_arg)? > {}
+
+            $zalsa::macro_if! { $generate_debug_impl =>
+                impl< $($db_lt_arg)? > std::fmt::Debug for $Struct< $($db_lt_arg)? > {
+                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+                        Self::default_debug_fmt(*self, f)
+                    }
+                }
+            }
+
+            impl< $($db_lt_arg)? > $zalsa::SalsaStructInDb for $Struct< $($db_lt_arg)? > {
+                type MemoIngredientMap = $zalsa::MemoIngredientSingletonIndex;
+
+                fn lookup_or_create_ingredient_index(aux: &$zalsa::Zalsa) -> $zalsa::IngredientIndices {
+                    aux.add_or_lookup_jar_by_type::<$zalsa_struct::JarImpl<$Configuration>>().into()
+                }
+
+                #[inline]
+                fn cast(id: $zalsa::Id, type_id: $zalsa::TypeId) -> $zalsa::Option<Self> {
+                    if type_id == $zalsa::TypeId::of::<$Struct>() {
+                        $zalsa::Some(<$Struct as $zalsa::FromId>::from_id(id))
+                    } else {
+                        $zalsa::None
+                    }
+                }
+            }
+
+            unsafe impl< $($db_lt_arg)? > $zalsa::Update for $Struct< $($db_lt_arg)? > {
+                unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool {
+                    if unsafe { *old_pointer } != new_value {
+                        unsafe { *old_pointer = new_value };
+                        true
+                    } else {
+                        false
+                    }
+                }
+            }
+
+            impl<$db_lt> $Struct< $($db_lt_arg)? >  {
+                pub fn $new_fn<$Db, $($indexed_ty: $zalsa::interned::Lookup<$field_ty> + std::hash::Hash,)*>(db: &$db_lt $Db,  $($field_id: $indexed_ty),*) -> Self
+                where
+                    // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                    $Db: ?Sized + salsa::Database,
+                    $(
+                        $field_ty: $zalsa::interned::HashEqLike<$indexed_ty>,
+                    )*
+                {
+                    $Configuration::ingredient(db).intern(db.as_dyn_database(),
+                        StructKey::<$db_lt>($($field_id,)* std::marker::PhantomData::default()), |_, data| ($($zalsa::interned::Lookup::into_owned(data.$field_index),)*))
+                }
+
+                $(
+                    $field_getter_vis fn $field_getter_id<$Db>(self, db: &'db $Db) -> $zalsa::return_mode_ty!($field_option, 'db, $field_ty)
+                    where
+                        // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                        $Db: ?Sized + $zalsa::Database,
+                    {
+                        let fields = $Configuration::ingredient(db).fields(db.as_dyn_database(), self);
+                        $zalsa::return_mode_expression!(
+                            $field_option,
+                            $field_ty,
+                            &fields.$field_index,
+                        )
+                    }
+                )*
+
+                /// Default debug formatting for this struct (may be useful if you define your own `Debug` impl)
+                pub fn default_debug_fmt(this: Self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+                    $zalsa::with_attached_database(|db| {
+                        let fields = $Configuration::ingredient(db).fields(db.as_dyn_database(), this);
+                        let mut f = f.debug_struct(stringify!($Struct));
+                        $(
+                            let f = f.field(stringify!($field_id), &fields.$field_index);
+                        )*
+                        f.finish()
+                    }).unwrap_or_else(|| {
+                        f.debug_tuple(stringify!($Struct))
+                            .field(&$zalsa::AsId::as_id(&this))
+                            .finish()
+                    })
+                }
+            }
+        };
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/setup_method_body.rs b/crates/salsa/components/salsa-macro-rules/src/setup_method_body.rs
new file mode 100644
index 000000000..3d900b2f5
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/setup_method_body.rs
@@ -0,0 +1,40 @@
+#[macro_export]
+macro_rules! setup_method_body {
+    (
+        salsa_tracked_attr: #[$salsa_tracked_attr:meta],
+        self: $self:ident,
+        self_ty: $self_ty:ty,
+        db_lt: $($db_lt:lifetime)?,
+        db: $db:ident,
+        db_ty: ($($db_ty:tt)*),
+        input_ids: [$($input_id:ident),*],
+        input_tys: [$($input_ty:ty),*],
+        output_ty: $output_ty:ty,
+        inner_fn_name: $inner_fn_name:ident,
+        inner_fn: $inner_fn:item,
+
+        // Annoyingly macro-rules hygiene does not extend to items defined in the macro.
+        // We have the procedural macro generate names for those items that are
+        // not used elsewhere in the user's code.
+        unused_names: [
+            $InnerTrait:ident,
+        ]
+    ) => {
+        {
+            trait $InnerTrait<$($db_lt)?> {
+                fn $inner_fn_name($self, db: $($db_ty)*, $($input_id: $input_ty),*) -> $output_ty;
+            }
+
+            impl<$($db_lt)?> $InnerTrait<$($db_lt)?> for $self_ty {
+                $inner_fn
+            }
+
+            #[$salsa_tracked_attr]
+            fn $inner_fn_name<$($db_lt)?>(db: $($db_ty)*, this: $self_ty, $($input_id: $input_ty),*) -> $output_ty {
+                <$self_ty as $InnerTrait>::$inner_fn_name(this, db, $($input_id),*)
+            }
+
+            $inner_fn_name($db, $self, $($input_id),*)
+        }
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/setup_tracked_fn.rs b/crates/salsa/components/salsa-macro-rules/src/setup_tracked_fn.rs
new file mode 100644
index 000000000..ac51848d1
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/setup_tracked_fn.rs
@@ -0,0 +1,380 @@
+/// Macro for setting up a function that must intern its arguments.
+#[macro_export]
+macro_rules! setup_tracked_fn {
+    (
+        // Attributes on the function
+        attrs: [$(#[$attr:meta]),*],
+
+        // Visibility of the function
+        vis: $vis:vis,
+
+        // Name of the function
+        fn_name: $fn_name:ident,
+
+        // Name of the `'db` lifetime that the user gave; if they didn't, then defaults to `'db`
+        db_lt: $db_lt:lifetime,
+
+        // Path to the database trait that the user's database parameter used
+        Db: $Db:path,
+
+        // Name of the database parameter given by the user.
+        db: $db:ident,
+
+        // An identifier for each function argument EXCEPT the database.
+        // We prefer to use the identifier the user gave, but if the user gave a pattern
+        // (e.g., `(a, b): (u32, u32)`) we will synthesize an identifier.
+        input_ids: [$($input_id:ident),*],
+
+        // Types of the function arguments (may reference `$generics`).
+        input_tys: [$($input_ty:ty),*],
+
+        // Return type of the function (may reference `$generics`).
+        output_ty: $output_ty:ty,
+
+        // Function body, may reference identifiers defined in `$input_pats` and the generics from `$generics`
+        inner_fn: {$($inner_fn:tt)*},
+
+        // Path to the cycle recovery function to use.
+        cycle_recovery_fn: ($($cycle_recovery_fn:tt)*),
+
+        // Path to function to get the initial value to use for cycle recovery.
+        cycle_recovery_initial: ($($cycle_recovery_initial:tt)*),
+
+        // Name of cycle recovery strategy variant to use.
+        cycle_recovery_strategy: $cycle_recovery_strategy:ident,
+
+        // If true, this is specifiable.
+        is_specifiable: $is_specifiable:tt,
+
+        // Equality check strategy function
+        values_equal: {$($values_equal:tt)+},
+
+        // If true, the input needs an interner (because it has >1 argument).
+        needs_interner: $needs_interner:tt,
+
+        // LRU capacity (a literal, maybe 0)
+        lru: $lru:tt,
+
+        // The return mode for the function, see `salsa_macros::options::Option::returns`
+        return_mode: $return_mode:tt,
+
+        assert_return_type_is_update: {$($assert_return_type_is_update:tt)*},
+
+        // Annoyingly macro-rules hygiene does not extend to items defined in the macro.
+        // We have the procedural macro generate names for those items that are
+        // not used elsewhere in the user's code.
+        unused_names: [
+            $zalsa:ident,
+            $Configuration:ident,
+            $InternedData:ident,
+            $FN_CACHE:ident,
+            $INTERN_CACHE:ident,
+            $inner:ident,
+        ]
+    ) => {
+        // Suppress this clippy lint because we sometimes require `'db` where the ordinary Rust rules would not.
+        #[allow(clippy::needless_lifetimes)]
+        // Suppress the lint against `cfg(loom)`.
+        #[allow(unexpected_cfgs)]
+        $(#[$attr])*
+        $vis fn $fn_name<$db_lt>(
+            $db: &$db_lt dyn $Db,
+            $($input_id: $input_ty,)*
+        ) -> salsa::plumbing::return_mode_ty!(($return_mode, __, __), $db_lt, $output_ty) {
+            use salsa::plumbing as $zalsa;
+
+            struct $Configuration;
+
+            $zalsa::__maybe_lazy_static! {
+                static $FN_CACHE: $zalsa::IngredientCache<$zalsa::function::IngredientImpl<$Configuration>> =
+                    $zalsa::IngredientCache::new();
+            }
+
+            $zalsa::macro_if! {
+                if $needs_interner {
+                    #[derive(Copy, Clone)]
+                    struct $InternedData<$db_lt>(
+                        salsa::Id,
+                        std::marker::PhantomData<&$db_lt $zalsa::interned::Value<$Configuration>>,
+                    );
+
+                    $zalsa::__maybe_lazy_static! {
+                        static $INTERN_CACHE: $zalsa::IngredientCache<$zalsa::interned::IngredientImpl<$Configuration>> =
+                            $zalsa::IngredientCache::new();
+                    }
+
+                    impl $zalsa::SalsaStructInDb for $InternedData<'_> {
+                        type MemoIngredientMap = $zalsa::MemoIngredientSingletonIndex;
+
+                        fn lookup_or_create_ingredient_index(aux: &$zalsa::Zalsa) -> $zalsa::IngredientIndices {
+                            $zalsa::IngredientIndices::empty()
+                        }
+
+                        #[inline]
+                        fn cast(id: $zalsa::Id, type_id: ::core::any::TypeId) -> Option<Self> {
+                            if type_id == ::core::any::TypeId::of::<$InternedData>() {
+                                Some($InternedData(id, ::core::marker::PhantomData))
+                            } else {
+                                None
+                            }
+                        }
+                    }
+
+                    impl $zalsa::AsId for $InternedData<'_> {
+                        #[inline]
+                        fn as_id(&self) -> salsa::Id {
+                            self.0
+                        }
+                    }
+
+                    impl $zalsa::FromId for $InternedData<'_> {
+                        #[inline]
+                        fn from_id(id: salsa::Id) -> Self {
+                            Self(id, ::core::marker::PhantomData)
+                        }
+                    }
+
+                    impl $zalsa::interned::Configuration for $Configuration {
+                        const LOCATION: $zalsa::Location = $zalsa::Location {
+                            file: file!(),
+                            line: line!(),
+                        };
+                        const DEBUG_NAME: &'static str = concat!(stringify!($fn_name), "::interned_arguments");
+
+                        type Fields<$db_lt> = ($($input_ty),*);
+
+                        type Struct<$db_lt> = $InternedData<$db_lt>;
+                    }
+                } else {
+                    type $InternedData<$db_lt> = ($($input_ty),*);
+                }
+            }
+
+            impl $Configuration {
+                fn fn_ingredient(db: &dyn $Db) -> &$zalsa::function::IngredientImpl<$Configuration> {
+                    let zalsa = db.zalsa();
+                    $FN_CACHE.get_or_create(zalsa, || {
+                        <dyn $Db as $Db>::zalsa_register_downcaster(db);
+                        zalsa.add_or_lookup_jar_by_type::<$Configuration>()
+                    })
+                }
+
+                pub fn fn_ingredient_mut(db: &mut dyn $Db) -> &mut $zalsa::function::IngredientImpl<Self> {
+                    <dyn $Db as $Db>::zalsa_register_downcaster(db);
+                    let zalsa_mut = db.zalsa_mut();
+                    let index = zalsa_mut.add_or_lookup_jar_by_type::<$Configuration>();
+                    let (ingredient, _) = zalsa_mut.lookup_ingredient_mut(index);
+                    ingredient.assert_type_mut::<$zalsa::function::IngredientImpl<Self>>()
+                }
+
+                $zalsa::macro_if! { $needs_interner =>
+                    fn intern_ingredient(
+                        db: &dyn $Db,
+                    ) -> &$zalsa::interned::IngredientImpl<$Configuration> {
+                        let zalsa = db.zalsa();
+                        $INTERN_CACHE.get_or_create(zalsa, || {
+                            <dyn $Db as $Db>::zalsa_register_downcaster(db);
+                            zalsa.add_or_lookup_jar_by_type::<$Configuration>().successor(0)
+                        })
+                    }
+                }
+            }
+
+            impl $zalsa::function::Configuration for $Configuration {
+                const LOCATION: $zalsa::Location = $zalsa::Location {
+                    file: file!(),
+                    line: line!(),
+                };
+                const DEBUG_NAME: &'static str = stringify!($fn_name);
+
+                type DbView = dyn $Db;
+
+                type SalsaStruct<$db_lt> = $InternedData<$db_lt>;
+
+                type Input<$db_lt> = ($($input_ty),*);
+
+                type Output<$db_lt> = $output_ty;
+
+                const CYCLE_STRATEGY: $zalsa::CycleRecoveryStrategy = $zalsa::CycleRecoveryStrategy::$cycle_recovery_strategy;
+
+                $($values_equal)+
+
+                fn execute<$db_lt>($db: &$db_lt Self::DbView, ($($input_id),*): ($($input_ty),*)) -> Self::Output<$db_lt> {
+                    $($assert_return_type_is_update)*
+
+                    $($inner_fn)*
+
+                    $inner($db, $($input_id),*)
+                }
+
+                fn cycle_initial<$db_lt>(db: &$db_lt Self::DbView, ($($input_id),*): ($($input_ty),*)) -> Self::Output<$db_lt> {
+                    $($cycle_recovery_initial)*(db, $($input_id),*)
+                }
+
+                fn recover_from_cycle<$db_lt>(
+                    db: &$db_lt dyn $Db,
+                    value: &Self::Output<$db_lt>,
+                    count: u32,
+                    ($($input_id),*): ($($input_ty),*)
+                ) -> $zalsa::CycleRecoveryAction<Self::Output<$db_lt>> {
+                    $($cycle_recovery_fn)*(db, value, count, $($input_id),*)
+                }
+
+                fn id_to_input<$db_lt>(db: &$db_lt Self::DbView, key: salsa::Id) -> Self::Input<$db_lt> {
+                    $zalsa::macro_if! {
+                        if $needs_interner {
+                            $Configuration::intern_ingredient(db).data(db.as_dyn_database(), key).clone()
+                        } else {
+                            $zalsa::FromIdWithDb::from_id(key, db.zalsa())
+                        }
+                    }
+                }
+            }
+
+            impl $zalsa::Jar for $Configuration {
+                fn create_dependencies(zalsa: &$zalsa::Zalsa) -> $zalsa::IngredientIndices
+                where
+                    Self: Sized
+                {
+                    $zalsa::macro_if! {
+                        if $needs_interner {
+                            $zalsa::IngredientIndices::empty()
+                        } else {
+                            <$InternedData as $zalsa::SalsaStructInDb>::lookup_or_create_ingredient_index(zalsa)
+                        }
+                    }
+                }
+
+                fn create_ingredients(
+                    zalsa: &$zalsa::Zalsa,
+                    first_index: $zalsa::IngredientIndex,
+                    struct_index: $zalsa::IngredientIndices,
+                ) -> Vec<Box<dyn $zalsa::Ingredient>> {
+                    let struct_index: $zalsa::IngredientIndices = $zalsa::macro_if! {
+                        if $needs_interner {
+                            first_index.successor(0).into()
+                        } else {
+                            struct_index
+                        }
+                    };
+
+                    $zalsa::macro_if! { $needs_interner =>
+                        let intern_ingredient = <$zalsa::interned::IngredientImpl<$Configuration>>::new(
+                            first_index.successor(0)
+                        );
+                    }
+
+                    let intern_ingredient_memo_types = $zalsa::macro_if! {
+                        if $needs_interner {
+                            Some($zalsa::Ingredient::memo_table_types(&intern_ingredient))
+                        } else {
+                            None
+                        }
+                    };
+                    // SAFETY: We call with the correct memo types.
+                    let memo_ingredient_indices = unsafe {
+                        $zalsa::NewMemoIngredientIndices::create(
+                            zalsa,
+                            struct_index,
+                            first_index,
+                            $zalsa::function::MemoEntryType::of::<$zalsa::function::Memo<$Configuration>>(),
+                            intern_ingredient_memo_types,
+                        )
+                    };
+
+                    let fn_ingredient = <$zalsa::function::IngredientImpl<$Configuration>>::new(
+                        first_index,
+                        memo_ingredient_indices,
+                        $lru,
+                        zalsa.views().downcaster_for::<dyn $Db>(),
+                    );
+                    $zalsa::macro_if! {
+                        if $needs_interner {
+                            vec![
+                                Box::new(fn_ingredient),
+                                Box::new(intern_ingredient),
+                            ]
+                        } else {
+                            vec![
+                                Box::new(fn_ingredient),
+                            ]
+                        }
+                    }
+                }
+
+                fn id_struct_type_id() -> $zalsa::TypeId {
+                    $zalsa::TypeId::of::<$InternedData<'static>>()
+                }
+            }
+
+            #[allow(non_local_definitions)]
+            impl $fn_name {
+                pub fn accumulated<$db_lt, A: salsa::Accumulator>(
+                    $db: &$db_lt dyn $Db,
+                    $($input_id: $input_ty,)*
+                ) -> Vec<&$db_lt A> {
+                    use salsa::plumbing as $zalsa;
+                    let key = $zalsa::macro_if! {
+                        if $needs_interner {
+                            $Configuration::intern_ingredient($db).intern_id($db.as_dyn_database(), ($($input_id),*), |_, data| data)
+                        } else {
+                            $zalsa::AsId::as_id(&($($input_id),*))
+                        }
+                    };
+
+                    $Configuration::fn_ingredient($db).accumulated_by::<A>($db, key)
+                }
+
+                $zalsa::macro_if! { $is_specifiable =>
+                    pub fn specify<$db_lt>(
+                        $db: &$db_lt dyn $Db,
+                        $($input_id: $input_ty,)*
+                        value: $output_ty,
+                    ) {
+                        let key = $zalsa::AsId::as_id(&($($input_id),*));
+                        $Configuration::fn_ingredient($db).specify_and_record(
+                            $db,
+                            key,
+                            value,
+                        )
+                    }
+                }
+
+                $zalsa::macro_if! { if0 $lru { } else {
+                    /// Sets the lru capacity
+                    ///
+                    /// **WARNING:** Just like an ordinary write, this method triggers
+                    /// cancellation. If you invoke it while a snapshot exists, it
+                    /// will block until that snapshot is dropped -- if that snapshot
+                    /// is owned by the current thread, this could trigger deadlock.
+                    #[allow(dead_code)]
+                    fn set_lru_capacity(db: &mut dyn $Db, value: usize) {
+                        $Configuration::fn_ingredient_mut(db).set_capacity(value);
+                    }
+                } }
+            }
+
+            $zalsa::attach($db, || {
+                let result = $zalsa::macro_if! {
+                    if $needs_interner {
+                        {
+                            let key = $Configuration::intern_ingredient($db).intern_id($db.as_dyn_database(), ($($input_id),*), |_, data| data);
+                            $Configuration::fn_ingredient($db).fetch($db, key)
+                        }
+                    } else {
+                        $Configuration::fn_ingredient($db).fetch($db, $zalsa::AsId::as_id(&($($input_id),*)))
+                    }
+                };
+
+                $zalsa::return_mode_expression!(($return_mode, __, __), $output_ty, result,)
+            })
+        }
+        // The struct needs be last in the macro expansion in order to make the tracked
+        // function's ident be identified as a function, not a struct, during semantic highlighting.
+        // for more details, see https://github.com/salsa-rs/salsa/pull/612.
+        #[allow(non_camel_case_types)]
+        $vis struct $fn_name {
+            _priv: std::convert::Infallible,
+        }
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/setup_tracked_struct.rs b/crates/salsa/components/salsa-macro-rules/src/setup_tracked_struct.rs
new file mode 100644
index 000000000..6d377017f
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/setup_tracked_struct.rs
@@ -0,0 +1,323 @@
+/// Macro for setting up a function that must intern its arguments.
+#[macro_export]
+macro_rules! setup_tracked_struct {
+    (
+        // Attributes on the function.
+        attrs: [$(#[$attr:meta]),*],
+
+        // Visibility of the struct.
+        vis: $vis:vis,
+
+        // Name of the struct.
+        Struct: $Struct:ident,
+
+        // Name of the `'db` lifetime that the user gave.
+        db_lt: $db_lt:lifetime,
+
+        // Name user gave for `new`.
+        new_fn: $new_fn:ident,
+
+        // Field names.
+        field_ids: [$($field_id:ident),*],
+
+        // Tracked field names.
+        tracked_ids: [$($tracked_id:ident),*],
+
+        // Visibility and names of tracked fields.
+        tracked_getters: [$($tracked_getter_vis:vis $tracked_getter_id:ident),*],
+
+        // Visibility and names of untracked fields.
+        untracked_getters: [$($untracked_getter_vis:vis $untracked_getter_id:ident),*],
+
+        // Field types, may reference `db_lt`.
+        field_tys: [$($field_ty:ty),*],
+
+        // Tracked field types.
+        tracked_tys: [$($tracked_ty:ty),*],
+
+        // Untracked field types.
+        untracked_tys: [$($untracked_ty:ty),*],
+
+        // Indices for each field from 0..N -- must be unsuffixed (e.g., `0`, `1`).
+        field_indices: [$($field_index:tt),*],
+
+        // Absolute indices of any tracked fields, relative to all other fields of this struct.
+        absolute_tracked_indices: [$($absolute_tracked_index:tt),*],
+
+        // Indices of any tracked fields, relative to only tracked fields on this struct.
+        relative_tracked_indices: [$($relative_tracked_index:tt),*],
+
+        // Absolute indices of any untracked fields.
+        absolute_untracked_indices: [$($absolute_untracked_index:tt),*],
+
+        // A set of "field options" for each tracked field.
+        //
+        // Each field option is a tuple `(return_mode, maybe_backdate)` where:
+        //
+        // * `return_mode` is an identifier as specified in `salsa_macros::options::Option::returns`
+        // * `maybe_backdate` is either the identifier `backdate` or `no_backdate`
+        //
+        // These are used to drive conditional logic for each field via recursive macro invocation
+        // (see e.g. @return_mode below).
+        tracked_options: [$($tracked_option:tt),*],
+
+        // A set of "field options" for each untracked field.
+        //
+        // Each field option is a tuple `(return_mode, maybe_backdate)` where:
+        //
+        // * `return_mode` is an identifier as specified in `salsa_macros::options::Option::returns`
+        // * `maybe_backdate` is either the identifier `backdate` or `no_backdate`
+        //
+        // These are used to drive conditional logic for each field via recursive macro invocation
+        // (see e.g. @return_mode below).
+        untracked_options: [$($untracked_option:tt),*],
+
+        // Number of tracked fields.
+        num_tracked_fields: $N:literal,
+
+        // If true, generate a debug impl.
+        generate_debug_impl: $generate_debug_impl:tt,
+
+        // Annoyingly macro-rules hygiene does not extend to items defined in the macro.
+        // We have the procedural macro generate names for those items that are
+        // not used elsewhere in the user's code.
+        unused_names: [
+            $zalsa:ident,
+            $zalsa_struct:ident,
+            $Configuration:ident,
+            $CACHE:ident,
+            $Db:ident,
+            $Revision:ident,
+        ]
+    ) => {
+        $(#[$attr])*
+        #[derive(Copy, Clone, PartialEq, Eq, Hash)]
+        $vis struct $Struct<$db_lt>(
+            salsa::Id,
+            std::marker::PhantomData < & $db_lt salsa::plumbing::tracked_struct::Value < $Struct<'static> > >
+        );
+
+        #[allow(clippy::all)]
+        #[allow(dead_code)]
+        const _: () = {
+            use salsa::plumbing as $zalsa;
+            use $zalsa::tracked_struct as $zalsa_struct;
+            use $zalsa::Revision as $Revision;
+
+            type $Configuration = $Struct<'static>;
+
+            impl $zalsa_struct::Configuration for $Configuration {
+                const LOCATION: $zalsa::Location = $zalsa::Location {
+                    file: file!(),
+                    line: line!(),
+                };
+                const DEBUG_NAME: &'static str = stringify!($Struct);
+
+                const TRACKED_FIELD_NAMES: &'static [&'static str] = &[
+                    $(stringify!($tracked_id),)*
+                ];
+
+                const TRACKED_FIELD_INDICES: &'static [usize] = &[
+                    $($relative_tracked_index,)*
+                ];
+
+                type Fields<$db_lt> = ($($field_ty,)*);
+
+                type Revisions = [$Revision; $N];
+
+                type Struct<$db_lt> = $Struct<$db_lt>;
+
+                fn untracked_fields(fields: &Self::Fields<'_>) -> impl std::hash::Hash {
+                    ( $( &fields.$absolute_untracked_index ),* )
+                }
+
+                fn new_revisions(current_revision: $Revision) -> Self::Revisions {
+                    [current_revision; $N]
+                }
+
+                unsafe fn update_fields<$db_lt>(
+                    current_revision: $Revision,
+                    revisions: &mut Self::Revisions,
+                    old_fields: *mut Self::Fields<$db_lt>,
+                    new_fields: Self::Fields<$db_lt>,
+                ) -> bool {
+                    use $zalsa::UpdateFallback as _;
+                    unsafe {
+                        $(
+                            $crate::maybe_backdate!(
+                                $tracked_option,
+                                $tracked_ty,
+                                (*old_fields).$absolute_tracked_index,
+                                new_fields.$absolute_tracked_index,
+                                revisions[$relative_tracked_index],
+                                current_revision,
+                                $zalsa,
+                            );
+                        )*;
+
+                        // If any untracked field has changed, return `true`, indicating that the tracked struct
+                        // itself should be considered changed.
+                        $(
+                            $zalsa::UpdateDispatch::<$untracked_ty>::maybe_update(
+                                &mut (*old_fields).$absolute_untracked_index,
+                                new_fields.$absolute_untracked_index,
+                            )
+                            |
+                        )* false
+                    }
+                }
+            }
+
+            impl $Configuration {
+                pub fn ingredient(db: &dyn $zalsa::Database) -> &$zalsa_struct::IngredientImpl<Self> {
+                    Self::ingredient_(db.zalsa())
+                }
+
+                // Suppress the lint against `cfg(loom)`.
+                #[allow(unexpected_cfgs)]
+                fn ingredient_(zalsa: &$zalsa::Zalsa) -> &$zalsa_struct::IngredientImpl<Self> {
+                    $zalsa::__maybe_lazy_static! {
+                        static CACHE: $zalsa::IngredientCache<$zalsa_struct::IngredientImpl<$Configuration>> =
+                            $zalsa::IngredientCache::new();
+                    }
+
+                    CACHE.get_or_create(zalsa, || {
+                        zalsa.add_or_lookup_jar_by_type::<$zalsa_struct::JarImpl<$Configuration>>()
+                    })
+                }
+            }
+
+            impl<$db_lt> $zalsa::FromId for $Struct<$db_lt> {
+                #[inline]
+                fn from_id(id: salsa::Id) -> Self {
+                    $Struct(id, std::marker::PhantomData)
+                }
+            }
+
+            impl $zalsa::AsId for $Struct<'_> {
+                #[inline]
+                fn as_id(&self) -> $zalsa::Id {
+                    self.0
+                }
+            }
+
+            impl $zalsa::SalsaStructInDb for $Struct<'_> {
+                type MemoIngredientMap = $zalsa::MemoIngredientSingletonIndex;
+
+                fn lookup_or_create_ingredient_index(aux: &$zalsa::Zalsa) -> $zalsa::IngredientIndices {
+                    aux.add_or_lookup_jar_by_type::<$zalsa_struct::JarImpl<$Configuration>>().into()
+                }
+
+                #[inline]
+                fn cast(id: $zalsa::Id, type_id: $zalsa::TypeId) -> $zalsa::Option<Self> {
+                    if type_id == $zalsa::TypeId::of::<$Struct<'static>>() {
+                        $zalsa::Some(<$Struct<'static> as $zalsa::FromId>::from_id(id))
+                    } else {
+                        $zalsa::None
+                    }
+                }
+            }
+
+            impl $zalsa::TrackedStructInDb for $Struct<'_> {
+                fn database_key_index(zalsa: &$zalsa::Zalsa, id: $zalsa::Id) -> $zalsa::DatabaseKeyIndex {
+                    $Configuration::ingredient_(zalsa).database_key_index(id)
+                }
+            }
+
+            unsafe impl Send for $Struct<'_> {}
+
+            unsafe impl Sync for $Struct<'_> {}
+
+            $zalsa::macro_if! { $generate_debug_impl =>
+                impl std::fmt::Debug for $Struct<'_> {
+                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+                        Self::default_debug_fmt(*self, f)
+                    }
+                }
+            }
+
+            unsafe impl $zalsa::Update for $Struct<'_> {
+                unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool {
+                    if unsafe { *old_pointer } != new_value {
+                        unsafe { *old_pointer = new_value };
+                        true
+                    } else {
+                        false
+                    }
+                }
+            }
+
+            impl<$db_lt> $Struct<$db_lt> {
+                pub fn $new_fn<$Db>(db: &$db_lt $Db, $($field_id: $field_ty),*) -> Self
+                where
+                    // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                    $Db: ?Sized + $zalsa::Database,
+                {
+                    $Configuration::ingredient(db.as_dyn_database()).new_struct(
+                        db.as_dyn_database(),
+                        ($($field_id,)*)
+                    )
+                }
+
+                $(
+                    $tracked_getter_vis fn $tracked_getter_id<$Db>(self, db: &$db_lt $Db) -> $crate::return_mode_ty!($tracked_option, $db_lt, $tracked_ty)
+                    where
+                        // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                        $Db: ?Sized + $zalsa::Database,
+                    {
+                        let db = db.as_dyn_database();
+                        let fields = $Configuration::ingredient(db).tracked_field(db, self, $relative_tracked_index);
+                        $crate::return_mode_expression!(
+                            $tracked_option,
+                            $tracked_ty,
+                            &fields.$absolute_tracked_index,
+                        )
+                    }
+                )*
+
+                $(
+                    $untracked_getter_vis fn $untracked_getter_id<$Db>(self, db: &$db_lt $Db) -> $crate::return_mode_ty!($untracked_option, $db_lt, $untracked_ty)
+                    where
+                        // FIXME(rust-lang/rust#65991): The `db` argument *should* have the type `dyn Database`
+                        $Db: ?Sized + $zalsa::Database,
+                    {
+                        let db = db.as_dyn_database();
+                        let fields = $Configuration::ingredient(db).untracked_field(db, self);
+                        $crate::return_mode_expression!(
+                            $untracked_option,
+                            $untracked_ty,
+                            &fields.$absolute_untracked_index,
+                        )
+                    }
+                )*
+            }
+
+            #[allow(unused_lifetimes)]
+            impl<'_db> $Struct<'_db> {
+                /// Default debug formatting for this struct (may be useful if you define your own `Debug` impl)
+                pub fn default_debug_fmt(this: Self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result
+                where
+                    // `zalsa::with_attached_database` has a local lifetime for the database
+                    // so we need this function to be higher-ranked over the db lifetime
+                    // Thus the actual lifetime of `Self` does not matter here so we discard
+                    // it with the `'_db` lifetime name as we cannot shadow lifetimes.
+                    $(for<$db_lt> $field_ty: std::fmt::Debug),*
+                {
+                    $zalsa::with_attached_database(|db| {
+                        let fields = $Configuration::ingredient(db).leak_fields(db, this);
+                        let mut f = f.debug_struct(stringify!($Struct));
+                        let f = f.field("[salsa id]", &$zalsa::AsId::as_id(&this));
+                        $(
+                            let f = f.field(stringify!($field_id), &fields.$field_index);
+                        )*
+                        f.finish()
+                    }).unwrap_or_else(|| {
+                        f.debug_struct(stringify!($Struct))
+                            .field("[salsa id]", &$zalsa::AsId::as_id(&this))
+                            .finish()
+                    })
+                }
+            }
+        };
+    };
+}
diff --git a/crates/salsa/components/salsa-macro-rules/src/unexpected_cycle_recovery.rs b/crates/salsa/components/salsa-macro-rules/src/unexpected_cycle_recovery.rs
new file mode 100644
index 000000000..a1cd1e73f
--- /dev/null
+++ b/crates/salsa/components/salsa-macro-rules/src/unexpected_cycle_recovery.rs
@@ -0,0 +1,20 @@
+// Macro that generates the body of the cycle recovery function
+// for the case where no cycle recovery is possible. This has to be
+// a macro because it can take a variadic number of arguments.
+#[macro_export]
+macro_rules! unexpected_cycle_recovery {
+    ($db:ident, $value:ident, $count:ident, $($other_inputs:ident),*) => {{
+        std::mem::drop($db);
+        std::mem::drop(($($other_inputs),*));
+        panic!("cannot recover from cycle")
+    }};
+}
+
+#[macro_export]
+macro_rules! unexpected_cycle_initial {
+    ($db:ident, $($other_inputs:ident),*) => {{
+        std::mem::drop($db);
+        std::mem::drop(($($other_inputs),*));
+        panic!("no cycle initial value")
+    }};
+}
diff --git a/crates/salsa/components/salsa-macros/CHANGELOG.md b/crates/salsa/components/salsa-macros/CHANGELOG.md
new file mode 100644
index 000000000..ba2d12be3
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/CHANGELOG.md
@@ -0,0 +1,51 @@
+# Changelog
+
+All notable changes to this project will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+## [Unreleased]
+
+## [0.21.0](https://github.com/salsa-rs/salsa/compare/salsa-macros-v0.20.0...salsa-macros-v0.21.0) - 2025-04-29
+
+### Fixed
+
+- allow unused lifetimes in tracked_struct expansion ([#824](https://github.com/salsa-rs/salsa/pull/824))
+
+### Other
+
+- Add a compile-fail test for a `'static` `!Update` struct ([#820](https://github.com/salsa-rs/salsa/pull/820))
+- squelch most clippy warnings in generated code ([#809](https://github.com/salsa-rs/salsa/pull/809))
+- Use `DatabaseKey` for interned events ([#813](https://github.com/salsa-rs/salsa/pull/813))
+
+## [0.20.0](https://github.com/salsa-rs/salsa/compare/salsa-macros-v0.19.0...salsa-macros-v0.20.0) - 2025-04-22
+
+### Added
+
+- Drop `Debug` requirements and flip implementation defaults ([#756](https://github.com/salsa-rs/salsa/pull/756))
+
+### Other
+
+- Add a third cycle mode, equivalent to old Salsa cycle behavior ([#801](https://github.com/salsa-rs/salsa/pull/801))
+- Normalize imports style ([#779](https://github.com/salsa-rs/salsa/pull/779))
+- Document most safety blocks ([#776](https://github.com/salsa-rs/salsa/pull/776))
+- bug [salsa-macros]: Improve debug name of tracked methods ([#755](https://github.com/salsa-rs/salsa/pull/755))
+- rewrite cycle handling to support fixed-point iteration ([#603](https://github.com/salsa-rs/salsa/pull/603))
+
+## [0.19.0](https://github.com/salsa-rs/salsa/compare/salsa-macros-v0.18.0...salsa-macros-v0.19.0) - 2025-03-10
+
+### Fixed
+
+- fix enums bug
+
+### Other
+
+- Store view downcaster in function ingredients directly ([#720](https://github.com/salsa-rs/salsa/pull/720))
+- :replace instead of std::mem::replace ([#746](https://github.com/salsa-rs/salsa/pull/746))
+- Cleanup `Cargo.toml`s ([#745](https://github.com/salsa-rs/salsa/pull/745))
+- address review comments
+- Skip memo ingredient index mapping for non enum tracked functions
+- Trade off a bit of memory for more speed in `MemoIngredientIndices`
+- Introduce Salsa enums
+- Track revisions for tracked fields only
diff --git a/crates/salsa/components/salsa-macros/Cargo.toml b/crates/salsa/components/salsa-macros/Cargo.toml
new file mode 100644
index 000000000..e9757c724
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/Cargo.toml
@@ -0,0 +1,19 @@
+[package]
+name = "salsa-macros"
+version = "0.21.1"
+authors.workspace = true
+edition.workspace = true
+license.workspace = true
+repository.workspace = true
+rust-version.workspace = true
+description = "Procedural macros for the salsa crate"
+
+[lib]
+proc-macro = true
+
+[dependencies]
+heck = "0.5.0"
+proc-macro2 = "1.0"
+quote = "1.0"
+syn = { version = "2.0.64", features = ["full", "visit-mut"] }
+synstructure = "0.13.1"
diff --git a/crates/salsa/components/salsa-macros/src/accumulator.rs b/crates/salsa/components/salsa-macros/src/accumulator.rs
new file mode 100644
index 000000000..8973f0fa3
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/accumulator.rs
@@ -0,0 +1,81 @@
+use proc_macro2::TokenStream;
+
+use crate::hygiene::Hygiene;
+use crate::options::{AllowedOptions, Options};
+use crate::token_stream_with_error;
+
+// #[salsa::accumulator(jar = Jar0)]
+// struct Accumulator(DataType);
+
+pub(crate) fn accumulator(
+    args: proc_macro::TokenStream,
+    input: proc_macro::TokenStream,
+) -> proc_macro::TokenStream {
+    let hygiene = Hygiene::from1(&input);
+    let args = syn::parse_macro_input!(args as Options<Accumulator>);
+    let struct_item = parse_macro_input!(input as syn::ItemStruct);
+    let ident = struct_item.ident.clone();
+    let m = StructMacro {
+        hygiene,
+        _args: args,
+        struct_item,
+    };
+    match m.try_expand() {
+        Ok(v) => crate::debug::dump_tokens(ident, v).into(),
+        Err(e) => token_stream_with_error(input, e),
+    }
+}
+
+struct Accumulator;
+
+impl AllowedOptions for Accumulator {
+    const RETURNS: bool = false;
+    const SPECIFY: bool = false;
+    const NO_EQ: bool = false;
+    const DEBUG: bool = false;
+    const NO_CLONE: bool = false;
+    const NO_LIFETIME: bool = false;
+    const SINGLETON: bool = false;
+    const DATA: bool = false;
+    const DB: bool = false;
+    const CYCLE_FN: bool = false;
+    const CYCLE_INITIAL: bool = false;
+    const CYCLE_RESULT: bool = false;
+    const LRU: bool = false;
+    const CONSTRUCTOR_NAME: bool = false;
+    const ID: bool = false;
+}
+
+struct StructMacro {
+    hygiene: Hygiene,
+    _args: Options<Accumulator>,
+    struct_item: syn::ItemStruct,
+}
+
+#[allow(non_snake_case)]
+impl StructMacro {
+    fn try_expand(self) -> syn::Result<TokenStream> {
+        let ident = self.struct_item.ident.clone();
+
+        let zalsa = self.hygiene.ident("zalsa");
+        let zalsa_struct = self.hygiene.ident("zalsa_struct");
+        let CACHE = self.hygiene.ident("CACHE");
+        let ingredient = self.hygiene.ident("ingredient");
+
+        let struct_item = self.struct_item;
+
+        Ok(quote! {
+            #struct_item
+
+            salsa::plumbing::setup_accumulator_impl! {
+                Struct: #ident,
+                unused_names: [
+                    #zalsa,
+                    #zalsa_struct,
+                    #CACHE,
+                    #ingredient,
+                ]
+            }
+        })
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/db.rs b/crates/salsa/components/salsa-macros/src/db.rs
new file mode 100644
index 000000000..478ebea5d
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/db.rs
@@ -0,0 +1,155 @@
+use proc_macro2::TokenStream;
+use syn::parse::Nothing;
+
+use crate::hygiene::Hygiene;
+use crate::token_stream_with_error;
+
+// Source:
+//
+// #[salsa::db]
+// pub struct Database {
+//    storage: salsa::Storage<Self>,
+// }
+
+pub(crate) fn db(
+    args: proc_macro::TokenStream,
+    input: proc_macro::TokenStream,
+) -> proc_macro::TokenStream {
+    let _nothing = syn::parse_macro_input!(args as Nothing);
+    let hygiene = Hygiene::from1(&input);
+    let item = parse_macro_input!(input as syn::Item);
+    let db_macro = DbMacro { hygiene };
+    match db_macro.try_db(item) {
+        Ok(v) => crate::debug::dump_tokens("db", v).into(),
+        Err(e) => token_stream_with_error(input, e),
+    }
+}
+
+struct DbMacro {
+    hygiene: Hygiene,
+}
+
+#[allow(non_snake_case)]
+impl DbMacro {
+    fn try_db(self, input: syn::Item) -> syn::Result<TokenStream> {
+        match input {
+            syn::Item::Struct(input) => {
+                let has_storage_impl = self.has_storage_impl(&input)?;
+                Ok(quote! {
+                    #has_storage_impl
+                    #input
+                })
+            }
+            syn::Item::Trait(mut input) => {
+                self.add_salsa_view_method(&mut input)?;
+                Ok(quote! {
+                    #input
+                })
+            }
+            syn::Item::Impl(mut input) => {
+                self.add_salsa_view_method_impl(&mut input)?;
+                Ok(quote! {
+                    #input
+                })
+            }
+            _ => Err(syn::Error::new_spanned(
+                input,
+                "`db` must be applied to a struct, trait, or impl",
+            )),
+        }
+    }
+
+    fn find_storage_field(&self, input: &syn::ItemStruct) -> syn::Result<syn::Ident> {
+        let storage = "storage";
+        for field in input.fields.iter() {
+            if let Some(i) = &field.ident {
+                if i == storage {
+                    return Ok(i.clone());
+                }
+            } else {
+                return Err(syn::Error::new_spanned(
+                    field,
+                    "database struct must be a braced struct (`{}`) with a field named `storage`",
+                ));
+            }
+        }
+
+        Err(syn::Error::new_spanned(
+            &input.ident,
+            "database struct must be a braced struct (`{}`) with a field named `storage`",
+        ))
+    }
+
+    fn has_storage_impl(&self, input: &syn::ItemStruct) -> syn::Result<TokenStream> {
+        let storage = self.find_storage_field(input)?;
+        let db = &input.ident;
+        let zalsa = self.hygiene.ident("zalsa");
+
+        Ok(quote! {
+            #[allow(clippy::all)]
+            #[allow(dead_code)]
+            const _: () = {
+                use salsa::plumbing as #zalsa;
+
+                unsafe impl #zalsa::HasStorage for #db {
+                    #[inline(always)]
+                    fn storage(&self) -> &#zalsa::Storage<Self> {
+                        &self.#storage
+                    }
+
+                    #[inline(always)]
+                    fn storage_mut(&mut self) -> &mut #zalsa::Storage<Self> {
+                        &mut self.#storage
+                    }
+                }
+            };
+        })
+    }
+
+    fn add_salsa_view_method(&self, input: &mut syn::ItemTrait) -> syn::Result<()> {
+        let trait_name = &input.ident;
+        input.items.push(parse_quote! {
+            #[doc(hidden)]
+            fn zalsa_register_downcaster(&self);
+        });
+
+        let comment = format!(" Downcast a [`dyn Database`] to a [`dyn {trait_name}`]");
+        input.items.push(parse_quote! {
+            #[doc = #comment]
+            ///
+            /// # Safety
+            ///
+            /// The input database must be of type `Self`.
+            #[doc(hidden)]
+            unsafe fn downcast(db: &dyn salsa::plumbing::Database) -> &dyn #trait_name where Self: Sized;
+        });
+        Ok(())
+    }
+
+    fn add_salsa_view_method_impl(&self, input: &mut syn::ItemImpl) -> syn::Result<()> {
+        let Some((_, TraitPath, _)) = &input.trait_ else {
+            return Err(syn::Error::new_spanned(
+                &input.self_ty,
+                "impl must be on a trait",
+            ));
+        };
+
+        input.items.push(parse_quote! {
+            #[doc(hidden)]
+            #[inline(always)]
+            fn zalsa_register_downcaster(&self)  {
+                salsa::plumbing::views(self).add(<Self as #TraitPath>::downcast);
+            }
+        });
+        input.items.push(parse_quote! {
+            #[doc(hidden)]
+            #[inline(always)]
+            unsafe fn downcast(db: &dyn salsa::plumbing::Database) -> &dyn #TraitPath where Self: Sized {
+                debug_assert_eq!(db.type_id(), ::core::any::TypeId::of::<Self>());
+                // SAFETY: The input database must be of type `Self`.
+                unsafe { &*salsa::plumbing::transmute_data_ptr::<dyn salsa::plumbing::Database, Self>(db) }
+            }
+        });
+        Ok(())
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/db_lifetime.rs b/crates/salsa/components/salsa-macros/src/db_lifetime.rs
new file mode 100644
index 000000000..87f8b726e
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/db_lifetime.rs
@@ -0,0 +1,73 @@
+//! Helper functions for working with fns, structs, and other generic things
+//! that are allowed to have a `'db` lifetime.
+
+use proc_macro2::Span;
+use syn::spanned::Spanned;
+
+/// Normally we try to use whatever lifetime parameter the user gave us
+/// to represent `'db`; but if they didn't give us one, we need to use a default
+/// name. We choose `'db`.
+pub(crate) fn default_db_lifetime(span: Span) -> syn::Lifetime {
+    syn::Lifetime {
+        apostrophe: span,
+        ident: syn::Ident::new("db", span),
+    }
+}
+
+/// Require that either there are no generics or exactly one lifetime parameter.
+pub(crate) fn require_optional_db_lifetime(generics: &syn::Generics) -> syn::Result<()> {
+    if generics.params.is_empty() {
+        return Ok(());
+    }
+
+    require_db_lifetime(generics)?;
+
+    Ok(())
+}
+
+/// Require that either there is exactly one lifetime parameter.
+pub(crate) fn require_db_lifetime(generics: &syn::Generics) -> syn::Result<()> {
+    if generics.params.is_empty() {
+        return Err(syn::Error::new_spanned(
+            generics,
+            "this definition must have a `'db` lifetime",
+        ));
+    }
+
+    for (param, index) in generics.params.iter().zip(0..) {
+        let error = match param {
+            syn::GenericParam::Lifetime(_) => index > 0,
+            syn::GenericParam::Type(_) | syn::GenericParam::Const(_) => true,
+        };
+
+        if error {
+            return Err(syn::Error::new_spanned(
+                param,
+                "only a single lifetime parameter is accepted",
+            ));
+        }
+    }
+
+    Ok(())
+}
+
+/// Return the `'db` lifetime given by the user, or a default.
+/// The generics ought to have been checked with `require_db_lifetime` already.
+pub(crate) fn db_lifetime(generics: &syn::Generics) -> syn::Lifetime {
+    if let Some(lt) = generics.lifetimes().next() {
+        lt.lifetime.clone()
+    } else {
+        default_db_lifetime(generics.span())
+    }
+}
+
+pub(crate) fn require_no_generics(generics: &syn::Generics) -> syn::Result<()> {
+    if let Some(param) = generics.params.iter().next() {
+        return Err(syn::Error::new_spanned(
+            param,
+            "generic parameters not allowed here",
+        ));
+    }
+
+    Ok(())
+}
diff --git a/crates/salsa/components/salsa-macros/src/debug.rs b/crates/salsa/components/salsa-macros/src/debug.rs
new file mode 100644
index 000000000..1f6845ed8
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/debug.rs
@@ -0,0 +1,43 @@
+use std::io::Write;
+use std::process::{Command, Stdio};
+use std::sync::OnceLock;
+
+use proc_macro2::TokenStream;
+
+static SALSA_DEBUG_MACRO: OnceLock<Option<String>> = OnceLock::new();
+
+pub(crate) fn debug_enabled(input_name: impl ToString) -> bool {
+    let Some(env_name) = SALSA_DEBUG_MACRO.get_or_init(|| std::env::var("SALSA_DEBUG_MACRO").ok())
+    else {
+        return false;
+    };
+
+    let input_name = input_name.to_string();
+    env_name == "*" || env_name == &input_name[..]
+}
+
+pub(crate) fn dump_tokens(input_name: impl ToString, tokens: TokenStream) -> TokenStream {
+    if debug_enabled(input_name) {
+        let token_string = tokens.to_string();
+
+        let _: Result<(), ()> = Command::new("rustfmt")
+            .arg("--emit=stdout")
+            .stdin(Stdio::piped())
+            .spawn()
+            .and_then(|mut rustfmt| {
+                rustfmt
+                    .stdin
+                    .take()
+                    .unwrap()
+                    .write_all(token_string.as_bytes())?;
+                rustfmt.wait_with_output()
+            })
+            .map(|output| eprintln!("{}", String::from_utf8_lossy(&output.stdout)))
+            .or_else(|_| {
+                eprintln!("{token_string}");
+                Ok(())
+            });
+    }
+
+    tokens
+}
diff --git a/crates/salsa/components/salsa-macros/src/fn_util.rs b/crates/salsa/components/salsa-macros/src/fn_util.rs
new file mode 100644
index 000000000..619d0fd97
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/fn_util.rs
@@ -0,0 +1,45 @@
+use crate::hygiene::Hygiene;
+use crate::xform::ChangeLt;
+
+/// Returns a vector of ids representing the function arguments.
+/// Prefers to reuse the names given by the user, if possible.
+pub fn input_ids(hygiene: &Hygiene, sig: &syn::Signature, skip: usize) -> Vec<syn::Ident> {
+    sig.inputs
+        .iter()
+        .skip(skip)
+        .zip(0..)
+        .map(|(input, index)| {
+            if let syn::FnArg::Typed(typed) = input {
+                if let syn::Pat::Ident(ident) = &*typed.pat {
+                    return ident.ident.clone();
+                }
+            }
+
+            hygiene.ident(&format!("input{index}"))
+        })
+        .collect()
+}
+
+pub fn input_tys(sig: &syn::Signature, skip: usize) -> syn::Result<Vec<&syn::Type>> {
+    sig.inputs
+        .iter()
+        .skip(skip)
+        .map(|input| {
+            if let syn::FnArg::Typed(typed) = input {
+                Ok(&*typed.ty)
+            } else {
+                Err(syn::Error::new_spanned(input, "unexpected receiver"))
+            }
+        })
+        .collect()
+}
+
+pub fn output_ty(db_lt: Option<&syn::Lifetime>, sig: &syn::Signature) -> syn::Result<syn::Type> {
+    match &sig.output {
+        syn::ReturnType::Default => Ok(parse_quote!(())),
+        syn::ReturnType::Type(_, ty) => match db_lt {
+            Some(db_lt) => Ok(ChangeLt::elided_to(db_lt).in_type(ty)),
+            None => Ok(syn::Type::clone(ty)),
+        },
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/hygiene.rs b/crates/salsa/components/salsa-macros/src/hygiene.rs
new file mode 100644
index 000000000..a01c1bc6f
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/hygiene.rs
@@ -0,0 +1,64 @@
+use std::collections::HashSet;
+
+use quote::ToTokens;
+
+pub struct Hygiene {
+    user_tokens: HashSet<String>,
+}
+
+impl Hygiene {
+    pub fn from1(tokens: &proc_macro::TokenStream) -> Self {
+        let mut user_tokens = HashSet::new();
+        push_idents1(tokens.clone(), &mut user_tokens);
+        Self { user_tokens }
+    }
+
+    pub fn from2(tokens: &impl ToTokens) -> Self {
+        let mut user_tokens = HashSet::new();
+        push_idents2(tokens.to_token_stream(), &mut user_tokens);
+        Self { user_tokens }
+    }
+}
+
+fn push_idents1(input: proc_macro::TokenStream, user_tokens: &mut HashSet<String>) {
+    input.into_iter().for_each(|token| match token {
+        proc_macro::TokenTree::Group(g) => {
+            push_idents1(g.stream(), user_tokens);
+        }
+        proc_macro::TokenTree::Ident(ident) => {
+            user_tokens.insert(ident.to_string());
+        }
+        proc_macro::TokenTree::Punct(_) => (),
+        proc_macro::TokenTree::Literal(_) => (),
+    })
+}
+
+fn push_idents2(input: proc_macro2::TokenStream, user_tokens: &mut HashSet<String>) {
+    input.into_iter().for_each(|token| match token {
+        proc_macro2::TokenTree::Group(g) => {
+            push_idents2(g.stream(), user_tokens);
+        }
+        proc_macro2::TokenTree::Ident(ident) => {
+            user_tokens.insert(ident.to_string());
+        }
+        proc_macro2::TokenTree::Punct(_) => (),
+        proc_macro2::TokenTree::Literal(_) => (),
+    })
+}
+
+impl Hygiene {
+    /// Generates an identifier similar to `text` but
+    /// distinct from any identifiers that appear in the user's
+    /// code.
+    pub(crate) fn ident(&self, text: &str) -> syn::Ident {
+        // Make the default be `foo_` rather than `foo` -- this helps detect
+        // cases where people wrote `foo` instead of `#foo` or `$foo` in the generated code.
+        let mut buffer = format!("{text}_");
+
+        while self.user_tokens.contains(&buffer) {
+            buffer.push('_');
+        }
+
+        syn::Ident::new(&buffer, proc_macro2::Span::call_site())
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/input.rs b/crates/salsa/components/salsa-macros/src/input.rs
new file mode 100644
index 000000000..51410da4d
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/input.rs
@@ -0,0 +1,145 @@
+use proc_macro2::TokenStream;
+
+use crate::hygiene::Hygiene;
+use crate::options::Options;
+use crate::salsa_struct::{SalsaStruct, SalsaStructAllowedOptions};
+use crate::token_stream_with_error;
+
+/// For an entity struct `Foo` with fields `f1: T1, ..., fN: TN`, we generate...
+///
+/// * the "id struct" `struct Foo(salsa::Id)`
+/// * the entity ingredient, which maps the id fields to the `Id`
+/// * for each value field, a function ingredient
+pub(crate) fn input(
+    args: proc_macro::TokenStream,
+    input: proc_macro::TokenStream,
+) -> proc_macro::TokenStream {
+    let args = syn::parse_macro_input!(args as InputArgs);
+    let hygiene = Hygiene::from1(&input);
+    let struct_item = parse_macro_input!(input as syn::ItemStruct);
+    let m = Macro {
+        hygiene,
+        args,
+        struct_item,
+    };
+    match m.try_macro() {
+        Ok(v) => v.into(),
+        Err(e) => token_stream_with_error(input, e),
+    }
+}
+
+type InputArgs = Options<InputStruct>;
+
+struct InputStruct;
+
+impl crate::options::AllowedOptions for InputStruct {
+    const RETURNS: bool = false;
+
+    const SPECIFY: bool = false;
+
+    const NO_EQ: bool = false;
+
+    const DEBUG: bool = true;
+
+    const NO_LIFETIME: bool = false;
+
+    const NO_CLONE: bool = false;
+
+    const SINGLETON: bool = true;
+
+    const DATA: bool = true;
+
+    const DB: bool = false;
+
+    const CYCLE_FN: bool = false;
+
+    const CYCLE_INITIAL: bool = false;
+
+    const CYCLE_RESULT: bool = false;
+
+    const LRU: bool = false;
+
+    const CONSTRUCTOR_NAME: bool = true;
+
+    const ID: bool = false;
+}
+
+impl SalsaStructAllowedOptions for InputStruct {
+    const KIND: &'static str = "input";
+
+    const ALLOW_TRACKED: bool = false;
+
+    const HAS_LIFETIME: bool = false;
+
+    const ELIDABLE_LIFETIME: bool = false;
+
+    const ALLOW_DEFAULT: bool = true;
+}
+
+struct Macro {
+    hygiene: Hygiene,
+    args: InputArgs,
+    struct_item: syn::ItemStruct,
+}
+
+impl Macro {
+    #[allow(non_snake_case)]
+    fn try_macro(&self) -> syn::Result<TokenStream> {
+        let salsa_struct = SalsaStruct::new(&self.struct_item, &self.args)?;
+
+        let attrs = &self.struct_item.attrs;
+        let vis = &self.struct_item.vis;
+        let struct_ident = &self.struct_item.ident;
+        let new_fn = salsa_struct.constructor_name();
+        let field_ids = salsa_struct.field_ids();
+        let field_indices = salsa_struct.field_indices();
+        let num_fields = salsa_struct.num_fields();
+        let field_vis = salsa_struct.field_vis();
+        let field_getter_ids = salsa_struct.field_getter_ids();
+        let field_setter_ids = salsa_struct.field_setter_ids();
+        let required_fields = salsa_struct.required_fields();
+        let field_options = salsa_struct.field_options();
+        let field_tys = salsa_struct.field_tys();
+        let field_durability_ids = salsa_struct.field_durability_ids();
+        let is_singleton = self.args.singleton.is_some();
+        let generate_debug_impl = salsa_struct.generate_debug_impl();
+
+        let zalsa = self.hygiene.ident("zalsa");
+        let zalsa_struct = self.hygiene.ident("zalsa_struct");
+        let Configuration = self.hygiene.ident("Configuration");
+        let Builder = self.hygiene.ident("Builder");
+        let CACHE = self.hygiene.ident("CACHE");
+        let Db = self.hygiene.ident("Db");
+
+        Ok(crate::debug::dump_tokens(
+            struct_ident,
+            quote! {
+                salsa::plumbing::setup_input_struct!(
+                    attrs: [#(#attrs),*],
+                    vis: #vis,
+                    Struct: #struct_ident,
+                    new_fn: #new_fn,
+                    field_options: [#(#field_options),*],
+                    field_ids: [#(#field_ids),*],
+                    field_getters: [#(#field_vis #field_getter_ids),*],
+                    field_setters: [#(#field_vis #field_setter_ids),*],
+                    field_tys: [#(#field_tys),*],
+                    field_indices: [#(#field_indices),*],
+                    required_fields: [#(#required_fields),*],
+                    field_durability_ids: [#(#field_durability_ids),*],
+                    num_fields: #num_fields,
+                    is_singleton: #is_singleton,
+                    generate_debug_impl: #generate_debug_impl,
+                    unused_names: [
+                        #zalsa,
+                        #zalsa_struct,
+                        #Configuration,
+                        #Builder,
+                        #CACHE,
+                        #Db,
+                    ]
+                );
+            },
+        ))
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/interned.rs b/crates/salsa/components/salsa-macros/src/interned.rs
new file mode 100644
index 000000000..b07a11aa5
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/interned.rs
@@ -0,0 +1,163 @@
+use proc_macro2::TokenStream;
+
+use crate::hygiene::Hygiene;
+use crate::options::Options;
+use crate::salsa_struct::{SalsaStruct, SalsaStructAllowedOptions};
+use crate::{db_lifetime, token_stream_with_error};
+
+/// For an entity struct `Foo` with fields `f1: T1, ..., fN: TN`, we generate...
+///
+/// * the "id struct" `struct Foo(salsa::Id)`
+/// * the entity ingredient, which maps the id fields to the `Id`
+/// * for each value field, a function ingredient
+pub(crate) fn interned(
+    args: proc_macro::TokenStream,
+    input: proc_macro::TokenStream,
+) -> proc_macro::TokenStream {
+    let args = syn::parse_macro_input!(args as InternedArgs);
+    let hygiene = Hygiene::from1(&input);
+    let struct_item = parse_macro_input!(input as syn::ItemStruct);
+    let m = Macro {
+        hygiene,
+        args,
+        struct_item,
+    };
+    match m.try_macro() {
+        Ok(v) => v.into(),
+        Err(e) => token_stream_with_error(input, e),
+    }
+}
+
+type InternedArgs = Options<InternedStruct>;
+
+struct InternedStruct;
+
+impl crate::options::AllowedOptions for InternedStruct {
+    const RETURNS: bool = false;
+
+    const SPECIFY: bool = false;
+
+    const NO_EQ: bool = false;
+
+    const DEBUG: bool = true;
+
+    const NO_LIFETIME: bool = true;
+
+    const NO_CLONE: bool = false;
+
+    const SINGLETON: bool = true;
+
+    const DATA: bool = true;
+
+    const DB: bool = false;
+
+    const CYCLE_FN: bool = false;
+
+    const CYCLE_INITIAL: bool = false;
+
+    const CYCLE_RESULT: bool = false;
+
+    const LRU: bool = false;
+
+    const CONSTRUCTOR_NAME: bool = true;
+
+    const ID: bool = true;
+}
+
+impl SalsaStructAllowedOptions for InternedStruct {
+    const KIND: &'static str = "interned";
+
+    const ALLOW_TRACKED: bool = false;
+
+    const HAS_LIFETIME: bool = true;
+
+    const ELIDABLE_LIFETIME: bool = true;
+
+    const ALLOW_DEFAULT: bool = false;
+}
+
+struct Macro {
+    hygiene: Hygiene,
+    args: InternedArgs,
+    struct_item: syn::ItemStruct,
+}
+
+impl Macro {
+    #[allow(non_snake_case)]
+    fn try_macro(&self) -> syn::Result<TokenStream> {
+        let salsa_struct = SalsaStruct::new(&self.struct_item, &self.args)?;
+
+        let attrs = &self.struct_item.attrs;
+        let vis = &self.struct_item.vis;
+        let struct_ident = &self.struct_item.ident;
+        let struct_data_ident = format_ident!("{}Data", struct_ident);
+        let db_lt = db_lifetime::db_lifetime(&self.struct_item.generics);
+        let new_fn = salsa_struct.constructor_name();
+        let field_ids = salsa_struct.field_ids();
+        let field_indices = salsa_struct.field_indices();
+        let num_fields = salsa_struct.num_fields();
+        let field_vis = salsa_struct.field_vis();
+        let field_getter_ids = salsa_struct.field_getter_ids();
+        let field_options = salsa_struct.field_options();
+        let field_tys = salsa_struct.field_tys();
+        let field_indexed_tys = salsa_struct.field_indexed_tys();
+        let generate_debug_impl = salsa_struct.generate_debug_impl();
+        let has_lifetime = salsa_struct.generate_lifetime();
+        let id = salsa_struct.id();
+
+        let (db_lt_arg, cfg, interior_lt) = if has_lifetime {
+            (
+                Some(db_lt.clone()),
+                quote!(#struct_ident<'static>),
+                db_lt.clone(),
+            )
+        } else {
+            let span = syn::spanned::Spanned::span(&self.struct_item.generics);
+            let static_lifetime = syn::Lifetime {
+                apostrophe: span,
+                ident: syn::Ident::new("static", span),
+            };
+
+            (None, quote!(#struct_ident), static_lifetime)
+        };
+
+        let zalsa = self.hygiene.ident("zalsa");
+        let zalsa_struct = self.hygiene.ident("zalsa_struct");
+        let Configuration = self.hygiene.ident("Configuration");
+        let CACHE = self.hygiene.ident("CACHE");
+        let Db = self.hygiene.ident("Db");
+
+        Ok(crate::debug::dump_tokens(
+            struct_ident,
+            quote! {
+                salsa::plumbing::setup_interned_struct!(
+                    attrs: [#(#attrs),*],
+                    vis: #vis,
+                    Struct: #struct_ident,
+                    StructData: #struct_data_ident,
+                    StructWithStatic: #cfg,
+                    db_lt: #db_lt,
+                    db_lt_arg: #db_lt_arg,
+                    id: #id,
+                    interior_lt: #interior_lt,
+                    new_fn: #new_fn,
+                    field_options: [#(#field_options),*],
+                    field_ids: [#(#field_ids),*],
+                    field_getters: [#(#field_vis #field_getter_ids),*],
+                    field_tys: [#(#field_tys),*],
+                    field_indices: [#(#field_indices),*],
+                    field_indexed_tys: [#(#field_indexed_tys),*],
+                    num_fields: #num_fields,
+                    generate_debug_impl: #generate_debug_impl,
+                    unused_names: [
+                        #zalsa,
+                        #zalsa_struct,
+                        #Configuration,
+                        #CACHE,
+                        #Db,
+                    ]
+                );
+            },
+        ))
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/lib.rs b/crates/salsa/components/salsa-macros/src/lib.rs
new file mode 100644
index 000000000..2d0a8c7d5
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/lib.rs
@@ -0,0 +1,95 @@
+//! This crate provides salsa's macros and attributes.
+
+#![recursion_limit = "256"]
+
+#[macro_use]
+extern crate quote;
+
+use proc_macro::TokenStream;
+
+macro_rules! parse_quote {
+    ($($inp:tt)*) => {
+        {
+            let tt = quote!{$($inp)*};
+            syn::parse2(tt.clone()).unwrap_or_else(|err| {
+                panic!("failed to parse `{}` at {}:{}:{}: {}", tt, file!(), line!(), column!(), err)
+            })
+        }
+    }
+}
+
+/// Similar to `syn::parse_macro_input`, however, when a parse error is encountered, it will return
+/// the input token stream in addition to the error. This will make it so that rust-analyzer can work
+/// with incomplete code.
+macro_rules! parse_macro_input {
+    ($tokenstream:ident as $ty:ty) => {
+        match syn::parse::<$ty>($tokenstream.clone()) {
+            Ok(data) => data,
+            Err(err) => {
+                return $crate::token_stream_with_error($tokenstream, err);
+            }
+        }
+    };
+}
+
+mod accumulator;
+mod db;
+mod db_lifetime;
+mod debug;
+mod fn_util;
+mod hygiene;
+mod input;
+mod interned;
+mod options;
+mod salsa_struct;
+mod supertype;
+mod tracked;
+mod tracked_fn;
+mod tracked_impl;
+mod tracked_struct;
+mod update;
+mod xform;
+
+#[proc_macro_attribute]
+pub fn accumulator(args: TokenStream, input: TokenStream) -> TokenStream {
+    accumulator::accumulator(args, input)
+}
+
+#[proc_macro_attribute]
+pub fn db(args: TokenStream, input: TokenStream) -> TokenStream {
+    db::db(args, input)
+}
+
+#[proc_macro_attribute]
+pub fn interned(args: TokenStream, input: TokenStream) -> TokenStream {
+    interned::interned(args, input)
+}
+
+#[proc_macro_derive(Supertype)]
+pub fn supertype(input: TokenStream) -> TokenStream {
+    supertype::supertype(input)
+}
+
+#[proc_macro_attribute]
+pub fn input(args: TokenStream, input: TokenStream) -> TokenStream {
+    input::input(args, input)
+}
+
+#[proc_macro_attribute]
+pub fn tracked(args: TokenStream, input: TokenStream) -> TokenStream {
+    tracked::tracked(args, input)
+}
+
+#[proc_macro_derive(Update)]
+pub fn update(input: TokenStream) -> TokenStream {
+    let item = parse_macro_input!(input as syn::DeriveInput);
+    match update::update_derive(item) {
+        Ok(tokens) => tokens.into(),
+        Err(error) => token_stream_with_error(input, error),
+    }
+}
+
+pub(crate) fn token_stream_with_error(mut tokens: TokenStream, error: syn::Error) -> TokenStream {
+    tokens.extend(TokenStream::from(error.into_compile_error()));
+    tokens
+}
diff --git a/crates/salsa/components/salsa-macros/src/options.rs b/crates/salsa/components/salsa-macros/src/options.rs
new file mode 100644
index 000000000..b4d9e08c0
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/options.rs
@@ -0,0 +1,375 @@
+use std::marker::PhantomData;
+
+use syn::ext::IdentExt;
+use syn::parenthesized;
+use syn::spanned::Spanned;
+
+/// "Options" are flags that can be supplied to the various salsa related
+/// macros. They are listed like `(ref, no_eq, foo=bar)` etc. The commas
+/// are required and trailing commas are permitted. The options accepted
+/// for any particular location are configured via the `AllowedOptions`
+/// trait.
+#[derive(Debug)]
+pub(crate) struct Options<A: AllowedOptions> {
+    /// The `returns` option is used to configure the "return mode" for the field/function.
+    /// This may be one of `copy`, `clone`, `ref`, `as_ref`, `as_deref`.
+    ///
+    /// If this is `Some`, the value is the ident representing the selected mode.
+    pub returns: Option<syn::Ident>,
+
+    /// The `no_eq` option is used to signal that a given field does not implement
+    /// the `Eq` trait and cannot be compared for equality.
+    ///
+    /// If this is `Some`, the value is the `no_eq` identifier.
+    pub no_eq: Option<syn::Ident>,
+
+    /// Signal we should generate a `Debug` impl.
+    ///
+    /// If this is `Some`, the value is the `debug` identifier.
+    pub debug: Option<syn::Ident>,
+
+    /// Signal we should not include the `'db` lifetime.
+    ///
+    /// If this is `Some`, the value is the `no_lifetime` identifier.
+    pub no_lifetime: Option<syn::Ident>,
+
+    /// Signal we should not generate a `Clone` impl.
+    ///
+    /// If this is `Some`, the value is the `no_clone` identifier.
+    pub no_clone: Option<syn::Ident>,
+
+    /// The `singleton` option is used on input with only one field
+    /// It allows the creation of convenient methods
+    pub singleton: Option<syn::Ident>,
+
+    /// The `specify` option is used to signal that a tracked function can
+    /// have its value externally specified (at least some of the time).
+    ///
+    /// If this is `Some`, the value is the `specify` identifier.
+    pub specify: Option<syn::Ident>,
+
+    /// The `db = <path>` option is used to indicate the db.
+    ///
+    /// If this is `Some`, the value is the `<path>`.
+    pub db_path: Option<syn::Path>,
+
+    /// The `cycle_fn = <path>` option is used to indicate the cycle recovery function.
+    ///
+    /// If this is `Some`, the value is the `<path>`.
+    pub cycle_fn: Option<syn::Path>,
+
+    /// The `cycle_initial = <path>` option is the initial value for cycle iteration.
+    ///
+    /// If this is `Some`, the value is the `<path>`.
+    pub cycle_initial: Option<syn::Path>,
+
+    /// The `cycle_result = <path>` option is the result for non-fixpoint cycle.
+    ///
+    /// If this is `Some`, the value is the `<path>`.
+    pub cycle_result: Option<syn::Expr>,
+
+    /// The `data = <ident>` option is used to define the name of the data type for an interned
+    /// struct.
+    ///
+    /// If this is `Some`, the value is the `<ident>`.
+    pub data: Option<syn::Ident>,
+
+    /// The `lru = <usize>` option is used to set the lru capacity for a tracked function.
+    ///
+    /// If this is `Some`, the value is the `<usize>`.
+    pub lru: Option<usize>,
+
+    /// The `constructor = <ident>` option lets the user specify the name of
+    /// the constructor of a salsa struct.
+    ///
+    /// If this is `Some`, the value is the `<ident>`.
+    pub constructor_name: Option<syn::Ident>,
+
+    /// The `id = <path>` option is used to set a custom ID for interrned structs.
+    ///
+    /// The ID must implement `salsa::plumbing::AsId` and `salsa::plumbing::FromId`.
+    /// If this is `Some`, the value is the `<ident>`.
+    pub id: Option<syn::Path>,
+
+    /// Remember the `A` parameter, which plays no role after parsing.
+    phantom: PhantomData<A>,
+}
+
+impl<A: AllowedOptions> Default for Options<A> {
+    fn default() -> Self {
+        Self {
+            returns: Default::default(),
+            specify: Default::default(),
+            no_eq: Default::default(),
+            debug: Default::default(),
+            no_lifetime: Default::default(),
+            no_clone: Default::default(),
+            db_path: Default::default(),
+            cycle_fn: Default::default(),
+            cycle_initial: Default::default(),
+            cycle_result: Default::default(),
+            data: Default::default(),
+            constructor_name: Default::default(),
+            phantom: Default::default(),
+            lru: Default::default(),
+            singleton: Default::default(),
+            id: Default::default(),
+        }
+    }
+}
+
+/// These flags determine which options are allowed in a given context
+pub(crate) trait AllowedOptions {
+    const RETURNS: bool;
+    const SPECIFY: bool;
+    const NO_EQ: bool;
+    const DEBUG: bool;
+    const NO_LIFETIME: bool;
+    const NO_CLONE: bool;
+    const SINGLETON: bool;
+    const DATA: bool;
+    const DB: bool;
+    const CYCLE_FN: bool;
+    const CYCLE_INITIAL: bool;
+    const CYCLE_RESULT: bool;
+    const LRU: bool;
+    const CONSTRUCTOR_NAME: bool;
+    const ID: bool;
+}
+
+type Equals = syn::Token![=];
+type Comma = syn::Token![,];
+
+impl<A: AllowedOptions> syn::parse::Parse for Options<A> {
+    fn parse(input: syn::parse::ParseStream) -> syn::Result<Self> {
+        let mut options = Options::default();
+
+        while !input.is_empty() {
+            let ident: syn::Ident = syn::Ident::parse_any(input)?;
+            if ident == "returns" {
+                let content;
+                parenthesized!(content in input);
+                let mode = syn::Ident::parse_any(&content)?;
+                if A::RETURNS {
+                    if let Some(old) = options.returns.replace(mode) {
+                        return Err(syn::Error::new(
+                            old.span(),
+                            "option `returns` provided twice",
+                        ));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`returns` option not allowed here",
+                    ));
+                }
+            } else if ident == "no_eq" {
+                if A::NO_EQ {
+                    if let Some(old) = options.no_eq.replace(ident) {
+                        return Err(syn::Error::new(old.span(), "option `no_eq` provided twice"));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`no_eq` option not allowed here",
+                    ));
+                }
+            } else if ident == "debug" {
+                if A::DEBUG {
+                    if let Some(old) = options.debug.replace(ident) {
+                        return Err(syn::Error::new(old.span(), "option `debug` provided twice"));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`debug` option not allowed here",
+                    ));
+                }
+            } else if ident == "no_lifetime" {
+                if A::NO_LIFETIME {
+                    if let Some(old) = options.no_lifetime.replace(ident) {
+                        return Err(syn::Error::new(
+                            old.span(),
+                            "option `no_lifetime` provided twice",
+                        ));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`no_lifetime` option not allowed here",
+                    ));
+                }
+            } else if ident == "no_clone" {
+                if A::NO_CLONE {
+                    if let Some(old) = options.no_clone.replace(ident) {
+                        return Err(syn::Error::new(
+                            old.span(),
+                            "option `no_clone` provided twice",
+                        ));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`no_clone` option not allowed here",
+                    ));
+                }
+            } else if ident == "singleton" {
+                if A::SINGLETON {
+                    if let Some(old) = options.singleton.replace(ident) {
+                        return Err(syn::Error::new(
+                            old.span(),
+                            "option `singleton` provided twice",
+                        ));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`singleton` option not allowed here",
+                    ));
+                }
+            } else if ident == "specify" {
+                if A::SPECIFY {
+                    if let Some(old) = options.specify.replace(ident) {
+                        return Err(syn::Error::new(
+                            old.span(),
+                            "option `specify` provided twice",
+                        ));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`specify` option not allowed here",
+                    ));
+                }
+            } else if ident == "db" {
+                if A::DB {
+                    let _eq = Equals::parse(input)?;
+                    let path = syn::Path::parse(input)?;
+                    if let Some(old) = options.db_path.replace(path) {
+                        return Err(syn::Error::new(old.span(), "option `db` provided twice"));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`db` option not allowed here",
+                    ));
+                }
+            } else if ident == "cycle_fn" {
+                if A::CYCLE_FN {
+                    let _eq = Equals::parse(input)?;
+                    let path = syn::Path::parse(input)?;
+                    if let Some(old) = options.cycle_fn.replace(path) {
+                        return Err(syn::Error::new(
+                            old.span(),
+                            "option `cycle_fn` provided twice",
+                        ));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`cycle_fn` option not allowed here",
+                    ));
+                }
+            } else if ident == "cycle_initial" {
+                if A::CYCLE_INITIAL {
+                    let _eq = Equals::parse(input)?;
+                    let path = syn::Path::parse(input)?;
+                    if let Some(old) = options.cycle_initial.replace(path) {
+                        return Err(syn::Error::new(
+                            old.span(),
+                            "option `cycle_initial` provided twice",
+                        ));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`cycle_initial` option not allowed here",
+                    ));
+                }
+            } else if ident == "cycle_result" {
+                if A::CYCLE_RESULT {
+                    let _eq = Equals::parse(input)?;
+                    let expr = syn::Expr::parse(input)?;
+                    if let Some(old) = options.cycle_result.replace(expr) {
+                        return Err(syn::Error::new(
+                            old.span(),
+                            "option `cycle_result` provided twice",
+                        ));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`cycle_result` option not allowed here",
+                    ));
+                }
+            } else if ident == "data" {
+                if A::DATA {
+                    let _eq = Equals::parse(input)?;
+                    let ident = syn::Ident::parse(input)?;
+                    if let Some(old) = options.data.replace(ident) {
+                        return Err(syn::Error::new(old.span(), "option `data` provided twice"));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`data` option not allowed here",
+                    ));
+                }
+            } else if ident == "lru" {
+                if A::LRU {
+                    let _eq = Equals::parse(input)?;
+                    let lit = syn::LitInt::parse(input)?;
+                    let value = lit.base10_parse::<usize>()?;
+                    if let Some(old) = options.lru.replace(value) {
+                        return Err(syn::Error::new(old.span(), "option `lru` provided twice"));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`lru` option not allowed here",
+                    ));
+                }
+            } else if ident == "constructor" {
+                if A::CONSTRUCTOR_NAME {
+                    let _eq = Equals::parse(input)?;
+                    let ident = syn::Ident::parse(input)?;
+                    if let Some(old) = options.constructor_name.replace(ident) {
+                        return Err(syn::Error::new(
+                            old.span(),
+                            "option `constructor` provided twice",
+                        ));
+                    }
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`constructor` option not allowed here",
+                    ));
+                }
+            } else if ident == "id" {
+                if A::ID {
+                    let _eq = Equals::parse(input)?;
+                    let path = syn::Path::parse(input)?;
+                    options.id = Some(path);
+                } else {
+                    return Err(syn::Error::new(
+                        ident.span(),
+                        "`id` option not allowed here",
+                    ));
+                }
+            } else {
+                return Err(syn::Error::new(
+                    ident.span(),
+                    format!("unrecognized option `{ident}`"),
+                ));
+            }
+
+            if input.is_empty() {
+                break;
+            }
+
+            let _comma = Comma::parse(input)?;
+        }
+
+        Ok(options)
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/salsa_struct.rs b/crates/salsa/components/salsa-macros/src/salsa_struct.rs
new file mode 100644
index 000000000..bec4121db
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/salsa_struct.rs
@@ -0,0 +1,422 @@
+//! Common code for `#[salsa::interned]`, `#[salsa::input]`, and
+//! `#[salsa::tracked]` decorators.
+//!
+//! Example of usage:
+//!
+//! ```rust,ignore
+//! #[salsa::interned(jar = Jar0, data = TyData0)]
+//! #[derive(Eq, PartialEq, Hash, Debug, Clone)]
+//! struct Ty0 {
+//!    field1: Type1,
+//!    #[ref] field2: Type2,
+//!    ...
+//! }
+//! ```
+//! For an interned or entity struct `Foo`, we generate:
+//!
+//! * the actual struct: `struct Foo(Id);`
+//! * constructor function: `impl Foo { fn new(db: &crate::Db, field1: Type1, ..., fieldN: TypeN) -> Self { ... } }
+//! * field accessors: `impl Foo { fn field1(&self) -> Type1 { self.field1.clone() } }`
+//!     * if the field is `ref`, we generate `fn field1(&self) -> &Type1`
+//!
+//! Only if there are no `ref` fields:
+//!
+//! * the data type: `struct FooData { field1: Type1, ... }` or `enum FooData { ... }`
+//! * data method `impl Foo { fn data(&self, db: &dyn crate::Db) -> FooData { FooData { f: self.f(db), ... } } }`
+//!     * this could be optimized, particularly for interned fields
+
+use proc_macro2::{Ident, Literal, Span, TokenStream};
+use syn::{ext::IdentExt, spanned::Spanned};
+
+use crate::db_lifetime;
+use crate::options::{AllowedOptions, Options};
+
+pub(crate) struct SalsaStruct<'s, A: SalsaStructAllowedOptions> {
+    struct_item: &'s syn::ItemStruct,
+    args: &'s Options<A>,
+    fields: Vec<SalsaField<'s>>,
+}
+
+pub(crate) trait SalsaStructAllowedOptions: AllowedOptions {
+    /// The kind of struct (e.g., interned, input, tracked).
+    const KIND: &'static str;
+
+    /// Are `#[tracked]` fields allowed?
+    const ALLOW_TRACKED: bool;
+
+    /// Does this kind of struct have a `'db` lifetime?
+    const HAS_LIFETIME: bool;
+
+    /// Can this struct elide the `'db` lifetime?
+    const ELIDABLE_LIFETIME: bool;
+
+    /// Are `#[default]` fields allowed?
+    const ALLOW_DEFAULT: bool;
+}
+
+pub(crate) struct SalsaField<'s> {
+    field: &'s syn::Field,
+
+    pub(crate) has_tracked_attr: bool,
+    pub(crate) has_default_attr: bool,
+    pub(crate) returns: syn::Ident,
+    pub(crate) has_no_eq_attr: bool,
+    get_name: syn::Ident,
+    set_name: syn::Ident,
+}
+
+const BANNED_FIELD_NAMES: &[&str] = &["from", "new"];
+const ALLOWED_RETURN_MODES: &[&str] = &["copy", "clone", "ref", "deref", "as_ref", "as_deref"];
+
+#[allow(clippy::type_complexity)]
+pub(crate) const FIELD_OPTION_ATTRIBUTES: &[(&str, fn(&syn::Attribute, &mut SalsaField))] = &[
+    ("tracked", |_, ef| ef.has_tracked_attr = true),
+    ("default", |_, ef| ef.has_default_attr = true),
+    ("returns", |attr, ef| {
+        ef.returns = attr.parse_args_with(syn::Ident::parse_any).unwrap();
+    }),
+    ("no_eq", |_, ef| ef.has_no_eq_attr = true),
+    ("get", |attr, ef| {
+        ef.get_name = attr.parse_args().unwrap();
+    }),
+    ("set", |attr, ef| {
+        ef.set_name = attr.parse_args().unwrap();
+    }),
+];
+
+impl<'s, A> SalsaStruct<'s, A>
+where
+    A: SalsaStructAllowedOptions,
+{
+    pub fn new(struct_item: &'s syn::ItemStruct, args: &'s Options<A>) -> syn::Result<Self> {
+        let syn::Fields::Named(n) = &struct_item.fields else {
+            return Err(syn::Error::new_spanned(
+                &struct_item.ident,
+                "must have named fields for a struct",
+            ));
+        };
+
+        let fields = n
+            .named
+            .iter()
+            .map(SalsaField::new)
+            .collect::<syn::Result<_>>()?;
+
+        let this = Self {
+            struct_item,
+            args,
+            fields,
+        };
+
+        this.maybe_disallow_tracked_fields()?;
+        this.maybe_disallow_default_fields()?;
+
+        this.check_generics()?;
+
+        Ok(this)
+    }
+
+    /// Returns the `constructor_name` in `Options` if it is `Some`, else `new`
+    pub(crate) fn constructor_name(&self) -> syn::Ident {
+        match self.args.constructor_name.clone() {
+            Some(name) => name,
+            None => Ident::new("new", self.struct_item.ident.span()),
+        }
+    }
+
+    /// Returns the `id` in `Options` if it is `Some`, else `salsa::Id`.
+    pub(crate) fn id(&self) -> syn::Path {
+        match &self.args.id {
+            Some(id) => id.clone(),
+            None => parse_quote!(salsa::Id),
+        }
+    }
+
+    /// Disallow `#[tracked]` attributes on the fields of this struct.
+    ///
+    /// If an `#[tracked]` field is found, return an error.
+    ///
+    /// # Parameters
+    ///
+    /// * `kind`, the attribute name (e.g., `input` or `interned`)
+    fn maybe_disallow_tracked_fields(&self) -> syn::Result<()> {
+        if A::ALLOW_TRACKED {
+            return Ok(());
+        }
+
+        // Check if any field has the `#[tracked]` attribute.
+        for ef in &self.fields {
+            if ef.has_tracked_attr {
+                return Err(syn::Error::new_spanned(
+                    ef.field,
+                    format!("`#[tracked]` cannot be used with `#[salsa::{}]`", A::KIND),
+                ));
+            }
+        }
+
+        Ok(())
+    }
+
+    /// Disallow `#[default]` attributes on the fields of this struct.
+    ///
+    /// If an `#[default]` field is found, return an error.
+    ///
+    /// # Parameters
+    ///
+    /// * `kind`, the attribute name (e.g., `input` or `interned`)
+    fn maybe_disallow_default_fields(&self) -> syn::Result<()> {
+        if A::ALLOW_DEFAULT {
+            return Ok(());
+        }
+
+        // Check if any field has the `#[default]` attribute.
+        for ef in &self.fields {
+            if ef.has_default_attr {
+                return Err(syn::Error::new_spanned(
+                    ef.field,
+                    format!("`#[default]` cannot be used with `#[salsa::{}]`", A::KIND),
+                ));
+            }
+        }
+
+        Ok(())
+    }
+
+    /// Check that the generic parameters look as expected for this kind of struct.
+    fn check_generics(&self) -> syn::Result<()> {
+        if A::HAS_LIFETIME {
+            if !A::ELIDABLE_LIFETIME {
+                db_lifetime::require_db_lifetime(&self.struct_item.generics)
+            } else {
+                Ok(())
+            }
+        } else {
+            db_lifetime::require_no_generics(&self.struct_item.generics)
+        }
+    }
+
+    pub(crate) fn field_ids(&self) -> Vec<&syn::Ident> {
+        self.fields
+            .iter()
+            .map(|f| f.field.ident.as_ref().unwrap())
+            .collect()
+    }
+
+    pub(crate) fn tracked_ids(&self) -> Vec<&syn::Ident> {
+        self.tracked_fields_iter()
+            .map(|(_, f)| f.field.ident.as_ref().unwrap())
+            .collect()
+    }
+
+    pub(crate) fn field_indices(&self) -> Vec<Literal> {
+        (0..self.fields.len())
+            .map(Literal::usize_unsuffixed)
+            .collect()
+    }
+
+    pub(crate) fn tracked_field_indices(&self) -> Vec<Literal> {
+        self.tracked_fields_iter()
+            .map(|(index, _)| Literal::usize_unsuffixed(index))
+            .collect()
+    }
+
+    pub(crate) fn untracked_field_indices(&self) -> Vec<Literal> {
+        self.untracked_fields_iter()
+            .map(|(index, _)| Literal::usize_unsuffixed(index))
+            .collect()
+    }
+
+    pub(crate) fn num_fields(&self) -> Literal {
+        Literal::usize_unsuffixed(self.fields.len())
+    }
+
+    pub(crate) fn num_tracked_fields(&self) -> Literal {
+        Literal::usize_unsuffixed(self.tracked_fields_iter().count())
+    }
+
+    pub(crate) fn required_fields(&self) -> Vec<TokenStream> {
+        self.fields
+            .iter()
+            .filter_map(|f| {
+                if f.has_default_attr {
+                    None
+                } else {
+                    let ident = f.field.ident.as_ref().unwrap();
+                    let ty = &f.field.ty;
+                    Some(quote!(#ident #ty))
+                }
+            })
+            .collect()
+    }
+
+    pub(crate) fn field_vis(&self) -> Vec<&syn::Visibility> {
+        self.fields.iter().map(|f| &f.field.vis).collect()
+    }
+
+    pub(crate) fn tracked_vis(&self) -> Vec<&syn::Visibility> {
+        self.tracked_fields_iter()
+            .map(|(_, f)| &f.field.vis)
+            .collect()
+    }
+
+    pub(crate) fn untracked_vis(&self) -> Vec<&syn::Visibility> {
+        self.untracked_fields_iter()
+            .map(|(_, f)| &f.field.vis)
+            .collect()
+    }
+
+    pub(crate) fn field_getter_ids(&self) -> Vec<&syn::Ident> {
+        self.fields.iter().map(|f| &f.get_name).collect()
+    }
+
+    pub(crate) fn tracked_getter_ids(&self) -> Vec<&syn::Ident> {
+        self.tracked_fields_iter()
+            .map(|(_, f)| &f.get_name)
+            .collect()
+    }
+
+    pub(crate) fn untracked_getter_ids(&self) -> Vec<&syn::Ident> {
+        self.untracked_fields_iter()
+            .map(|(_, f)| &f.get_name)
+            .collect()
+    }
+
+    pub(crate) fn field_setter_ids(&self) -> Vec<&syn::Ident> {
+        self.fields.iter().map(|f| &f.set_name).collect()
+    }
+
+    pub(crate) fn field_durability_ids(&self) -> Vec<syn::Ident> {
+        self.fields
+            .iter()
+            .map(|f| quote::format_ident!("{}_durability", f.field.ident.as_ref().unwrap()))
+            .collect()
+    }
+
+    pub(crate) fn field_tys(&self) -> Vec<&syn::Type> {
+        self.fields.iter().map(|f| &f.field.ty).collect()
+    }
+
+    pub(crate) fn tracked_tys(&self) -> Vec<&syn::Type> {
+        self.tracked_fields_iter()
+            .map(|(_, f)| &f.field.ty)
+            .collect()
+    }
+
+    pub(crate) fn untracked_tys(&self) -> Vec<&syn::Type> {
+        self.untracked_fields_iter()
+            .map(|(_, f)| &f.field.ty)
+            .collect()
+    }
+
+    pub(crate) fn field_indexed_tys(&self) -> Vec<syn::Ident> {
+        self.fields
+            .iter()
+            .enumerate()
+            .map(|(i, _)| quote::format_ident!("T{i}"))
+            .collect()
+    }
+
+    pub(crate) fn field_options(&self) -> Vec<TokenStream> {
+        self.fields.iter().map(SalsaField::options).collect()
+    }
+
+    pub(crate) fn tracked_options(&self) -> Vec<TokenStream> {
+        self.tracked_fields_iter()
+            .map(|(_, f)| f.options())
+            .collect()
+    }
+
+    pub(crate) fn untracked_options(&self) -> Vec<TokenStream> {
+        self.untracked_fields_iter()
+            .map(|(_, f)| f.options())
+            .collect()
+    }
+
+    pub fn generate_debug_impl(&self) -> bool {
+        self.args.debug.is_some()
+    }
+
+    pub fn generate_lifetime(&self) -> bool {
+        self.args.no_lifetime.is_none()
+    }
+
+    fn tracked_fields_iter(&self) -> impl Iterator<Item = (usize, &SalsaField<'s>)> {
+        self.fields
+            .iter()
+            .enumerate()
+            .filter(|(_, f)| f.has_tracked_attr)
+    }
+
+    fn untracked_fields_iter(&self) -> impl Iterator<Item = (usize, &SalsaField<'s>)> {
+        self.fields
+            .iter()
+            .enumerate()
+            .filter(|(_, f)| !f.has_tracked_attr)
+    }
+}
+
+impl<'s> SalsaField<'s> {
+    fn new(field: &'s syn::Field) -> syn::Result<Self> {
+        let field_name = field.ident.as_ref().unwrap();
+        let field_name_str = field_name.to_string();
+        if BANNED_FIELD_NAMES.iter().any(|n| *n == field_name_str) {
+            return Err(syn::Error::new(
+                field_name.span(),
+                format!("the field name `{field_name_str}` is disallowed in salsa structs",),
+            ));
+        }
+
+        let get_name = Ident::new(&field_name_str, field_name.span());
+        let set_name = Ident::new(&format!("set_{field_name_str}",), field_name.span());
+        let returns = Ident::new("clone", field.span());
+        let mut result = SalsaField {
+            field,
+            has_tracked_attr: false,
+            returns,
+            has_default_attr: false,
+            has_no_eq_attr: false,
+            get_name,
+            set_name,
+        };
+
+        // Scan the attributes and look for the salsa attributes:
+        for attr in &field.attrs {
+            for (fa, func) in FIELD_OPTION_ATTRIBUTES {
+                if attr.path().is_ident(fa) {
+                    func(attr, &mut result);
+                }
+            }
+        }
+
+        // Validate return mode
+        if !ALLOWED_RETURN_MODES
+            .iter()
+            .any(|mode| mode == &result.returns.to_string())
+        {
+            return Err(syn::Error::new(
+                result.returns.span(),
+                format!("Invalid return mode. Allowed modes are: {ALLOWED_RETURN_MODES:?}"),
+            ));
+        }
+
+        Ok(result)
+    }
+
+    fn options(&self) -> TokenStream {
+        let returns = &self.returns;
+
+        let backdate_ident = if self.has_no_eq_attr {
+            syn::Ident::new("no_backdate", Span::call_site())
+        } else {
+            syn::Ident::new("backdate", Span::call_site())
+        };
+
+        let default_ident = if self.has_default_attr {
+            syn::Ident::new("default", Span::call_site())
+        } else {
+            syn::Ident::new("required", Span::call_site())
+        };
+
+        quote!((#returns, #backdate_ident, #default_ident))
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/supertype.rs b/crates/salsa/components/salsa-macros/src/supertype.rs
new file mode 100644
index 000000000..5b433bd86
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/supertype.rs
@@ -0,0 +1,105 @@
+use proc_macro2::TokenStream;
+
+use crate::token_stream_with_error;
+
+/// The implementation of the `supertype` macro.
+///
+/// For an entity enum `Foo` with variants `Variant1, ..., VariantN`, we generate
+/// mappings between the variants and their corresponding supertypes.
+pub(crate) fn supertype(input: proc_macro::TokenStream) -> proc_macro::TokenStream {
+    let enum_item = parse_macro_input!(input as syn::ItemEnum);
+    match enum_impl(enum_item) {
+        Ok(v) => v.into(),
+        Err(e) => token_stream_with_error(input, e),
+    }
+}
+
+fn enum_impl(enum_item: syn::ItemEnum) -> syn::Result<TokenStream> {
+    let enum_name = enum_item.ident.clone();
+    let mut variant_names = Vec::new();
+    let mut variant_types = Vec::new();
+    if enum_item.variants.is_empty() {
+        return Err(syn::Error::new(
+            enum_item.enum_token.span,
+            "empty enums are not permitted",
+        ));
+    }
+    for variant in &enum_item.variants {
+        let valid = match &variant.fields {
+            syn::Fields::Unnamed(fields) => {
+                variant_names.push(variant.ident.clone());
+                variant_types.push(fields.unnamed[0].ty.clone());
+                fields.unnamed.len() == 1
+            }
+            syn::Fields::Unit | syn::Fields::Named(_) => false,
+        };
+        if !valid {
+            return Err(syn::Error::new(
+                variant.ident.span(),
+                "the only form allowed is `Variant(SalsaStruct)`",
+            ));
+        }
+    }
+
+    let (impl_generics, type_generics, where_clause) = enum_item.generics.split_for_impl();
+
+    let as_id = quote! {
+        impl #impl_generics zalsa::AsId for #enum_name #type_generics
+        #where_clause {
+            #[inline]
+            fn as_id(&self) -> zalsa::Id {
+                match self {
+                    #( Self::#variant_names(__v) => zalsa::AsId::as_id(__v), )*
+                }
+            }
+        }
+    };
+
+    let from_id = quote! {
+        impl #impl_generics zalsa::FromIdWithDb for #enum_name #type_generics
+        #where_clause {
+            #[inline]
+            fn from_id(__id: zalsa::Id, zalsa: &zalsa::Zalsa) -> Self {
+                let __type_id = zalsa.lookup_page_type_id(__id);
+                <Self as zalsa::SalsaStructInDb>::cast(__id, __type_id).expect("invalid enum variant")
+            }
+        }
+    };
+
+    let salsa_struct_in_db = quote! {
+        impl #impl_generics zalsa::SalsaStructInDb for #enum_name #type_generics
+        #where_clause {
+            type MemoIngredientMap = zalsa::MemoIngredientIndices;
+
+            #[inline]
+            fn lookup_or_create_ingredient_index(__zalsa: &zalsa::Zalsa) -> zalsa::IngredientIndices {
+                zalsa::IngredientIndices::merge([ #( <#variant_types as zalsa::SalsaStructInDb>::lookup_or_create_ingredient_index(__zalsa) ),* ])
+            }
+
+            #[inline]
+            fn cast(id: zalsa::Id, type_id: ::core::any::TypeId) -> Option<Self> {
+                #(
+                    // Subtle: the ingredient can be missing, but in this case the id cannot come
+                    // from it - because it wasn't initialized yet.
+                    if let Some(result) = <#variant_types as zalsa::SalsaStructInDb>::cast(id, type_id) {
+                        Some(Self::#variant_names(result))
+                    } else
+                )*
+                {
+                    None
+                }
+            }
+        }
+    };
+
+    let all_impls = quote! {
+        const _: () = {
+            use salsa::plumbing as zalsa;
+
+            #as_id
+            #from_id
+            #salsa_struct_in_db
+        };
+    };
+    Ok(all_impls)
+}
diff --git a/crates/salsa/components/salsa-macros/src/tracked.rs b/crates/salsa/components/salsa-macros/src/tracked.rs
new file mode 100644
index 000000000..af09197e1
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/tracked.rs
@@ -0,0 +1,24 @@
+use syn::spanned::Spanned;
+use syn::Item;
+
+use crate::token_stream_with_error;
+
+pub(crate) fn tracked(
+    args: proc_macro::TokenStream,
+    input: proc_macro::TokenStream,
+) -> proc_macro::TokenStream {
+    let item = parse_macro_input!(input as Item);
+    let res = match item {
+        syn::Item::Struct(item) => crate::tracked_struct::tracked_struct(args, item),
+        syn::Item::Fn(item) => crate::tracked_fn::tracked_fn(args, item),
+        syn::Item::Impl(item) => crate::tracked_impl::tracked_impl(args, item),
+        _ => Err(syn::Error::new(
+            item.span(),
+            "tracked can only be applied to structs, functions, and impls",
+        )),
+    };
+    match res {
+        Ok(s) => s.into(),
+        Err(err) => token_stream_with_error(input, err),
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/tracked_fn.rs b/crates/salsa/components/salsa-macros/src/tracked_fn.rs
new file mode 100644
index 000000000..5022a18a2
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/tracked_fn.rs
@@ -0,0 +1,419 @@
+use proc_macro2::{Literal, Span, TokenStream};
+use quote::ToTokens;
+use syn::spanned::Spanned;
+use syn::{Ident, ItemFn};
+
+use crate::hygiene::Hygiene;
+use crate::options::Options;
+use crate::{db_lifetime, fn_util};
+
+// Source:
+//
+// #[salsa::db]
+// pub struct Database {
+//    storage: salsa::Storage<Self>,
+// }
+
+pub(crate) fn tracked_fn(args: proc_macro::TokenStream, item: ItemFn) -> syn::Result<TokenStream> {
+    let hygiene = Hygiene::from2(&item);
+    let args: FnArgs = syn::parse(args)?;
+    let db_macro = Macro { hygiene, args };
+    db_macro.try_fn(item)
+}
+
+pub type FnArgs = Options<TrackedFn>;
+
+pub struct TrackedFn;
+
+impl crate::options::AllowedOptions for TrackedFn {
+    const RETURNS: bool = true;
+
+    const SPECIFY: bool = true;
+
+    const NO_EQ: bool = true;
+
+    const DEBUG: bool = false;
+
+    const NO_LIFETIME: bool = false;
+
+    const NO_CLONE: bool = false;
+
+    const SINGLETON: bool = false;
+
+    const DATA: bool = false;
+
+    const DB: bool = false;
+
+    const CYCLE_FN: bool = true;
+
+    const CYCLE_INITIAL: bool = true;
+
+    const CYCLE_RESULT: bool = true;
+
+    const LRU: bool = true;
+
+    const CONSTRUCTOR_NAME: bool = false;
+
+    const ID: bool = false;
+}
+
+struct Macro {
+    hygiene: Hygiene,
+    args: FnArgs,
+}
+
+struct ValidFn<'item> {
+    db_ident: &'item syn::Ident,
+    db_path: &'item syn::Path,
+}
+
+const ALLOWED_RETURN_MODES: &[&str] = &["copy", "clone", "ref", "deref", "as_ref", "as_deref"];
+
+#[allow(non_snake_case)]
+impl Macro {
+    fn try_fn(&self, item: syn::ItemFn) -> syn::Result<TokenStream> {
+        let ValidFn { db_ident, db_path } = self.validity_check(&item)?;
+
+        let attrs = &item.attrs;
+        let fn_name = &item.sig.ident;
+        let vis = &item.vis;
+        let db_lt = db_lifetime::db_lifetime(&item.sig.generics);
+        let input_ids = self.input_ids(&item);
+        let input_tys = self.input_tys(&item)?;
+        let output_ty = self.output_ty(&db_lt, &item)?;
+        let (cycle_recovery_fn, cycle_recovery_initial, cycle_recovery_strategy) =
+            self.cycle_recovery()?;
+        let is_specifiable = self.args.specify.is_some();
+        let eq = if let Some(token) = &self.args.no_eq {
+            if self.args.cycle_fn.is_some() {
+                return Err(syn::Error::new_spanned(
+                    token,
+                    "the `no_eq` option cannot be used with `cycle_fn`",
+                ));
+            }
+            quote!(false)
+        } else {
+            quote_spanned!(output_ty.span() =>
+                old_value == new_value
+            )
+        };
+        // we need to generate the entire function here
+        // as the locals (parameters) will have def site hygiene otherwise
+        // if emitted in the decl macro
+        let eq = quote! {
+            fn values_equal<#db_lt>(
+                old_value: &Self::Output<#db_lt>,
+                new_value: &Self::Output<#db_lt>,
+            ) -> bool {
+                #eq
+            }
+        };
+
+        let mut inner_fn = item.clone();
+        inner_fn.vis = syn::Visibility::Inherited;
+        inner_fn.sig.ident = self.hygiene.ident("inner");
+
+        let zalsa = self.hygiene.ident("zalsa");
+        let Configuration = self.hygiene.ident("Configuration");
+        let InternedData = self.hygiene.ident("InternedData");
+        let FN_CACHE = self.hygiene.ident("FN_CACHE");
+        let INTERN_CACHE = self.hygiene.ident("INTERN_CACHE");
+        let inner = &inner_fn.sig.ident;
+
+        let function_type = function_type(&item);
+
+        if is_specifiable {
+            match function_type {
+                FunctionType::Constant | FunctionType::RequiresInterning => {
+                    return Err(syn::Error::new_spanned(
+                        self.args.specify.as_ref().unwrap(),
+                        "only functions with a single salsa struct as their input can be specified",
+                    ))
+                }
+                FunctionType::SalsaStruct => {}
+            }
+        }
+
+        if let (Some(_), Some(token)) = (&self.args.lru, &self.args.specify) {
+            return Err(syn::Error::new_spanned(
+                token,
+                "the `specify` and `lru` options cannot be used together",
+            ));
+        }
+
+        let needs_interner = match function_type {
+            FunctionType::Constant | FunctionType::RequiresInterning => true,
+            FunctionType::SalsaStruct => false,
+        };
+
+        let lru = Literal::usize_unsuffixed(self.args.lru.unwrap_or(0));
+
+        let return_mode = self
+            .args
+            .returns
+            .clone()
+            .unwrap_or(Ident::new("clone", Span::call_site()));
+
+        // Validate return mode
+        if !ALLOWED_RETURN_MODES
+            .iter()
+            .any(|mode| mode == &return_mode.to_string())
+        {
+            return Err(syn::Error::new(
+                return_mode.span(),
+                format!("Invalid return mode. Allowed modes are: {ALLOWED_RETURN_MODES:?}"),
+            ));
+        }
+
+        // The path expression is responsible for emitting the primary span in the diagnostic we
+        // want, so by uniformly using `output_ty.span()` we ensure that the diagnostic is emitted
+        // at the return type in the original input.
+        // See the tests/compile-fail/tracked_fn_return_ref.rs test
+        let maybe_update_path = quote_spanned! {output_ty.span() =>
+            UpdateDispatch::<#output_ty>::maybe_update
+        };
+        let assert_return_type_is_update = quote! {
+            #[allow(clippy::all, warnings)]
+            fn _assert_return_type_is_update<#db_lt>()  {
+                use #zalsa::{UpdateFallback, UpdateDispatch};
+                #maybe_update_path;
+            }
+        };
+
+        Ok(crate::debug::dump_tokens(
+            fn_name,
+            quote![salsa::plumbing::setup_tracked_fn! {
+                attrs: [#(#attrs),*],
+                vis: #vis,
+                fn_name: #fn_name,
+                db_lt: #db_lt,
+                Db: #db_path,
+                db: #db_ident,
+                input_ids: [#(#input_ids),*],
+                input_tys: [#(#input_tys),*],
+                output_ty: #output_ty,
+                inner_fn: { #inner_fn },
+                cycle_recovery_fn: #cycle_recovery_fn,
+                cycle_recovery_initial: #cycle_recovery_initial,
+                cycle_recovery_strategy: #cycle_recovery_strategy,
+                is_specifiable: #is_specifiable,
+                values_equal: {#eq},
+                needs_interner: #needs_interner,
+                lru: #lru,
+                return_mode: #return_mode,
+                assert_return_type_is_update: { #assert_return_type_is_update },
+                unused_names: [
+                    #zalsa,
+                    #Configuration,
+                    #InternedData,
+                    #FN_CACHE,
+                    #INTERN_CACHE,
+                    #inner,
+                ]
+            }],
+        ))
+    }
+
+    fn validity_check<'item>(&self, item: &'item syn::ItemFn) -> syn::Result<ValidFn<'item>> {
+        db_lifetime::require_optional_db_lifetime(&item.sig.generics)?;
+
+        if item.sig.inputs.is_empty() {
+            return Err(syn::Error::new_spanned(
+                &item.sig.ident,
+                "tracked functions must have at least a database argument",
+            ));
+        }
+
+        let (db_ident, db_path) =
+            check_db_argument(&item.sig.inputs[0], item.sig.generics.lifetimes().next())?;
+
+        Ok(ValidFn { db_ident, db_path })
+    }
+
+    fn cycle_recovery(&self) -> syn::Result<(TokenStream, TokenStream, TokenStream)> {
+        // TODO should we ask the user to specify a struct that impls a trait with two methods,
+        // rather than asking for two methods separately?
+        match (
+            &self.args.cycle_fn,
+            &self.args.cycle_initial,
+            &self.args.cycle_result,
+        ) {
+            (Some(cycle_fn), Some(cycle_initial), None) => Ok((
+                quote!((#cycle_fn)),
+                quote!((#cycle_initial)),
+                quote!(Fixpoint),
+            )),
+            (None, None, None) => Ok((
+                quote!((salsa::plumbing::unexpected_cycle_recovery!)),
+                quote!((salsa::plumbing::unexpected_cycle_initial!)),
+                quote!(Panic),
+            )),
+            (Some(_), None, None) => Err(syn::Error::new_spanned(
+                self.args.cycle_fn.as_ref().unwrap(),
+                "must provide `cycle_initial` along with `cycle_fn`",
+            )),
+            (None, Some(_), None) => Err(syn::Error::new_spanned(
+                self.args.cycle_initial.as_ref().unwrap(),
+                "must provide `cycle_fn` along with `cycle_initial`",
+            )),
+            (None, None, Some(cycle_result)) => Ok((
+                quote!((salsa::plumbing::unexpected_cycle_recovery!)),
+                quote!((#cycle_result)),
+                quote!(FallbackImmediate),
+            )),
+            (_, _, Some(_)) => Err(syn::Error::new_spanned(
+                self.args.cycle_initial.as_ref().unwrap(),
+                "must provide either `cycle_result` or `cycle_fn` & `cycle_initial`, not both",
+            )),
+        }
+    }
+
+    fn input_ids(&self, item: &ItemFn) -> Vec<syn::Ident> {
+        fn_util::input_ids(&self.hygiene, &item.sig, 1)
+    }
+
+    fn input_tys<'syn>(&self, item: &'syn ItemFn) -> syn::Result<Vec<&'syn syn::Type>> {
+        fn_util::input_tys(&item.sig, 1)
+    }
+
+    fn output_ty(&self, db_lt: &syn::Lifetime, item: &syn::ItemFn) -> syn::Result<syn::Type> {
+        fn_util::output_ty(Some(db_lt), &item.sig)
+    }
+}
+
+#[derive(Debug, PartialEq, Eq, Hash)]
+enum FunctionType {
+    Constant,
+    SalsaStruct,
+    RequiresInterning,
+}
+
+fn function_type(item_fn: &syn::ItemFn) -> FunctionType {
+    match item_fn.sig.inputs.len() {
+        0 => unreachable!(
+            "functions have been checked to have at least a database argument by this point"
+        ),
+        1 => FunctionType::Constant,
+        2 => FunctionType::SalsaStruct,
+        _ => FunctionType::RequiresInterning,
+    }
+}
+
+pub fn check_db_argument<'arg>(
+    fn_arg: &'arg syn::FnArg,
+    explicit_lt: Option<&'arg syn::LifetimeParam>,
+) -> syn::Result<(&'arg syn::Ident, &'arg syn::Path)> {
+    match fn_arg {
+        syn::FnArg::Receiver(_) => {
+            // If we see `&self` where a database was expected, that indicates
+            // that `#[tracked]` was applied to a method.
+            Err(syn::Error::new_spanned(
+                fn_arg,
+                "#[salsa::tracked] must also be applied to the impl block for tracked methods",
+            ))
+        }
+        syn::FnArg::Typed(typed) => {
+            let syn::Pat::Ident(db_pat_ident) = &*typed.pat else {
+                return Err(syn::Error::new_spanned(
+                    &typed.pat,
+                    "database parameter must have a simple name",
+                ));
+            };
+
+            let syn::PatIdent {
+                attrs,
+                by_ref,
+                mutability,
+                ident: db_ident,
+                subpat,
+            } = db_pat_ident;
+
+            if !attrs.is_empty() {
+                return Err(syn::Error::new_spanned(
+                    db_pat_ident,
+                    "database parameter cannot have attributes",
+                ));
+            }
+
+            if by_ref.is_some() {
+                return Err(syn::Error::new_spanned(
+                    by_ref,
+                    "database parameter cannot be borrowed",
+                ));
+            }
+
+            if mutability.is_some() {
+                return Err(syn::Error::new_spanned(
+                    mutability,
+                    "database parameter cannot be mutable",
+                ));
+            }
+
+            if let Some((at, _)) = subpat {
+                return Err(syn::Error::new_spanned(
+                    at,
+                    "database parameter cannot have a subpattern",
+                ));
+            }
+
+            let tykind_error_msg =
+                "must have type `&dyn Db`, where `Db` is some Salsa Database trait";
+
+            let syn::Type::Reference(ref_type) = &*typed.ty else {
+                return Err(syn::Error::new(typed.ty.span(), tykind_error_msg));
+            };
+
+            if let Some(lt) = explicit_lt {
+                if ref_type.lifetime.is_none() {
+                    return Err(syn::Error::new_spanned(
+                        ref_type.and_token,
+                        format!("must have a `{}` lifetime", lt.lifetime.to_token_stream()),
+                    ));
+                }
+            }
+
+            let extract_db_path = || -> Result<&'arg syn::Path, Span> {
+                if let Some(m) = &ref_type.mutability {
+                    return Err(m.span());
+                }
+
+                let syn::Type::TraitObject(d) = &*ref_type.elem else {
+                    return Err(ref_type.span());
+                };
+
+                if d.bounds.len() != 1 {
+                    return Err(d.span());
+                }
+
+                let syn::TypeParamBound::Trait(syn::TraitBound {
+                    paren_token,
+                    modifier,
+                    lifetimes,
+                    path,
+                }) = &d.bounds[0]
+                else {
+                    return Err(d.span());
+                };
+
+                if let Some(p) = paren_token {
+                    return Err(p.span.open());
+                }
+
+                let syn::TraitBoundModifier::None = modifier else {
+                    return Err(d.span());
+                };
+
+                if let Some(lt) = lifetimes {
+                    return Err(lt.span());
+                }
+
+                Ok(path)
+            };
+
+            let db_path =
+                extract_db_path().map_err(|span| syn::Error::new(span, tykind_error_msg))?;
+
+            Ok((db_ident, db_path))
+        }
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/tracked_impl.rs b/crates/salsa/components/salsa-macros/src/tracked_impl.rs
new file mode 100644
index 000000000..256eae3f5
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/tracked_impl.rs
@@ -0,0 +1,326 @@
+use std::collections::HashSet;
+
+use proc_macro2::TokenStream;
+use quote::ToTokens;
+use syn::parse::Nothing;
+use syn::visit_mut::VisitMut;
+
+use crate::hygiene::Hygiene;
+use crate::tracked_fn::FnArgs;
+use crate::xform::ChangeSelfPath;
+
+pub(crate) fn tracked_impl(
+    args: proc_macro::TokenStream,
+    item: syn::ItemImpl,
+) -> syn::Result<TokenStream> {
+    let hygiene = Hygiene::from2(&item);
+    let _: Nothing = syn::parse(args)?;
+    let m = Macro { hygiene };
+    let generated = m.try_generate(item)?;
+    Ok(generated)
+}
+
+struct Macro {
+    hygiene: Hygiene,
+}
+
+struct MethodArguments<'syn> {
+    self_token: &'syn syn::token::SelfValue,
+    db_ty: &'syn syn::Type,
+    db_ident: &'syn syn::Ident,
+    db_lt: Option<&'syn syn::Lifetime>,
+    input_ids: Vec<syn::Ident>,
+    input_tys: Vec<&'syn syn::Type>,
+    output_ty: syn::Type,
+}
+
+impl Macro {
+    fn try_generate(&self, mut impl_item: syn::ItemImpl) -> syn::Result<TokenStream> {
+        let mut member_items = std::mem::take(&mut impl_item.items);
+        let member_idents: HashSet<_> = member_items
+            .iter()
+            .filter_map(|item| match item {
+                syn::ImplItem::Const(it) => Some(it.ident.clone()),
+                syn::ImplItem::Fn(it) => Some(it.sig.ident.clone()),
+                syn::ImplItem::Type(it) => Some(it.ident.clone()),
+                syn::ImplItem::Macro(_) => None,
+                syn::ImplItem::Verbatim(_) => None,
+                _ => None,
+            })
+            .collect();
+        for member_item in &mut member_items {
+            self.modify_member(&impl_item, member_item, &member_idents)?;
+        }
+        impl_item.items = member_items;
+        Ok(crate::debug::dump_tokens(
+            format!("impl {:?}", impl_item.self_ty),
+            impl_item.into_token_stream(),
+        ))
+    }
+
+    #[allow(non_snake_case)]
+    fn modify_member(
+        &self,
+        impl_item: &syn::ItemImpl,
+        member_item: &mut syn::ImplItem,
+        member_idents: &HashSet<syn::Ident>,
+    ) -> syn::Result<()> {
+        let syn::ImplItem::Fn(fn_item) = member_item else {
+            return Ok(());
+        };
+
+        let self_ty = &impl_item.self_ty;
+
+        let Some(tracked_attr_index) = fn_item.attrs.iter().position(|a| self.is_tracked_attr(a))
+        else {
+            return Ok(());
+        };
+
+        let trait_ = match &impl_item.trait_ {
+            Some((None, path, _)) => Some((path, member_idents)),
+            _ => None,
+        };
+        let mut change = ChangeSelfPath::new(self_ty, trait_);
+        change.visit_impl_item_fn_mut(fn_item);
+
+        let salsa_tracked_attr = fn_item.attrs.remove(tracked_attr_index);
+        let args: FnArgs = match &salsa_tracked_attr.meta {
+            syn::Meta::Path(..) => Default::default(),
+            _ => salsa_tracked_attr.parse_args()?,
+        };
+
+        let InnerTrait = self.hygiene.ident("InnerTrait");
+        let inner_fn_name = self.hygiene.ident(&fn_item.sig.ident.to_string());
+
+        let MethodArguments {
+            self_token,
+            db_ty,
+            db_ident,
+            db_lt,
+            input_ids,
+            input_tys,
+            output_ty,
+        } = self.validity_check(impl_item, fn_item)?;
+
+        let mut inner_fn = fn_item.clone();
+        inner_fn.vis = syn::Visibility::Inherited;
+        inner_fn.sig.ident = inner_fn_name.clone();
+
+        // Construct the body of the method
+
+        let block = parse_quote!({
+            salsa::plumbing::setup_method_body! {
+                salsa_tracked_attr: #salsa_tracked_attr,
+                self: #self_token,
+                self_ty: #self_ty,
+                db_lt: #db_lt,
+                db: #db_ident,
+                db_ty: (#db_ty),
+                input_ids: [#(#input_ids),*],
+                input_tys: [#(#input_tys),*],
+                output_ty: #output_ty,
+                inner_fn_name: #inner_fn_name,
+                inner_fn: #inner_fn,
+
+                // Annoyingly macro-rules hygiene does not extend to items defined in the macro.
+                // We have the procedural macro generate names for those items that are
+                // not used elsewhere in the user's code.
+                unused_names: [
+                    #InnerTrait,
+                ]
+            }
+        });
+
+        // Update the method that will actually appear in the impl to have the new body
+        // and its true return type
+        let db_lt = db_lt.cloned();
+        self.update_return_type(&mut fn_item.sig, &args, &db_lt)?;
+        fn_item.block = block;
+
+        Ok(())
+    }
+
+    fn validity_check<'syn>(
+        &self,
+        impl_item: &'syn syn::ItemImpl,
+        fn_item: &'syn syn::ImplItemFn,
+    ) -> syn::Result<MethodArguments<'syn>> {
+        let db_lt = self.extract_db_lifetime(impl_item, fn_item)?;
+
+        let self_token = self.check_self_argument(fn_item)?;
+
+        let (db_ident, db_ty) = self.check_db_argument(&fn_item.sig.inputs[1])?;
+
+        let input_ids: Vec<syn::Ident> = crate::fn_util::input_ids(&self.hygiene, &fn_item.sig, 2);
+        let input_tys = crate::fn_util::input_tys(&fn_item.sig, 2)?;
+        let output_ty = crate::fn_util::output_ty(db_lt, &fn_item.sig)?;
+
+        Ok(MethodArguments {
+            self_token,
+            db_ident,
+            db_lt,
+            db_ty,
+            input_ids,
+            input_tys,
+            output_ty,
+        })
+    }
+
+    fn is_tracked_attr(&self, attr: &syn::Attribute) -> bool {
+        if attr.path().segments.len() != 2 {
+            return false;
+        }
+
+        let seg0 = &attr.path().segments[0];
+        let seg1 = &attr.path().segments[1];
+
+        seg0.ident == "salsa"
+            && seg1.ident == "tracked"
+            && seg0.arguments.is_empty()
+            && seg1.arguments.is_empty()
+    }
+
+    fn extract_db_lifetime<'syn>(
+        &self,
+        impl_item: &'syn syn::ItemImpl,
+        fn_item: &'syn syn::ImplItemFn,
+    ) -> syn::Result<Option<&'syn syn::Lifetime>> {
+        // Either the impl XOR the fn can have generics, and it must be at most a lifetime
+        let mut db_lt = None;
+        for param in impl_item
+            .generics
+            .params
+            .iter()
+            .chain(fn_item.sig.generics.params.iter())
+        {
+            match param {
+                syn::GenericParam::Lifetime(lt) => {
+                    if db_lt.is_none() {
+                        if let Some(bound) = lt.bounds.iter().next() {
+                            return Err(syn::Error::new_spanned(
+                                bound,
+                                "lifetime parameters on tracked methods must not have bounds",
+                            ));
+                        }
+
+                        db_lt = Some(&lt.lifetime);
+                    } else {
+                        return Err(syn::Error::new_spanned(
+                            param,
+                            "tracked method already has a lifetime parameter in scope",
+                        ));
+                    }
+                }
+                _ => {
+                    return Err(syn::Error::new_spanned(
+                        param,
+                        "tracked methods cannot have non-lifetime generic parameters",
+                    ));
+                }
+            }
+        }
+
+        Ok(db_lt)
+    }
+
+    fn check_self_argument<'syn>(
+        &self,
+        fn_item: &'syn syn::ImplItemFn,
+    ) -> syn::Result<&'syn syn::token::SelfValue> {
+        if fn_item.sig.inputs.is_empty() {
+            return Err(syn::Error::new_spanned(
+                &fn_item.sig.ident,
+                "tracked methods must have arguments",
+            ));
+        }
+
+        let syn::FnArg::Receiver(syn::Receiver {
+            attrs: _,
+            self_token,
+            reference,
+            mutability: _,
+            colon_token,
+            ty: _,
+        }) = &fn_item.sig.inputs[0]
+        else {
+            return Err(syn::Error::new_spanned(
+                &fn_item.sig.inputs[0],
+                "tracked methods must take a `self` argument",
+            ));
+        };
+
+        if let Some(colon_token) = colon_token {
+            return Err(syn::Error::new_spanned(
+                colon_token,
+                "tracked method's `self` argument must not have an explicit type",
+            ));
+        }
+
+        if let Some((and_token, _)) = reference {
+            return Err(syn::Error::new_spanned(
+                and_token,
+                "tracked methods's first argument must be declared as `self`, not `&self` or `&mut self`",
+            ));
+        }
+
+        Ok(self_token)
+    }
+
+    fn check_db_argument<'syn>(
+        &self,
+        input: &'syn syn::FnArg,
+    ) -> syn::Result<(&'syn syn::Ident, &'syn syn::Type)> {
+        let syn::FnArg::Typed(typed) = input else {
+            return Err(syn::Error::new_spanned(
+                input,
+                "tracked methods must take a database parameter",
+            ));
+        };
+
+        let syn::Pat::Ident(db_pat_ident) = &*typed.pat else {
+            return Err(syn::Error::new_spanned(
+                &typed.pat,
+                "database parameter must have a simple name",
+            ));
+        };
+
+        let db_ident = &db_pat_ident.ident;
+        let db_ty = &*typed.ty;
+
+        Ok((db_ident, db_ty))
+    }
+
+    fn update_return_type(
+        &self,
+        sig: &mut syn::Signature,
+        args: &FnArgs,
+        db_lt: &Option<syn::Lifetime>,
+    ) -> syn::Result<()> {
+        if let Some(returns) = &args.returns {
+            if let syn::ReturnType::Type(_, t) = &mut sig.output {
+                if returns == "copy" || returns == "clone" {
+                    // leave as is
+                } else if returns == "ref" {
+                    **t = parse_quote!(& #db_lt #t)
+                } else if returns == "deref" {
+                    **t = parse_quote!(& #db_lt <#t as ::core::ops::Deref>::Target)
+                } else if returns == "as_ref" {
+                    **t = parse_quote!(<#t as ::salsa::SalsaAsRef>::AsRef<#db_lt>)
+                } else if returns == "as_deref" {
+                    **t = parse_quote!(<#t as ::salsa::SalsaAsDeref>::AsDeref<#db_lt>)
+                } else {
+                    return Err(syn::Error::new_spanned(
+                        returns,
+                        format!("Unknown returns mode `{returns}`"),
+                    ));
+                }
+            } else {
+                return Err(syn::Error::new_spanned(
+                    returns,
+                    "returns attribute requires explicit return type",
+                ));
+            };
+        }
+        Ok(())
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/tracked_struct.rs b/crates/salsa/components/salsa-macros/src/tracked_struct.rs
new file mode 100644
index 000000000..4970591e1
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/tracked_struct.rs
@@ -0,0 +1,168 @@
+use proc_macro2::TokenStream;
+
+use crate::db_lifetime;
+use crate::hygiene::Hygiene;
+use crate::options::Options;
+use crate::salsa_struct::{SalsaStruct, SalsaStructAllowedOptions};
+
+/// For an entity struct `Foo` with fields `f1: T1, ..., fN: TN`, we generate...
+///
+/// * the "id struct" `struct Foo(salsa::Id)`
+/// * the entity ingredient, which maps the id fields to the `Id`
+/// * for each value field, a function ingredient
+pub(crate) fn tracked_struct(
+    args: proc_macro::TokenStream,
+    struct_item: syn::ItemStruct,
+) -> syn::Result<TokenStream> {
+    let hygiene = Hygiene::from2(&struct_item);
+    let m = Macro {
+        hygiene,
+        args: syn::parse(args)?,
+        struct_item,
+    };
+    m.try_macro()
+}
+
+type TrackedArgs = Options<TrackedStruct>;
+
+struct TrackedStruct;
+
+impl crate::options::AllowedOptions for TrackedStruct {
+    const RETURNS: bool = false;
+
+    const SPECIFY: bool = false;
+
+    const NO_EQ: bool = false;
+
+    const DEBUG: bool = true;
+
+    const NO_LIFETIME: bool = false;
+
+    const NO_CLONE: bool = false;
+
+    const SINGLETON: bool = true;
+
+    const DATA: bool = true;
+
+    const DB: bool = false;
+
+    const CYCLE_FN: bool = false;
+
+    const CYCLE_INITIAL: bool = false;
+
+    const CYCLE_RESULT: bool = false;
+
+    const LRU: bool = false;
+
+    const CONSTRUCTOR_NAME: bool = true;
+
+    const ID: bool = false;
+}
+
+impl SalsaStructAllowedOptions for TrackedStruct {
+    const KIND: &'static str = "tracked";
+
+    const ALLOW_TRACKED: bool = true;
+
+    const HAS_LIFETIME: bool = true;
+
+    const ELIDABLE_LIFETIME: bool = false;
+
+    const ALLOW_DEFAULT: bool = false;
+}
+
+struct Macro {
+    hygiene: Hygiene,
+    args: TrackedArgs,
+    struct_item: syn::ItemStruct,
+}
+
+impl Macro {
+    #[allow(non_snake_case)]
+    fn try_macro(&self) -> syn::Result<TokenStream> {
+        let salsa_struct = SalsaStruct::new(&self.struct_item, &self.args)?;
+
+        let attrs = &self.struct_item.attrs;
+        let vis = &self.struct_item.vis;
+        let struct_ident = &self.struct_item.ident;
+        let db_lt = db_lifetime::db_lifetime(&self.struct_item.generics);
+        let new_fn = salsa_struct.constructor_name();
+
+        let field_ids = salsa_struct.field_ids();
+        let tracked_ids = salsa_struct.tracked_ids();
+
+        let tracked_vis = salsa_struct.tracked_vis();
+        let untracked_vis = salsa_struct.untracked_vis();
+
+        let tracked_getter_ids = salsa_struct.tracked_getter_ids();
+        let untracked_getter_ids = salsa_struct.untracked_getter_ids();
+
+        let field_indices = salsa_struct.field_indices();
+
+        let absolute_tracked_indices = salsa_struct.tracked_field_indices();
+        let relative_tracked_indices = (0..absolute_tracked_indices.len()).collect::<Vec<_>>();
+
+        let absolute_untracked_indices = salsa_struct.untracked_field_indices();
+
+        let tracked_options = salsa_struct.tracked_options();
+        let untracked_options = salsa_struct.untracked_options();
+
+        let field_tys = salsa_struct.field_tys();
+        let tracked_tys = salsa_struct.tracked_tys();
+        let untracked_tys = salsa_struct.untracked_tys();
+
+        let num_tracked_fields = salsa_struct.num_tracked_fields();
+        let generate_debug_impl = salsa_struct.generate_debug_impl();
+
+        let zalsa = self.hygiene.ident("zalsa");
+        let zalsa_struct = self.hygiene.ident("zalsa_struct");
+        let Configuration = self.hygiene.ident("Configuration");
+        let CACHE = self.hygiene.ident("CACHE");
+        let Db = self.hygiene.ident("Db");
+        let Revision = self.hygiene.ident("Revision");
+
+        Ok(crate::debug::dump_tokens(
+            struct_ident,
+            quote! {
+                salsa::plumbing::setup_tracked_struct!(
+                    attrs: [#(#attrs),*],
+                    vis: #vis,
+                    Struct: #struct_ident,
+                    db_lt: #db_lt,
+                    new_fn: #new_fn,
+
+                    field_ids: [#(#field_ids),*],
+                    tracked_ids: [#(#tracked_ids),*],
+
+                    tracked_getters: [#(#tracked_vis #tracked_getter_ids),*],
+                    untracked_getters: [#(#untracked_vis #untracked_getter_ids),*],
+
+                    field_tys: [#(#field_tys),*],
+                    tracked_tys: [#(#tracked_tys),*],
+                    untracked_tys: [#(#untracked_tys),*],
+
+                    field_indices: [#(#field_indices),*],
+
+                    absolute_tracked_indices: [#(#absolute_tracked_indices),*],
+                    relative_tracked_indices: [#(#relative_tracked_indices),*],
+
+                    absolute_untracked_indices: [#(#absolute_untracked_indices),*],
+
+                    tracked_options: [#(#tracked_options),*],
+                    untracked_options: [#(#untracked_options),*],
+
+                    num_tracked_fields: #num_tracked_fields,
+                    generate_debug_impl: #generate_debug_impl,
+                    unused_names: [
+                        #zalsa,
+                        #zalsa_struct,
+                        #Configuration,
+                        #CACHE,
+                        #Db,
+                        #Revision,
+                    ]
+                );
+            },
+        ))
+    }
+}
diff --git a/crates/salsa/components/salsa-macros/src/update.rs b/crates/salsa/components/salsa-macros/src/update.rs
new file mode 100644
index 000000000..c779ad6ea
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/update.rs
@@ -0,0 +1,102 @@
+use proc_macro2::{Literal, TokenStream};
+use syn::spanned::Spanned;
+use synstructure::BindStyle;
+
+use crate::hygiene::Hygiene;
+
+pub(crate) fn update_derive(input: syn::DeriveInput) -> syn::Result<TokenStream> {
+    let hygiene = Hygiene::from2(&input);
+
+    if let syn::Data::Union(_) = &input.data {
+        return Err(syn::Error::new_spanned(
+            &input.ident,
+            "`derive(Update)` does not support `union`",
+        ));
+    }
+
+    let mut structure = synstructure::Structure::new(&input);
+
+    for v in structure.variants_mut() {
+        v.bind_with(|_| BindStyle::Move);
+    }
+
+    let old_pointer = hygiene.ident("old_pointer");
+    let new_value = hygiene.ident("new_value");
+
+    let fields: TokenStream = structure
+        .variants()
+        .iter()
+        .map(|variant| {
+            let variant_pat = variant.pat();
+
+            // First check that the `new_value` has same variant.
+            // Extract its fields and convert to a tuple.
+            let make_tuple = variant
+                .bindings()
+                .iter()
+                .fold(quote!(), |tokens, binding| quote!(#tokens #binding,));
+            let make_new_value = quote_spanned! {variant.ast().ident.span()=>
+                let #new_value = if let #variant_pat = #new_value {
+                    (#make_tuple)
+                } else {
+                    *#old_pointer = #new_value;
+                    return true;
+                };
+            };
+
+            // For each field, invoke `maybe_update` recursively to update its value.
+            // Or the results together (using `|`, not `||`, to avoid shortcircuiting)
+            // to get the final return value.
+            let update_fields = variant.bindings().iter().enumerate().fold(
+                quote!(false),
+                |tokens, (index, binding)| {
+                    let field_ty = &binding.ast().ty;
+                    let field_index = Literal::usize_unsuffixed(index);
+
+                    let field_span = binding
+                        .ast()
+                        .ident
+                        .as_ref()
+                        .map(Spanned::span)
+                        .unwrap_or(binding.ast().span());
+
+                    let update_field = quote_spanned! {field_span=>
+                        salsa::plumbing::UpdateDispatch::<#field_ty>::maybe_update(
+                            #binding,
+                            #new_value.#field_index,
+                        )
+                    };
+
+                    quote! {
+                        #tokens | unsafe { #update_field }
+                    }
+                },
+            );
+
+            quote!(
+                #variant_pat => {
+                    #make_new_value
+                    #update_fields
+                }
+            )
+        })
+        .collect();
+
+    let ident = &input.ident;
+    let (impl_generics, ty_generics, where_clause) = input.generics.split_for_impl();
+    let tokens = quote! {
+        #[allow(clippy::all)]
+        #[automatically_derived]
+        unsafe impl #impl_generics salsa::Update for #ident #ty_generics #where_clause {
+            unsafe fn maybe_update(#old_pointer: *mut Self, #new_value: Self) -> bool {
+                use ::salsa::plumbing::UpdateFallback as _;
+                let #old_pointer = unsafe { &mut *#old_pointer };
+                match #old_pointer {
+                    #fields
+                }
+            }
+        }
+    };
+
+    Ok(crate::debug::dump_tokens(&input.ident, tokens))
+}
diff --git a/crates/salsa/components/salsa-macros/src/xform.rs b/crates/salsa/components/salsa-macros/src/xform.rs
new file mode 100644
index 000000000..54f99fdaa
--- /dev/null
+++ b/crates/salsa/components/salsa-macros/src/xform.rs
@@ -0,0 +1,145 @@
+use std::collections::HashSet;
+
+use quote::ToTokens;
+use syn::punctuated::Punctuated;
+use syn::spanned::Spanned;
+use syn::visit_mut::VisitMut;
+
+pub(crate) struct ChangeLt<'a> {
+    from: Option<&'a str>,
+    to: String,
+}
+
+impl ChangeLt<'_> {
+    pub fn elided_to(db_lt: &syn::Lifetime) -> Self {
+        ChangeLt {
+            from: Some("_"),
+            to: db_lt.ident.to_string(),
+        }
+    }
+
+    pub fn in_type(mut self, ty: &syn::Type) -> syn::Type {
+        let mut ty = ty.clone();
+        self.visit_type_mut(&mut ty);
+        ty
+    }
+}
+
+impl syn::visit_mut::VisitMut for ChangeLt<'_> {
+    fn visit_lifetime_mut(&mut self, i: &mut syn::Lifetime) {
+        if self.from.map(|f| i.ident == f).unwrap_or(true) {
+            i.ident = syn::Ident::new(&self.to, i.ident.span());
+        }
+    }
+}
+
+pub(crate) struct ChangeSelfPath<'a> {
+    self_ty: &'a syn::Type,
+    trait_: Option<(&'a syn::Path, &'a HashSet<syn::Ident>)>,
+}
+
+impl ChangeSelfPath<'_> {
+    pub fn new<'a>(
+        self_ty: &'a syn::Type,
+        trait_: Option<(&'a syn::Path, &'a HashSet<syn::Ident>)>,
+    ) -> ChangeSelfPath<'a> {
+        ChangeSelfPath { self_ty, trait_ }
+    }
+}
+
+impl syn::visit_mut::VisitMut for ChangeSelfPath<'_> {
+    fn visit_type_mut(&mut self, i: &mut syn::Type) {
+        if let syn::Type::Path(syn::TypePath { qself: None, path }) = i {
+            if path.segments.len() == 1 && path.segments.first().is_some_and(|s| s.ident == "Self")
+            {
+                let span = path.segments.first().unwrap().span();
+                *i = respan(self.self_ty, span);
+            }
+        }
+        syn::visit_mut::visit_type_mut(self, i);
+    }
+
+    fn visit_type_path_mut(&mut self, i: &mut syn::TypePath) {
+        // `<Self as ..>` cases are handled in `visit_type_mut`
+        if i.qself.is_some() {
+            syn::visit_mut::visit_type_path_mut(self, i);
+            return;
+        }
+
+        // A single path `Self` case is handled in `visit_type_mut`
+        if i.path.segments.first().is_some_and(|s| s.ident == "Self") && i.path.segments.len() > 1 {
+            let span = i.path.segments.first().unwrap().span();
+            let ty = Box::new(respan::<syn::Type>(self.self_ty, span));
+            let lt_token = syn::Token![<](span);
+            let gt_token = syn::Token![>](span);
+            match self.trait_ {
+                // If the next segment's ident is a trait member, replace `Self::` with
+                // `<ActualTy as Trait>::`
+                Some((trait_, member_idents))
+                    if member_idents.contains(&i.path.segments.iter().nth(1).unwrap().ident) =>
+                {
+                    let qself = syn::QSelf {
+                        lt_token,
+                        ty,
+                        position: trait_.segments.len(),
+                        as_token: Some(syn::Token![as](span)),
+                        gt_token,
+                    };
+                    i.qself = Some(qself);
+                    i.path.segments = Punctuated::from_iter(
+                        trait_
+                            .segments
+                            .iter()
+                            .chain(i.path.segments.iter().skip(1))
+                            .cloned(),
+                    );
+                }
+                // Replace `Self::` with `<ActualTy>::` otherwise
+                _ => {
+                    let qself = syn::QSelf {
+                        lt_token,
+                        ty,
+                        position: 0,
+                        as_token: None,
+                        gt_token,
+                    };
+                    i.qself = Some(qself);
+                    i.path.segments =
+                        Punctuated::from_iter(i.path.segments.iter().skip(1).cloned());
+                }
+            }
+        }
+
+        syn::visit_mut::visit_type_path_mut(self, i);
+    }
+}
+
+fn respan<T>(t: &T, span: proc_macro2::Span) -> T
+where
+    T: ToTokens + Spanned + syn::parse::Parse,
+{
+    let tokens = t.to_token_stream();
+    let respanned = respan_tokenstream(tokens, span);
+    syn::parse2(respanned).unwrap()
+}
+
+fn respan_tokenstream(
+    stream: proc_macro2::TokenStream,
+    span: proc_macro2::Span,
+) -> proc_macro2::TokenStream {
+    stream
+        .into_iter()
+        .map(|token| respan_token(token, span))
+        .collect()
+}
+
+fn respan_token(
+    mut token: proc_macro2::TokenTree,
+    span: proc_macro2::Span,
+) -> proc_macro2::TokenTree {
+    if let proc_macro2::TokenTree::Group(g) = &mut token {
+        *g = proc_macro2::Group::new(g.delimiter(), respan_tokenstream(g.stream(), span));
+    }
+    token.set_span(span);
+    token
+}
diff --git a/crates/salsa/examples/calc/compile.rs b/crates/salsa/examples/calc/compile.rs
new file mode 100644
index 000000000..3a7dd8ce9
--- /dev/null
+++ b/crates/salsa/examples/calc/compile.rs
@@ -0,0 +1,9 @@
+use crate::ir::SourceProgram;
+use crate::parser::parse_statements;
+use crate::type_check::type_check_program;
+
+#[salsa::tracked]
+pub fn compile(db: &dyn crate::Db, source_program: SourceProgram) {
+    let program = parse_statements(db, source_program);
+    type_check_program(db, program);
+}
diff --git a/crates/salsa/examples/calc/db.rs b/crates/salsa/examples/calc/db.rs
new file mode 100644
index 000000000..63cc4fe12
--- /dev/null
+++ b/crates/salsa/examples/calc/db.rs
@@ -0,0 +1,64 @@
+#[cfg(test)]
+use std::sync::{Arc, Mutex};
+
+// ANCHOR: db_struct
+#[salsa::db]
+#[derive(Clone)]
+#[cfg_attr(not(test), derive(Default))]
+pub struct CalcDatabaseImpl {
+    storage: salsa::Storage<Self>,
+
+    // The logs are only used for testing and demonstrating reuse:
+    #[cfg(test)]
+    logs: Arc<Mutex<Option<Vec<String>>>>,
+}
+
+#[cfg(test)]
+impl Default for CalcDatabaseImpl {
+    fn default() -> Self {
+        let logs = <Arc<Mutex<Option<Vec<String>>>>>::default();
+        Self {
+            storage: salsa::Storage::new(Some(Box::new({
+                let logs = logs.clone();
+                move |event| {
+                    eprintln!("Event: {event:?}");
+                    // Log interesting events, if logging is enabled
+                    if let Some(logs) = &mut *logs.lock().unwrap() {
+                        // only log interesting events
+                        if let salsa::EventKind::WillExecute { .. } = event.kind {
+                            logs.push(format!("Event: {event:?}"));
+                        }
+                    }
+                }
+            }))),
+            logs,
+        }
+    }
+}
+// ANCHOR_END: db_struct
+
+impl CalcDatabaseImpl {
+    /// Enable logging of each salsa event.
+    #[cfg(test)]
+    pub fn enable_logging(&self) {
+        let mut logs = self.logs.lock().unwrap();
+        if logs.is_none() {
+            *logs = Some(vec![]);
+        }
+    }
+
+    #[cfg(test)]
+    pub fn take_logs(&self) -> Vec<String> {
+        let mut logs = self.logs.lock().unwrap();
+        if let Some(logs) = &mut *logs {
+            std::mem::take(logs)
+        } else {
+            vec![]
+        }
+    }
+}
+
+// ANCHOR: db_impl
+#[salsa::db]
+impl salsa::Database for CalcDatabaseImpl {}
+// ANCHOR_END: db_impl
diff --git a/crates/salsa/examples/calc/ir.rs b/crates/salsa/examples/calc/ir.rs
new file mode 100644
index 000000000..7909b2642
--- /dev/null
+++ b/crates/salsa/examples/calc/ir.rs
@@ -0,0 +1,149 @@
+#![allow(clippy::needless_borrow)]
+
+use ordered_float::OrderedFloat;
+
+// ANCHOR: input
+#[salsa::input(debug)]
+pub struct SourceProgram {
+    #[returns(ref)]
+    pub text: String,
+}
+// ANCHOR_END: input
+
+// ANCHOR: interned_ids
+#[salsa::interned(debug)]
+pub struct VariableId<'db> {
+    #[returns(ref)]
+    pub text: String,
+}
+
+#[salsa::interned(debug)]
+pub struct FunctionId<'db> {
+    #[returns(ref)]
+    pub text: String,
+}
+// ANCHOR_END: interned_ids
+
+// ANCHOR: program
+#[salsa::tracked(debug)]
+pub struct Program<'db> {
+    #[tracked]
+    #[returns(ref)]
+    pub statements: Vec<Statement<'db>>,
+}
+// ANCHOR_END: program
+
+// ANCHOR: statements_and_expressions
+#[derive(Eq, PartialEq, Debug, Hash, salsa::Update)]
+pub struct Statement<'db> {
+    pub span: Span<'db>,
+
+    pub data: StatementData<'db>,
+}
+
+impl<'db> Statement<'db> {
+    pub fn new(span: Span<'db>, data: StatementData<'db>) -> Self {
+        Statement { span, data }
+    }
+}
+
+#[derive(Eq, PartialEq, Debug, Hash, salsa::Update)]
+pub enum StatementData<'db> {
+    /// Defines `fn <name>(<args>) = <body>`
+    Function(Function<'db>),
+    /// Defines `print <expr>`
+    Print(Expression<'db>),
+}
+
+#[derive(Eq, PartialEq, Debug, Hash, salsa::Update)]
+pub struct Expression<'db> {
+    pub span: Span<'db>,
+
+    pub data: ExpressionData<'db>,
+}
+
+impl<'db> Expression<'db> {
+    pub fn new(span: Span<'db>, data: ExpressionData<'db>) -> Self {
+        Expression { span, data }
+    }
+}
+
+#[derive(Eq, PartialEq, Debug, Hash, salsa::Update)]
+pub enum ExpressionData<'db> {
+    Op(Box<Expression<'db>>, Op, Box<Expression<'db>>),
+    Number(OrderedFloat<f64>),
+    Variable(VariableId<'db>),
+    Call(FunctionId<'db>, Vec<Expression<'db>>),
+}
+
+#[derive(Eq, PartialEq, Copy, Clone, Hash, Debug)]
+pub enum Op {
+    Add,
+    Subtract,
+    Multiply,
+    Divide,
+}
+// ANCHOR_END: statements_and_expressions
+
+// ANCHOR: functions
+#[salsa::tracked(debug)]
+pub struct Function<'db> {
+    pub name: FunctionId<'db>,
+
+    name_span: Span<'db>,
+
+    #[tracked]
+    #[returns(ref)]
+    pub args: Vec<VariableId<'db>>,
+
+    #[tracked]
+    #[returns(ref)]
+    pub body: Expression<'db>,
+}
+// ANCHOR_END: functions
+
+#[salsa::tracked(debug)]
+pub struct Span<'db> {
+    #[tracked]
+    pub start: usize,
+    #[tracked]
+    pub end: usize,
+}
+
+// ANCHOR: diagnostic
+#[salsa::accumulator]
+#[derive(Debug)]
+#[allow(dead_code)] // Debug impl uses them
+pub struct Diagnostic {
+    pub start: usize,
+    pub end: usize,
+    pub message: String,
+}
+// ANCHOR_END: diagnostic
+
+impl Diagnostic {
+    pub fn new(start: usize, end: usize, message: String) -> Self {
+        Diagnostic {
+            start,
+            end,
+            message,
+        }
+    }
+
+    #[cfg(test)]
+    pub fn render(&self, db: &dyn crate::Db, src: SourceProgram) -> String {
+        use annotate_snippets::*;
+        let line_start = src.text(db)[..self.start].lines().count() + 1;
+        Renderer::plain()
+            .render(
+                Level::Error.title(&self.message).snippet(
+                    Snippet::source(src.text(db))
+                        .line_start(line_start)
+                        .origin("input")
+                        .fold(true)
+                        .annotation(Level::Error.span(self.start..self.end).label("here")),
+                ),
+            )
+            .to_string()
+    }
+}
diff --git a/crates/salsa/examples/calc/main.rs b/crates/salsa/examples/calc/main.rs
new file mode 100644
index 000000000..616dede67
--- /dev/null
+++ b/crates/salsa/examples/calc/main.rs
@@ -0,0 +1,17 @@
+use db::CalcDatabaseImpl;
+use ir::{Diagnostic, SourceProgram};
+use salsa::Database as Db;
+
+mod compile;
+mod db;
+mod ir;
+mod parser;
+mod type_check;
+
+pub fn main() {
+    let db: CalcDatabaseImpl = Default::default();
+    let source_program = SourceProgram::new(&db, String::new());
+    compile::compile(&db, source_program);
+    let diagnostics = compile::compile::accumulated::<Diagnostic>(&db, source_program);
+    eprintln!("{diagnostics:?}");
+}
diff --git a/crates/salsa/examples/calc/parser.rs b/crates/salsa/examples/calc/parser.rs
new file mode 100644
index 000000000..45fafb6dd
--- /dev/null
+++ b/crates/salsa/examples/calc/parser.rs
@@ -0,0 +1,823 @@
+use ordered_float::OrderedFloat;
+use salsa::Accumulator;
+
+use crate::ir::{
+    Diagnostic, Expression, ExpressionData, Function, FunctionId, Op, Program, SourceProgram, Span,
+    Statement, StatementData, VariableId,
+};
+
+// ANCHOR: parse_statements
+#[salsa::tracked]
+pub fn parse_statements(db: &dyn crate::Db, source: SourceProgram) -> Program<'_> {
+    // Get the source text from the database
+    let source_text = source.text(db);
+
+    // Create the parser
+    let mut parser = Parser {
+        db,
+        source_text,
+        position: 0,
+    };
+
+    // Read in statements until we reach the end of the input
+    let mut result = vec![];
+    loop {
+        // Skip over any whitespace
+        parser.skip_whitespace();
+
+        // If there are no more tokens, break
+        if parser.peek().is_none() {
+            break;
+        }
+
+        // Otherwise, there is more input, so parse a statement.
+        if let Some(statement) = parser.parse_statement() {
+            result.push(statement);
+        } else {
+            // If we failed, report an error at whatever position the parser
+            // got stuck. We could recover here by skipping to the end of the line
+            // or something like that. But we leave that as an exercise for the reader!
+            parser.report_error();
+            break;
+        }
+    }
+
+    Program::new(db, result)
+}
+// ANCHOR_END: parse_statements
+
+/// The parser tracks the current position in the input.
+///
+/// There are parsing methods on the parser named `parse_foo`. Each such method tries to parse a
+/// `foo` at current position. Once they've recognized a `foo`, they return `Some(foo)` with the
+/// result, and they update the position. If there is a parse error
+/// (i.e., they don't recognize a `foo` at the current position), they return `None`,
+/// and they leave `position` at roughly the spot where parsing failed. You can use this to
+/// report errors and recover.
+///
+/// There are some simpler method that read a single token (e.g., [`Parser::ch`]
+/// or [`Parser::word`]). These methods guarantee that, when they return `None`, the position
+/// is not changed apart from consuming whitespace. This allows them to be used to probe ahead
+/// and test the next token.
+struct Parser<'source, 'db> {
+    db: &'db dyn crate::Db,
+    source_text: &'source str,
+    position: usize,
+}
+
+impl<'db> Parser<'_, 'db> {
+    // Invoke `f` and, if it returns `None`, then restore the parsing position.
+    fn probe<T: std::fmt::Debug>(&mut self, f: impl FnOnce(&mut Self) -> Option<T>) -> Option<T> {
+        let p = self.position;
+        if let Some(v) = f(self) {
+            Some(v)
+        } else {
+            self.position = p;
+            None
+        }
+    }
+
+    // ANCHOR: report_error
+    /// Report an error diagnostic at the current position.
+    fn report_error(&self) {
+        let next_position = match self.peek() {
+            Some(ch) => self.position + ch.len_utf8(),
+            None => self.position,
+        };
+        Diagnostic {
+            start: self.position,
+            end: next_position,
+            message: "unexpected character".to_string(),
+        }
+        .accumulate(self.db);
+    }
+    // ANCHOR_END: report_error
+
+    fn peek(&self) -> Option<char> {
+        self.source_text[self.position..].chars().next()
+    }
+
+    // Returns a span ranging from `start_position` until the current position (exclusive)
+    fn span_from(&self, start_position: usize) -> Span<'db> {
+        Span::new(self.db, start_position, self.position)
+    }
+
+    fn consume(&mut self, ch: char) {
+        debug_assert!(self.peek() == Some(ch));
+        self.position += ch.len_utf8();
+    }
+
+    /// Skips whitespace and returns the new position.
+    fn skip_whitespace(&mut self) -> usize {
+        while let Some(ch) = self.peek() {
+            if ch.is_whitespace() {
+                self.consume(ch);
+            } else {
+                break;
+            }
+        }
+        self.position
+    }
+
+    // ANCHOR: parse_statement
+    fn parse_statement(&mut self) -> Option<Statement<'db>> {
+        let start_position = self.skip_whitespace();
+        let word = self.word()?;
+        if word == "fn" {
+            let func = self.parse_function()?;
+            Some(Statement::new(
+                self.span_from(start_position),
+                StatementData::Function(func),
+            ))
+        } else if word == "print" {
+            let expr = self.parse_expression()?;
+            Some(Statement::new(
+                self.span_from(start_position),
+                StatementData::Print(expr),
+            ))
+        } else {
+            None
+        }
+    }
+    // ANCHOR_END: parse_statement
+
+    // ANCHOR: parse_function
+    fn parse_function(&mut self) -> Option<Function<'db>> {
+        let start_position = self.skip_whitespace();
+        let name = self.word()?;
+        let name_span = self.span_from(start_position);
+        let name: FunctionId = FunctionId::new(self.db, name);
+        //                     ^^^^^^^^^^^^^^^
+        //                Create a new interned struct.
+        self.ch('(')?;
+        let args = self.parameters()?;
+        self.ch(')')?;
+        self.ch('=')?;
+        let body = self.parse_expression()?;
+        Some(Function::new(self.db, name, name_span, args, body))
+        //   ^^^^^^^^^^^^^
+        // Create a new entity struct.
+    }
+    // ANCHOR_END: parse_function
+
+    fn parse_expression(&mut self) -> Option<Expression<'db>> {
+        self.parse_op_expression(Self::parse_expression1, Self::low_op)
+    }
+
+    fn low_op(&mut self) -> Option<Op> {
+        if self.ch('+').is_some() {
+            Some(Op::Add)
+        } else if self.ch('-').is_some() {
+            Some(Op::Subtract)
+        } else {
+            None
+        }
+    }
+
+    /// Parses a high-precedence expression (times, div).
+    ///
+    /// On failure, skips arbitrary tokens.
+    fn parse_expression1(&mut self) -> Option<Expression<'db>> {
+        self.parse_op_expression(Self::parse_expression2, Self::high_op)
+    }
+
+    fn high_op(&mut self) -> Option<Op> {
+        if self.ch('*').is_some() {
+            Some(Op::Multiply)
+        } else if self.ch('/').is_some() {
+            Some(Op::Divide)
+        } else {
+            None
+        }
+    }
+
+    fn parse_op_expression(
+        &mut self,
+        mut parse_expr: impl FnMut(&mut Self) -> Option<Expression<'db>>,
+        mut op: impl FnMut(&mut Self) -> Option<Op>,
+    ) -> Option<Expression<'db>> {
+        let start_position = self.skip_whitespace();
+        let mut expr1 = parse_expr(self)?;
+
+        while let Some(op) = op(self) {
+            let expr2 = parse_expr(self)?;
+            expr1 = Expression::new(
+                self.span_from(start_position),
+                ExpressionData::Op(Box::new(expr1), op, Box::new(expr2)),
+            );
+        }
+
+        Some(expr1)
+    }
+
+    /// Parses a "base expression" (no operators).
+    ///
+    /// On failure, skips arbitrary tokens.
+    fn parse_expression2(&mut self) -> Option<Expression<'db>> {
+        let start_position = self.skip_whitespace();
+        if let Some(w) = self.word() {
+            if self.ch('(').is_some() {
+                let f = FunctionId::new(self.db, w);
+                let args = self.parse_expressions()?;
+                self.ch(')')?;
+                return Some(Expression::new(
+                    self.span_from(start_position),
+                    ExpressionData::Call(f, args),
+                ));
+            }
+
+            let v = VariableId::new(self.db, w);
+            Some(Expression::new(
+                self.span_from(start_position),
+                ExpressionData::Variable(v),
+            ))
+        } else if let Some(n) = self.number() {
+            Some(Expression::new(
+                self.span_from(start_position),
+                ExpressionData::Number(OrderedFloat::from(n)),
+            ))
+        } else if self.ch('(').is_some() {
+            let expr = self.parse_expression()?;
+            self.ch(')')?;
+            Some(expr)
+        } else {
+            None
+        }
+    }
+
+    fn parse_expressions(&mut self) -> Option<Vec<Expression<'db>>> {
+        let mut r = vec![];
+        loop {
+            let expr = self.parse_expression()?;
+            r.push(expr);
+            if self.ch(',').is_none() {
+                return Some(r);
+            }
+        }
+    }
+
+    /// Parses a list of variable identifiers, like `a, b, c`.
+    /// No trailing commas because I am lazy.
+    ///
+    /// On failure, skips arbitrary tokens.
+    fn parameters(&mut self) -> Option<Vec<VariableId<'db>>> {
+        let mut r = vec![];
+        loop {
+            let name = self.word()?;
+            let vid = VariableId::new(self.db, name);
+            r.push(vid);
+
+            if self.ch(',').is_none() {
+                return Some(r);
+            }
+        }
+    }
+
+    /// Parses a single character.
+    ///
+    /// Even on failure, only skips whitespace.
+    fn ch(&mut self, c: char) -> Option<Span<'db>> {
+        let start_position = self.skip_whitespace();
+        match self.peek() {
+            Some(p) if c == p => {
+                self.consume(c);
+                Some(self.span_from(start_position))
+            }
+            _ => None,
+        }
+    }
+
+    /// Parses an identifier.
+    ///
+    /// Even on failure, only skips whitespace.
+    fn word(&mut self) -> Option<String> {
+        self.skip_whitespace();
+
+        // In this loop, if we consume any characters, we always
+        // return `Some`.
+        let mut s = String::new();
+        let _position = self.position;
+        while let Some(ch) = self.peek() {
+            if ch.is_alphabetic() || ch == '_' || (!s.is_empty() && ch.is_numeric()) {
+                s.push(ch);
+            } else {
+                break;
+            }
+
+            self.consume(ch);
+        }
+
+        if s.is_empty() {
+            None
+        } else {
+            Some(s)
+        }
+    }
+
+    /// Parses a number.
+    ///
+    /// Even on failure, only skips whitespace.
+    fn number(&mut self) -> Option<f64> {
+        let _start_position = self.skip_whitespace();
+
+        self.probe(|this| {
+            //  We need the call to `probe` here because we could consume
+            //    some characters like `3.1.2.3`, invoke `str::parse`, and then
+            //    still return `None`.
+            let mut s = String::new();
+            while let Some(ch) = this.peek() {
+                if ch.is_numeric() || ch == '.' {
+                    s.push(ch);
+                } else {
+                    break;
+                }
+
+                this.consume(ch);
+            }
+
+            if s.is_empty() {
+                None
+            } else {
+                str::parse(&s).ok()
+            }
+        })
+    }
+}
+
+// ANCHOR: parse_string
+/// Create a new database with the given source text and parse the result.
+/// Returns the statements and the diagnostics generated.
+#[cfg(test)]
+fn parse_string(source_text: &str) -> String {
+    use salsa::Database;
+
+    use crate::db::CalcDatabaseImpl;
+
+    CalcDatabaseImpl::default().attach(|db| {
+        // Create the source program
+        let source_program = SourceProgram::new(db, source_text.to_string());
+
+        // Invoke the parser
+        let statements = parse_statements(db, source_program);
+
+        // Read out any diagnostics
+        let accumulated = parse_statements::accumulated::<Diagnostic>(db, source_program);
+
+        // Format the result as a string and return it
+        format!("{:#?}", (statements, accumulated))
+    })
+}
+// ANCHOR_END: parse_string
+
+// ANCHOR: parse_print
+#[test]
+fn parse_print() {
+    let actual = parse_string("print 1 + 2");
+    let expected = expect_test::expect![[r#"
+        (
+            Program {
+                [salsa id]: Id(800),
+                statements: [
+                    Statement {
+                        span: Span {
+                            [salsa id]: Id(404),
+                            start: 0,
+                            end: 11,
+                        },
+                        data: Print(
+                            Expression {
+                                span: Span {
+                                    [salsa id]: Id(403),
+                                    start: 6,
+                                    end: 11,
+                                },
+                                data: Op(
+                                    Expression {
+                                        span: Span {
+                                            [salsa id]: Id(400),
+                                            start: 6,
+                                            end: 7,
+                                        },
+                                        data: Number(
+                                            1.0,
+                                        ),
+                                    },
+                                    Add,
+                                    Expression {
+                                        span: Span {
+                                            [salsa id]: Id(402),
+                                            start: 10,
+                                            end: 11,
+                                        },
+                                        data: Number(
+                                            2.0,
+                                        ),
+                                    },
+                                ),
+                            },
+                        ),
+                    },
+                ],
+            },
+            [],
+        )"#]];
+    expected.assert_eq(&actual);
+}
+// ANCHOR_END: parse_print
+
+#[test]
+fn parse_example() {
+    let actual = parse_string(
+        "
+            fn area_rectangle(w, h) = w * h
+            fn area_circle(r) = 3.14 * r * r
+            print area_rectangle(3, 4)
+            print area_circle(1)
+            print 11 * 2
+        ",
+    );
+    let expected = expect_test::expect![[r#"
+        (
+            Program {
+                [salsa id]: Id(1400),
+                statements: [
+                    Statement {
+                        span: Span {
+                            [salsa id]: Id(409),
+                            start: 13,
+                            end: 57,
+                        },
+                        data: Function(
+                            Function {
+                                [salsa id]: Id(1000),
+                                name: FunctionId {
+                                    text: "area_rectangle",
+                                },
+                                name_span: Span {
+                                    [salsa id]: Id(400),
+                                    start: 16,
+                                    end: 30,
+                                },
+                                args: [
+                                    VariableId {
+                                        text: "w",
+                                    },
+                                    VariableId {
+                                        text: "h",
+                                    },
+                                ],
+                                body: Expression {
+                                    span: Span {
+                                        [salsa id]: Id(408),
+                                        start: 39,
+                                        end: 57,
+                                    },
+                                    data: Op(
+                                        Expression {
+                                            span: Span {
+                                                [salsa id]: Id(405),
+                                                start: 39,
+                                                end: 41,
+                                            },
+                                            data: Variable(
+                                                VariableId {
+                                                    text: "w",
+                                                },
+                                            ),
+                                        },
+                                        Multiply,
+                                        Expression {
+                                            span: Span {
+                                                [salsa id]: Id(407),
+                                                start: 43,
+                                                end: 57,
+                                            },
+                                            data: Variable(
+                                                VariableId {
+                                                    text: "h",
+                                                },
+                                            ),
+                                        },
+                                    ),
+                                },
+                            },
+                        ),
+                    },
+                    Statement {
+                        span: Span {
+                            [salsa id]: Id(415),
+                            start: 57,
+                            end: 102,
+                        },
+                        data: Function(
+                            Function {
+                                [salsa id]: Id(1001),
+                                name: FunctionId {
+                                    text: "area_circle",
+                                },
+                                name_span: Span {
+                                    [salsa id]: Id(40a),
+                                    start: 60,
+                                    end: 71,
+                                },
+                                args: [
+                                    VariableId {
+                                        text: "r",
+                                    },
+                                ],
+                                body: Expression {
+                                    span: Span {
+                                        [salsa id]: Id(414),
+                                        start: 77,
+                                        end: 102,
+                                    },
+                                    data: Op(
+                                        Expression {
+                                            span: Span {
+                                                [salsa id]: Id(411),
+                                                start: 77,
+                                                end: 86,
+                                            },
+                                            data: Op(
+                                                Expression {
+                                                    span: Span {
+                                                        [salsa id]: Id(40e),
+                                                        start: 77,
+                                                        end: 81,
+                                                    },
+                                                    data: Number(
+                                                        3.14,
+                                                    ),
+                                                },
+                                                Multiply,
+                                                Expression {
+                                                    span: Span {
+                                                        [salsa id]: Id(410),
+                                                        start: 84,
+                                                        end: 86,
+                                                    },
+                                                    data: Variable(
+                                                        VariableId {
+                                                            text: "r",
+                                                        },
+                                                    ),
+                                                },
+                                            ),
+                                        },
+                                        Multiply,
+                                        Expression {
+                                            span: Span {
+                                                [salsa id]: Id(413),
+                                                start: 88,
+                                                end: 102,
+                                            },
+                                            data: Variable(
+                                                VariableId {
+                                                    text: "r",
+                                                },
+                                            ),
+                                        },
+                                    ),
+                                },
+                            },
+                        ),
+                    },
+                    Statement {
+                        span: Span {
+                            [salsa id]: Id(41c),
+                            start: 102,
+                            end: 141,
+                        },
+                        data: Print(
+                            Expression {
+                                span: Span {
+                                    [salsa id]: Id(41b),
+                                    start: 108,
+                                    end: 128,
+                                },
+                                data: Call(
+                                    FunctionId {
+                                        text: "area_rectangle",
+                                    },
+                                    [
+                                        Expression {
+                                            span: Span {
+                                                [salsa id]: Id(417),
+                                                start: 123,
+                                                end: 124,
+                                            },
+                                            data: Number(
+                                                3.0,
+                                            ),
+                                        },
+                                        Expression {
+                                            span: Span {
+                                                [salsa id]: Id(419),
+                                                start: 126,
+                                                end: 127,
+                                            },
+                                            data: Number(
+                                                4.0,
+                                            ),
+                                        },
+                                    ],
+                                ),
+                            },
+                        ),
+                    },
+                    Statement {
+                        span: Span {
+                            [salsa id]: Id(421),
+                            start: 141,
+                            end: 174,
+                        },
+                        data: Print(
+                            Expression {
+                                span: Span {
+                                    [salsa id]: Id(420),
+                                    start: 147,
+                                    end: 161,
+                                },
+                                data: Call(
+                                    FunctionId {
+                                        text: "area_circle",
+                                    },
+                                    [
+                                        Expression {
+                                            span: Span {
+                                                [salsa id]: Id(41e),
+                                                start: 159,
+                                                end: 160,
+                                            },
+                                            data: Number(
+                                                1.0,
+                                            ),
+                                        },
+                                    ],
+                                ),
+                            },
+                        ),
+                    },
+                    Statement {
+                        span: Span {
+                            [salsa id]: Id(426),
+                            start: 174,
+                            end: 195,
+                        },
+                        data: Print(
+                            Expression {
+                                span: Span {
+                                    [salsa id]: Id(425),
+                                    start: 180,
+                                    end: 186,
+                                },
+                                data: Op(
+                                    Expression {
+                                        span: Span {
+                                            [salsa id]: Id(422),
+                                            start: 180,
+                                            end: 182,
+                                        },
+                                        data: Number(
+                                            11.0,
+                                        ),
+                                    },
+                                    Multiply,
+                                    Expression {
+                                        span: Span {
+                                            [salsa id]: Id(424),
+                                            start: 185,
+                                            end: 186,
+                                        },
+                                        data: Number(
+                                            2.0,
+                                        ),
+                                    },
+                                ),
+                            },
+                        ),
+                    },
+                ],
+            },
+            [],
+        )"#]];
+    expected.assert_eq(&actual);
+}
+
+#[test]
+fn parse_error() {
+    let source_text: &str = "print 1 + + 2";
+    //                       0123456789^ <-- this is the position 10, where the error is reported
+    let actual = parse_string(source_text);
+    let expected = expect_test::expect![[r#"
+        (
+            Program {
+                [salsa id]: Id(800),
+                statements: [],
+            },
+            [
+                Diagnostic {
+                    start: 10,
+                    end: 11,
+                    message: "unexpected character",
+                },
+            ],
+        )"#]];
+    expected.assert_eq(&actual);
+}
+
+#[test]
+fn parse_precedence() {
+    // this parses as `(1 + (2 * 3)) + 4`
+    let source_text: &str = "print 1 + 2 * 3 + 4";
+    let actual = parse_string(source_text);
+    let expected = expect_test::expect![[r#"
+        (
+            Program {
+                [salsa id]: Id(800),
+                statements: [
+                    Statement {
+                        span: Span {
+                            [salsa id]: Id(40a),
+                            start: 0,
+                            end: 19,
+                        },
+                        data: Print(
+                            Expression {
+                                span: Span {
+                                    [salsa id]: Id(409),
+                                    start: 6,
+                                    end: 19,
+                                },
+                                data: Op(
+                                    Expression {
+                                        span: Span {
+                                            [salsa id]: Id(406),
+                                            start: 6,
+                                            end: 16,
+                                        },
+                                        data: Op(
+                                            Expression {
+                                                span: Span {
+                                                    [salsa id]: Id(400),
+                                                    start: 6,
+                                                    end: 7,
+                                                },
+                                                data: Number(
+                                                    1.0,
+                                                ),
+                                            },
+                                            Add,
+                                            Expression {
+                                                span: Span {
+                                                    [salsa id]: Id(405),
+                                                    start: 10,
+                                                    end: 15,
+                                                },
+                                                data: Op(
+                                                    Expression {
+                                                        span: Span {
+                                                            [salsa id]: Id(402),
+                                                            start: 10,
+                                                            end: 11,
+                                                        },
+                                                        data: Number(
+                                                            2.0,
+                                                        ),
+                                                    },
+                                                    Multiply,
+                                                    Expression {
+                                                        span: Span {
+                                                            [salsa id]: Id(404),
+                                                            start: 14,
+                                                            end: 15,
+                                                        },
+                                                        data: Number(
+                                                            3.0,
+                                                        ),
+                                                    },
+                                                ),
+                                            },
+                                        ),
+                                    },
+                                    Add,
+                                    Expression {
+                                        span: Span {
+                                            [salsa id]: Id(408),
+                                            start: 18,
+                                            end: 19,
+                                        },
+                                        data: Number(
+                                            4.0,
+                                        ),
+                                    },
+                                ),
+                            },
+                        ),
+                    },
+                ],
+            },
+            [],
+        )"#]];
+    expected.assert_eq(&actual);
+}
diff --git a/crates/salsa/examples/calc/type_check.rs b/crates/salsa/examples/calc/type_check.rs
new file mode 100644
index 000000000..5757380cb
--- /dev/null
+++ b/crates/salsa/examples/calc/type_check.rs
@@ -0,0 +1,270 @@
+#[cfg(test)]
+use expect_test::expect;
+use salsa::Accumulator;
+#[cfg(test)]
+use test_log::test;
+
+use crate::ir::{
+    Diagnostic, Expression, Function, FunctionId, Program, Span, StatementData, VariableId,
+};
+
+// ANCHOR: parse_statements
+#[salsa::tracked]
+pub fn type_check_program<'db>(db: &'db dyn crate::Db, program: Program<'db>) {
+    for statement in program.statements(db) {
+        match &statement.data {
+            StatementData::Function(f) => type_check_function(db, *f, program),
+            StatementData::Print(e) => CheckExpression::new(db, program, &[]).check(e),
+        }
+    }
+}
+
+#[salsa::tracked]
+pub fn type_check_function<'db>(
+    db: &'db dyn crate::Db,
+    function: Function<'db>,
+    program: Program<'db>,
+) {
+    CheckExpression::new(db, program, function.args(db)).check(function.body(db))
+}
+
+#[salsa::tracked]
+pub fn find_function<'db>(
+    db: &'db dyn crate::Db,
+    program: Program<'db>,
+    name: FunctionId<'db>,
+) -> Option<Function<'db>> {
+    program
+        .statements(db)
+        .iter()
+        .flat_map(|s| match &s.data {
+            StatementData::Function(f) if f.name(db) == name => Some(*f),
+            _ => None,
+        })
+        .next()
+}
+
+struct CheckExpression<'input, 'db> {
+    db: &'db dyn crate::Db,
+    program: Program<'db>,
+    names_in_scope: &'input [VariableId<'db>],
+}
+
+impl<'input, 'db> CheckExpression<'input, 'db> {
+    pub fn new(
+        db: &'db dyn crate::Db,
+        program: Program<'db>,
+        names_in_scope: &'input [VariableId<'db>],
+    ) -> Self {
+        CheckExpression {
+            db,
+            program,
+            names_in_scope,
+        }
+    }
+}
+
+impl<'db> CheckExpression<'_, 'db> {
+    fn check(&self, expression: &Expression<'db>) {
+        match &expression.data {
+            crate::ir::ExpressionData::Op(left, _, right) => {
+                self.check(left);
+                self.check(right);
+            }
+            crate::ir::ExpressionData::Number(_) => {}
+            crate::ir::ExpressionData::Variable(v) => {
+                if !self.names_in_scope.contains(v) {
+                    self.report_error(
+                        expression.span,
+                        format!("the variable `{}` is not declared", v.text(self.db)),
+                    );
+                }
+            }
+            crate::ir::ExpressionData::Call(f, args) => {
+                if self.find_function(*f).is_none() {
+                    self.report_error(
+                        expression.span,
+                        format!("the function `{}` is not declared", f.text(self.db)),
+                    );
+                }
+                for arg in args {
+                    self.check(arg);
+                }
+            }
+        }
+    }
+
+    fn find_function(&self, f: FunctionId<'db>) -> Option<Function<'db>> {
+        find_function(self.db, self.program, f)
+    }
+
+    fn report_error(&self, span: Span, message: String) {
+        Diagnostic::new(span.start(self.db), span.end(self.db), message).accumulate(self.db);
+    }
+}
+
+/// Create a new database with the given source text and parse the result.
+/// Returns the statements and the diagnostics generated.
+#[cfg(test)]
+fn check_string(
+    source_text: &str,
+    expected_diagnostics: expect_test::Expect,
+    edits: &[(&str, expect_test::Expect)],
+) {
+    use salsa::{Database, Setter};
+
+    use crate::db::CalcDatabaseImpl;
+    use crate::ir::SourceProgram;
+    use crate::parser::parse_statements;
+
+    // Create the database
+    let mut db = CalcDatabaseImpl::default();
+    db.enable_logging();
+
+    // Create the source program
+    let source_program = SourceProgram::new(&db, source_text.to_string());
+
+    // Invoke the parser
+    let program = parse_statements(&db, source_program);
+
+    // Read out any diagnostics
+    db.attach(|db| {
+        let rendered_diagnostics: String =
+            type_check_program::accumulated::<Diagnostic>(db, program)
+                .into_iter()
+                .map(|d| d.render(db, source_program))
+                .collect::<Vec<_>>()
+                .join("\n");
+        expected_diagnostics.assert_eq(&rendered_diagnostics);
+    });
+
+    // Apply edits and check diagnostics/logs after each one
+    for (new_source_text, expected_diagnostics) in edits {
+        source_program
+            .set_text(&mut db)
+            .to(new_source_text.to_string());
+
+        db.attach(|db| {
+            let program = parse_statements(db, source_program);
+            expected_diagnostics
+                .assert_debug_eq(&type_check_program::accumulated::<Diagnostic>(db, program));
+        });
+    }
+}
+
+#[test]
+fn check_print() {
+    check_string("print 1 + 2", expect![""], &[]);
+}
+
+#[test]
+fn check_bad_variable_in_program() {
+    check_string(
+        "print a + b",
+        expect![[r#"
+            error: the variable `a` is not declared
+             --> input:2:7
+              |
+            2 | print a + b
+              |       ^^ here
+              |
+            error: the variable `b` is not declared
+             --> input:2:11
+              |
+            2 | print a + b
+              |           ^ here
+              |"#]],
+        &[],
+    );
+}
+
+#[test]
+fn check_bad_function_in_program() {
+    check_string(
+        "print a(22)",
+        expect![[r#"
+            error: the function `a` is not declared
+             --> input:2:7
+              |
+            2 | print a(22)
+              |       ^^^^^ here
+              |"#]],
+        &[],
+    );
+}
+
+#[test]
+fn check_bad_variable_in_function() {
+    check_string(
+        "
+            fn add_one(a) = a + b
+            print add_one(22)
+        ",
+        expect![[r#"
+            error: the variable `b` is not declared
+             --> input:4:33
+              |
+            4 |               fn add_one(a) = a + b
+              |  _________________________________^
+            5 | |             print add_one(22)
+              | |____________^ here
+              |"#]],
+        &[],
+    );
+}
+
+#[test]
+fn check_bad_function_in_function() {
+    check_string(
+        "
+            fn add_one(a) = add_two(a) + b
+            print add_one(22)
+        ",
+        expect![[r#"
+            error: the function `add_two` is not declared
+             --> input:4:29
+              |
+            4 |             fn add_one(a) = add_two(a) + b
+              |                             ^^^^^^^^^^ here
+              |
+            error: the variable `b` is not declared
+             --> input:4:42
+              |
+            4 |               fn add_one(a) = add_two(a) + b
+              |  __________________________________________^
+            5 | |             print add_one(22)
+              | |____________^ here
+              |"#]],
+        &[],
+    );
+}
+
+#[test]
+fn fix_bad_variable_in_function() {
+    check_string(
+        "
+            fn double(a) = a * b
+            fn quadruple(a) = double(double(a))
+            print quadruple(2)
+        ",
+        expect![[r#"
+            error: the variable `b` is not declared
+             --> input:4:32
+              |
+            4 |               fn double(a) = a * b
+              |  ________________________________^
+            5 | |             fn quadruple(a) = double(double(a))
+              | |____________^ here
+              |"#]],
+        &[(
+            "
+                fn double(a) = a * 2
+                fn quadruple(a) = double(double(a))
+                print quadruple(2)
+            ",
+            expect![[r#"
+                []
+            "#]],
+        )],
+    );
+}
diff --git a/crates/salsa/examples/lazy-input/inputs/a b/crates/salsa/examples/lazy-input/inputs/a
new file mode 100644
index 000000000..b85b3ca35
--- /dev/null
+++ b/crates/salsa/examples/lazy-input/inputs/a
@@ -0,0 +1,2 @@
+2
+./aa
diff --git a/crates/salsa/examples/lazy-input/inputs/aa b/crates/salsa/examples/lazy-input/inputs/aa
new file mode 100644
index 000000000..45a4fb75d
--- /dev/null
+++ b/crates/salsa/examples/lazy-input/inputs/aa
@@ -0,0 +1 @@
+8
diff --git a/crates/salsa/examples/lazy-input/inputs/b b/crates/salsa/examples/lazy-input/inputs/b
new file mode 100644
index 000000000..b8626c4cf
--- /dev/null
+++ b/crates/salsa/examples/lazy-input/inputs/b
@@ -0,0 +1 @@
+4
diff --git a/crates/salsa/examples/lazy-input/inputs/start b/crates/salsa/examples/lazy-input/inputs/start
new file mode 100644
index 000000000..966033263
--- /dev/null
+++ b/crates/salsa/examples/lazy-input/inputs/start
@@ -0,0 +1,3 @@
+1
+./a
+./b
diff --git a/crates/salsa/examples/lazy-input/main.rs b/crates/salsa/examples/lazy-input/main.rs
new file mode 100644
index 000000000..233d933de
--- /dev/null
+++ b/crates/salsa/examples/lazy-input/main.rs
@@ -0,0 +1,225 @@
+#![allow(unreachable_patterns)]
+// FIXME(rust-lang/rust#129031): regression in nightly
+use std::path::PathBuf;
+use std::sync::{Arc, Mutex};
+use std::time::Duration;
+
+use crossbeam_channel::{unbounded, Sender};
+use dashmap::mapref::entry::Entry;
+use dashmap::DashMap;
+use eyre::{eyre, Context, Report, Result};
+use notify_debouncer_mini::notify::{RecommendedWatcher, RecursiveMode};
+use notify_debouncer_mini::{new_debouncer, DebounceEventResult, Debouncer};
+use salsa::{Accumulator, Setter, Storage};
+
+// ANCHOR: main
+fn main() -> Result<()> {
+    // Create the channel to receive file change events.
+    let (tx, rx) = unbounded();
+    let mut db = LazyInputDatabase::new(tx);
+
+    let initial_file_path = std::env::args_os()
+        .nth(1)
+        .ok_or_else(|| eyre!("Usage: ./lazy-input <input-file>"))?;
+
+    // Create the initial input using the input method so that changes to it
+    // will be watched like the other files.
+    let initial = db.input(initial_file_path.into())?;
+    loop {
+        // Compile the code starting at the provided input, this will read other
+        // needed files using the on-demand mechanism.
+        let sum = compile(&db, initial);
+        let diagnostics = compile::accumulated::<Diagnostic>(&db, initial);
+        if diagnostics.is_empty() {
+            println!("Sum is: {sum}");
+        } else {
+            for diagnostic in diagnostics {
+                println!("{}", diagnostic.0);
+            }
+        }
+
+        for log in db.logs.lock().unwrap().drain(..) {
+            eprintln!("{log}");
+        }
+
+        // Wait for file change events, the output can't change unless the
+        // inputs change.
+        for event in rx.recv()?.unwrap() {
+            let path = event.path.canonicalize().wrap_err_with(|| {
+                format!("Failed to canonicalize path {}", event.path.display())
+            })?;
+            let file = match db.files.get(&path) {
+                Some(file) => *file,
+                None => continue,
+            };
+            // `path` has changed, so read it and update the contents to match.
+            // This creates a new revision and causes the incremental algorithm
+            // to kick in, just like any other update to a salsa input.
+            let contents = std::fs::read_to_string(path)
+                .wrap_err_with(|| format!("Failed to read file {}", event.path.display()))?;
+            file.set_contents(&mut db).to(contents);
+        }
+    }
+}
+// ANCHOR_END: main
+
+// ANCHOR: db
+#[salsa::input]
+struct File {
+    path: PathBuf,
+    #[returns(ref)]
+    contents: String,
+}
+
+#[salsa::db]
+trait Db: salsa::Database {
+    fn input(&self, path: PathBuf) -> Result<File>;
+}
+
+#[salsa::db]
+#[derive(Clone)]
+struct LazyInputDatabase {
+    storage: Storage<Self>,
+    logs: Arc<Mutex<Vec<String>>>,
+    files: DashMap<PathBuf, File>,
+    file_watcher: Arc<Mutex<Debouncer<RecommendedWatcher>>>,
+}
+
+impl LazyInputDatabase {
+    fn new(tx: Sender<DebounceEventResult>) -> Self {
+        let logs: Arc<Mutex<Vec<String>>> = Default::default();
+        Self {
+            storage: Storage::new(Some(Box::new({
+                let logs = logs.clone();
+                move |event| {
+                    // don't log boring events
+                    if let salsa::EventKind::WillExecute { .. } = event.kind {
+                        logs.lock().unwrap().push(format!("{event:?}"));
+                    }
+                }
+            }))),
+            logs,
+            files: DashMap::new(),
+            file_watcher: Arc::new(Mutex::new(
+                new_debouncer(Duration::from_secs(1), tx).unwrap(),
+            )),
+        }
+    }
+}
+
+#[salsa::db]
+impl salsa::Database for LazyInputDatabase {}
+
+#[salsa::db]
+impl Db for LazyInputDatabase {
+    fn input(&self, path: PathBuf) -> Result<File> {
+        let path = path
+            .canonicalize()
+            .wrap_err_with(|| format!("Failed to read {}", path.display()))?;
+        Ok(match self.files.entry(path.clone()) {
+            // If the file already exists in our cache then just return it.
+            Entry::Occupied(entry) => *entry.get(),
+            // If we haven't read this file yet set up the watch, read the
+            // contents, store it in the cache, and return it.
+            Entry::Vacant(entry) => {
+                // Set up the watch before reading the contents to try to avoid
+                // race conditions.
+                let watcher = &mut *self.file_watcher.lock().unwrap();
+                watcher
+                    .watcher()
+                    .watch(&path, RecursiveMode::NonRecursive)
+                    .unwrap();
+                let contents = std::fs::read_to_string(&path)
+                    .wrap_err_with(|| format!("Failed to read {}", path.display()))?;
+                *entry.insert(File::new(self, path, contents))
+            }
+        })
+    }
+}
+// ANCHOR_END: db
+
+#[salsa::accumulator]
+struct Diagnostic(String);
+
+impl Diagnostic {
+    fn push_error(db: &dyn Db, file: File, error: Report) {
+        Diagnostic(format!(
+            "Error in file {}: {:?}\n",
+            file.path(db)
+                .file_name()
+                .unwrap_or_else(|| "<unknown>".as_ref())
+                .to_string_lossy(),
+            error,
+        ))
+        .accumulate(db);
+    }
+}
+
+#[salsa::tracked]
+struct ParsedFile<'db> {
+    value: u32,
+    #[returns(ref)]
+    links: Vec<ParsedFile<'db>>,
+}
+
+#[salsa::tracked]
+fn compile(db: &dyn Db, input: File) -> u32 {
+    let parsed = parse(db, input);
+    sum(db, parsed)
+}
+
+#[salsa::tracked]
+fn parse(db: &dyn Db, input: File) -> ParsedFile<'_> {
+    let mut lines = input.contents(db).lines();
+    let value = match lines.next().map(|line| (line.parse::<u32>(), line)) {
+        Some((Ok(num), _)) => num,
+        Some((Err(e), line)) => {
+            Diagnostic::push_error(
+                db,
+                input,
+                Report::new(e).wrap_err(format!(
+                    "First line ({line}) could not be parsed as an integer"
+                )),
+            );
+            0
+        }
+        None => {
+            Diagnostic::push_error(db, input, eyre!("File must contain an integer"));
+            0
+        }
+    };
+    let links = lines
+        .filter_map(|path| {
+            let relative_path = match path.parse::<PathBuf>() {
+                Ok(path) => path,
+                Err(err) => {
+                    Diagnostic::push_error(
+                        db,
+                        input,
+                        Report::new(err).wrap_err(format!("Failed to parse path: {path}")),
+                    );
+                    return None;
+                }
+            };
+            let link_path = input.path(db).parent().unwrap().join(relative_path);
+            match db.input(link_path) {
+                Ok(file) => Some(parse(db, file)),
+                Err(err) => {
+                    Diagnostic::push_error(db, input, err);
+                    None
+                }
+            }
+        })
+        .collect();
+    ParsedFile::new(db, value, links)
+}
+
+#[salsa::tracked]
+fn sum<'db>(db: &'db dyn Db, input: ParsedFile<'db>) -> u32 {
+    input.value(db)
+        + input
+            .links(db)
+            .iter()
+            .map(|&file| sum(db, file))
+            .sum::<u32>()
+}
diff --git a/crates/salsa/justfile b/crates/salsa/justfile
new file mode 100644
index 000000000..d397f66b8
--- /dev/null
+++ b/crates/salsa/justfile
@@ -0,0 +1,10 @@
+test:
+    cargo test --workspace --all-features --all-targets --no-fail-fast
+
+miri:
+    cargo +nightly miri test --no-fail-fast --all-features
+
+loom:
+    RUSTFLAGS="--cfg loom" cargo check --workspace --features loom
+
+all: test miri
diff --git a/crates/salsa/release-plz.toml b/crates/salsa/release-plz.toml
new file mode 100644
index 000000000..3fca3f6ac
--- /dev/null
+++ b/crates/salsa/release-plz.toml
@@ -0,0 +1,11 @@
+[[package]]
+name = "salsa"
+version_group = "salsa"
+
+[[package]]
+name = "salsa-macros"
+version_group = "salsa"
+
+[[package]]
+name = "salsa-macro-rules"
+version_group = "salsa"
diff --git a/crates/salsa/src/accumulator.rs b/crates/salsa/src/accumulator.rs
new file mode 100644
index 000000000..35808d6d2
--- /dev/null
+++ b/crates/salsa/src/accumulator.rs
@@ -0,0 +1,132 @@
+//! Basic test of accumulator functionality.
+
+use std::any::{Any, TypeId};
+use std::fmt;
+use std::marker::PhantomData;
+use std::panic::UnwindSafe;
+
+use accumulated::{Accumulated, AnyAccumulated};
+
+use crate::cycle::CycleHeads;
+use crate::function::VerifyResult;
+use crate::ingredient::{Ingredient, Jar};
+use crate::loom::sync::Arc;
+use crate::plumbing::{IngredientIndices, ZalsaLocal};
+use crate::table::memo::MemoTableTypes;
+use crate::zalsa::{IngredientIndex, Zalsa};
+use crate::{Database, Id, Revision};
+
+mod accumulated;
+pub(crate) mod accumulated_map;
+
+/// Trait implemented on the struct that user annotated with `#[salsa::accumulator]`.
+/// The `Self` type is therefore the types to be accumulated.
+pub trait Accumulator: Send + Sync + Any + Sized + UnwindSafe {
+    const DEBUG_NAME: &'static str;
+
+    /// Accumulate an instance of this in the database for later retrieval.
+    fn accumulate<Db>(self, db: &Db)
+    where
+        Db: ?Sized + Database;
+}
+
+pub struct JarImpl<A: Accumulator> {
+    phantom: PhantomData<A>,
+}
+
+impl<A: Accumulator> Default for JarImpl<A> {
+    fn default() -> Self {
+        Self {
+            phantom: Default::default(),
+        }
+    }
+}
+
+impl<A: Accumulator> Jar for JarImpl<A> {
+    fn create_ingredients(
+        _zalsa: &Zalsa,
+        first_index: IngredientIndex,
+        _dependencies: IngredientIndices,
+    ) -> Vec<Box<dyn Ingredient>> {
+        vec![Box::new(<IngredientImpl<A>>::new(first_index))]
+    }
+
+    fn id_struct_type_id() -> TypeId {
+        TypeId::of::<A>()
+    }
+}
+
+pub struct IngredientImpl<A: Accumulator> {
+    index: IngredientIndex,
+    phantom: PhantomData<Accumulated<A>>,
+}
+
+impl<A: Accumulator> IngredientImpl<A> {
+    /// Find the accumulator ingredient for `A` in the database, if any.
+    pub fn from_zalsa(zalsa: &Zalsa) -> Option<&Self> {
+        let index = zalsa.add_or_lookup_jar_by_type::<JarImpl<A>>();
+        let ingredient = zalsa.lookup_ingredient(index).assert_type::<Self>();
+        Some(ingredient)
+    }
+
+    pub fn new(index: IngredientIndex) -> Self {
+        Self {
+            index,
+            phantom: PhantomData,
+        }
+    }
+
+    pub fn push(&self, zalsa_local: &ZalsaLocal, value: A) {
+        if let Err(()) = zalsa_local.accumulate(self.index, value) {
+            panic!("cannot accumulate values outside of an active tracked function");
+        }
+    }
+
+    pub fn index(&self) -> IngredientIndex {
+        self.index
+    }
+}
+
+impl<A: Accumulator> Ingredient for IngredientImpl<A> {
+    fn location(&self) -> &'static crate::ingredient::Location {
+        &const {
+            crate::ingredient::Location {
+                file: file!(),
+                line: line!(),
+            }
+        }
+    }
+
+    fn ingredient_index(&self) -> IngredientIndex {
+        self.index
+    }
+
+    unsafe fn maybe_changed_after(
+        &self,
+        _db: &dyn Database,
+        _input: Id,
+        _revision: Revision,
+        _cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        panic!("nothing should ever depend on an accumulator directly")
+    }
+
+    fn debug_name(&self) -> &'static str {
+        A::DEBUG_NAME
+    }
+
+    fn memo_table_types(&self) -> Arc<MemoTableTypes> {
+        unreachable!("accumulator does not allocate pages")
+    }
+}
+
+impl<A> std::fmt::Debug for IngredientImpl<A>
+where
+    A: Accumulator,
+{
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct(std::any::type_name::<Self>())
+            .field("index", &self.index)
+            .finish()
+    }
+}
diff --git a/crates/salsa/src/accumulator/accumulated.rs b/crates/salsa/src/accumulator/accumulated.rs
new file mode 100644
index 000000000..2102a0eda
--- /dev/null
+++ b/crates/salsa/src/accumulator/accumulated.rs
@@ -0,0 +1,54 @@
+use std::any::Any;
+use std::fmt::Debug;
+
+use crate::accumulator::Accumulator;
+
+#[derive(Clone, Debug)]
+pub(crate) struct Accumulated<A: Accumulator> {
+    values: Vec<A>,
+}
+
+pub(crate) trait AnyAccumulated: Any + Send + Sync {
+    fn as_dyn_any(&self) -> &dyn Any;
+    fn as_dyn_any_mut(&mut self) -> &mut dyn Any;
+}
+
+impl<A: Accumulator> Accumulated<A> {
+    pub fn push(&mut self, value: A) {
+        self.values.push(value);
+    }
+
+    pub fn extend_with_accumulated<'slf>(&'slf self, values: &mut Vec<&'slf A>) {
+        values.extend(&self.values);
+    }
+}
+
+impl<A: Accumulator> Default for Accumulated<A> {
+    fn default() -> Self {
+        Self {
+            values: Default::default(),
+        }
+    }
+}
+
+impl<A> AnyAccumulated for Accumulated<A>
+where
+    A: Accumulator,
+{
+    fn as_dyn_any(&self) -> &dyn Any {
+        self
+    }
+
+    fn as_dyn_any_mut(&mut self) -> &mut dyn Any {
+        self
+    }
+}
+
+impl dyn AnyAccumulated {
+    pub fn accumulate<A: Accumulator>(&mut self, value: A) {
+        self.as_dyn_any_mut()
+            .downcast_mut::<Accumulated<A>>()
+            .unwrap()
+            .push(value);
+    }
+}
diff --git a/crates/salsa/src/accumulator/accumulated_map.rs b/crates/salsa/src/accumulator/accumulated_map.rs
new file mode 100644
index 000000000..c1b466262
--- /dev/null
+++ b/crates/salsa/src/accumulator/accumulated_map.rs
@@ -0,0 +1,146 @@
+use std::ops;
+
+use rustc_hash::FxHashMap;
+
+use crate::accumulator::accumulated::Accumulated;
+use crate::accumulator::{Accumulator, AnyAccumulated};
+use crate::loom::sync::atomic::{AtomicBool, Ordering};
+use crate::IngredientIndex;
+
+#[derive(Default)]
+pub struct AccumulatedMap {
+    map: FxHashMap<IngredientIndex, Box<dyn AnyAccumulated>>,
+}
+
+impl std::fmt::Debug for AccumulatedMap {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("AccumulatedMap")
+            .field("map", &self.map.keys())
+            .finish()
+    }
+}
+
+impl AccumulatedMap {
+    pub fn accumulate<A: Accumulator>(&mut self, index: IngredientIndex, value: A) {
+        self.map
+            .entry(index)
+            .or_insert_with(|| <Box<Accumulated<A>>>::default())
+            .accumulate(value);
+    }
+
+    pub fn extend_with_accumulated<'slf, A: Accumulator>(
+        &'slf self,
+        index: IngredientIndex,
+        output: &mut Vec<&'slf A>,
+    ) {
+        let Some(a) = self.map.get(&index) else {
+            return;
+        };
+
+        a.as_dyn_any()
+            .downcast_ref::<Accumulated<A>>()
+            .unwrap()
+            .extend_with_accumulated(output);
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.map.is_empty()
+    }
+
+    pub fn clear(&mut self) {
+        self.map.clear()
+    }
+}
+
+/// Tracks whether any input read during a query's execution has any accumulated values.
+///
+/// Knowning whether any input has accumulated values makes aggregating the accumulated values
+/// cheaper because we can skip over entire subtrees.
+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
+pub enum InputAccumulatedValues {
+    /// The query nor any of its inputs have any accumulated values.
+    #[default]
+    Empty,
+
+    /// The query or any of its inputs have at least one accumulated value.
+    Any,
+}
+
+impl InputAccumulatedValues {
+    pub const fn is_any(self) -> bool {
+        matches!(self, Self::Any)
+    }
+
+    pub const fn is_empty(self) -> bool {
+        matches!(self, Self::Empty)
+    }
+
+    pub fn or_else(self, other: impl FnOnce() -> Self) -> Self {
+        if self.is_any() {
+            Self::Any
+        } else {
+            other()
+        }
+    }
+}
+
+impl ops::BitOr for InputAccumulatedValues {
+    type Output = Self;
+
+    fn bitor(self, rhs: Self) -> Self::Output {
+        match (self, rhs) {
+            (Self::Any, _) | (_, Self::Any) => Self::Any,
+            (Self::Empty, Self::Empty) => Self::Empty,
+        }
+    }
+}
+
+impl ops::BitOrAssign for InputAccumulatedValues {
+    fn bitor_assign(&mut self, rhs: Self) {
+        *self = *self | rhs;
+    }
+}
+
+#[derive(Debug, Default)]
+pub struct AtomicInputAccumulatedValues(AtomicBool);
+
+impl Clone for AtomicInputAccumulatedValues {
+    fn clone(&self) -> Self {
+        Self(AtomicBool::new(self.0.load(Ordering::Relaxed)))
+    }
+}
+
+impl AtomicInputAccumulatedValues {
+    pub(crate) fn new(accumulated_inputs: InputAccumulatedValues) -> Self {
+        Self(AtomicBool::new(accumulated_inputs.is_any()))
+    }
+
+    pub(crate) fn store(&self, accumulated: InputAccumulatedValues) {
+        self.0.store(accumulated.is_any(), Ordering::Release);
+    }
+
+    pub(crate) fn load(&self) -> InputAccumulatedValues {
+        if self.0.load(Ordering::Acquire) {
+            InputAccumulatedValues::Any
+        } else {
+            InputAccumulatedValues::Empty
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn atomic_input_accumulated_values() {
+        let val = AtomicInputAccumulatedValues::new(InputAccumulatedValues::Empty);
+        assert_eq!(val.load(), InputAccumulatedValues::Empty);
+        val.store(InputAccumulatedValues::Any);
+        assert_eq!(val.load(), InputAccumulatedValues::Any);
+        let val = AtomicInputAccumulatedValues::new(InputAccumulatedValues::Any);
+        assert_eq!(val.load(), InputAccumulatedValues::Any);
+        val.store(InputAccumulatedValues::Empty);
+        assert_eq!(val.load(), InputAccumulatedValues::Empty);
+    }
+}
diff --git a/crates/salsa/src/active_query.rs b/crates/salsa/src/active_query.rs
new file mode 100644
index 000000000..8f52c4265
--- /dev/null
+++ b/crates/salsa/src/active_query.rs
@@ -0,0 +1,478 @@
+use std::ops::Not;
+use std::{fmt, mem, ops};
+
+use crate::accumulator::accumulated_map::{
+    AccumulatedMap, AtomicInputAccumulatedValues, InputAccumulatedValues,
+};
+use crate::cycle::CycleHeads;
+use crate::durability::Durability;
+use crate::hash::FxIndexSet;
+use crate::key::DatabaseKeyIndex;
+use crate::loom::sync::atomic::AtomicBool;
+use crate::runtime::Stamp;
+use crate::tracked_struct::{Disambiguator, DisambiguatorMap, IdentityHash, IdentityMap};
+use crate::zalsa_local::{QueryEdge, QueryEdges, QueryOrigin, QueryRevisions};
+use crate::{Accumulator, IngredientIndex, Revision};
+
+#[derive(Debug)]
+pub(crate) struct ActiveQuery {
+    /// What query is executing
+    pub(crate) database_key_index: DatabaseKeyIndex,
+
+    /// Minimum durability of inputs observed so far.
+    durability: Durability,
+
+    /// Maximum revision of all inputs observed. If we observe an
+    /// untracked read, this will be set to the most recent revision.
+    changed_at: Revision,
+
+    /// Inputs: Set of subqueries that were accessed thus far.
+    /// Outputs: Tracks values written by this query. Could be...
+    ///
+    /// * tracked structs created
+    /// * invocations of `specify`
+    /// * accumulators pushed to
+    input_outputs: FxIndexSet<QueryEdge>,
+
+    /// True if there was an untracked read.
+    untracked_read: bool,
+
+    /// When new tracked structs are created, their data is hashed, and the resulting
+    /// hash is added to this map. If it is not present, then the disambiguator is 0.
+    /// Otherwise it is 1 more than the current value (which is incremented).
+    ///
+    /// This table starts empty as the query begins and is gradually populated.
+    /// Note that if a query executes in 2 different revisions but creates the same
+    /// set of tracked structs, they will get the same disambiguator values.
+    disambiguator_map: DisambiguatorMap,
+
+    /// Map from tracked struct keys (which include the hash + disambiguator) to their
+    /// final id.
+    pub(crate) tracked_struct_ids: IdentityMap,
+
+    /// Stores the values accumulated to the given ingredient.
+    /// The type of accumulated value is erased but known to the ingredient.
+    accumulated: AccumulatedMap,
+
+    /// [`InputAccumulatedValues::Empty`] if any input read during the query's execution
+    /// has any accumulated values.
+    accumulated_inputs: InputAccumulatedValues,
+
+    /// Provisional cycle results that this query depends on.
+    cycle_heads: CycleHeads,
+
+    /// If this query is a cycle head, iteration count of that cycle.
+    iteration_count: u32,
+}
+
+impl ActiveQuery {
+    pub(super) fn seed_iteration(
+        &mut self,
+        durability: Durability,
+        changed_at: Revision,
+        edges: &[QueryEdge],
+        untracked_read: bool,
+    ) {
+        assert!(self.input_outputs.is_empty());
+        self.input_outputs = edges.iter().cloned().collect();
+        self.durability = self.durability.min(durability);
+        self.changed_at = self.changed_at.max(changed_at);
+        self.untracked_read |= untracked_read;
+    }
+
+    pub(super) fn add_read(
+        &mut self,
+        input: DatabaseKeyIndex,
+        durability: Durability,
+        changed_at: Revision,
+        has_accumulated: bool,
+        accumulated_inputs: &AtomicInputAccumulatedValues,
+        cycle_heads: &CycleHeads,
+    ) {
+        self.durability = self.durability.min(durability);
+        self.changed_at = self.changed_at.max(changed_at);
+        self.input_outputs.insert(QueryEdge::Input(input));
+        self.accumulated_inputs = self.accumulated_inputs.or_else(|| match has_accumulated {
+            true => InputAccumulatedValues::Any,
+            false => accumulated_inputs.load(),
+        });
+        self.cycle_heads.extend(cycle_heads);
+    }
+
+    pub(super) fn add_read_simple(
+        &mut self,
+        input: DatabaseKeyIndex,
+        durability: Durability,
+        revision: Revision,
+    ) {
+        self.durability = self.durability.min(durability);
+        self.changed_at = self.changed_at.max(revision);
+        self.input_outputs.insert(QueryEdge::Input(input));
+    }
+
+    pub(super) fn add_untracked_read(&mut self, changed_at: Revision) {
+        self.untracked_read = true;
+        self.durability = Durability::MIN;
+        self.changed_at = changed_at;
+    }
+
+    pub(super) fn add_synthetic_read(&mut self, durability: Durability, revision: Revision) {
+        self.untracked_read = true;
+        self.durability = self.durability.min(durability);
+        self.changed_at = self.changed_at.max(revision);
+    }
+
+    pub(super) fn accumulate(&mut self, index: IngredientIndex, value: impl Accumulator) {
+        self.accumulated.accumulate(index, value);
+    }
+
+    /// Adds a key to our list of outputs.
+    pub(super) fn add_output(&mut self, key: DatabaseKeyIndex) {
+        self.input_outputs.insert(QueryEdge::Output(key));
+    }
+
+    /// True if the given key was output by this query.
+    pub(super) fn is_output(&self, key: DatabaseKeyIndex) -> bool {
+        self.input_outputs.contains(&QueryEdge::Output(key))
+    }
+
+    pub(super) fn disambiguate(&mut self, key: IdentityHash) -> Disambiguator {
+        self.disambiguator_map.disambiguate(key)
+    }
+
+    pub(super) fn stamp(&self) -> Stamp {
+        Stamp {
+            value: (),
+            durability: self.durability,
+            changed_at: self.changed_at,
+        }
+    }
+
+    pub(super) fn iteration_count(&self) -> u32 {
+        self.iteration_count
+    }
+}
+
+impl ActiveQuery {
+    fn new(database_key_index: DatabaseKeyIndex, iteration_count: u32) -> Self {
+        ActiveQuery {
+            database_key_index,
+            durability: Durability::MAX,
+            changed_at: Revision::start(),
+            input_outputs: FxIndexSet::default(),
+            untracked_read: false,
+            disambiguator_map: Default::default(),
+            tracked_struct_ids: Default::default(),
+            accumulated: Default::default(),
+            accumulated_inputs: Default::default(),
+            cycle_heads: Default::default(),
+            iteration_count,
+        }
+    }
+
+    fn top_into_revisions(&mut self) -> QueryRevisions {
+        let &mut Self {
+            database_key_index: _,
+            durability,
+            changed_at,
+            ref mut input_outputs,
+            untracked_read,
+            ref mut disambiguator_map,
+            ref mut tracked_struct_ids,
+            ref mut accumulated,
+            accumulated_inputs,
+            ref mut cycle_heads,
+            iteration_count: _,
+        } = self;
+
+        let edges = QueryEdges::new(input_outputs.drain(..));
+        let origin = if untracked_read {
+            QueryOrigin::DerivedUntracked(edges)
+        } else {
+            QueryOrigin::Derived(edges)
+        };
+        disambiguator_map.clear();
+        let accumulated = accumulated
+            .is_empty()
+            .not()
+            .then(|| Box::new(mem::take(accumulated)));
+        let tracked_struct_ids = mem::take(tracked_struct_ids);
+        let accumulated_inputs = AtomicInputAccumulatedValues::new(accumulated_inputs);
+        let cycle_heads = mem::take(cycle_heads);
+        QueryRevisions {
+            changed_at,
+            durability,
+            origin,
+            tracked_struct_ids,
+            accumulated_inputs,
+            accumulated,
+            verified_final: AtomicBool::new(cycle_heads.is_empty()),
+            cycle_heads,
+        }
+    }
+
+    fn clear(&mut self) {
+        let Self {
+            database_key_index: _,
+            durability: _,
+            changed_at: _,
+            input_outputs,
+            untracked_read: _,
+            disambiguator_map,
+            tracked_struct_ids,
+            accumulated,
+            accumulated_inputs: _,
+            cycle_heads,
+            iteration_count,
+        } = self;
+        input_outputs.clear();
+        disambiguator_map.clear();
+        tracked_struct_ids.clear();
+        accumulated.clear();
+        *cycle_heads = Default::default();
+        *iteration_count = 0;
+    }
+
+    fn reset_for(&mut self, new_database_key_index: DatabaseKeyIndex, new_iteration_count: u32) {
+        let Self {
+            database_key_index,
+            durability,
+            changed_at,
+            input_outputs,
+            untracked_read,
+            disambiguator_map,
+            tracked_struct_ids,
+            accumulated,
+            accumulated_inputs,
+            cycle_heads,
+            iteration_count,
+        } = self;
+        *database_key_index = new_database_key_index;
+        *durability = Durability::MAX;
+        *changed_at = Revision::start();
+        *untracked_read = false;
+        *accumulated_inputs = Default::default();
+        *iteration_count = new_iteration_count;
+        debug_assert!(
+            input_outputs.is_empty(),
+            "`ActiveQuery::clear` or `ActiveQuery::into_revisions` should've been called"
+        );
+        debug_assert!(
+            disambiguator_map.is_empty(),
+            "`ActiveQuery::clear` or `ActiveQuery::into_revisions` should've been called"
+        );
+        debug_assert!(
+            tracked_struct_ids.is_empty(),
+            "`ActiveQuery::clear` or `ActiveQuery::into_revisions` should've been called"
+        );
+        debug_assert!(
+            cycle_heads.is_empty(),
+            "`ActiveQuery::clear` or `ActiveQuery::into_revisions` should've been called"
+        );
+        debug_assert!(
+            accumulated.is_empty(),
+            "`ActiveQuery::clear` or `ActiveQuery::into_revisions` should've been called"
+        );
+    }
+}
+
+#[derive(Default)]
+pub(crate) struct QueryStack {
+    stack: Vec<ActiveQuery>,
+    len: usize,
+}
+
+impl std::fmt::Debug for QueryStack {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        if f.alternate() {
+            f.debug_list()
+                .entries(self.stack.iter().map(|q| q.database_key_index))
+                .finish()
+        } else {
+            f.debug_struct("QueryStack")
+                .field("stack", &self.stack)
+                .field("len", &self.len)
+                .finish()
+        }
+    }
+}
+
+impl ops::Deref for QueryStack {
+    type Target = [ActiveQuery];
+
+    #[inline(always)]
+    fn deref(&self) -> &Self::Target {
+        &self.stack[..self.len]
+    }
+}
+
+impl ops::DerefMut for QueryStack {
+    #[inline(always)]
+    fn deref_mut(&mut self) -> &mut Self::Target {
+        &mut self.stack[..self.len]
+    }
+}
+
+impl QueryStack {
+    pub(crate) fn push_new_query(
+        &mut self,
+        database_key_index: DatabaseKeyIndex,
+        iteration_count: u32,
+    ) {
+        if self.len < self.stack.len() {
+            self.stack[self.len].reset_for(database_key_index, iteration_count);
+        } else {
+            self.stack
+                .push(ActiveQuery::new(database_key_index, iteration_count));
+        }
+        self.len += 1;
+    }
+
+    #[cfg(debug_assertions)]
+    pub(crate) fn len(&self) -> usize {
+        self.len
+    }
+
+    pub(crate) fn pop_into_revisions(
+        &mut self,
+        key: DatabaseKeyIndex,
+        #[cfg(debug_assertions)] push_len: usize,
+    ) -> QueryRevisions {
+        #[cfg(debug_assertions)]
+        assert_eq!(push_len, self.len(), "unbalanced push/pop");
+        debug_assert_ne!(self.len, 0, "too many pops");
+        self.len -= 1;
+        debug_assert_eq!(
+            self.stack[self.len].database_key_index, key,
+            "unbalanced push/pop"
+        );
+        self.stack[self.len].top_into_revisions()
+    }
+
+    pub(crate) fn pop(&mut self, key: DatabaseKeyIndex, #[cfg(debug_assertions)] push_len: usize) {
+        #[cfg(debug_assertions)]
+        assert_eq!(push_len, self.len(), "unbalanced push/pop");
+        debug_assert_ne!(self.len, 0, "too many pops");
+        self.len -= 1;
+        debug_assert_eq!(
+            self.stack[self.len].database_key_index, key,
+            "unbalanced push/pop"
+        );
+        self.stack[self.len].clear()
+    }
+}
+
+struct CapturedQuery {
+    database_key_index: DatabaseKeyIndex,
+    durability: Durability,
+    changed_at: Revision,
+    cycle_heads: CycleHeads,
+    iteration_count: u32,
+}
+
+impl fmt::Debug for CapturedQuery {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        let mut debug_struct = f.debug_struct("CapturedQuery");
+        debug_struct
+            .field("database_key_index", &self.database_key_index)
+            .field("durability", &self.durability)
+            .field("changed_at", &self.changed_at);
+        if !self.cycle_heads.is_empty() {
+            debug_struct
+                .field("cycle_heads", &self.cycle_heads)
+                .field("iteration_count", &self.iteration_count);
+        }
+        debug_struct.finish()
+    }
+}
+
+pub struct Backtrace(Box<[CapturedQuery]>);
+
+impl Backtrace {
+    pub fn capture() -> Option<Self> {
+        crate::with_attached_database(|db| {
+            db.zalsa_local().try_with_query_stack(|stack| {
+                Backtrace(
+                    stack
+                        .iter()
+                        .rev()
+                        .map(|query| CapturedQuery {
+                            database_key_index: query.database_key_index,
+                            durability: query.durability,
+                            changed_at: query.changed_at,
+                            cycle_heads: query.cycle_heads.clone(),
+                            iteration_count: query.iteration_count,
+                        })
+                        .collect(),
+                )
+            })
+        })?
+    }
+}
+
+impl fmt::Debug for Backtrace {
+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(fmt, "Backtrace ")?;
+
+        let mut dbg = fmt.debug_list();
+
+        for frame in &self.0 {
+            dbg.entry(&frame);
+        }
+
+        dbg.finish()
+    }
+}
+
+impl fmt::Display for Backtrace {
+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
+        writeln!(fmt, "query stacktrace:")?;
+        let full = fmt.alternate();
+        let indent = "             ";
+        for (
+            idx,
+            &CapturedQuery {
+                database_key_index,
+                durability,
+                changed_at,
+                ref cycle_heads,
+                iteration_count,
+            },
+        ) in self.0.iter().enumerate()
+        {
+            write!(fmt, "{idx:>4}: {database_key_index:?}")?;
+            if full {
+                write!(fmt, " -> ({changed_at:?}, {durability:#?}")?;
+                if !cycle_heads.is_empty() || iteration_count > 0 {
+                    write!(fmt, ", iteration = {iteration_count:?}")?;
+                }
+                write!(fmt, ")")?;
+            }
+            writeln!(fmt)?;
+            crate::attach::with_attached_database(|db| {
+                let ingredient = db
+                    .zalsa()
+                    .lookup_ingredient(database_key_index.ingredient_index());
+                let loc = ingredient.location();
+                writeln!(fmt, "{indent}at {}:{}", loc.file, loc.line)?;
+                if !cycle_heads.is_empty() {
+                    write!(fmt, "{indent}cycle heads: ")?;
+                    for (idx, head) in cycle_heads.iter().enumerate() {
+                        if idx != 0 {
+                            write!(fmt, ", ")?;
+                        }
+                        write!(
+                            fmt,
+                            "{:?} -> {:?}",
+                            head.database_key_index, head.iteration_count
+                        )?;
+                    }
+                    writeln!(fmt)?;
+                }
+                Ok(())
+            })
+            .transpose()?;
+        }
+        Ok(())
+    }
+}
diff --git a/crates/salsa/src/attach.rs b/crates/salsa/src/attach.rs
new file mode 100644
index 000000000..7324eb35d
--- /dev/null
+++ b/crates/salsa/src/attach.rs
@@ -0,0 +1,125 @@
+use std::ptr::NonNull;
+
+use crate::loom::cell::Cell;
+use crate::Database;
+
+#[cfg(loom)]
+crate::loom::thread_local! {
+    /// The thread-local state salsa requires for a given thread
+    static ATTACHED: Attached = Attached::new();
+}
+
+// loom's `thread_local` macro does not support const-initialization.
+#[cfg(not(loom))]
+crate::loom::thread_local! {
+    /// The thread-local state salsa requires for a given thread
+    static ATTACHED: Attached = const { Attached::new() }
+}
+
+/// State that is specific to a single execution thread.
+///
+/// Internally, this type uses ref-cells.
+///
+/// **Note also that all mutations to the database handle (and hence
+/// to the local-state) must be undone during unwinding.**
+struct Attached {
+    /// Pointer to the currently attached database.
+    database: Cell<Option<NonNull<dyn Database>>>,
+}
+
+impl Attached {
+    #[cfg(loom)]
+    fn new() -> Self {
+        Self {
+            database: Cell::new(None),
+        }
+    }
+
+    #[cfg(not(loom))]
+    const fn new() -> Self {
+        Self {
+            database: Cell::new(None),
+        }
+    }
+
+    #[inline]
+    fn attach<Db, R>(&self, db: &Db, op: impl FnOnce() -> R) -> R
+    where
+        Db: ?Sized + Database,
+    {
+        struct DbGuard<'s> {
+            state: Option<&'s Attached>,
+        }
+
+        impl<'s> DbGuard<'s> {
+            #[inline]
+            fn new(attached: &'s Attached, db: &dyn Database) -> Self {
+                match attached.database.get() {
+                    Some(current_db) => {
+                        let new_db = NonNull::from(db);
+                        if !std::ptr::addr_eq(current_db.as_ptr(), new_db.as_ptr()) {
+                            panic!(
+                                                "Cannot change database mid-query. current: {current_db:?}, new: {new_db:?}",
+                                            );
+                        }
+                        Self { state: None }
+                    }
+                    None => {
+                        // Otherwise, set the database.
+                        attached.database.set(Some(NonNull::from(db)));
+                        Self {
+                            state: Some(attached),
+                        }
+                    }
+                }
+            }
+        }
+
+        impl Drop for DbGuard<'_> {
+            #[inline]
+            fn drop(&mut self) {
+                // Reset database to null if we did anything in `DbGuard::new`.
+                if let Some(attached) = self.state {
+                    attached.database.set(None);
+                }
+            }
+        }
+
+        let _guard = DbGuard::new(self, db.as_dyn_database());
+        op()
+    }
+
+    /// Access the "attached" database. Returns `None` if no database is attached.
+    /// Databases are attached with `attach_database`.
+    #[inline]
+    fn with<R>(&self, op: impl FnOnce(&dyn Database) -> R) -> Option<R> {
+        let db = self.database.get()?;
+
+        // SAFETY: We always attach the database in for the entire duration of a function,
+        // so it cannot become "unattached" while this function is running.
+        Some(op(unsafe { db.as_ref() }))
+    }
+}
+
+/// Attach the database to the current thread and execute `op`.
+/// Panics if a different database has already been attached.
+#[inline]
+pub fn attach<R, Db>(db: &Db, op: impl FnOnce() -> R) -> R
+where
+    Db: ?Sized + Database,
+{
+    ATTACHED.with(
+        #[inline]
+        |a| a.attach(db, op),
+    )
+}
+
+/// Access the "attached" database. Returns `None` if no database is attached.
+/// Databases are attached with `attach_database`.
+#[inline]
+pub fn with_attached_database<R>(op: impl FnOnce(&dyn Database) -> R) -> Option<R> {
+    ATTACHED.with(
+        #[inline]
+        |a| a.with(op),
+    )
+}
diff --git a/crates/salsa/src/cancelled.rs b/crates/salsa/src/cancelled.rs
new file mode 100644
index 000000000..9ffc9424d
--- /dev/null
+++ b/crates/salsa/src/cancelled.rs
@@ -0,0 +1,55 @@
+use std::fmt;
+use std::panic::{self, UnwindSafe};
+
+/// A panic payload indicating that execution of a salsa query was cancelled.
+///
+/// This can occur for a few reasons:
+/// *
+/// *
+/// *
+#[derive(Debug)]
+#[non_exhaustive]
+pub enum Cancelled {
+    /// The query was operating on revision R, but there is a pending write to move to revision R+1.
+    #[non_exhaustive]
+    PendingWrite,
+
+    /// The query was blocked on another thread, and that thread panicked.
+    #[non_exhaustive]
+    PropagatedPanic,
+}
+
+impl Cancelled {
+    pub(crate) fn throw(self) -> ! {
+        // We use resume and not panic here to avoid running the panic
+        // hook (that is, to avoid collecting and printing backtrace).
+        std::panic::resume_unwind(Box::new(self));
+    }
+
+    /// Runs `f`, and catches any salsa cancellation.
+    pub fn catch<F, T>(f: F) -> Result<T, Cancelled>
+    where
+        F: FnOnce() -> T + UnwindSafe,
+    {
+        match panic::catch_unwind(f) {
+            Ok(t) => Ok(t),
+            Err(payload) => match payload.downcast() {
+                Ok(cancelled) => Err(*cancelled),
+                Err(payload) => panic::resume_unwind(payload),
+            },
+        }
+    }
+}
+
+impl std::fmt::Display for Cancelled {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        let why = match self {
+            Cancelled::PendingWrite => "pending write",
+            Cancelled::PropagatedPanic => "propagated panic",
+        };
+        f.write_str("cancelled because of ")?;
+        f.write_str(why)
+    }
+}
+
+impl std::error::Error for Cancelled {}
diff --git a/crates/salsa/src/cycle.rs b/crates/salsa/src/cycle.rs
new file mode 100644
index 000000000..c0e2bd2ea
--- /dev/null
+++ b/crates/salsa/src/cycle.rs
@@ -0,0 +1,226 @@
+//! Cycle handling
+//!
+//! Salsa's default cycle handling is quite simple: if we encounter a cycle (that is, if we attempt
+//! to execute a query that is already on the active query stack), we panic.
+//!
+//! By setting `cycle_fn` and `cycle_initial` arguments to `salsa::tracked`, queries can opt-in to
+//! fixed-point iteration instead.
+//!
+//! We call the query which triggers the cycle (that is, the query that is already on the stack
+//! when it is called again) the "cycle head". The cycle head is responsible for managing iteration
+//! of the cycle. When a cycle is encountered, if the cycle head has `cycle_fn` and `cycle_initial`
+//! set, it will call the `cycle_initial` function to generate an "empty" or "initial" value for
+//! fixed-point iteration, which will be returned to its caller. Then each query in the cycle will
+//! compute a value normally, but every computed value will track the head(s) of the cycles it is
+//! part of. Every query's "cycle heads" are the union of all the cycle heads of all the queries it
+//! depends on. A memoized query result with cycle heads is called a "provisional value".
+//!
+//! For example, if `qa` calls `qb`, and `qb` calls `qc`, and `qc` calls `qa`, then `qa` will call
+//! its `cycle_initial` function to get an initial value, and return that as its result to `qc`,
+//! marked with `qa` as cycle head. `qc` will compute its own provisional result based on that, and
+//! return to `qb` a result also marked with `qa` as cycle head. `qb` will similarly compute and
+//! return a provisional value back to `qa`.
+//!
+//! When a query observes that it has just computed a result which contains itself as a cycle head,
+//! it recognizes that it is responsible for resolving this cycle and calls its `cycle_fn` to
+//! decide how to do so. The `cycle_fn` function is passed the provisional value just computed for
+//! that query and the count of iterations so far, and must return either
+//! `CycleRecoveryAction::Iterate` (which signals that the cycle head should re-iterate the cycle),
+//! or `CycleRecoveryAction::Fallback` (which signals that the cycle head should replace its
+//! computed value with the given fallback value).
+//!
+//! If the cycle head ever observes that the provisional value it just recomputed is the same as
+//! the provisional value from the previous iteration, the cycle has converged. The cycle head will
+//! mark that value as final (by removing itself as cycle head) and return it.
+//!
+//! Other queries in the cycle will still have provisional values recorded, but those values should
+//! now also be considered final! We don't eagerly walk the entire cycle to mark them final.
+//! Instead, we wait until the next time that provisional value is read, and then we check if all
+//! of its cycle heads have a final result, in which case it, too, can be marked final. (This is
+//! implemented in `shallow_verify_memo` and `validate_provisional`.)
+//!
+//! If the `cycle_fn` returns a fallback value, the cycle head will replace its provisional value
+//! with that fallback, and then iterate the cycle one more time. A fallback value is expected to
+//! result in a stable, converged cycle. If it does not (that is, if the result of another
+//! iteration of the cycle is not the same as the fallback value), we'll panic.
+//!
+//! In nested cycle cases, the inner cycle head will iterate until its own cycle is resolved, but
+//! the "final" value it then returns will still be provisional on the outer cycle head. The outer
+//! cycle head may then iterate, which may result in a new set of iterations on the inner cycle,
+//! for each iteration of the outer cycle.
+
+use thin_vec::{thin_vec, ThinVec};
+
+use crate::key::DatabaseKeyIndex;
+
+/// The maximum number of times we'll fixpoint-iterate before panicking.
+///
+/// Should only be relevant in case of a badly configured cycle recovery.
+pub const MAX_ITERATIONS: u32 = 200;
+
+/// Return value from a cycle recovery function.
+#[derive(Debug)]
+pub enum CycleRecoveryAction<T> {
+    /// Iterate the cycle again to look for a fixpoint.
+    Iterate,
+
+    /// Cut off iteration and use the given result value for this query.
+    Fallback(T),
+}
+
+/// Cycle recovery strategy: Is this query capable of recovering from
+/// a cycle that results from executing the function? If so, how?
+#[derive(Copy, Clone, Debug, PartialEq, Eq)]
+pub enum CycleRecoveryStrategy {
+    /// Cannot recover from cycles: panic.
+    ///
+    /// This is the default.
+    Panic,
+
+    /// Recovers from cycles by fixpoint iterating and/or falling
+    /// back to a sentinel value.
+    ///
+    /// This choice is computed by the query's `cycle_recovery`
+    /// function and initial value.
+    Fixpoint,
+
+    /// Recovers from cycles by inserting a fallback value for all
+    /// queries that have a fallback, and ignoring any other query
+    /// in the cycle (as if they were not computed).
+    FallbackImmediate,
+}
+
+/// A "cycle head" is the query at which we encounter a cycle; that is, if A -> B -> C -> A, then A
+/// would be the cycle head. It returns an "initial value" when the cycle is encountered (if
+/// fixpoint iteration is enabled for that query), and then is responsible for re-iterating the
+/// cycle until it converges.
+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
+pub struct CycleHead {
+    pub(crate) database_key_index: DatabaseKeyIndex,
+    pub(crate) iteration_count: u32,
+}
+
+/// Any provisional value generated by any query in a cycle will track the cycle head(s) (can be
+/// plural in case of nested cycles) representing the cycles it is part of, and the current
+/// iteration count for each cycle head. This struct tracks these cycle heads.
+#[derive(Clone, Debug, Default)]
+pub struct CycleHeads(ThinVec<CycleHead>);
+
+impl CycleHeads {
+    pub(crate) fn is_empty(&self) -> bool {
+        self.0.is_empty()
+    }
+
+    pub(crate) fn initial(database_key_index: DatabaseKeyIndex) -> Self {
+        Self(thin_vec![CycleHead {
+            database_key_index,
+            iteration_count: 0,
+        }])
+    }
+
+    pub(crate) fn iter(&self) -> std::slice::Iter<'_, CycleHead> {
+        self.0.iter()
+    }
+
+    pub(crate) fn contains(&self, value: &DatabaseKeyIndex) -> bool {
+        self.into_iter()
+            .any(|head| head.database_key_index == *value)
+    }
+
+    pub(crate) fn remove(&mut self, value: &DatabaseKeyIndex) -> bool {
+        let found = self
+            .0
+            .iter()
+            .position(|&head| head.database_key_index == *value);
+        let Some(found) = found else { return false };
+        self.0.swap_remove(found);
+        true
+    }
+
+    pub(crate) fn update_iteration_count(
+        &mut self,
+        cycle_head_index: DatabaseKeyIndex,
+        new_iteration_count: u32,
+    ) {
+        if let Some(cycle_head) = self
+            .0
+            .iter_mut()
+            .find(|cycle_head| cycle_head.database_key_index == cycle_head_index)
+        {
+            cycle_head.iteration_count = new_iteration_count;
+        }
+    }
+
+    #[inline]
+    pub(crate) fn push_initial(&mut self, database_key_index: DatabaseKeyIndex) {
+        if let Some(existing) = self
+            .0
+            .iter()
+            .find(|candidate| candidate.database_key_index == database_key_index)
+        {
+            assert_eq!(existing.iteration_count, 0);
+        } else {
+            self.0.push(CycleHead {
+                database_key_index,
+                iteration_count: 0,
+            });
+        }
+    }
+
+    #[inline]
+    pub(crate) fn extend(&mut self, other: &Self) {
+        self.0.reserve(other.0.len());
+
+        for head in other {
+            if let Some(existing) = self
+                .0
+                .iter()
+                .find(|candidate| candidate.database_key_index == head.database_key_index)
+            {
+                assert_eq!(existing.iteration_count, head.iteration_count);
+            } else {
+                self.0.push(*head);
+            }
+        }
+    }
+}
+
+impl IntoIterator for CycleHeads {
+    type Item = CycleHead;
+    type IntoIter = <ThinVec<Self::Item> as IntoIterator>::IntoIter;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.0.into_iter()
+    }
+}
+
+impl<'a> std::iter::IntoIterator for &'a CycleHeads {
+    type Item = &'a CycleHead;
+    type IntoIter = std::slice::Iter<'a, CycleHead>;
+
+    fn into_iter(self) -> Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl From<CycleHead> for CycleHeads {
+    fn from(value: CycleHead) -> Self {
+        Self(thin_vec![value])
+    }
+}
+
+#[cfg(not(loom))]
+pub(crate) static EMPTY_CYCLE_HEADS: std::sync::LazyLock<CycleHeads> =
+    std::sync::LazyLock::new(|| CycleHeads(ThinVec::new()));
+
+#[cfg(loom)]
+loom::lazy_static! {
+    pub(crate) static ref EMPTY_CYCLE_HEADS: CycleHeads = CycleHeads(ThinVec::new());
+}
+
+#[derive(Debug, PartialEq, Eq)]
+pub enum CycleHeadKind {
+    Provisional,
+    NotProvisional,
+    FallbackImmediate,
+}
diff --git a/crates/salsa/src/database.rs b/crates/salsa/src/database.rs
new file mode 100644
index 000000000..72204a582
--- /dev/null
+++ b/crates/salsa/src/database.rs
@@ -0,0 +1,135 @@
+use std::any::Any;
+use std::borrow::Cow;
+
+use crate::zalsa::{IngredientIndex, ZalsaDatabase};
+use crate::{Durability, Revision};
+
+/// The trait implemented by all Salsa databases.
+/// You can create your own subtraits of this trait using the `#[salsa::db]`(`crate::db`) procedural macro.
+pub trait Database: Send + AsDynDatabase + Any + ZalsaDatabase {
+    /// Enforces current LRU limits, evicting entries if necessary.
+    ///
+    /// **WARNING:** Just like an ordinary write, this method triggers
+    /// cancellation. If you invoke it while a snapshot exists, it
+    /// will block until that snapshot is dropped -- if that snapshot
+    /// is owned by the current thread, this could trigger deadlock.
+    fn trigger_lru_eviction(&mut self) {
+        let zalsa_mut = self.zalsa_mut();
+        zalsa_mut.evict_lru();
+    }
+
+    /// A "synthetic write" causes the system to act *as though* some
+    /// input of durability `durability` has changed, triggering a new revision.
+    /// This is mostly useful for profiling scenarios.
+    ///
+    /// **WARNING:** Just like an ordinary write, this method triggers
+    /// cancellation. If you invoke it while a snapshot exists, it
+    /// will block until that snapshot is dropped -- if that snapshot
+    /// is owned by the current thread, this could trigger deadlock.
+    fn synthetic_write(&mut self, durability: Durability) {
+        let zalsa_mut = self.zalsa_mut();
+        zalsa_mut.new_revision();
+        zalsa_mut.runtime_mut().report_tracked_write(durability);
+    }
+
+    /// Reports that the query depends on some state unknown to salsa.
+    ///
+    /// Queries which report untracked reads will be re-executed in the next
+    /// revision.
+    fn report_untracked_read(&self) {
+        let (zalsa, zalsa_local) = self.zalsas();
+        zalsa_local.report_untracked_read(zalsa.current_revision())
+    }
+
+    /// Return the "debug name" (i.e., the struct name, etc) for an "ingredient",
+    /// which are the fine-grained components we use to track data. This is intended
+    /// for debugging and the contents of the returned string are not semver-guaranteed.
+    ///
+    /// Ingredient indices can be extracted from [`DatabaseKeyIndex`](`crate::DatabaseKeyIndex`) values.
+    fn ingredient_debug_name(&self, ingredient_index: IngredientIndex) -> Cow<'_, str> {
+        Cow::Borrowed(
+            self.zalsa()
+                .lookup_ingredient(ingredient_index)
+                .debug_name(),
+        )
+    }
+
+    /// Starts unwinding the stack if the current revision is cancelled.
+    ///
+    /// This method can be called by query implementations that perform
+    /// potentially expensive computations, in order to speed up propagation of
+    /// cancellation.
+    ///
+    /// Cancellation will automatically be triggered by salsa on any query
+    /// invocation.
+    ///
+    /// This method should not be overridden by `Database` implementors. A
+    /// `salsa_event` is emitted when this method is called, so that should be
+    /// used instead.
+    fn unwind_if_revision_cancelled(&self) {
+        let (zalsa, zalsa_local) = self.zalsas();
+        zalsa.unwind_if_revision_cancelled(zalsa_local);
+    }
+
+    /// Execute `op` with the database in thread-local storage for debug print-outs.
+    #[inline(always)]
+    fn attach<R>(&self, op: impl FnOnce(&Self) -> R) -> R
+    where
+        Self: Sized,
+    {
+        crate::attach::attach(self, || op(self))
+    }
+
+    #[doc(hidden)]
+    #[inline(always)]
+    fn zalsa_register_downcaster(&self) {
+        // The no-op downcaster is special cased in view caster construction.
+    }
+
+    #[doc(hidden)]
+    #[inline(always)]
+    unsafe fn downcast(db: &dyn Database) -> &dyn Database
+    where
+        Self: Sized,
+    {
+        // No-op
+        db
+    }
+}
+
+/// Upcast to a `dyn Database`.
+///
+/// Only required because upcasts not yet stabilized (*grr*).
+pub trait AsDynDatabase {
+    fn as_dyn_database(&self) -> &dyn Database;
+    fn as_dyn_database_mut(&mut self) -> &mut dyn Database;
+}
+
+impl<T: Database> AsDynDatabase for T {
+    #[inline(always)]
+    fn as_dyn_database(&self) -> &dyn Database {
+        self
+    }
+
+    #[inline(always)]
+    fn as_dyn_database_mut(&mut self) -> &mut dyn Database {
+        self
+    }
+}
+
+pub fn current_revision<Db: ?Sized + Database>(db: &Db) -> Revision {
+    db.zalsa().current_revision()
+}
+
+impl dyn Database {
+    /// Upcasts `self` to the given view.
+    ///
+    /// # Panics
+    ///
+    /// If the view has not been added to the database (see [`crate::views::Views`]).
+    #[track_caller]
+    pub fn as_view<DbView: ?Sized + Database>(&self) -> &DbView {
+        let views = self.zalsa().views();
+        views.downcaster_for().downcast(self)
+    }
+}
diff --git a/crates/salsa/src/database_impl.rs b/crates/salsa/src/database_impl.rs
new file mode 100644
index 000000000..c1eda125a
--- /dev/null
+++ b/crates/salsa/src/database_impl.rs
@@ -0,0 +1,52 @@
+use tracing::Level;
+
+use crate::storage::HasStorage;
+use crate::{Database, Storage};
+
+/// Default database implementation that you can use if you don't
+/// require any custom user data.
+#[derive(Clone)]
+pub struct DatabaseImpl {
+    storage: Storage<Self>,
+}
+
+impl Default for DatabaseImpl {
+    fn default() -> Self {
+        Self {
+            // Default behavior: tracing debug log the event.
+            storage: Storage::new(if tracing::enabled!(Level::DEBUG) {
+                Some(Box::new(|event| {
+                    tracing::debug!("salsa_event({:?})", event)
+                }))
+            } else {
+                None
+            }),
+        }
+    }
+}
+
+impl DatabaseImpl {
+    /// Create a new database; equivalent to `Self::default`.
+    pub fn new() -> Self {
+        Self::default()
+    }
+
+    pub fn storage(&self) -> &Storage<Self> {
+        &self.storage
+    }
+}
+
+impl Database for DatabaseImpl {}
+
+// SAFETY: The `storage` and `storage_mut` fields return a reference to the same storage field owned by `self`.
+unsafe impl HasStorage for DatabaseImpl {
+    #[inline(always)]
+    fn storage(&self) -> &Storage<Self> {
+        &self.storage
+    }
+
+    #[inline(always)]
+    fn storage_mut(&mut self) -> &mut Storage<Self> {
+        &mut self.storage
+    }
+}
diff --git a/crates/salsa/src/durability.rs b/crates/salsa/src/durability.rs
new file mode 100644
index 000000000..26fdf5320
--- /dev/null
+++ b/crates/salsa/src/durability.rs
@@ -0,0 +1,104 @@
+/// Describes how likely a value is to changehow "durable" it is.
+///
+/// By default, inputs have `Durability::LOW` and interned values have
+/// `Durability::HIGH`. But inputs can be explicitly set with other
+/// durabilities.
+///
+/// We use durabilities to optimize the work of "revalidating" a query
+/// after some input has changed. Ordinarily, in a new revision,
+/// queries have to trace all their inputs back to the base inputs to
+/// determine if any of those inputs have changed. But if we know that
+/// the only changes were to inputs of low durability (the common
+/// case), and we know that the query only used inputs of medium
+/// durability or higher, then we can skip that enumeration.
+///
+/// Typically, one assigns low durabilities to inputs that the user is
+/// frequently editing. Medium or high durabilities are used for
+/// configuration, the source from library crates, or other things
+/// that are unlikely to be edited.
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
+pub struct Durability(DurabilityVal);
+
+impl std::fmt::Debug for Durability {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        if f.alternate() {
+            match self.0 {
+                DurabilityVal::Low => f.write_str("Durability::LOW"),
+                DurabilityVal::Medium => f.write_str("Durability::MEDIUM"),
+                DurabilityVal::High => f.write_str("Durability::HIGH"),
+            }
+        } else {
+            f.debug_tuple("Durability")
+                .field(&(self.0 as usize))
+                .finish()
+        }
+    }
+}
+
+// We use an enum here instead of a u8 for niches.
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
+enum DurabilityVal {
+    Low = 0,
+    Medium = 1,
+    High = 2,
+}
+
+impl From<u8> for DurabilityVal {
+    fn from(value: u8) -> Self {
+        match value {
+            0 => DurabilityVal::Low,
+            1 => DurabilityVal::Medium,
+            2 => DurabilityVal::High,
+            _ => panic!("invalid durability"),
+        }
+    }
+}
+
+impl Durability {
+    /// Low durability: things that change frequently.
+    ///
+    /// Example: part of the crate being edited
+    pub const LOW: Durability = Durability(DurabilityVal::Low);
+
+    /// Medium durability: things that change sometimes, but rarely.
+    ///
+    /// Example: a Cargo.toml file
+    pub const MEDIUM: Durability = Durability(DurabilityVal::Medium);
+
+    /// High durability: things that are not expected to change under
+    /// common usage.
+    ///
+    /// Example: the standard library or something from crates.io
+    pub const HIGH: Durability = Durability(DurabilityVal::High);
+
+    /// The minimum possible durability; equivalent to LOW but
+    /// "conceptually" distinct (i.e., if we add more durability
+    /// levels, this could change).
+    pub(crate) const MIN: Durability = Self::LOW;
+
+    /// The maximum possible durability; equivalent to HIGH but
+    /// "conceptually" distinct (i.e., if we add more durability
+    /// levels, this could change).
+    pub(crate) const MAX: Durability = Self::HIGH;
+
+    /// Number of durability levels.
+    pub(crate) const LEN: usize = Self::HIGH.0 as usize + 1;
+
+    pub(crate) fn index(self) -> usize {
+        self.0 as usize
+    }
+
+    pub(crate) fn as_u8(self) -> u8 {
+        self.0 as u8
+    }
+
+    pub(crate) fn from_u8(value: u8) -> Self {
+        Self(DurabilityVal::from(value))
+    }
+}
+
+impl Default for Durability {
+    fn default() -> Self {
+        Durability::LOW
+    }
+}
diff --git a/crates/salsa/src/event.rs b/crates/salsa/src/event.rs
new file mode 100644
index 000000000..d7272806c
--- /dev/null
+++ b/crates/salsa/src/event.rs
@@ -0,0 +1,118 @@
+use crate::key::DatabaseKeyIndex;
+use crate::loom::thread::{self, ThreadId};
+use crate::Revision;
+
+/// The `Event` struct identifies various notable things that can
+/// occur during salsa execution. Instances of this struct are given
+/// to `salsa_event`.
+#[derive(Debug)]
+pub struct Event {
+    /// The id of the thread that triggered the event.
+    pub thread_id: ThreadId,
+
+    /// What sort of event was it.
+    pub kind: EventKind,
+}
+
+impl Event {
+    pub fn new(kind: EventKind) -> Self {
+        Self {
+            thread_id: thread::current().id(),
+            kind,
+        }
+    }
+}
+
+/// An enum identifying the various kinds of events that can occur.
+#[derive(Debug)]
+pub enum EventKind {
+    /// Occurs when we found that all inputs to a memoized value are
+    /// up-to-date and hence the value can be re-used without
+    /// executing the closure.
+    ///
+    /// Executes before the "re-used" value is returned.
+    DidValidateMemoizedValue {
+        /// The database-key for the affected value. Implements `Debug`.
+        database_key: DatabaseKeyIndex,
+    },
+
+    /// Indicates that another thread (with id `other_thread_id`) is processing the
+    /// given query (`database_key`), so we will block until they
+    /// finish.
+    ///
+    /// Executes after we have registered with the other thread but
+    /// before they have answered us.
+    WillBlockOn {
+        /// The id of the thread we will block on.
+        other_thread_id: ThreadId,
+
+        /// The database-key for the affected value. Implements `Debug`.
+        database_key: DatabaseKeyIndex,
+    },
+
+    /// Indicates that the function for this query will be executed.
+    /// This is either because it has never executed before or because
+    /// its inputs may be out of date.
+    WillExecute {
+        /// The database-key for the affected value. Implements `Debug`.
+        database_key: DatabaseKeyIndex,
+    },
+
+    WillIterateCycle {
+        /// The database-key for the cycle head. Implements `Debug`.
+        database_key: DatabaseKeyIndex,
+        iteration_count: u32,
+        fell_back: bool,
+    },
+
+    /// Indicates that `unwind_if_cancelled` was called and salsa will check if
+    /// the current revision has been cancelled.
+    WillCheckCancellation,
+
+    /// Indicates that one [`Handle`](`crate::Handle`) has set the cancellation flag.
+    /// When other active handles execute salsa methods, they will observe this flag
+    /// and panic with a sentinel value of type [`Cancelled`](`crate::Cancelled`).
+    DidSetCancellationFlag,
+
+    /// Discovered that a query used to output a given output but no longer does.
+    WillDiscardStaleOutput {
+        /// Key for the query that is executing and which no longer outputs the given value.
+        execute_key: DatabaseKeyIndex,
+
+        /// Key for the query that is no longer output
+        output_key: DatabaseKeyIndex,
+    },
+
+    /// Tracked structs or memoized data were discarded (freed).
+    DidDiscard {
+        /// Value being discarded.
+        key: DatabaseKeyIndex,
+    },
+
+    /// Discarded accumulated data from a given fn
+    DidDiscardAccumulated {
+        /// The key of the fn that accumulated results
+        executor_key: DatabaseKeyIndex,
+
+        /// Accumulator that was accumulated into
+        accumulator: DatabaseKeyIndex,
+    },
+
+    /// Indicates that a value was newly interned.
+    DidInternValue {
+        // The key of the interned value.
+        key: DatabaseKeyIndex,
+
+        // The revision the value was interned in.
+        revision: Revision,
+    },
+
+    /// Indicates that a previously interned value was read in a new revision.
+    DidReinternValue {
+        // The key of the interned value.
+        key: DatabaseKeyIndex,
+
+        // The revision the value was interned in.
+        revision: Revision,
+    },
+}
diff --git a/crates/salsa/src/function.rs b/crates/salsa/src/function.rs
new file mode 100644
index 000000000..f7e659915
--- /dev/null
+++ b/crates/salsa/src/function.rs
@@ -0,0 +1,341 @@
+use std::any::Any;
+use std::fmt;
+use std::ptr::NonNull;
+
+pub(crate) use maybe_changed_after::VerifyResult;
+
+use crate::accumulator::accumulated_map::{AccumulatedMap, InputAccumulatedValues};
+use crate::cycle::{CycleHeadKind, CycleHeads, CycleRecoveryAction, CycleRecoveryStrategy};
+use crate::function::delete::DeletedEntries;
+use crate::function::sync::{ClaimResult, SyncTable};
+use crate::ingredient::Ingredient;
+use crate::key::DatabaseKeyIndex;
+use crate::loom::sync::Arc;
+use crate::plumbing::MemoIngredientMap;
+use crate::salsa_struct::SalsaStructInDb;
+use crate::table::memo::MemoTableTypes;
+use crate::table::Table;
+use crate::views::DatabaseDownCaster;
+use crate::zalsa::{IngredientIndex, MemoIngredientIndex, Zalsa};
+use crate::zalsa_local::QueryOrigin;
+use crate::{Database, Id, Revision};
+
+mod accumulated;
+mod backdate;
+mod delete;
+mod diff_outputs;
+mod execute;
+mod fetch;
+mod inputs;
+mod lru;
+mod maybe_changed_after;
+mod memo;
+mod specify;
+mod sync;
+
+pub type Memo<C> = memo::Memo<<C as Configuration>::Output<'static>>;
+
+pub trait Configuration: Any {
+    const DEBUG_NAME: &'static str;
+    const LOCATION: crate::ingredient::Location;
+
+    /// The database that this function is associated with.
+    type DbView: ?Sized + crate::Database;
+
+    /// The "salsa struct type" that this function is associated with.
+    /// This can be just `salsa::Id` for functions that intern their arguments
+    /// and are not clearly associated with any one salsa struct.
+    type SalsaStruct<'db>: SalsaStructInDb;
+
+    /// The input to the function
+    type Input<'db>: Send + Sync;
+
+    /// The value computed by the function.
+    type Output<'db>: Send + Sync;
+
+    /// Determines whether this function can recover from being a participant in a cycle
+    /// (and, if so, how).
+    const CYCLE_STRATEGY: CycleRecoveryStrategy;
+
+    /// Invokes after a new result `new_value` has been computed for which an older memoized value
+    /// existed `old_value`, or in fixpoint iteration. Returns true if the new value is equal to
+    /// the older one.
+    ///
+    /// This invokes user code in form of the `Eq` impl.
+    fn values_equal<'db>(old_value: &Self::Output<'db>, new_value: &Self::Output<'db>) -> bool;
+
+    // FIXME: This should take a `&Zalsa`
+    /// Convert from the id used internally to the value that execute is expecting.
+    /// This is a no-op if the input to the function is a salsa struct.
+    fn id_to_input(db: &Self::DbView, key: Id) -> Self::Input<'_>;
+
+    /// Invoked when we need to compute the value for the given key, either because we've never
+    /// computed it before or because the old one relied on inputs that have changed.
+    ///
+    /// This invokes the function the user wrote.
+    fn execute<'db>(db: &'db Self::DbView, input: Self::Input<'db>) -> Self::Output<'db>;
+
+    /// Get the cycle recovery initial value.
+    fn cycle_initial<'db>(db: &'db Self::DbView, input: Self::Input<'db>) -> Self::Output<'db>;
+
+    /// Decide whether to iterate a cycle again or fallback. `value` is the provisional return
+    /// value from the latest iteration of this cycle. `count` is the number of cycle iterations
+    /// we've already completed.
+    fn recover_from_cycle<'db>(
+        db: &'db Self::DbView,
+        value: &Self::Output<'db>,
+        count: u32,
+        input: Self::Input<'db>,
+    ) -> CycleRecoveryAction<Self::Output<'db>>;
+}
+
+/// Function ingredients are the "workhorse" of salsa.
+///
+/// They are used for tracked functions, for the "value" fields of tracked structs, and for the fields of input structs.
+/// The function ingredient is fairly complex and so its code is spread across multiple modules, typically one per method.
+/// The main entry points are:
+///
+/// * the `fetch` method, which is invoked when the function is called by the user's code;
+///   it will return a memoized value if one exists, or execute the function otherwise.
+/// * the `specify` method, which can only be used when the key is an entity created by the active query.
+///   It sets the value of the function imperatively, so that when later fetches occur, they'll return this value.
+/// * the `store` method, which can only be invoked with an `&mut` reference, and is to set input fields.
+pub struct IngredientImpl<C: Configuration> {
+    /// The ingredient index we were assigned in the database.
+    /// Used to construct `DatabaseKeyIndex` values.
+    index: IngredientIndex,
+
+    /// The index for the memo/sync tables
+    ///
+    /// This may be a [`crate::memo_ingredient_indices::MemoIngredientSingletonIndex`] or a
+    /// [`crate::memo_ingredient_indices::MemoIngredientIndices`], depending on whether the
+    /// tracked function's struct is a plain salsa struct or an enum `#[derive(Supertype)]`.
+    memo_ingredient_indices: <C::SalsaStruct<'static> as SalsaStructInDb>::MemoIngredientMap,
+
+    /// Used to find memos to throw out when we have too many memoized values.
+    lru: lru::Lru,
+
+    /// A downcaster from `dyn Database` to `C::DbView`.
+    ///
+    /// # Safety
+    ///
+    /// The supplied database must be be the same as the database used to construct the [`Views`]
+    /// instances that this downcaster was derived from.
+    view_caster: DatabaseDownCaster<C::DbView>,
+
+    sync_table: SyncTable,
+
+    /// When `fetch` and friends executes, they return a reference to the
+    /// value stored in the memo that is extended to live as long as the `&self`
+    /// reference we start with. This means that whenever we remove something
+    /// from `memo_map` with an `&self` reference, there *could* be references to its
+    /// internals still in use. Therefore we push the memo into this queue and
+    /// only *actually* free up memory when a new revision starts (which means
+    /// we have an `&mut` reference to self).
+    ///
+    /// You might think that we could do this only if the memo was verified in the
+    /// current revision: you would be right, but we are being defensive, because
+    /// we don't know that we can trust the database to give us the same runtime
+    /// everytime and so forth.
+    deleted_entries: DeletedEntries<C>,
+}
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    pub fn new(
+        index: IngredientIndex,
+        memo_ingredient_indices: <C::SalsaStruct<'static> as SalsaStructInDb>::MemoIngredientMap,
+        lru: usize,
+        view_caster: DatabaseDownCaster<C::DbView>,
+    ) -> Self {
+        Self {
+            index,
+            memo_ingredient_indices,
+            lru: lru::Lru::new(lru),
+            deleted_entries: Default::default(),
+            view_caster,
+            sync_table: SyncTable::new(index),
+        }
+    }
+
+    #[inline]
+    pub fn database_key_index(&self, key: Id) -> DatabaseKeyIndex {
+        DatabaseKeyIndex::new(self.index, key)
+    }
+
+    pub fn set_capacity(&mut self, capacity: usize) {
+        self.lru.set_capacity(capacity);
+    }
+
+    /// Returns a reference to the memo value that lives as long as self.
+    /// This is UNSAFE: the caller is responsible for ensuring that the
+    /// memo will not be released so long as the `&self` is valid.
+    /// This is done by (a) ensuring the memo is present in the memo-map
+    /// when this function is called and (b) ensuring that any entries
+    /// removed from the memo-map are added to `deleted_entries`, which is
+    /// only cleared with `&mut self`.
+    unsafe fn extend_memo_lifetime<'this>(
+        &'this self,
+        memo: &memo::Memo<C::Output<'this>>,
+    ) -> &'this memo::Memo<C::Output<'this>> {
+        // SAFETY: the caller must guarantee that the memo will not be released before `&self`
+        unsafe { std::mem::transmute(memo) }
+    }
+
+    fn insert_memo<'db>(
+        &'db self,
+        zalsa: &'db Zalsa,
+        id: Id,
+        memo: memo::Memo<C::Output<'db>>,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) -> &'db memo::Memo<C::Output<'db>> {
+        // We convert to a `NonNull` here as soon as possible because we are going to alias
+        // into the `Box`, which is a `noalias` type.
+        // FIXME: Use `Box::into_non_null` once stable
+        let memo = NonNull::from(Box::leak(Box::new(memo)));
+
+        if let Some(old_value) =
+            self.insert_memo_into_table_for(zalsa, id, memo, memo_ingredient_index)
+        {
+            // In case there is a reference to the old memo out there, we have to store it
+            // in the deleted entries. This will get cleared when a new revision starts.
+            //
+            // SAFETY: Once the revision starts, there will be no outstanding borrows to the
+            // memo contents, and so it will be safe to free.
+            unsafe { self.deleted_entries.push(old_value) };
+        }
+        // SAFETY: memo has been inserted into the table
+        unsafe { self.extend_memo_lifetime(memo.as_ref()) }
+    }
+
+    #[inline]
+    fn memo_ingredient_index(&self, zalsa: &Zalsa, id: Id) -> MemoIngredientIndex {
+        self.memo_ingredient_indices.get_zalsa_id(zalsa, id)
+    }
+}
+
+impl<C> Ingredient for IngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn location(&self) -> &'static crate::ingredient::Location {
+        &C::LOCATION
+    }
+
+    fn ingredient_index(&self) -> IngredientIndex {
+        self.index
+    }
+
+    unsafe fn maybe_changed_after(
+        &self,
+        db: &dyn Database,
+        input: Id,
+        revision: Revision,
+        cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        // SAFETY: The `db` belongs to the ingredient as per caller invariant
+        let db = unsafe { self.view_caster.downcast_unchecked(db) };
+        self.maybe_changed_after(db, input, revision, cycle_heads)
+    }
+
+    /// True if the input `input` contains a memo that cites itself as a cycle head.
+    /// This indicates an intermediate value for a cycle that has not yet reached a fixed point.
+    fn cycle_head_kind(&self, zalsa: &Zalsa, input: Id) -> CycleHeadKind {
+        let is_provisional = self
+            .get_memo_from_table_for(zalsa, input, self.memo_ingredient_index(zalsa, input))
+            .is_some_and(|memo| {
+                memo.cycle_heads()
+                    .into_iter()
+                    .any(|head| head.database_key_index == self.database_key_index(input))
+            });
+        if is_provisional {
+            CycleHeadKind::Provisional
+        } else if C::CYCLE_STRATEGY == CycleRecoveryStrategy::FallbackImmediate {
+            CycleHeadKind::FallbackImmediate
+        } else {
+            CycleHeadKind::NotProvisional
+        }
+    }
+
+    /// Attempts to claim `key_index`, returning `false` if a cycle occurs.
+    fn wait_for(&self, zalsa: &Zalsa, key_index: Id) -> bool {
+        match self.sync_table.try_claim(zalsa, key_index) {
+            ClaimResult::Retry | ClaimResult::Claimed(_) => true,
+            ClaimResult::Cycle => false,
+        }
+    }
+
+    fn origin(&self, zalsa: &Zalsa, key: Id) -> Option<QueryOrigin> {
+        self.origin(zalsa, key)
+    }
+
+    fn mark_validated_output(
+        &self,
+        zalsa: &Zalsa,
+        executor: DatabaseKeyIndex,
+        output_key: crate::Id,
+    ) {
+        self.validate_specified_value(zalsa, executor, output_key);
+    }
+
+    fn remove_stale_output(
+        &self,
+        _zalsa: &Zalsa,
+        _executor: DatabaseKeyIndex,
+        _stale_output_key: crate::Id,
+    ) {
+        // This function is invoked when a query Q specifies the value for `stale_output_key` in rev 1,
+        // but not in rev 2. We don't do anything in this case, we just leave the (now stale) memo.
+        // Since its `verified_at` field has not changed, it will be considered dirty if it is invoked.
+    }
+
+    fn requires_reset_for_new_revision(&self) -> bool {
+        true
+    }
+
+    fn reset_for_new_revision(&mut self, table: &mut Table) {
+        self.lru.for_each_evicted(|evict| {
+            let ingredient_index = table.ingredient_index(evict);
+            Self::evict_value_from_memo_for(
+                table.memos_mut(evict),
+                self.memo_ingredient_indices.get(ingredient_index),
+            )
+        });
+
+        self.deleted_entries.clear();
+    }
+
+    fn debug_name(&self) -> &'static str {
+        C::DEBUG_NAME
+    }
+
+    fn memo_table_types(&self) -> Arc<MemoTableTypes> {
+        unreachable!("function does not allocate pages")
+    }
+
+    fn cycle_recovery_strategy(&self) -> CycleRecoveryStrategy {
+        C::CYCLE_STRATEGY
+    }
+
+    fn accumulated<'db>(
+        &'db self,
+        db: &'db dyn Database,
+        key_index: Id,
+    ) -> (Option<&'db AccumulatedMap>, InputAccumulatedValues) {
+        let db = self.view_caster.downcast(db);
+        self.accumulated_map(db, key_index)
+    }
+}
+
+impl<C> std::fmt::Debug for IngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct(std::any::type_name::<Self>())
+            .field("index", &self.index)
+            .finish()
+    }
+}
diff --git a/crates/salsa/src/function/accumulated.rs b/crates/salsa/src/function/accumulated.rs
new file mode 100644
index 000000000..216cdd8b5
--- /dev/null
+++ b/crates/salsa/src/function/accumulated.rs
@@ -0,0 +1,105 @@
+use crate::accumulator::accumulated_map::{AccumulatedMap, InputAccumulatedValues};
+use crate::accumulator::{self};
+use crate::function::{Configuration, IngredientImpl};
+use crate::hash::FxHashSet;
+use crate::zalsa::ZalsaDatabase;
+use crate::zalsa_local::QueryOrigin;
+use crate::{AsDynDatabase, DatabaseKeyIndex, Id};
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    /// Helper used by `accumulate` functions. Computes the results accumulated by `database_key_index`
+    /// and its inputs.
+    pub fn accumulated_by<'db, A>(&self, db: &'db C::DbView, key: Id) -> Vec<&'db A>
+    where
+        A: accumulator::Accumulator,
+    {
+        let (zalsa, zalsa_local) = db.zalsas();
+
+        // NOTE: We don't have a precise way to track accumulated values at present,
+        // so we report any read of them as an untracked read.
+        //
+        // Like tracked struct fields, accumulated values are essentially a "side channel output"
+        // from a tracked function, hence we can't report this as a read of the tracked function(s)
+        // whose accumulated values we are probing, since the accumulated values may have changed
+        // even when the main return value of the function has not changed.
+        //
+        // Unlike tracked struct fields, we don't have a distinct id or ingredient to represent
+        // "the values of type A accumulated by tracked function X". Typically accumulated values
+        // are read from outside of salsa anyway so this is not a big deal.
+        zalsa_local.report_untracked_read(zalsa.current_revision());
+
+        let Some(accumulator) = <accumulator::IngredientImpl<A>>::from_zalsa(zalsa) else {
+            return vec![];
+        };
+        let mut output = vec![];
+
+        // First ensure the result is up to date
+        self.fetch(db, key);
+
+        let db = db.as_dyn_database();
+        let db_key = self.database_key_index(key);
+        let mut visited: FxHashSet<DatabaseKeyIndex> = FxHashSet::default();
+        let mut stack: Vec<DatabaseKeyIndex> = vec![db_key];
+
+        // Do a depth-first search across the dependencies of `key`, reading the values accumulated by
+        // each dependency.
+        while let Some(k) = stack.pop() {
+            // Already visited `k`?
+            if !visited.insert(k) {
+                continue;
+            }
+
+            let ingredient = zalsa.lookup_ingredient(k.ingredient_index());
+            // Extend `output` with any values accumulated by `k`.
+            let (accumulated_map, input) = ingredient.accumulated(db, k.key_index());
+            if let Some(accumulated_map) = accumulated_map {
+                accumulated_map.extend_with_accumulated(accumulator.index(), &mut output);
+            }
+            // Skip over the inputs because we know that the entire sub-graph has no accumulated values
+            if input.is_empty() {
+                continue;
+            }
+
+            // Find the inputs of `k` and push them onto the stack.
+            //
+            // Careful: to ensure the user gets a consistent ordering in their
+            // output vector, we want to push in execution order, so reverse order to
+            // ensure the first child that was executed will be the first child popped
+            // from the stack.
+            let Some(origin) = ingredient.origin(zalsa, k.key_index()) else {
+                continue;
+            };
+
+            if let QueryOrigin::Derived(edges) | QueryOrigin::DerivedUntracked(edges) = &origin {
+                stack.reserve(edges.input_outputs.len());
+            }
+
+            stack.extend(
+                origin
+                    .inputs()
+                    .filter_map(|input| TryInto::<DatabaseKeyIndex>::try_into(input).ok())
+                    .rev(),
+            );
+
+            visited.reserve(stack.len());
+        }
+
+        output
+    }
+
+    pub(super) fn accumulated_map<'db>(
+        &'db self,
+        db: &'db C::DbView,
+        key: Id,
+    ) -> (Option<&'db AccumulatedMap>, InputAccumulatedValues) {
+        // NEXT STEP: stash and refactor `fetch` to return an `&Memo` so we can make this work
+        let memo = self.refresh_memo(db, db.zalsa(), key);
+        (
+            memo.revisions.accumulated.as_deref(),
+            memo.revisions.accumulated_inputs.load(),
+        )
+    }
+}
diff --git a/crates/salsa/src/function/backdate.rs b/crates/salsa/src/function/backdate.rs
new file mode 100644
index 000000000..709111908
--- /dev/null
+++ b/crates/salsa/src/function/backdate.rs
@@ -0,0 +1,47 @@
+use crate::function::memo::Memo;
+use crate::function::{Configuration, IngredientImpl};
+use crate::zalsa_local::QueryRevisions;
+use crate::DatabaseKeyIndex;
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    /// If the value/durability of this memo is equal to what is found in `revisions`/`value`,
+    /// then update `revisions.changed_at` to match `self.revisions.changed_at`. This is invoked
+    /// on an old memo when a new memo has been produced to check whether there have been changed.
+    pub(super) fn backdate_if_appropriate<'db>(
+        &self,
+        old_memo: &Memo<C::Output<'db>>,
+        index: DatabaseKeyIndex,
+        revisions: &mut QueryRevisions,
+        value: &C::Output<'db>,
+    ) {
+        // We've seen issues where queries weren't re-validated when backdating provisional values
+        // in ty. This is more of a bandaid because we're close to a release and don't have the time to prove
+        // right now whether backdating could be made safe for queries participating in queries.
+        // TODO: Write a test that demonstrates that backdating queries participating in a cycle isn't safe
+        // OR write many tests showing that it is (and fixing the case where it didn't correctly account for today).
+        if !revisions.cycle_heads.is_empty() {
+            return;
+        }
+
+        if let Some(old_value) = &old_memo.value {
+            // Careful: if the value became less durable than it
+            // used to be, that is a "breaking change" that our
+            // consumers must be aware of. Becoming *more* durable
+            // is not. See the test `durable_to_less_durable`.
+            if revisions.durability >= old_memo.revisions.durability
+                && C::values_equal(old_value, value)
+            {
+                tracing::debug!(
+                    "{index:?} value is equal, back-dating to {:?}",
+                    old_memo.revisions.changed_at,
+                );
+
+                assert!(old_memo.revisions.changed_at <= revisions.changed_at);
+                revisions.changed_at = old_memo.revisions.changed_at;
+            }
+        }
+    }
+}
diff --git a/crates/salsa/src/function/delete.rs b/crates/salsa/src/function/delete.rs
new file mode 100644
index 000000000..77b5c0564
--- /dev/null
+++ b/crates/salsa/src/function/delete.rs
@@ -0,0 +1,55 @@
+use std::ptr::NonNull;
+
+use crate::function::memo::Memo;
+use crate::function::Configuration;
+
+/// Stores the list of memos that have been deleted so they can be freed
+/// once the next revision starts. See the comment on the field
+/// `deleted_entries` of [`FunctionIngredient`][] for more details.
+pub(super) struct DeletedEntries<C: Configuration> {
+    memos: boxcar::Vec<SharedBox<Memo<C::Output<'static>>>>,
+}
+
+#[allow(clippy::undocumented_unsafe_blocks)] // TODO(#697) document safety
+unsafe impl<T: Send> Send for SharedBox<T> {}
+#[allow(clippy::undocumented_unsafe_blocks)] // TODO(#697) document safety
+unsafe impl<T: Sync> Sync for SharedBox<T> {}
+
+impl<C: Configuration> Default for DeletedEntries<C> {
+    fn default() -> Self {
+        Self {
+            memos: Default::default(),
+        }
+    }
+}
+
+impl<C: Configuration> DeletedEntries<C> {
+    /// # Safety
+    ///
+    /// The memo must be valid and safe to free when the `DeletedEntries` list is cleared or dropped.
+    pub(super) unsafe fn push(&self, memo: NonNull<Memo<C::Output<'_>>>) {
+        // Safety: The memo must be valid and safe to free when the `DeletedEntries` list is cleared or dropped.
+        let memo = unsafe {
+            std::mem::transmute::<NonNull<Memo<C::Output<'_>>>, NonNull<Memo<C::Output<'static>>>>(
+                memo,
+            )
+        };
+
+        self.memos.push(SharedBox(memo));
+    }
+
+    /// Free all deleted memos, keeping the list available for reuse.
+    pub(super) fn clear(&mut self) {
+        self.memos.clear();
+    }
+}
+
+/// A wrapper around `NonNull` that frees the allocation when it is dropped.
+struct SharedBox<T>(NonNull<T>);
+
+impl<T> Drop for SharedBox<T> {
+    fn drop(&mut self) {
+        // SAFETY: Guaranteed by the caller of `DeletedEntries::push`.
+        unsafe { drop(Box::from_raw(self.0.as_ptr())) };
+    }
+}
diff --git a/crates/salsa/src/function/diff_outputs.rs b/crates/salsa/src/function/diff_outputs.rs
new file mode 100644
index 000000000..b00dc4143
--- /dev/null
+++ b/crates/salsa/src/function/diff_outputs.rs
@@ -0,0 +1,64 @@
+use crate::function::memo::Memo;
+use crate::function::{Configuration, IngredientImpl};
+use crate::hash::FxIndexSet;
+use crate::zalsa::Zalsa;
+use crate::zalsa_local::QueryRevisions;
+use crate::{DatabaseKeyIndex, Event, EventKind};
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    /// Compute the old and new outputs and invoke `remove_stale_output`
+    /// for each output that was generated before but is not generated now.
+    ///
+    /// This function takes a `&mut` reference to `revisions` to remove outputs
+    /// that no longer exist in this revision from [`QueryRevisions::tracked_struct_ids`].
+    ///
+    /// If `provisional` is true, the new outputs are from a cycle-provisional result. In
+    /// that case, we won't panic if we see outputs from the current revision become stale.
+    pub(super) fn diff_outputs(
+        &self,
+        zalsa: &Zalsa,
+        key: DatabaseKeyIndex,
+        old_memo: &Memo<C::Output<'_>>,
+        revisions: &mut QueryRevisions,
+    ) {
+        // Iterate over the outputs of the `old_memo` and put them into a hashset
+        let mut old_outputs: FxIndexSet<_> = old_memo.revisions.origin.outputs().collect();
+
+        if old_outputs.is_empty() {
+            return;
+        }
+
+        // Iterate over the outputs of the current query
+        // and remove elements from `old_outputs` when we find them
+        for new_output in revisions.origin.outputs() {
+            old_outputs.swap_remove(&new_output);
+        }
+
+        if old_outputs.is_empty() {
+            return;
+        }
+
+        // Remove the outputs that are no longer present in the current revision
+        // to prevent that the next revision is seeded with an id mapping that no longer exists.
+        revisions.tracked_struct_ids.retain(|&k, &mut value| {
+            !old_outputs.contains(&DatabaseKeyIndex::new(k.ingredient_index(), value))
+        });
+
+        for old_output in old_outputs {
+            Self::report_stale_output(zalsa, key, old_output);
+        }
+    }
+
+    fn report_stale_output(zalsa: &Zalsa, key: DatabaseKeyIndex, output: DatabaseKeyIndex) {
+        zalsa.event(&|| {
+            Event::new(EventKind::WillDiscardStaleOutput {
+                execute_key: key,
+                output_key: output,
+            })
+        });
+        output.remove_stale_output(zalsa, key);
+    }
+}
diff --git a/crates/salsa/src/function/execute.rs b/crates/salsa/src/function/execute.rs
new file mode 100644
index 000000000..bcb43a8ce
--- /dev/null
+++ b/crates/salsa/src/function/execute.rs
@@ -0,0 +1,275 @@
+use crate::cycle::{CycleRecoveryStrategy, MAX_ITERATIONS};
+use crate::function::memo::Memo;
+use crate::function::{Configuration, IngredientImpl};
+use crate::loom::sync::atomic::{AtomicBool, Ordering};
+use crate::zalsa::{MemoIngredientIndex, Zalsa, ZalsaDatabase};
+use crate::zalsa_local::{ActiveQueryGuard, QueryRevisions};
+use crate::{Event, EventKind, Id, Revision};
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    /// Executes the query function for the given `active_query`. Creates and stores
+    /// a new memo with the result, backdated if possible. Once this completes,
+    /// the query will have been popped off the active query stack.
+    ///
+    /// # Parameters
+    ///
+    /// * `db`, the database.
+    /// * `active_query`, the active stack frame for the query to execute.
+    /// * `opt_old_memo`, the older memo, if any existed. Used for backdating.
+    #[inline(never)]
+    pub(super) fn execute<'db>(
+        &'db self,
+        db: &'db C::DbView,
+        active_query: ActiveQueryGuard<'db>,
+        opt_old_memo: Option<&Memo<C::Output<'db>>>,
+    ) -> &'db Memo<C::Output<'db>> {
+        let database_key_index = active_query.database_key_index;
+        let id = database_key_index.key_index();
+
+        tracing::info!("{:?}: executing query", database_key_index);
+        let zalsa = db.zalsa();
+
+        zalsa.event(&|| {
+            Event::new(EventKind::WillExecute {
+                database_key: database_key_index,
+            })
+        });
+        let memo_ingredient_index = self.memo_ingredient_index(zalsa, id);
+
+        let (new_value, mut revisions) = match C::CYCLE_STRATEGY {
+            CycleRecoveryStrategy::Panic => {
+                Self::execute_query(db, active_query, opt_old_memo, zalsa.current_revision(), id)
+            }
+            CycleRecoveryStrategy::FallbackImmediate => {
+                let (mut new_value, mut revisions) = Self::execute_query(
+                    db,
+                    active_query,
+                    opt_old_memo,
+                    zalsa.current_revision(),
+                    id,
+                );
+
+                if !revisions.cycle_heads.is_empty() {
+                    // Did the new result we got depend on our own provisional value, in a cycle?
+                    if revisions.cycle_heads.contains(&database_key_index) {
+                        // Ignore the computed value, leave the fallback value there.
+                        let memo = self
+                            .get_memo_from_table_for(zalsa, id, memo_ingredient_index)
+                            .unwrap_or_else(|| {
+                                unreachable!(
+                                    "{database_key_index:#?} is a `FallbackImmediate` cycle head, \
+                                        but no memo found"
+                                )
+                            });
+                        // We need to mark the memo as finalized so other cycle participants that have fallbacks
+                        // will be verified (participants that don't have fallbacks will not be verified).
+                        memo.revisions.verified_final.store(true, Ordering::Release);
+                        return memo;
+                    }
+
+                    // If we're in the middle of a cycle and we have a fallback, use it instead.
+                    // Cycle participants that don't have a fallback will be discarded in
+                    // `validate_provisional()`.
+                    let cycle_heads = revisions.cycle_heads;
+                    let active_query = db.zalsa_local().push_query(database_key_index, 0);
+                    new_value = C::cycle_initial(db, C::id_to_input(db, id));
+                    revisions = active_query.pop();
+                    // We need to set `cycle_heads` and `verified_final` because it needs to propagate to the callers.
+                    // When verifying this, we will see we have fallback and mark ourselves verified.
+                    revisions.cycle_heads = cycle_heads;
+                    revisions.verified_final = AtomicBool::new(false);
+                }
+                (new_value, revisions)
+            }
+            CycleRecoveryStrategy::Fixpoint => self.execute_maybe_iterate(
+                db,
+                active_query,
+                opt_old_memo,
+                zalsa,
+                id,
+                memo_ingredient_index,
+            ),
+        };
+
+        if let Some(old_memo) = opt_old_memo {
+            // If the new value is equal to the old one, then it didn't
+            // really change, even if some of its inputs have. So we can
+            // "backdate" its `changed_at` revision to be the same as the
+            // old value.
+            self.backdate_if_appropriate(old_memo, database_key_index, &mut revisions, &new_value);
+
+            // Diff the new outputs with the old, to discard any no-longer-emitted
+            // outputs and update the tracked struct IDs for seeding the next revision.
+            self.diff_outputs(zalsa, database_key_index, old_memo, &mut revisions);
+        }
+        self.insert_memo(
+            zalsa,
+            id,
+            Memo::new(Some(new_value), zalsa.current_revision(), revisions),
+            memo_ingredient_index,
+        )
+    }
+
+    #[inline]
+    fn execute_maybe_iterate<'db>(
+        &'db self,
+        db: &'db C::DbView,
+        mut active_query: ActiveQueryGuard<'db>,
+        opt_old_memo: Option<&Memo<C::Output<'db>>>,
+        zalsa: &'db Zalsa,
+        id: Id,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) -> (C::Output<'db>, QueryRevisions) {
+        let database_key_index = active_query.database_key_index;
+        let mut iteration_count: u32 = 0;
+        let mut fell_back = false;
+
+        // Our provisional value from the previous iteration, when doing fixpoint iteration.
+        // Initially it's set to None, because the initial provisional value is created lazily,
+        // only when a cycle is actually encountered.
+        let mut opt_last_provisional: Option<&Memo<<C as Configuration>::Output<'db>>> = None;
+        loop {
+            let previous_memo = opt_last_provisional.or(opt_old_memo);
+            let (mut new_value, mut revisions) = Self::execute_query(
+                db,
+                active_query,
+                previous_memo,
+                zalsa.current_revision(),
+                id,
+            );
+
+            // Did the new result we got depend on our own provisional value, in a cycle?
+            if revisions.cycle_heads.contains(&database_key_index) {
+                let last_provisional_value = if let Some(last_provisional) = opt_last_provisional {
+                    // We have a last provisional value from our previous time around the loop.
+                    last_provisional.value.as_ref()
+                } else {
+                    // This is our first time around the loop; a provisional value must have been
+                    // inserted into the memo table when the cycle was hit, so let's pull our
+                    // initial provisional value from there.
+                    let memo = self
+                        .get_memo_from_table_for(zalsa, id, memo_ingredient_index)
+                        .unwrap_or_else(|| {
+                            unreachable!(
+                                "{database_key_index:#?} is a cycle head, \
+                                        but no provisional memo found"
+                            )
+                        });
+                    debug_assert!(memo.may_be_provisional());
+                    memo.value.as_ref()
+                };
+                // SAFETY: The `LRU` does not run mid-execution, so the value remains filled
+                let last_provisional_value = unsafe { last_provisional_value.unwrap_unchecked() };
+                tracing::debug!(
+                    "{database_key_index:?}: execute: \
+                        I am a cycle head, comparing last provisional value with new value"
+                );
+                // If the new result is equal to the last provisional result, the cycle has
+                // converged and we are done.
+                if !C::values_equal(&new_value, last_provisional_value) {
+                    if fell_back {
+                        // We fell back to a value last iteration, but the fallback didn't result
+                        // in convergence. We only have bad options here: continue iterating
+                        // (ignoring the request to fall back), or forcibly use the fallback and
+                        // leave the cycle in an inconsistent state (we'll be using a value for
+                        // this query that it doesn't evaluate to, given its inputs). Maybe we'll
+                        // have to go with the latter, but for now let's panic and see if real use
+                        // cases need non-converging fallbacks.
+                        panic!("{database_key_index:?}: execute: fallback did not converge");
+                    }
+                    // We are in a cycle that hasn't converged; ask the user's
+                    // cycle-recovery function what to do:
+                    match C::recover_from_cycle(
+                        db,
+                        &new_value,
+                        iteration_count,
+                        C::id_to_input(db, id),
+                    ) {
+                        crate::CycleRecoveryAction::Iterate => {
+                            tracing::debug!("{database_key_index:?}: execute: iterate again");
+                        }
+                        crate::CycleRecoveryAction::Fallback(fallback_value) => {
+                            tracing::debug!(
+                                "{database_key_index:?}: execute: user cycle_fn says to fall back"
+                            );
+                            new_value = fallback_value;
+                            // We have to insert the fallback value for this query and then iterate
+                            // one more time to fill in correct values for everything else in the
+                            // cycle based on it; then we'll re-insert it as final value.
+                            fell_back = true;
+                        }
+                    }
+                    // `iteration_count` can't overflow as we check it against `MAX_ITERATIONS`
+                    // which is less than `u32::MAX`.
+                    iteration_count += 1;
+                    if iteration_count > MAX_ITERATIONS {
+                        panic!("{database_key_index:?}: execute: too many cycle iterations");
+                    }
+                    zalsa.event(&|| {
+                        Event::new(EventKind::WillIterateCycle {
+                            database_key: database_key_index,
+                            iteration_count,
+                            fell_back,
+                        })
+                    });
+                    revisions
+                        .cycle_heads
+                        .update_iteration_count(database_key_index, iteration_count);
+                    opt_last_provisional = Some(self.insert_memo(
+                        zalsa,
+                        id,
+                        Memo::new(Some(new_value), zalsa.current_revision(), revisions),
+                        memo_ingredient_index,
+                    ));
+
+                    active_query = db
+                        .zalsa_local()
+                        .push_query(database_key_index, iteration_count);
+
+                    continue;
+                }
+                tracing::debug!(
+                    "{database_key_index:?}: execute: fixpoint iteration has a final value"
+                );
+                revisions.cycle_heads.remove(&database_key_index);
+            }
+
+            tracing::debug!("{database_key_index:?}: execute: result.revisions = {revisions:#?}");
+
+            break (new_value, revisions);
+        }
+    }
+
+    #[inline]
+    fn execute_query<'db>(
+        db: &'db C::DbView,
+        active_query: ActiveQueryGuard<'db>,
+        opt_old_memo: Option<&Memo<C::Output<'db>>>,
+        current_revision: Revision,
+        id: Id,
+    ) -> (C::Output<'db>, QueryRevisions) {
+        if let Some(old_memo) = opt_old_memo {
+            // If we already executed this query once, then use the tracked-struct ids from the
+            // previous execution as the starting point for the new one.
+            active_query.seed_tracked_struct_ids(&old_memo.revisions.tracked_struct_ids);
+
+            // Copy over all inputs and outputs from a previous iteration.
+            // This is necessary to:
+            // * ensure that tracked struct created during the previous iteration
+            //   (and are owned by the query) are alive even if the query in this iteration no longer creates them.
+            // * ensure the final returned memo depends on all inputs from all iterations.
+            if old_memo.may_be_provisional() && old_memo.verified_at.load() == current_revision {
+                active_query.seed_iteration(&old_memo.revisions);
+            }
+        }
+
+        // Query was not previously executed, or value is potentially
+        // stale, or value is absent. Let's execute!
+        let new_value = C::execute(db, C::id_to_input(db, id));
+
+        (new_value, active_query.pop())
+    }
+}
diff --git a/crates/salsa/src/function/fetch.rs b/crates/salsa/src/function/fetch.rs
new file mode 100644
index 000000000..6e461a59f
--- /dev/null
+++ b/crates/salsa/src/function/fetch.rs
@@ -0,0 +1,218 @@
+use crate::cycle::{CycleHeads, CycleRecoveryStrategy};
+use crate::function::memo::Memo;
+use crate::function::sync::ClaimResult;
+use crate::function::{Configuration, IngredientImpl, VerifyResult};
+use crate::loom::sync::AtomicMut;
+use crate::zalsa::{MemoIngredientIndex, Zalsa, ZalsaDatabase};
+use crate::zalsa_local::QueryRevisions;
+use crate::Id;
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    pub fn fetch<'db>(&'db self, db: &'db C::DbView, id: Id) -> &'db C::Output<'db> {
+        let (zalsa, zalsa_local) = db.zalsas();
+        zalsa.unwind_if_revision_cancelled(zalsa_local);
+
+        let memo = self.refresh_memo(db, zalsa, id);
+        // SAFETY: We just refreshed the memo so it is guaranteed to contain a value now.
+        let memo_value = unsafe { memo.value.as_ref().unwrap_unchecked() };
+
+        self.lru.record_use(id);
+
+        zalsa_local.report_tracked_read(
+            self.database_key_index(id),
+            memo.revisions.durability,
+            memo.revisions.changed_at,
+            memo.revisions.accumulated.is_some(),
+            &memo.revisions.accumulated_inputs,
+            memo.cycle_heads(),
+        );
+
+        memo_value
+    }
+
+    #[inline(always)]
+    pub(super) fn refresh_memo<'db>(
+        &'db self,
+        db: &'db C::DbView,
+        zalsa: &'db Zalsa,
+        id: Id,
+    ) -> &'db Memo<C::Output<'db>> {
+        let memo_ingredient_index = self.memo_ingredient_index(zalsa, id);
+        loop {
+            if let Some(memo) = self
+                .fetch_hot(zalsa, id, memo_ingredient_index)
+                .or_else(|| self.fetch_cold_with_retry(zalsa, db, id, memo_ingredient_index))
+            {
+                return memo;
+            }
+        }
+    }
+
+    #[inline(always)]
+    fn fetch_hot<'db>(
+        &'db self,
+        zalsa: &'db Zalsa,
+        id: Id,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) -> Option<&'db Memo<C::Output<'db>>> {
+        let memo = self.get_memo_from_table_for(zalsa, id, memo_ingredient_index)?;
+
+        memo.value.as_ref()?;
+
+        let database_key_index = self.database_key_index(id);
+
+        let can_shallow_update = self.shallow_verify_memo(zalsa, database_key_index, memo);
+
+        if can_shallow_update.yes() && !memo.may_be_provisional() {
+            self.update_shallow(zalsa, database_key_index, memo, can_shallow_update);
+
+            // SAFETY: memo is present in memo_map and we have verified that it is
+            // still valid for the current revision.
+            unsafe { Some(self.extend_memo_lifetime(memo)) }
+        } else {
+            None
+        }
+    }
+
+    #[inline(never)]
+    fn fetch_cold_with_retry<'db>(
+        &'db self,
+        zalsa: &'db Zalsa,
+        db: &'db C::DbView,
+        id: Id,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) -> Option<&'db Memo<C::Output<'db>>> {
+        let memo = self.fetch_cold(zalsa, db, id, memo_ingredient_index)?;
+
+        // If we get back a provisional cycle memo, and it's provisional on any cycle heads
+        // that are claimed by a different thread, we can't propagate the provisional memo
+        // any further (it could escape outside the cycle); we need to block on the other
+        // thread completing fixpoint iteration of the cycle, and then we can re-query for
+        // our no-longer-provisional memo.
+        // That is only correct for fixpoint cycles, though: `FallbackImmediate` cycles
+        // never have provisional entries.
+        if C::CYCLE_STRATEGY == CycleRecoveryStrategy::FallbackImmediate
+            || !memo.provisional_retry(zalsa, self.database_key_index(id))
+        {
+            Some(memo)
+        } else {
+            None
+        }
+    }
+
+    fn fetch_cold<'db>(
+        &'db self,
+        zalsa: &'db Zalsa,
+        db: &'db C::DbView,
+        id: Id,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) -> Option<&'db Memo<C::Output<'db>>> {
+        // Try to claim this query: if someone else has claimed it already, go back and start again.
+        let _claim_guard = match self.sync_table.try_claim(zalsa, id) {
+            ClaimResult::Retry => return None,
+            ClaimResult::Cycle => {
+                let database_key_index = self.database_key_index(id);
+                // check if there's a provisional value for this query
+                // Note we don't `validate_may_be_provisional` the memo here as we want to reuse an
+                // existing provisional memo if it exists
+                let memo_guard = self.get_memo_from_table_for(zalsa, id, memo_ingredient_index);
+                if let Some(memo) = memo_guard {
+                    if memo.value.is_some()
+                        && memo.revisions.cycle_heads.contains(&database_key_index)
+                    {
+                        let can_shallow_update =
+                            self.shallow_verify_memo(zalsa, database_key_index, memo);
+                        if can_shallow_update.yes() {
+                            self.update_shallow(
+                                zalsa,
+                                database_key_index,
+                                memo,
+                                can_shallow_update,
+                            );
+                            // SAFETY: memo is present in memo_map.
+                            return unsafe { Some(self.extend_memo_lifetime(memo)) };
+                        }
+                    }
+                }
+                // no provisional value; create/insert/return initial provisional value
+                return match C::CYCLE_STRATEGY {
+                    CycleRecoveryStrategy::Panic => db.zalsa_local().with_query_stack(|stack| {
+                        panic!(
+                            "dependency graph cycle when querying {database_key_index:#?}, \
+                            set cycle_fn/cycle_initial to fixpoint iterate.\n\
+                            Query stack:\n{stack:#?}",
+                        );
+                    }),
+                    CycleRecoveryStrategy::Fixpoint => {
+                        tracing::debug!(
+                            "hit cycle at {database_key_index:#?}, \
+                            inserting and returning fixpoint initial value"
+                        );
+                        let revisions = QueryRevisions::fixpoint_initial(database_key_index);
+                        let initial_value = self
+                            .initial_value(db, id)
+                            .expect("`CycleRecoveryStrategy::Fixpoint` should have initial_value");
+                        Some(self.insert_memo(
+                            zalsa,
+                            id,
+                            Memo::new(Some(initial_value), zalsa.current_revision(), revisions),
+                            memo_ingredient_index,
+                        ))
+                    }
+                    CycleRecoveryStrategy::FallbackImmediate => {
+                        tracing::debug!(
+                            "hit a `FallbackImmediate` cycle at {database_key_index:#?}"
+                        );
+                        let active_query = db.zalsa_local().push_query(database_key_index, 0);
+                        let fallback_value = self.initial_value(db, id).expect(
+                            "`CycleRecoveryStrategy::FallbackImmediate` should have initial_value",
+                        );
+                        let mut revisions = active_query.pop();
+                        revisions.cycle_heads = CycleHeads::initial(database_key_index);
+                        // We need this for `cycle_heads()` to work. We will unset this in the outer `execute()`.
+                        revisions.verified_final.write_mut(false);
+                        Some(self.insert_memo(
+                            zalsa,
+                            id,
+                            Memo::new(Some(fallback_value), zalsa.current_revision(), revisions),
+                            memo_ingredient_index,
+                        ))
+                    }
+                };
+            }
+            ClaimResult::Claimed(guard) => guard,
+        };
+
+        // Now that we've claimed the item, check again to see if there's a "hot" value.
+        let opt_old_memo = self.get_memo_from_table_for(zalsa, id, memo_ingredient_index);
+        if let Some(old_memo) = opt_old_memo {
+            if old_memo.value.is_some() {
+                let mut cycle_heads = CycleHeads::default();
+                if let VerifyResult::Unchanged(_) = self.deep_verify_memo(
+                    db,
+                    zalsa,
+                    old_memo,
+                    self.database_key_index(id),
+                    &mut cycle_heads,
+                ) {
+                    if cycle_heads.is_empty() {
+                        // SAFETY: memo is present in memo_map and we have verified that it is
+                        // still valid for the current revision.
+                        return unsafe { Some(self.extend_memo_lifetime(old_memo)) };
+                    }
+                }
+            }
+        }
+
+        let memo = self.execute(
+            db,
+            db.zalsa_local().push_query(self.database_key_index(id), 0),
+            opt_old_memo,
+        );
+
+        Some(memo)
+    }
+}
diff --git a/crates/salsa/src/function/inputs.rs b/crates/salsa/src/function/inputs.rs
new file mode 100644
index 000000000..7f201e0b9
--- /dev/null
+++ b/crates/salsa/src/function/inputs.rs
@@ -0,0 +1,15 @@
+use crate::function::{Configuration, IngredientImpl};
+use crate::zalsa::Zalsa;
+use crate::zalsa_local::QueryOrigin;
+use crate::Id;
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    pub(super) fn origin(&self, zalsa: &Zalsa, key: Id) -> Option<QueryOrigin> {
+        let memo_ingredient_index = self.memo_ingredient_index(zalsa, key);
+        self.get_memo_from_table_for(zalsa, key, memo_ingredient_index)
+            .map(|m| m.revisions.origin.clone())
+    }
+}
diff --git a/crates/salsa/src/function/lru.rs b/crates/salsa/src/function/lru.rs
new file mode 100644
index 000000000..f981eb6bf
--- /dev/null
+++ b/crates/salsa/src/function/lru.rs
@@ -0,0 +1,51 @@
+use std::num::NonZeroUsize;
+
+use crate::hash::FxLinkedHashSet;
+use crate::loom::sync::Mutex;
+use crate::Id;
+
+pub(super) struct Lru {
+    capacity: Option<NonZeroUsize>,
+    set: Mutex<FxLinkedHashSet<Id>>,
+}
+
+impl Lru {
+    pub fn new(cap: usize) -> Self {
+        Self {
+            capacity: NonZeroUsize::new(cap),
+            set: Mutex::default(),
+        }
+    }
+
+    #[inline(always)]
+    pub(super) fn record_use(&self, index: Id) {
+        if self.capacity.is_some() {
+            self.insert(index);
+        }
+    }
+
+    #[inline(never)]
+    fn insert(&self, index: Id) {
+        let mut set = self.set.lock();
+        set.insert(index);
+    }
+
+    pub(super) fn set_capacity(&mut self, capacity: usize) {
+        self.capacity = NonZeroUsize::new(capacity);
+        if self.capacity.is_none() {
+            self.set.get_mut().clear();
+        }
+    }
+
+    pub(super) fn for_each_evicted(&mut self, mut cb: impl FnMut(Id)) {
+        let Some(cap) = self.capacity else {
+            return;
+        };
+        let set = self.set.get_mut();
+        while set.len() > cap.get() {
+            if let Some(id) = set.pop_front() {
+                cb(id);
+            }
+        }
+    }
+}
diff --git a/crates/salsa/src/function/maybe_changed_after.rs b/crates/salsa/src/function/maybe_changed_after.rs
new file mode 100644
index 000000000..a16d53fab
--- /dev/null
+++ b/crates/salsa/src/function/maybe_changed_after.rs
@@ -0,0 +1,510 @@
+use crate::accumulator::accumulated_map::InputAccumulatedValues;
+use crate::cycle::{CycleHeadKind, CycleHeads, CycleRecoveryStrategy};
+use crate::function::memo::Memo;
+use crate::function::sync::ClaimResult;
+use crate::function::{Configuration, IngredientImpl};
+use crate::key::DatabaseKeyIndex;
+use crate::loom::sync::atomic::Ordering;
+use crate::plumbing::ZalsaLocal;
+use crate::zalsa::{MemoIngredientIndex, Zalsa, ZalsaDatabase};
+use crate::zalsa_local::{QueryEdge, QueryOrigin};
+use crate::{AsDynDatabase as _, Id, Revision};
+
+/// Result of memo validation.
+pub enum VerifyResult {
+    /// Memo has changed and needs to be recomputed.
+    Changed,
+
+    /// Memo remains valid.
+    ///
+    /// The inner value tracks whether the memo or any of its dependencies have an
+    /// accumulated value.
+    Unchanged(InputAccumulatedValues),
+}
+
+impl VerifyResult {
+    pub(crate) fn changed_if(changed: bool) -> Self {
+        if changed {
+            Self::Changed
+        } else {
+            Self::unchanged()
+        }
+    }
+
+    pub(crate) fn unchanged() -> Self {
+        Self::Unchanged(InputAccumulatedValues::Empty)
+    }
+}
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    pub(super) fn maybe_changed_after<'db>(
+        &'db self,
+        db: &'db C::DbView,
+        id: Id,
+        revision: Revision,
+        cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        let (zalsa, zalsa_local) = db.zalsas();
+        let memo_ingredient_index = self.memo_ingredient_index(zalsa, id);
+        zalsa.unwind_if_revision_cancelled(zalsa_local);
+
+        loop {
+            let database_key_index = self.database_key_index(id);
+
+            tracing::debug!("{database_key_index:?}: maybe_changed_after(revision = {revision:?})");
+
+            // Check if we have a verified version: this is the hot path.
+            let memo_guard = self.get_memo_from_table_for(zalsa, id, memo_ingredient_index);
+            let Some(memo) = memo_guard else {
+                // No memo? Assume has changed.
+                return VerifyResult::Changed;
+            };
+
+            let can_shallow_update = self.shallow_verify_memo(zalsa, database_key_index, memo);
+            if can_shallow_update.yes() && !memo.may_be_provisional() {
+                self.update_shallow(zalsa, database_key_index, memo, can_shallow_update);
+
+                return if memo.revisions.changed_at > revision {
+                    VerifyResult::Changed
+                } else {
+                    VerifyResult::Unchanged(memo.revisions.accumulated_inputs.load())
+                };
+            }
+
+            if let Some(mcs) = self.maybe_changed_after_cold(
+                zalsa,
+                db,
+                id,
+                revision,
+                memo_ingredient_index,
+                cycle_heads,
+            ) {
+                return mcs;
+            } else {
+                // We failed to claim, have to retry.
+            }
+        }
+    }
+
+    #[inline(never)]
+    fn maybe_changed_after_cold<'db>(
+        &'db self,
+        zalsa: &Zalsa,
+        db: &'db C::DbView,
+        key_index: Id,
+        revision: Revision,
+        memo_ingredient_index: MemoIngredientIndex,
+        cycle_heads: &mut CycleHeads,
+    ) -> Option<VerifyResult> {
+        let database_key_index = self.database_key_index(key_index);
+
+        let _claim_guard = match self.sync_table.try_claim(zalsa, key_index) {
+            ClaimResult::Retry => return None,
+            ClaimResult::Cycle => match C::CYCLE_STRATEGY {
+                CycleRecoveryStrategy::Panic => db.zalsa_local().with_query_stack(|stack| {
+                    panic!(
+                        "dependency graph cycle when validating {database_key_index:#?}, \
+                            set cycle_fn/cycle_initial to fixpoint iterate.\n\
+                            Query stack:\n{stack:#?}",
+                    );
+                }),
+                CycleRecoveryStrategy::FallbackImmediate => {
+                    return Some(VerifyResult::unchanged());
+                }
+                CycleRecoveryStrategy::Fixpoint => {
+                    tracing::debug!(
+                        "hit cycle at {database_key_index:?} in `maybe_changed_after`,  returning fixpoint initial value",
+                    );
+                    cycle_heads.push_initial(database_key_index);
+                    return Some(VerifyResult::unchanged());
+                }
+            },
+            ClaimResult::Claimed(guard) => guard,
+        };
+        // Load the current memo, if any.
+        let Some(old_memo) = self.get_memo_from_table_for(zalsa, key_index, memo_ingredient_index)
+        else {
+            return Some(VerifyResult::Changed);
+        };
+
+        tracing::debug!(
+            "{database_key_index:?}: maybe_changed_after_cold, successful claim, \
+                revision = {revision:?}, old_memo = {old_memo:#?}",
+            old_memo = old_memo.tracing_debug()
+        );
+
+        // Check if the inputs are still valid. We can just compare `changed_at`.
+        let deep_verify =
+            self.deep_verify_memo(db, zalsa, old_memo, database_key_index, cycle_heads);
+        if let VerifyResult::Unchanged(accumulated_inputs) = deep_verify {
+            return Some(if old_memo.revisions.changed_at > revision {
+                VerifyResult::Changed
+            } else {
+                VerifyResult::Unchanged(accumulated_inputs)
+            });
+        }
+
+        // If inputs have changed, but we have an old value, we can re-execute.
+        // It is possible the result will be equal to the old value and hence
+        // backdated. In that case, although we will have computed a new memo,
+        // the value has not logically changed.
+        // However, executing the query here is only safe if we are not in a cycle.
+        // In a cycle, it's important that the cycle head gets executed or we
+        // risk that some dependencies of this query haven't been verified yet because
+        // the cycle head returned *fixpoint initial* without validating its dependencies.
+        // `in_cycle` tracks if the enclosing query is in a cycle. `deep_verify.cycle_heads` tracks
+        // if **this query** encountered a cycle (which means there's some provisional value somewhere floating around).
+        if old_memo.value.is_some() && cycle_heads.is_empty() {
+            let active_query = db.zalsa_local().push_query(database_key_index, 0);
+            let memo = self.execute(db, active_query, Some(old_memo));
+            let changed_at = memo.revisions.changed_at;
+
+            return Some(if changed_at > revision {
+                VerifyResult::Changed
+            } else {
+                VerifyResult::Unchanged(match &memo.revisions.accumulated {
+                    Some(_) => InputAccumulatedValues::Any,
+                    None => memo.revisions.accumulated_inputs.load(),
+                })
+            });
+        }
+
+        // Otherwise, nothing for it: have to consider the value to have changed.
+        Some(VerifyResult::Changed)
+    }
+
+    /// `Some` if the memo's value and `changed_at` time is still valid in this revision.
+    /// Does only a shallow O(1) check, doesn't walk the dependencies.
+    ///
+    /// In general, a provisional memo (from cycle iteration) does not verify. Since we don't
+    /// eagerly finalize all provisional memos in cycle iteration, we have to lazily check here
+    /// (via `validate_provisional`) whether a may-be-provisional memo should actually be verified
+    /// final, because its cycle heads are all now final.
+    #[inline]
+    pub(super) fn shallow_verify_memo(
+        &self,
+        zalsa: &Zalsa,
+        database_key_index: DatabaseKeyIndex,
+        memo: &Memo<C::Output<'_>>,
+    ) -> ShallowUpdate {
+        tracing::debug!(
+            "{database_key_index:?}: shallow_verify_memo(memo = {memo:#?})",
+            memo = memo.tracing_debug()
+        );
+        let verified_at = memo.verified_at.load();
+        let revision_now = zalsa.current_revision();
+
+        if verified_at == revision_now {
+            // Already verified.
+            return ShallowUpdate::Verified;
+        }
+
+        let last_changed = zalsa.last_changed_revision(memo.revisions.durability);
+        tracing::debug!(
+            "{database_key_index:?}: check_durability(memo = {memo:#?}, last_changed={:?} <= verified_at={:?}) = {:?}",
+            last_changed,
+            verified_at,
+            last_changed <= verified_at,
+            memo = memo.tracing_debug()
+        );
+        if last_changed <= verified_at {
+            // No input of the suitable durability has changed since last verified.
+            ShallowUpdate::HigherDurability
+        } else {
+            ShallowUpdate::No
+        }
+    }
+
+    #[inline]
+    pub(super) fn update_shallow(
+        &self,
+        zalsa: &Zalsa,
+        database_key_index: DatabaseKeyIndex,
+        memo: &Memo<C::Output<'_>>,
+        update: ShallowUpdate,
+    ) {
+        if let ShallowUpdate::HigherDurability = update {
+            memo.mark_as_verified(zalsa, database_key_index);
+            memo.mark_outputs_as_verified(zalsa, database_key_index);
+        }
+    }
+
+    /// Validates this memo if it is a provisional memo. Returns true for:
+    /// * non provisional memos
+    /// * provisional memos that have been successfully marked as verified final, that is, its
+    ///   cycle heads have all been finalized.
+    /// * provisional memos that have been created in the same revision and iteration and are part of the same cycle.
+    #[inline]
+    pub(super) fn validate_may_be_provisional(
+        &self,
+        zalsa: &Zalsa,
+        zalsa_local: &ZalsaLocal,
+        database_key_index: DatabaseKeyIndex,
+        memo: &Memo<C::Output<'_>>,
+    ) -> bool {
+        !memo.may_be_provisional()
+            || self.validate_provisional(zalsa, database_key_index, memo)
+            || self.validate_same_iteration(zalsa_local, database_key_index, memo)
+    }
+
+    /// Check if this memo's cycle heads have all been finalized. If so, mark it verified final and
+    /// return true, if not return false.
+    #[inline]
+    fn validate_provisional(
+        &self,
+        zalsa: &Zalsa,
+        database_key_index: DatabaseKeyIndex,
+        memo: &Memo<C::Output<'_>>,
+    ) -> bool {
+        tracing::trace!(
+            "{database_key_index:?}: validate_provisional(memo = {memo:#?})",
+            memo = memo.tracing_debug()
+        );
+        for cycle_head in &memo.revisions.cycle_heads {
+            let kind = zalsa
+                .lookup_ingredient(cycle_head.database_key_index.ingredient_index())
+                .cycle_head_kind(zalsa, cycle_head.database_key_index.key_index());
+            match kind {
+                CycleHeadKind::Provisional => return false,
+                CycleHeadKind::NotProvisional => {
+                    // FIXME: We can ignore this, I just don't have a use-case for this.
+                    if C::CYCLE_STRATEGY == CycleRecoveryStrategy::FallbackImmediate {
+                        panic!("cannot mix `cycle_fn` and `cycle_result` in cycles")
+                    }
+                }
+                CycleHeadKind::FallbackImmediate => match C::CYCLE_STRATEGY {
+                    CycleRecoveryStrategy::Panic => {
+                        // Queries without fallback are not considered when inside a cycle.
+                        return false;
+                    }
+                    // FIXME: We can do the same as with `CycleRecoveryStrategy::Panic` here, I just don't have
+                    // a use-case for this.
+                    CycleRecoveryStrategy::Fixpoint => {
+                        panic!("cannot mix `cycle_fn` and `cycle_result` in cycles")
+                    }
+                    CycleRecoveryStrategy::FallbackImmediate => {}
+                },
+            }
+        }
+        // Relaxed is sufficient here because there are no other writes we need to ensure have
+        // happened before marking this memo as verified-final.
+        memo.revisions.verified_final.store(true, Ordering::Relaxed);
+        true
+    }
+
+    /// If this is a provisional memo, validate that it was cached in the same iteration of the
+    /// same cycle(s) that we are still executing. If so, it is valid for reuse. This avoids
+    /// runaway re-execution of the same queries within a fixpoint iteration.
+    pub(super) fn validate_same_iteration(
+        &self,
+        zalsa_local: &ZalsaLocal,
+        database_key_index: DatabaseKeyIndex,
+        memo: &Memo<C::Output<'_>>,
+    ) -> bool {
+        tracing::trace!(
+            "{database_key_index:?}: validate_same_iteration(memo = {memo:#?})",
+            memo = memo.tracing_debug()
+        );
+
+        let cycle_heads = &memo.revisions.cycle_heads;
+        if cycle_heads.is_empty() {
+            return true;
+        }
+
+        zalsa_local.with_query_stack(|stack| {
+            cycle_heads.iter().all(|cycle_head| {
+                stack
+                    .iter()
+                    .rev()
+                    .find(|query| query.database_key_index == cycle_head.database_key_index)
+                    .is_some_and(|query| query.iteration_count() == cycle_head.iteration_count)
+            })
+        })
+    }
+
+    /// VerifyResult::Unchanged if the memo's value and `changed_at` time is up-to-date in the
+    /// current revision. When this returns Unchanged with no cycle heads, it also updates the
+    /// memo's `verified_at` field if needed to make future calls cheaper.
+    ///
+    /// Takes an [`ActiveQueryGuard`] argument because this function recursively
+    /// walks dependencies of `old_memo` and may even execute them to see if their
+    /// outputs have changed.
+    pub(super) fn deep_verify_memo(
+        &self,
+        db: &C::DbView,
+        zalsa: &Zalsa,
+        old_memo: &Memo<C::Output<'_>>,
+        database_key_index: DatabaseKeyIndex,
+        cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        tracing::debug!(
+            "{database_key_index:?}: deep_verify_memo(old_memo = {old_memo:#?})",
+            old_memo = old_memo.tracing_debug()
+        );
+
+        let can_shallow_update = self.shallow_verify_memo(zalsa, database_key_index, old_memo);
+        if can_shallow_update.yes()
+            && self.validate_may_be_provisional(
+                zalsa,
+                db.zalsa_local(),
+                database_key_index,
+                old_memo,
+            )
+        {
+            self.update_shallow(zalsa, database_key_index, old_memo, can_shallow_update);
+
+            return VerifyResult::unchanged();
+        }
+
+        match &old_memo.revisions.origin {
+            QueryOrigin::Assigned(_) => {
+                // If the value was assigned by another query,
+                // and that query were up-to-date,
+                // then we would have updated the `verified_at` field already.
+                // So the fact that we are here means that it was not specified
+                // during this revision or is otherwise stale.
+                //
+                // Example of how this can happen:
+                //
+                // Conditionally specified queries
+                // where the value is specified
+                // in rev 1 but not in rev 2.
+                VerifyResult::Changed
+            }
+            // Return `Unchanged` similar to the initial value that we insert
+            // when we hit the cycle. Any dependencies accessed when creating the fixpoint initial
+            // are tracked by the outer query. Nothing should have changed assuming that the
+            // fixpoint initial function is deterministic.
+            QueryOrigin::FixpointInitial => {
+                cycle_heads.push_initial(database_key_index);
+                VerifyResult::unchanged()
+            }
+            QueryOrigin::DerivedUntracked(_) => {
+                // Untracked inputs? Have to assume that it changed.
+                VerifyResult::Changed
+            }
+            QueryOrigin::Derived(edges) => {
+                let is_provisional = old_memo.may_be_provisional();
+
+                // If the value is from the same revision but is still provisional, consider it changed
+                // because we're now in a new iteration.
+                if can_shallow_update == ShallowUpdate::Verified && is_provisional {
+                    return VerifyResult::Changed;
+                }
+
+                let dyn_db = db.as_dyn_database();
+
+                let mut inputs = InputAccumulatedValues::Empty;
+                // Fully tracked inputs? Iterate over the inputs and check them, one by one.
+                //
+                // NB: It's important here that we are iterating the inputs in the order that
+                // they executed. It's possible that if the value of some input I0 is no longer
+                // valid, then some later input I1 might never have executed at all, so verifying
+                // it is still up to date is meaningless.
+                for &edge in edges.input_outputs.iter() {
+                    match edge {
+                        QueryEdge::Input(dependency_index) => {
+                            match dependency_index.maybe_changed_after(
+                                dyn_db,
+                                zalsa,
+                                old_memo.verified_at.load(),
+                                cycle_heads,
+                            ) {
+                                VerifyResult::Changed => return VerifyResult::Changed,
+                                VerifyResult::Unchanged(input_accumulated) => {
+                                    inputs |= input_accumulated;
+                                }
+                            }
+                        }
+                        QueryEdge::Output(dependency_index) => {
+                            // Subtle: Mark outputs as validated now, even though we may
+                            // later find an input that requires us to re-execute the function.
+                            // Even if it re-execute, the function will wind up writing the same value,
+                            // since all prior inputs were green. It's important to do this during
+                            // this loop, because it's possible that one of our input queries will
+                            // re-execute and may read one of our earlier outputs
+                            // (e.g., in a scenario where we do something like
+                            // `e = Entity::new(..); query(e);` and `query` reads a field of `e`).
+                            //
+                            // NB. Accumulators are also outputs, but the above logic doesn't
+                            // quite apply to them. Since multiple values are pushed, the first value
+                            // may be unchanged, but later values could be different.
+                            // In that case, however, the data accumulated
+                            // by this function cannot be read until this function is marked green,
+                            // so even if we mark them as valid here, the function will re-execute
+                            // and overwrite the contents.
+                            dependency_index.mark_validated_output(zalsa, database_key_index);
+                        }
+                    }
+                }
+
+                // Possible scenarios here:
+                //
+                // 1. Cycle heads is empty. We traversed our full dependency graph and neither hit any
+                //    cycles, nor found any changed dependencies. We can mark our memo verified and
+                //    return Unchanged with empty cycle heads.
+                //
+                // 2. Cycle heads is non-empty, and does not contain our own key index. We are part of
+                //    a cycle, and since we don't know if some other cycle participant that hasn't been
+                //    traversed yet (that is, some other dependency of the cycle head, which is only a
+                //    dependency of ours via the cycle) might still have changed, we can't yet mark our
+                //    memo verified. We can return a provisional Unchanged, with cycle heads.
+                //
+                // 3. Cycle heads is non-empty, and contains only our own key index. We are the head of
+                //    a cycle, and we've now traversed the entire cycle and found no changes, but no
+                //    other cycle participants were verified (they would have all hit case 2 above).
+                //    Similar to `execute`, return unchanged and lazily verify the other cycle-participants
+                //    when they're used next.
+                //
+                // 4. Cycle heads is non-empty, and contains our own key index as well as other key
+                //    indices. We are the head of a cycle nested within another cycle. We can't mark
+                //    our own memo verified (for the same reason as in case 2: the full outer cycle
+                //    hasn't been validated unchanged yet). We return Unchanged, with ourself removed
+                //    from cycle heads. We will handle our own memo (and the rest of our cycle) on a
+                //    future iteration; first the outer cycle head needs to verify itself.
+
+                cycle_heads.remove(&database_key_index);
+
+                // 1 and 3
+                if cycle_heads.is_empty() {
+                    old_memo.mark_as_verified(zalsa, database_key_index);
+                    old_memo.revisions.accumulated_inputs.store(inputs);
+
+                    if is_provisional {
+                        old_memo
+                            .revisions
+                            .verified_final
+                            .store(true, Ordering::Relaxed);
+                    }
+                }
+
+                VerifyResult::Unchanged(inputs)
+            }
+        }
+    }
+}
+
+#[derive(Copy, Clone, Eq, PartialEq)]
+pub(super) enum ShallowUpdate {
+    /// The memo is from this revision and has already been verified
+    Verified,
+
+    /// The revision for the memo's durability hasn't changed. It can be marked as verified
+    /// in this revision.
+    HigherDurability,
+
+    /// The memo requires a deep verification.
+    No,
+}
+
+impl ShallowUpdate {
+    pub(super) fn yes(&self) -> bool {
+        matches!(
+            self,
+            ShallowUpdate::Verified | ShallowUpdate::HigherDurability
+        )
+    }
+}
diff --git a/crates/salsa/src/function/memo.rs b/crates/salsa/src/function/memo.rs
new file mode 100644
index 000000000..d849fbb48
--- /dev/null
+++ b/crates/salsa/src/function/memo.rs
@@ -0,0 +1,271 @@
+use std::any::Any;
+use std::fmt::{Debug, Formatter};
+use std::mem::transmute;
+use std::ptr::NonNull;
+
+use crate::cycle::{CycleHeadKind, CycleHeads, CycleRecoveryStrategy, EMPTY_CYCLE_HEADS};
+use crate::function::{Configuration, IngredientImpl};
+use crate::key::DatabaseKeyIndex;
+use crate::loom::sync::atomic::Ordering;
+use crate::revision::AtomicRevision;
+use crate::table::memo::MemoTableWithTypesMut;
+use crate::zalsa::{MemoIngredientIndex, Zalsa};
+use crate::zalsa_local::{QueryOrigin, QueryRevisions};
+use crate::{Event, EventKind, Id, Revision};
+
+impl<C: Configuration> IngredientImpl<C> {
+    /// Inserts the memo for the given key; (atomically) overwrites and returns any previously existing memo
+    pub(super) fn insert_memo_into_table_for<'db>(
+        &self,
+        zalsa: &'db Zalsa,
+        id: Id,
+        memo: NonNull<Memo<C::Output<'db>>>,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) -> Option<NonNull<Memo<C::Output<'db>>>> {
+        // SAFETY: The table stores 'static memos (to support `Any`), the memos are in fact valid
+        // for `'db` though as we delay their dropping to the end of a revision.
+        let static_memo = unsafe {
+            transmute::<NonNull<Memo<C::Output<'db>>>, NonNull<Memo<C::Output<'static>>>>(memo)
+        };
+        let old_static_memo = zalsa
+            .memo_table_for(id)
+            .insert(memo_ingredient_index, static_memo)?;
+        // SAFETY: The table stores 'static memos (to support `Any`), the memos are in fact valid
+        // for `'db` though as we delay their dropping to the end of a revision.
+        Some(unsafe {
+            transmute::<NonNull<Memo<C::Output<'static>>>, NonNull<Memo<C::Output<'db>>>>(
+                old_static_memo,
+            )
+        })
+    }
+
+    /// Loads the current memo for `key_index`. This does not hold any sort of
+    /// lock on the `memo_map` once it returns, so this memo could immediately
+    /// become outdated if other threads store into the `memo_map`.
+    pub(super) fn get_memo_from_table_for<'db>(
+        &self,
+        zalsa: &'db Zalsa,
+        id: Id,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) -> Option<&'db Memo<C::Output<'db>>> {
+        let static_memo = zalsa.memo_table_for(id).get(memo_ingredient_index)?;
+        // SAFETY: The table stores 'static memos (to support `Any`), the memos are in fact valid
+        // for `'db` though as we delay their dropping to the end of a revision.
+        Some(unsafe {
+            transmute::<&Memo<C::Output<'static>>, &'db Memo<C::Output<'db>>>(static_memo.as_ref())
+        })
+    }
+
+    /// Evicts the existing memo for the given key, replacing it
+    /// with an equivalent memo that has no value. If the memo is untracked, FixpointInitial,
+    /// or has values assigned as output of another query, this has no effect.
+    pub(super) fn evict_value_from_memo_for(
+        table: MemoTableWithTypesMut<'_>,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) {
+        let map = |memo: &mut Memo<C::Output<'static>>| {
+            match &memo.revisions.origin {
+                QueryOrigin::Assigned(_)
+                | QueryOrigin::DerivedUntracked(_)
+                | QueryOrigin::FixpointInitial => {
+                    // Careful: Cannot evict memos whose values were
+                    // assigned as output of another query
+                    // or those with untracked inputs
+                    // as their values cannot be reconstructed.
+                }
+                QueryOrigin::Derived(_) => {
+                    // Set the memo value to `None`.
+                    memo.value = None;
+                }
+            }
+        };
+
+        table.map_memo(memo_ingredient_index, map)
+    }
+
+    pub(super) fn initial_value<'db>(
+        &'db self,
+        db: &'db C::DbView,
+        key: Id,
+    ) -> Option<C::Output<'db>> {
+        match C::CYCLE_STRATEGY {
+            CycleRecoveryStrategy::Fixpoint | CycleRecoveryStrategy::FallbackImmediate => {
+                Some(C::cycle_initial(db, C::id_to_input(db, key)))
+            }
+            CycleRecoveryStrategy::Panic => None,
+        }
+    }
+}
+
+#[derive(Debug)]
+pub struct Memo<V> {
+    /// The result of the query, if we decide to memoize it.
+    pub(super) value: Option<V>,
+
+    /// Last revision when this memo was verified; this begins
+    /// as the current revision.
+    pub(super) verified_at: AtomicRevision,
+
+    /// Revision information
+    pub(super) revisions: QueryRevisions,
+}
+
+// Memo's are stored a lot, make sure their size is doesn't randomly increase.
+#[cfg(not(loom))]
+const _: [(); std::mem::size_of::<Memo<std::num::NonZeroUsize>>()] =
+    [(); std::mem::size_of::<[usize; 13]>()];
+
+impl<V> Memo<V> {
+    pub(super) fn new(value: Option<V>, revision_now: Revision, revisions: QueryRevisions) -> Self {
+        Memo {
+            value,
+            verified_at: AtomicRevision::from(revision_now),
+            revisions,
+        }
+    }
+
+    /// True if this may be a provisional cycle-iteration result.
+    #[inline]
+    pub(super) fn may_be_provisional(&self) -> bool {
+        // Relaxed is OK here, because `verified_final` is only ever mutated in one direction (from
+        // `false` to `true`), and changing it to `true` on memos with cycle heads where it was
+        // ever `false` is purely an optimization; if we read an out-of-date `false`, it just means
+        // we might go validate it again unnecessarily.
+        !self.revisions.verified_final.load(Ordering::Relaxed)
+    }
+
+    /// Invoked when `refresh_memo` is about to return a memo to the caller; if that memo is
+    /// provisional, and its cycle head is claimed by another thread, we need to wait for that
+    /// other thread to complete the fixpoint iteration, and then retry fetching our own memo.
+    ///
+    /// Return `true` if the caller should retry, `false` if the caller should go ahead and return
+    /// this memo to the caller.
+    #[inline(always)]
+    pub(super) fn provisional_retry(
+        &self,
+        zalsa: &Zalsa,
+        database_key_index: DatabaseKeyIndex,
+    ) -> bool {
+        if self.revisions.cycle_heads.is_empty() {
+            return false;
+        }
+
+        if !self.may_be_provisional() {
+            return false;
+        };
+
+        return provisional_retry_cold(zalsa, database_key_index, &self.revisions.cycle_heads);
+
+        #[inline(never)]
+        fn provisional_retry_cold(
+            zalsa: &Zalsa,
+            database_key_index: DatabaseKeyIndex,
+            cycle_heads: &CycleHeads,
+        ) -> bool {
+            let mut retry = false;
+
+            for head in cycle_heads {
+                let head_index = head.database_key_index;
+
+                if head_index == database_key_index {
+                    continue;
+                }
+
+                let ingredient = zalsa.lookup_ingredient(head_index.ingredient_index());
+                let cycle_head_kind = ingredient.cycle_head_kind(zalsa, head_index.key_index());
+                if matches!(
+                    cycle_head_kind,
+                    CycleHeadKind::NotProvisional | CycleHeadKind::FallbackImmediate
+                ) {
+                    // This cycle is already finalized, so we don't need to wait on it;
+                    // keep looping through cycle heads.
+                    retry = true;
+                } else if ingredient.wait_for(zalsa, head_index.key_index()) {
+                    // There's a new memo available for the cycle head; fetch our own
+                    // updated memo and see if it's still provisional or if the cycle
+                    // has resolved.
+                    retry = true;
+                } else {
+                    // We hit a cycle blocking on the cycle head; this means it's in
+                    // our own active query stack and we are responsible to resolve the
+                    // cycle, so go ahead and return the provisional memo.
+                    return false;
+                }
+            }
+
+            // If `retry` is `true`, all our cycle heads (barring ourself) are complete; re-fetch
+            // and we should get a non-provisional memo. If we get here and `retry` is still
+            // `false`, we have no cycle heads other than ourself, so we are a provisional value of
+            // the cycle head (either initial value, or from a later iteration) and should be
+            // returned to caller to allow fixpoint iteration to proceed. (All cases in the loop
+            // above other than "cycle head is self" are either terminal or set `retry`.)
+            retry
+        }
+    }
+
+    /// Cycle heads that should be propagated to dependent queries.
+    #[inline(always)]
+    pub(super) fn cycle_heads(&self) -> &CycleHeads {
+        if self.may_be_provisional() {
+            &self.revisions.cycle_heads
+        } else {
+            &EMPTY_CYCLE_HEADS
+        }
+    }
+
+    /// Mark memo as having been verified in the `revision_now`, which should
+    /// be the current revision.
+    /// The caller is responsible to update the memo's `accumulated` state if their accumulated
+    /// values have changed since.
+    #[inline]
+    pub(super) fn mark_as_verified(&self, zalsa: &Zalsa, database_key_index: DatabaseKeyIndex) {
+        zalsa.event(&|| {
+            Event::new(EventKind::DidValidateMemoizedValue {
+                database_key: database_key_index,
+            })
+        });
+
+        self.verified_at.store(zalsa.current_revision());
+    }
+
+    pub(super) fn mark_outputs_as_verified(
+        &self,
+        zalsa: &Zalsa,
+        database_key_index: DatabaseKeyIndex,
+    ) {
+        for output in self.revisions.origin.outputs() {
+            output.mark_validated_output(zalsa, database_key_index);
+        }
+    }
+
+    pub(super) fn tracing_debug(&self) -> impl std::fmt::Debug + '_ {
+        struct TracingDebug<'a, T> {
+            memo: &'a Memo<T>,
+        }
+
+        impl<T> std::fmt::Debug for TracingDebug<'_, T> {
+            fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
+                f.debug_struct("Memo")
+                    .field(
+                        "value",
+                        if self.memo.value.is_some() {
+                            &"Some(<value>)"
+                        } else {
+                            &"None"
+                        },
+                    )
+                    .field("verified_at", &self.memo.verified_at)
+                    // .field("revisions", &self.memo.revisions)
+                    .finish()
+            }
+        }
+
+        TracingDebug { memo: self }
+    }
+}
+
+impl<V: Send + Sync + Any> crate::table::memo::Memo for Memo<V> {
+    fn origin(&self) -> &QueryOrigin {
+        &self.revisions.origin
+    }
+}
diff --git a/crates/salsa/src/function/specify.rs b/crates/salsa/src/function/specify.rs
new file mode 100644
index 000000000..cde9fe424
--- /dev/null
+++ b/crates/salsa/src/function/specify.rs
@@ -0,0 +1,133 @@
+use crate::accumulator::accumulated_map::InputAccumulatedValues;
+use crate::function::memo::Memo;
+use crate::function::{Configuration, IngredientImpl};
+use crate::loom::sync::atomic::AtomicBool;
+use crate::revision::AtomicRevision;
+use crate::tracked_struct::TrackedStructInDb;
+use crate::zalsa::{Zalsa, ZalsaDatabase};
+use crate::zalsa_local::{QueryOrigin, QueryRevisions};
+use crate::{DatabaseKeyIndex, Id};
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    /// Specify the value for `key` *and* record that we did so.
+    /// Used for explicit calls to `specify`, but not needed for pre-declared tracked struct fields.
+    pub fn specify_and_record<'db>(&'db self, db: &'db C::DbView, key: Id, value: C::Output<'db>)
+    where
+        C::Input<'db>: TrackedStructInDb,
+    {
+        let (zalsa, zalsa_local) = db.zalsas();
+
+        let (active_query_key, current_deps) = match zalsa_local.active_query() {
+            Some(v) => v,
+            None => panic!("can only use `specify` inside a tracked function"),
+        };
+
+        // `specify` only works if the key is a tracked struct created in the current query.
+        //
+        // The reason is this. We want to ensure that the same result is reached regardless of
+        // the "path" that the user takes through the execution graph.
+        // If you permit values to be specified from other queries, you can have a situation like this:
+        // * Q0 creates the tracked struct T0
+        // * Q1 specifies the value for F(T0)
+        // * Q2 invokes F(T0)
+        // * Q3 invokes Q1 and then Q2
+        // * Q4 invokes Q2 and then Q1
+        //
+        // Now, if We invoke Q3 first, We get one result for Q2, but if We invoke Q4 first, We get a different value. That's no good.
+        let database_key_index = <C::Input<'db>>::database_key_index(zalsa, key);
+        if !zalsa_local.is_output_of_active_query(database_key_index) {
+            panic!("can only use `specify` on salsa structs created during the current tracked fn");
+        }
+
+        // Subtle: we treat the "input" to a set query as if it were
+        // volatile.
+        //
+        // The idea is this. You have the current query C that
+        // created the entity E, and it is setting the value F(E) of the function F.
+        // When some other query R reads the field F(E), in order to have obtained
+        // the entity E, it has to have executed the query C.
+        //
+        // This will have forced C to either:
+        //
+        // - not create E this time, in which case R shouldn't have it (some kind of leak has occurred)
+        // - assign a value to F(E), in which case `verified_at` will be the current revision and `changed_at` will be updated appropriately
+        // - NOT assign a value to F(E), in which case we need to re-execute the function (which typically panics).
+        //
+        // So, ruling out the case of a leak having occurred, that means that the reader R will either see:
+        //
+        // - a result that is verified in the current revision, because it was set, which will use the set value
+        // - a result that is NOT verified and has untracked inputs, which will re-execute (and likely panic)
+
+        let revision = zalsa.current_revision();
+        let mut revisions = QueryRevisions {
+            changed_at: current_deps.changed_at,
+            durability: current_deps.durability,
+            origin: QueryOrigin::Assigned(active_query_key),
+            tracked_struct_ids: Default::default(),
+            accumulated: Default::default(),
+            accumulated_inputs: Default::default(),
+            verified_final: AtomicBool::new(true),
+            cycle_heads: Default::default(),
+        };
+
+        let memo_ingredient_index = self.memo_ingredient_index(zalsa, key);
+        if let Some(old_memo) = self.get_memo_from_table_for(zalsa, key, memo_ingredient_index) {
+            self.backdate_if_appropriate(old_memo, database_key_index, &mut revisions, &value);
+            self.diff_outputs(zalsa, database_key_index, old_memo, &mut revisions);
+        }
+
+        let memo = Memo {
+            value: Some(value),
+            verified_at: AtomicRevision::from(revision),
+            revisions,
+        };
+
+        tracing::debug!(
+            "specify: about to add memo {:#?} for key {:?}",
+            memo.tracing_debug(),
+            key
+        );
+        self.insert_memo(zalsa, key, memo, memo_ingredient_index);
+
+        // Record that the current query *specified* a value for this cell.
+        let database_key_index = self.database_key_index(key);
+        zalsa_local.add_output(database_key_index);
+    }
+
+    /// Invoked when the query `executor` has been validated as having green inputs
+    /// and `key` is a value that was specified by `executor`.
+    /// Marks `key` as valid in the current revision since if `executor` had re-executed,
+    /// it would have specified `key` again.
+    pub(super) fn validate_specified_value(
+        &self,
+        zalsa: &Zalsa,
+        executor: DatabaseKeyIndex,
+        key: Id,
+    ) {
+        let memo_ingredient_index = self.memo_ingredient_index(zalsa, key);
+
+        let memo = match self.get_memo_from_table_for(zalsa, key, memo_ingredient_index) {
+            Some(m) => m,
+            None => return,
+        };
+
+        // If we are marking this as validated, it must be a value that was
+        // assigned by `executor`.
+        match memo.revisions.origin {
+            QueryOrigin::Assigned(by_query) => assert_eq!(by_query, executor),
+            _ => panic!(
+                "expected a query assigned by `{:?}`, not `{:?}`",
+                executor, memo.revisions.origin,
+            ),
+        }
+
+        let database_key_index = self.database_key_index(key);
+        memo.mark_as_verified(zalsa, database_key_index);
+        memo.revisions
+            .accumulated_inputs
+            .store(InputAccumulatedValues::Empty);
+    }
+}
diff --git a/crates/salsa/src/function/sync.rs b/crates/salsa/src/function/sync.rs
new file mode 100644
index 000000000..13c3285d2
--- /dev/null
+++ b/crates/salsa/src/function/sync.rs
@@ -0,0 +1,122 @@
+use rustc_hash::FxHashMap;
+
+use crate::key::DatabaseKeyIndex;
+use crate::loom::sync::Mutex;
+use crate::loom::thread::{self, ThreadId};
+use crate::runtime::{BlockResult, WaitResult};
+use crate::zalsa::Zalsa;
+use crate::{Id, IngredientIndex};
+
+/// Tracks the keys that are currently being processed; used to coordinate between
+/// worker threads.
+pub(crate) struct SyncTable {
+    syncs: Mutex<FxHashMap<Id, SyncState>>,
+    ingredient: IngredientIndex,
+}
+
+pub(crate) enum ClaimResult<'a> {
+    Retry,
+    Cycle,
+    Claimed(ClaimGuard<'a>),
+}
+
+struct SyncState {
+    id: ThreadId,
+
+    /// Set to true if any other queries are blocked,
+    /// waiting for this query to complete.
+    anyone_waiting: bool,
+}
+
+impl SyncTable {
+    pub(crate) fn new(ingredient: IngredientIndex) -> Self {
+        Self {
+            syncs: Default::default(),
+            ingredient,
+        }
+    }
+
+    pub(crate) fn try_claim<'me>(&'me self, zalsa: &'me Zalsa, key_index: Id) -> ClaimResult<'me> {
+        let mut write = self.syncs.lock();
+        match write.entry(key_index) {
+            std::collections::hash_map::Entry::Occupied(occupied_entry) => {
+                let &mut SyncState {
+                    id,
+                    ref mut anyone_waiting,
+                } = occupied_entry.into_mut();
+                // NB: `Ordering::Relaxed` is sufficient here,
+                // as there are no loads that are "gated" on this
+                // value. Everything that is written is also protected
+                // by a lock that must be acquired. The role of this
+                // boolean is to decide *whether* to acquire the lock,
+                // not to gate future atomic reads.
+                *anyone_waiting = true;
+                match zalsa.runtime().block_on(
+                    zalsa,
+                    DatabaseKeyIndex::new(self.ingredient, key_index),
+                    id,
+                    write,
+                ) {
+                    BlockResult::Completed => ClaimResult::Retry,
+                    BlockResult::Cycle => ClaimResult::Cycle,
+                }
+            }
+            std::collections::hash_map::Entry::Vacant(vacant_entry) => {
+                vacant_entry.insert(SyncState {
+                    id: thread::current().id(),
+                    anyone_waiting: false,
+                });
+                ClaimResult::Claimed(ClaimGuard {
+                    key_index,
+                    zalsa,
+                    sync_table: self,
+                    _padding: false,
+                })
+            }
+        }
+    }
+}
+
+/// Marks an active 'claim' in the synchronization map. The claim is
+/// released when this value is dropped.
+#[must_use]
+pub(crate) struct ClaimGuard<'me> {
+    key_index: Id,
+    zalsa: &'me Zalsa,
+    sync_table: &'me SyncTable,
+    // Reduce the size of ClaimResult by making more niches available in ClaimGuard; this fits into
+    // the padding of ClaimGuard so doesn't increase its size.
+    _padding: bool,
+}
+
+impl ClaimGuard<'_> {
+    fn remove_from_map_and_unblock_queries(&self) {
+        let mut syncs = self.sync_table.syncs.lock();
+
+        let SyncState { anyone_waiting, .. } =
+            syncs.remove(&self.key_index).expect("key claimed twice?");
+
+        if anyone_waiting {
+            self.zalsa.runtime().unblock_queries_blocked_on(
+                DatabaseKeyIndex::new(self.sync_table.ingredient, self.key_index),
+                if std::thread::panicking() {
+                    WaitResult::Panicked
+                } else {
+                    WaitResult::Completed
+                },
+            )
+        }
+    }
+}
+
+impl Drop for ClaimGuard<'_> {
+    fn drop(&mut self) {
+        self.remove_from_map_and_unblock_queries()
+    }
+}
+
+impl std::fmt::Debug for SyncTable {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("SyncTable").finish()
+    }
+}
diff --git a/crates/salsa/src/hash.rs b/crates/salsa/src/hash.rs
new file mode 100644
index 000000000..d1bb0cf4f
--- /dev/null
+++ b/crates/salsa/src/hash.rs
@@ -0,0 +1,11 @@
+use std::hash::{BuildHasher, Hash};
+
+pub(crate) type FxHasher = std::hash::BuildHasherDefault<rustc_hash::FxHasher>;
+pub(crate) type FxIndexSet<K> = indexmap::IndexSet<K, FxHasher>;
+pub(crate) type FxDashMap<K, V> = dashmap::DashMap<K, V, FxHasher>;
+pub(crate) type FxLinkedHashSet<K> = hashlink::LinkedHashSet<K, FxHasher>;
+pub(crate) type FxHashSet<K> = std::collections::HashSet<K, FxHasher>;
+
+pub(crate) fn hash<T: Hash>(t: &T) -> u64 {
+    FxHasher::default().hash_one(t)
+}
diff --git a/crates/salsa/src/id.rs b/crates/salsa/src/id.rs
new file mode 100644
index 000000000..30c8ff95a
--- /dev/null
+++ b/crates/salsa/src/id.rs
@@ -0,0 +1,96 @@
+use std::fmt::Debug;
+use std::hash::Hash;
+use std::num::NonZeroU32;
+
+use crate::zalsa::Zalsa;
+
+/// The `Id` of a salsa struct in the database [`Table`](`crate::table::Table`).
+///
+/// The higher-order bits of an `Id` identify a [`Page`](`crate::table::Page`)
+/// and the low-order bits identify a slot within the page.
+///
+/// An Id is a newtype'd u32 ranging from `0..Id::MAX_U32`.
+/// The maximum range is smaller than a standard u32 to leave
+/// room for niches; currently there is only one niche, so that
+/// `Option<Id>` is the same size as an `Id`.
+///
+/// As an end-user of `Salsa` you will generally not use `Id` directly,
+/// it is wrapped in new types.
+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
+pub struct Id {
+    value: NonZeroU32,
+}
+
+impl Id {
+    pub const MAX_U32: u32 = u32::MAX - 0xFF;
+    pub const MAX_USIZE: usize = Self::MAX_U32 as usize;
+
+    /// Create a `salsa::Id` from a u32 value. This value should
+    /// be less than [`Self::MAX_U32`].
+    ///
+    /// In general, you should not need to create salsa ids yourself,
+    /// but it can be useful if you are using the type as a general
+    /// purpose "identifier" internally.
+    ///
+    /// # Safety
+    ///
+    /// The supplied value must be less than [`Self::MAX_U32`].
+    #[doc(hidden)]
+    #[track_caller]
+    #[inline]
+    pub const unsafe fn from_u32(v: u32) -> Self {
+        debug_assert!(v < Self::MAX_U32);
+        Id {
+            // SAFETY: Caller obligation
+            value: unsafe { NonZeroU32::new_unchecked(v + 1) },
+        }
+    }
+
+    #[inline]
+    pub const fn as_u32(self) -> u32 {
+        self.value.get() - 1
+    }
+}
+
+impl Debug for Id {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(f, "Id({:x})", self.as_u32())
+    }
+}
+
+/// Internal salsa trait for types that can be represented as a salsa id.
+pub trait AsId: Sized {
+    fn as_id(&self) -> Id;
+}
+
+/// Internal Salsa trait for types that are just a newtype'd [`Id`][].
+pub trait FromId {
+    fn from_id(id: Id) -> Self;
+}
+
+impl AsId for Id {
+    #[inline]
+    fn as_id(&self) -> Id {
+        *self
+    }
+}
+
+impl FromId for Id {
+    #[inline]
+    fn from_id(id: Id) -> Self {
+        id
+    }
+}
+
+/// Enums cannot use [`FromId`] because they need access to the DB to tell the `TypeId` of the variant,
+/// so they use this trait instead, that has a blanket implementation for `FromId`.
+pub trait FromIdWithDb {
+    fn from_id(id: Id, zalsa: &Zalsa) -> Self;
+}
+
+impl<T: FromId> FromIdWithDb for T {
+    #[inline]
+    fn from_id(id: Id, _zalsa: &Zalsa) -> Self {
+        FromId::from_id(id)
+    }
+}
diff --git a/crates/salsa/src/ingredient.rs b/crates/salsa/src/ingredient.rs
new file mode 100644
index 000000000..60d2c1f40
--- /dev/null
+++ b/crates/salsa/src/ingredient.rs
@@ -0,0 +1,205 @@
+use std::any::{Any, TypeId};
+use std::fmt;
+
+use crate::accumulator::accumulated_map::{AccumulatedMap, InputAccumulatedValues};
+use crate::cycle::{CycleHeadKind, CycleHeads, CycleRecoveryStrategy};
+use crate::function::VerifyResult;
+use crate::loom::sync::Arc;
+use crate::plumbing::IngredientIndices;
+use crate::table::memo::MemoTableTypes;
+use crate::table::Table;
+use crate::zalsa::{transmute_data_mut_ptr, transmute_data_ptr, IngredientIndex, Zalsa};
+use crate::zalsa_local::QueryOrigin;
+use crate::{Database, DatabaseKeyIndex, Id, Revision};
+
+/// A "jar" is a group of ingredients that are added atomically.
+/// Each type implementing jar can be added to the database at most once.
+pub trait Jar: Any {
+    /// This creates the ingredient dependencies of this jar. We need to split this from `create_ingredients()`
+    /// because while `create_ingredients()` is called, a lock on the ingredient map is held (to guarantee
+    /// atomicity), so other ingredients could not be created.
+    ///
+    /// Only tracked fns use this.
+    fn create_dependencies(_zalsa: &Zalsa) -> IngredientIndices
+    where
+        Self: Sized,
+    {
+        IngredientIndices::empty()
+    }
+
+    /// Create the ingredients given the index of the first one.
+    /// All subsequent ingredients will be assigned contiguous indices.
+    fn create_ingredients(
+        zalsa: &Zalsa,
+        first_index: IngredientIndex,
+        dependencies: IngredientIndices,
+    ) -> Vec<Box<dyn Ingredient>>
+    where
+        Self: Sized;
+
+    /// This returns the [`TypeId`] of the ID struct, that is, the struct that wraps `salsa::Id`
+    /// and carry the name of the jar.
+    fn id_struct_type_id() -> TypeId
+    where
+        Self: Sized;
+}
+
+pub struct Location {
+    pub file: &'static str,
+    pub line: u32,
+}
+
+pub trait Ingredient: Any + std::fmt::Debug + Send + Sync {
+    fn debug_name(&self) -> &'static str;
+    fn location(&self) -> &'static Location;
+
+    /// Has the value for `input` in this ingredient changed after `revision`?
+    ///
+    /// # Safety
+    ///
+    /// The passed in database needs to be the same one that the ingredient was created with.
+    unsafe fn maybe_changed_after<'db>(
+        &'db self,
+        db: &'db dyn Database,
+        input: Id,
+        revision: Revision,
+        cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult;
+
+    /// Is the value for `input` in this ingredient a cycle head that is still provisional?
+    ///
+    /// In the case of nested cycles, we are not asking here whether the value is provisional due
+    /// to the outer cycle being unresolved, only whether its own cycle remains provisional.
+    fn cycle_head_kind(&self, zalsa: &Zalsa, input: Id) -> CycleHeadKind {
+        _ = (zalsa, input);
+        CycleHeadKind::NotProvisional
+    }
+
+    /// Invoked when the current thread needs to wait for a result for the given `key_index`.
+    ///
+    /// A return value of `true` indicates that a result is now available. A return value of
+    /// `false` means that a cycle was encountered; the waited-on query is either already claimed
+    /// by the current thread, or by a thread waiting on the current thread.
+    fn wait_for(&self, zalsa: &Zalsa, key_index: Id) -> bool {
+        _ = (zalsa, key_index);
+        true
+    }
+
+    /// Invoked when the value `output_key` should be marked as valid in the current revision.
+    /// This occurs because the value for `executor`, which generated it, was marked as valid
+    /// in the current revision.
+    fn mark_validated_output(
+        &self,
+        zalsa: &Zalsa,
+        executor: DatabaseKeyIndex,
+        output_key: crate::Id,
+    ) {
+        let _ = (zalsa, executor, output_key);
+        unreachable!("only tracked struct and function ingredients can have validatable outputs")
+    }
+
+    /// Invoked when the value `stale_output` was output by `executor` in a previous
+    /// revision, but was NOT output in the current revision.
+    ///
+    /// This hook is used to clear out the stale value so others cannot read it.
+    fn remove_stale_output(&self, zalsa: &Zalsa, executor: DatabaseKeyIndex, stale_output_key: Id) {
+        let _ = (zalsa, executor, stale_output_key);
+        unreachable!("only tracked struct ingredients can have stale outputs")
+    }
+
+    /// Returns the [`IngredientIndex`] of this ingredient.
+    fn ingredient_index(&self) -> IngredientIndex;
+
+    /// Returns true if `reset_for_new_revision` should be called when new revisions start.
+    /// Invoked once when ingredient is added and not after that.
+    fn requires_reset_for_new_revision(&self) -> bool {
+        false
+    }
+
+    /// Invoked when a new revision is about to start.
+    /// This moment is important because it means that we have an `&mut`-reference to the
+    /// database, and hence any pre-existing `&`-references must have expired.
+    /// Many ingredients, given an `&'db`-reference to the database,
+    /// use unsafe code to return `&'db`-references to internal values.
+    /// The backing memory for those values can only be freed once an `&mut`-reference to the
+    /// database is created.
+    ///
+    /// **Important:** to actually receive resets, the ingredient must set
+    /// [`IngredientRequiresReset::RESET_ON_NEW_REVISION`] to true.
+    fn reset_for_new_revision(&mut self, table: &mut Table) {
+        _ = table;
+        panic!(
+            "Ingredient `{}` set `Ingredient::requires_reset_for_new_revision` to true but does \
+            not overwrite `Ingredient::reset_for_new_revision`",
+            self.debug_name()
+        );
+    }
+
+    fn memo_table_types(&self) -> Arc<MemoTableTypes>;
+
+    fn fmt_index(&self, index: crate::Id, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
+        fmt_index(self.debug_name(), index, fmt)
+    }
+    // Function ingredient methods
+
+    /// If this ingredient is a participant in a cycle, what is its cycle recovery strategy?
+    /// (Really only relevant to [`crate::function::FunctionIngredient`],
+    /// since only function ingredients push themselves onto the active query stack.)
+    fn cycle_recovery_strategy(&self) -> CycleRecoveryStrategy {
+        unreachable!("only function ingredients can be part of a cycle")
+    }
+
+    /// What were the inputs (if any) that were used to create the value at `key_index`.
+    fn origin(&self, zalsa: &Zalsa, key_index: Id) -> Option<QueryOrigin> {
+        let _ = (zalsa, key_index);
+        unreachable!("only function ingredients have origins")
+    }
+
+    /// What values were accumulated during the creation of the value at `key_index`
+    /// (if any).
+    fn accumulated<'db>(
+        &'db self,
+        db: &'db dyn Database,
+        key_index: Id,
+    ) -> (Option<&'db AccumulatedMap>, InputAccumulatedValues) {
+        let _ = (db, key_index);
+        (None, InputAccumulatedValues::Empty)
+    }
+}
+
+impl dyn Ingredient {
+    /// Equivalent to the `downcast` methods on `any`.
+    /// Because we do not have dyn-upcasting support, we need this workaround.
+    pub fn assert_type<T: Any>(&self) -> &T {
+        assert_eq!(
+            self.type_id(),
+            TypeId::of::<T>(),
+            "ingredient `{self:?}` is not of type `{}`",
+            std::any::type_name::<T>()
+        );
+
+        // SAFETY: We know that the underlying data pointer
+        // refers to a value of type T because of the `TypeId` check above.
+        unsafe { transmute_data_ptr(self) }
+    }
+
+    /// Equivalent to the `downcast` methods on `any`.
+    /// Because we do not have dyn-upcasting support, we need this workaround.
+    pub fn assert_type_mut<T: Any>(&mut self) -> &mut T {
+        assert_eq!(
+            Any::type_id(self),
+            TypeId::of::<T>(),
+            "ingredient `{self:?}` is not of type `{}`",
+            std::any::type_name::<T>()
+        );
+
+        // SAFETY: We know that the underlying data pointer
+        // refers to a value of type T because of the `TypeId` check above.
+        unsafe { transmute_data_mut_ptr(self) }
+    }
+}
+
+/// A helper function to show human readable fmt.
+pub(crate) fn fmt_index(debug_name: &str, id: Id, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
+    write!(fmt, "{debug_name}({id:?})")
+}
diff --git a/crates/salsa/src/input.rs b/crates/salsa/src/input.rs
new file mode 100644
index 000000000..db86c4c65
--- /dev/null
+++ b/crates/salsa/src/input.rs
@@ -0,0 +1,294 @@
+use std::any::{Any, TypeId};
+use std::fmt;
+use std::mem::MaybeUninit;
+use std::ops::IndexMut;
+
+pub mod input_field;
+pub mod setter;
+pub mod singleton;
+
+use input_field::FieldIngredientImpl;
+
+use crate::cycle::CycleHeads;
+use crate::function::VerifyResult;
+use crate::id::{AsId, FromId, FromIdWithDb};
+use crate::ingredient::Ingredient;
+use crate::input::singleton::{Singleton, SingletonChoice};
+use crate::key::DatabaseKeyIndex;
+use crate::loom::cell::UnsafeCell;
+use crate::loom::sync::Arc;
+use crate::plumbing::{Jar, Stamp};
+use crate::table::memo::{MemoTable, MemoTableTypes};
+use crate::table::{Slot, Table};
+use crate::zalsa::{IngredientIndex, Zalsa};
+use crate::{Database, Durability, Id, Revision, Runtime};
+
+pub trait Configuration: Any {
+    const DEBUG_NAME: &'static str;
+    const FIELD_DEBUG_NAMES: &'static [&'static str];
+    const LOCATION: crate::ingredient::Location;
+
+    /// The singleton state for this input if any.
+    type Singleton: SingletonChoice + Send + Sync;
+
+    /// The input struct (which wraps an `Id`)
+    type Struct: FromId + AsId + 'static + Send + Sync;
+
+    /// A (possibly empty) tuple of the fields for this struct.
+    type Fields: Send + Sync;
+
+    /// A array of [`StampedValue<()>`](`StampedValue`) tuples, one per each of the value fields.
+    type Stamps: Send + Sync + fmt::Debug + IndexMut<usize, Output = Stamp>;
+}
+
+pub struct JarImpl<C: Configuration> {
+    _phantom: std::marker::PhantomData<C>,
+}
+
+impl<C: Configuration> Default for JarImpl<C> {
+    fn default() -> Self {
+        Self {
+            _phantom: Default::default(),
+        }
+    }
+}
+
+impl<C: Configuration> Jar for JarImpl<C> {
+    fn create_ingredients(
+        _zalsa: &Zalsa,
+        struct_index: crate::zalsa::IngredientIndex,
+        _dependencies: crate::memo_ingredient_indices::IngredientIndices,
+    ) -> Vec<Box<dyn Ingredient>> {
+        let struct_ingredient: IngredientImpl<C> = IngredientImpl::new(struct_index);
+
+        std::iter::once(Box::new(struct_ingredient) as _)
+            .chain((0..C::FIELD_DEBUG_NAMES.len()).map(|field_index| {
+                Box::new(<FieldIngredientImpl<C>>::new(struct_index, field_index)) as _
+            }))
+            .collect()
+    }
+
+    fn id_struct_type_id() -> TypeId {
+        TypeId::of::<C::Struct>()
+    }
+}
+
+pub struct IngredientImpl<C: Configuration> {
+    ingredient_index: IngredientIndex,
+    singleton: C::Singleton,
+    memo_table_types: Arc<MemoTableTypes>,
+    _phantom: std::marker::PhantomData<C::Struct>,
+}
+
+impl<C: Configuration> IngredientImpl<C> {
+    pub fn new(index: IngredientIndex) -> Self {
+        Self {
+            ingredient_index: index,
+            singleton: Default::default(),
+            memo_table_types: Arc::new(MemoTableTypes::default()),
+            _phantom: std::marker::PhantomData,
+        }
+    }
+
+    fn data(zalsa: &Zalsa, id: Id) -> &Value<C> {
+        zalsa.table().get(id)
+    }
+
+    fn data_raw(table: &Table, id: Id) -> &UnsafeCell<MaybeUninit<Value<C>>> {
+        table.get_raw(id)
+    }
+
+    pub fn database_key_index(&self, id: C::Struct) -> DatabaseKeyIndex {
+        DatabaseKeyIndex::new(self.ingredient_index, id.as_id())
+    }
+
+    pub fn new_input(&self, db: &dyn Database, fields: C::Fields, stamps: C::Stamps) -> C::Struct {
+        let (zalsa, zalsa_local) = db.zalsas();
+
+        let id = self.singleton.with_scope(|| {
+            zalsa_local.allocate(zalsa, self.ingredient_index, |_| Value::<C> {
+                fields,
+                stamps,
+                memos: Default::default(),
+            })
+        });
+
+        FromIdWithDb::from_id(id, zalsa)
+    }
+
+    /// Change the value of the field `field_index` to a new value.
+    ///
+    /// # Parameters
+    ///
+    /// * `runtime`, the salsa runtiem
+    /// * `id`, id of the input struct
+    /// * `field_index`, index of the field that will be changed
+    /// * `durability`, durability of the new value. If omitted, uses the durability of the previous value.
+    /// * `setter`, function that modifies the fields tuple; should only modify the element for `field_index`
+    pub fn set_field<R>(
+        &mut self,
+        runtime: &mut Runtime,
+        id: C::Struct,
+        field_index: usize,
+        durability: Option<Durability>,
+        setter: impl FnOnce(&mut C::Fields) -> R,
+    ) -> R {
+        let id: Id = id.as_id();
+
+        Self::data_raw(runtime.table(), id).get_mut().with(|r| {
+            // SAFETY: We hold `&mut` on the runtime so no `&`-references can be active.
+            // Also, we don't access any other data from the table while `r` is active.
+            let r = unsafe { (*r).assume_init_mut() };
+
+            let stamp = &mut r.stamps[field_index];
+
+            if stamp.durability != Durability::MIN {
+                runtime.report_tracked_write(stamp.durability);
+            }
+
+            stamp.durability = durability.unwrap_or(stamp.durability);
+            stamp.changed_at = runtime.current_revision();
+            setter(&mut r.fields)
+        })
+    }
+
+    /// Get the singleton input previously created (if any).
+    #[doc(hidden)]
+    pub fn get_singleton_input(&self, zalsa: &Zalsa) -> Option<C::Struct>
+    where
+        C: Configuration<Singleton = Singleton>,
+    {
+        self.singleton
+            .index()
+            .map(|id| FromIdWithDb::from_id(id, zalsa))
+    }
+
+    /// Access field of an input.
+    /// Note that this function returns the entire tuple of value fields.
+    /// The caller is responsible for selecting the appropriate element.
+    pub fn field<'db>(
+        &'db self,
+        db: &'db dyn crate::Database,
+        id: C::Struct,
+        field_index: usize,
+    ) -> &'db C::Fields {
+        let (zalsa, zalsa_local) = db.zalsas();
+        let field_ingredient_index = self.ingredient_index.successor(field_index);
+        let id = id.as_id();
+        let value = Self::data(zalsa, id);
+        let stamp = &value.stamps[field_index];
+        zalsa_local.report_tracked_read_simple(
+            DatabaseKeyIndex::new(field_ingredient_index, id),
+            stamp.durability,
+            stamp.changed_at,
+        );
+        &value.fields
+    }
+
+    #[cfg(feature = "salsa_unstable")]
+    /// Returns all data corresponding to the input struct.
+    pub fn entries<'db>(
+        &'db self,
+        db: &'db dyn crate::Database,
+    ) -> impl Iterator<Item = &'db Value<C>> {
+        db.zalsa().table().slots_of::<Value<C>>()
+    }
+
+    /// Peek at the field values without recording any read dependency.
+    /// Used for debug printouts.
+    pub fn leak_fields<'db>(&'db self, db: &'db dyn Database, id: C::Struct) -> &'db C::Fields {
+        let zalsa = db.zalsa();
+        let id = id.as_id();
+        let value = Self::data(zalsa, id);
+        &value.fields
+    }
+}
+
+impl<C: Configuration> Ingredient for IngredientImpl<C> {
+    fn location(&self) -> &'static crate::ingredient::Location {
+        &C::LOCATION
+    }
+
+    fn ingredient_index(&self) -> IngredientIndex {
+        self.ingredient_index
+    }
+
+    unsafe fn maybe_changed_after(
+        &self,
+        _db: &dyn Database,
+        _input: Id,
+        _revision: Revision,
+        _cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        // Input ingredients are just a counter, they store no data, they are immortal.
+        // Their *fields* are stored in function ingredients elsewhere.
+        VerifyResult::unchanged()
+    }
+
+    fn debug_name(&self) -> &'static str {
+        C::DEBUG_NAME
+    }
+
+    fn memo_table_types(&self) -> Arc<MemoTableTypes> {
+        self.memo_table_types.clone()
+    }
+}
+
+impl<C: Configuration> std::fmt::Debug for IngredientImpl<C> {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct(std::any::type_name::<Self>())
+            .field("index", &self.ingredient_index)
+            .finish()
+    }
+}
+
+#[derive(Debug)]
+pub struct Value<C>
+where
+    C: Configuration,
+{
+    /// Fields of this input struct.
+    ///
+    /// They can change across revisions, but they do not change within
+    /// a particular revision.
+    fields: C::Fields,
+
+    /// The revision and durability information for each field: when did this field last change.
+    stamps: C::Stamps,
+
+    /// Memos
+    memos: MemoTable,
+}
+
+impl<C> Value<C>
+where
+    C: Configuration,
+{
+    /// Fields of this tracked struct.
+    ///
+    /// They can change across revisions, but they do not change within
+    /// a particular revision.
+    #[cfg(feature = "salsa_unstable")]
+    pub fn fields(&self) -> &C::Fields {
+        &self.fields
+    }
+}
+
+pub trait HasBuilder {
+    type Builder;
+}
+
+impl<C> Slot for Value<C>
+where
+    C: Configuration,
+{
+    #[inline(always)]
+    unsafe fn memos(&self, _current_revision: Revision) -> &crate::table::memo::MemoTable {
+        &self.memos
+    }
+
+    #[inline(always)]
+    fn memos_mut(&mut self) -> &mut crate::table::memo::MemoTable {
+        &mut self.memos
+    }
+}
diff --git a/crates/salsa/src/input/input_field.rs b/crates/salsa/src/input/input_field.rs
new file mode 100644
index 000000000..d5a4899d8
--- /dev/null
+++ b/crates/salsa/src/input/input_field.rs
@@ -0,0 +1,93 @@
+use std::fmt;
+use std::marker::PhantomData;
+
+use crate::cycle::CycleHeads;
+use crate::function::VerifyResult;
+use crate::ingredient::Ingredient;
+use crate::input::{Configuration, IngredientImpl, Value};
+use crate::loom::sync::Arc;
+use crate::table::memo::MemoTableTypes;
+use crate::zalsa::IngredientIndex;
+use crate::{Database, Id, Revision};
+
+/// Ingredient used to represent the fields of a `#[salsa::input]`.
+///
+/// These fields can only be mutated by a call to a setter with an `&mut`
+/// reference to the database, and therefore cannot be mutated during a tracked
+/// function or in parallel.
+/// However for on-demand inputs to work the fields must be able to be set via
+/// a shared reference, so some locking is required.
+/// Altogether this makes the implementation somewhat simpler than tracked
+/// structs.
+pub struct FieldIngredientImpl<C: Configuration> {
+    index: IngredientIndex,
+    field_index: usize,
+    phantom: PhantomData<fn() -> Value<C>>,
+}
+
+impl<C> FieldIngredientImpl<C>
+where
+    C: Configuration,
+{
+    pub(super) fn new(struct_index: IngredientIndex, field_index: usize) -> Self {
+        Self {
+            index: struct_index.successor(field_index),
+            field_index,
+            phantom: PhantomData,
+        }
+    }
+}
+
+impl<C> Ingredient for FieldIngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn location(&self) -> &'static crate::ingredient::Location {
+        &C::LOCATION
+    }
+
+    fn ingredient_index(&self) -> IngredientIndex {
+        self.index
+    }
+
+    unsafe fn maybe_changed_after(
+        &self,
+        db: &dyn Database,
+        input: Id,
+        revision: Revision,
+        _cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        let zalsa = db.zalsa();
+        let value = <IngredientImpl<C>>::data(zalsa, input);
+        VerifyResult::changed_if(value.stamps[self.field_index].changed_at > revision)
+    }
+
+    fn fmt_index(&self, index: crate::Id, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(
+            fmt,
+            "{input}.{field}({id:?})",
+            input = C::DEBUG_NAME,
+            field = C::FIELD_DEBUG_NAMES[self.field_index],
+            id = index
+        )
+    }
+
+    fn debug_name(&self) -> &'static str {
+        C::FIELD_DEBUG_NAMES[self.field_index]
+    }
+
+    fn memo_table_types(&self) -> Arc<MemoTableTypes> {
+        unreachable!("input fields do not allocate pages")
+    }
+}
+
+impl<C> std::fmt::Debug for FieldIngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct(std::any::type_name::<Self>())
+            .field("index", &self.index)
+            .finish()
+    }
+}
diff --git a/crates/salsa/src/input/setter.rs b/crates/salsa/src/input/setter.rs
new file mode 100644
index 000000000..4f157565c
--- /dev/null
+++ b/crates/salsa/src/input/setter.rs
@@ -0,0 +1,75 @@
+use std::marker::PhantomData;
+
+use crate::input::{Configuration, IngredientImpl};
+use crate::{Durability, Runtime};
+
+/// Setter for a field of an input.
+pub trait Setter: Sized {
+    type FieldTy;
+    fn with_durability(self, durability: Durability) -> Self;
+    fn to(self, value: Self::FieldTy) -> Self::FieldTy;
+}
+
+#[must_use]
+pub struct SetterImpl<'setter, C: Configuration, S, F> {
+    runtime: &'setter mut Runtime,
+    id: C::Struct,
+    ingredient: &'setter mut IngredientImpl<C>,
+    durability: Option<Durability>,
+    field_index: usize,
+    setter: S,
+    phantom: PhantomData<fn(F)>,
+}
+
+impl<'setter, C, S, F> SetterImpl<'setter, C, S, F>
+where
+    C: Configuration,
+    S: FnOnce(&mut C::Fields, F) -> F,
+{
+    pub fn new(
+        runtime: &'setter mut Runtime,
+        id: C::Struct,
+        field_index: usize,
+        ingredient: &'setter mut IngredientImpl<C>,
+        setter: S,
+    ) -> Self {
+        SetterImpl {
+            runtime,
+            id,
+            field_index,
+            ingredient,
+            durability: None,
+            setter,
+            phantom: PhantomData,
+        }
+    }
+}
+
+impl<C, S, F> Setter for SetterImpl<'_, C, S, F>
+where
+    C: Configuration,
+    S: FnOnce(&mut C::Fields, F) -> F,
+{
+    type FieldTy = F;
+
+    fn with_durability(mut self, durability: Durability) -> Self {
+        self.durability = Some(durability);
+        self
+    }
+
+    fn to(self, value: F) -> F {
+        let Self {
+            runtime,
+            id,
+            ingredient,
+            durability,
+            field_index,
+            setter,
+            phantom: _,
+        } = self;
+
+        ingredient.set_field(runtime, id, field_index, durability, |tuple| {
+            setter(tuple, value)
+        })
+    }
+}
diff --git a/crates/salsa/src/input/singleton.rs b/crates/salsa/src/input/singleton.rs
new file mode 100644
index 000000000..3c8dc88bb
--- /dev/null
+++ b/crates/salsa/src/input/singleton.rs
@@ -0,0 +1,59 @@
+use crate::loom::sync::atomic::{AtomicU32, Ordering};
+use crate::Id;
+
+mod sealed {
+    pub trait Sealed {}
+}
+
+pub trait SingletonChoice: sealed::Sealed + Default {
+    fn with_scope(&self, cb: impl FnOnce() -> Id) -> Id;
+    fn index(&self) -> Option<Id>;
+}
+
+pub struct Singleton {
+    index: AtomicU32,
+}
+impl sealed::Sealed for Singleton {}
+impl SingletonChoice for Singleton {
+    fn with_scope(&self, cb: impl FnOnce() -> Id) -> Id {
+        if self.index.load(Ordering::Acquire) != 0 {
+            panic!("singleton struct may not be duplicated");
+        }
+        let id = cb();
+        if self
+            .index
+            .compare_exchange(0, id.as_u32() + 1, Ordering::AcqRel, Ordering::Acquire)
+            .is_err()
+        {
+            panic!("singleton struct may not be duplicated");
+        }
+        id
+    }
+
+    fn index(&self) -> Option<Id> {
+        match self.index.load(Ordering::Acquire) {
+            0 => None,
+            // SAFETY: Our u32 is derived from an ID and thus safe to convert back.
+            id => Some(unsafe { Id::from_u32(id - 1) }),
+        }
+    }
+}
+
+impl Default for Singleton {
+    fn default() -> Self {
+        Self {
+            index: AtomicU32::new(0),
+        }
+    }
+}
+#[derive(Default)]
+pub struct NotSingleton;
+impl sealed::Sealed for NotSingleton {}
+impl SingletonChoice for NotSingleton {
+    fn with_scope(&self, cb: impl FnOnce() -> Id) -> Id {
+        cb()
+    }
+    fn index(&self) -> Option<Id> {
+        None
+    }
+}
diff --git a/crates/salsa/src/interned.rs b/crates/salsa/src/interned.rs
new file mode 100644
index 000000000..542436549
--- /dev/null
+++ b/crates/salsa/src/interned.rs
@@ -0,0 +1,648 @@
+#![allow(clippy::undocumented_unsafe_blocks)] // TODO(#697) document safety
+
+use std::any::TypeId;
+use std::fmt;
+use std::hash::{BuildHasher, Hash, Hasher};
+use std::marker::PhantomData;
+use std::path::{Path, PathBuf};
+
+use dashmap::SharedValue;
+
+use crate::cycle::CycleHeads;
+use crate::durability::Durability;
+use crate::function::VerifyResult;
+use crate::hash::FxDashMap;
+use crate::id::{AsId, FromId};
+use crate::ingredient::Ingredient;
+use crate::loom::cell::Cell;
+use crate::loom::sync::atomic::{AtomicU8, Ordering};
+use crate::loom::sync::Arc;
+use crate::plumbing::{IngredientIndices, Jar};
+use crate::revision::AtomicRevision;
+use crate::table::memo::{MemoTable, MemoTableTypes};
+use crate::table::Slot;
+use crate::zalsa::{IngredientIndex, Zalsa};
+use crate::{Database, DatabaseKeyIndex, Event, EventKind, Id, Revision};
+
+pub trait Configuration: Sized + 'static {
+    const LOCATION: crate::ingredient::Location;
+
+    const DEBUG_NAME: &'static str;
+
+    /// The fields of the struct being interned.
+    type Fields<'db>: InternedData;
+
+    /// The end user struct
+    type Struct<'db>: Copy + FromId + AsId;
+}
+
+pub trait InternedData: Sized + Eq + Hash + Clone + Sync + Send {}
+impl<T: Eq + Hash + Clone + Sync + Send> InternedData for T {}
+
+pub struct JarImpl<C: Configuration> {
+    phantom: PhantomData<C>,
+}
+
+/// The interned ingredient hashes values of type `Data` to produce an `Id`.
+///
+/// It used to store interned structs but also to store the id fields of a tracked struct.
+/// Interned values endure until they are explicitly removed in some way.
+pub struct IngredientImpl<C: Configuration> {
+    /// Index of this ingredient in the database (used to construct database-ids, etc).
+    ingredient_index: IngredientIndex,
+
+    /// Maps from data to the existing interned id for that data.
+    ///
+    /// This doesn't hold the fields themselves to save memory, instead it points to the slot ID.
+    ///
+    /// Deadlock requirement: We access `value_map` while holding lock on `key_map`, but not vice versa.
+    key_map: FxDashMap<Id, ()>,
+
+    memo_table_types: Arc<MemoTableTypes>,
+
+    _marker: PhantomData<fn() -> C>,
+}
+
+/// Struct storing the interned fields.
+pub struct Value<C>
+where
+    C: Configuration,
+{
+    fields: C::Fields<'static>,
+    memos: MemoTable,
+
+    /// The revision the value was first interned in.
+    first_interned_at: Revision,
+
+    /// The most recent interned revision.
+    last_interned_at: AtomicRevision,
+
+    /// The minimum durability of all inputs consumed by the creator
+    /// query prior to creating this tracked struct. If any of those
+    /// inputs changes, then the creator query may create this struct
+    /// with different values.
+    durability: AtomicU8,
+}
+
+impl<C> Value<C>
+where
+    C: Configuration,
+{
+    // Loads the durability of this interned struct.
+    fn durability(&self) -> Durability {
+        Durability::from_u8(self.durability.load(Ordering::Acquire))
+    }
+
+    /// Fields of this interned struct.
+    #[cfg(feature = "salsa_unstable")]
+    pub fn fields(&self) -> &C::Fields<'static> {
+        &self.fields
+    }
+}
+
+impl<C: Configuration> Default for JarImpl<C> {
+    fn default() -> Self {
+        Self {
+            phantom: PhantomData,
+        }
+    }
+}
+
+impl<C: Configuration> Jar for JarImpl<C> {
+    fn create_ingredients(
+        _zalsa: &Zalsa,
+        first_index: IngredientIndex,
+        _dependencies: IngredientIndices,
+    ) -> Vec<Box<dyn Ingredient>> {
+        vec![Box::new(IngredientImpl::<C>::new(first_index)) as _]
+    }
+
+    fn id_struct_type_id() -> TypeId {
+        TypeId::of::<C::Struct<'static>>()
+    }
+}
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    pub fn new(ingredient_index: IngredientIndex) -> Self {
+        Self {
+            ingredient_index,
+            key_map: Default::default(),
+            memo_table_types: Arc::new(MemoTableTypes::default()),
+            _marker: PhantomData,
+        }
+    }
+
+    unsafe fn to_internal_data<'db>(&'db self, data: C::Fields<'db>) -> C::Fields<'static> {
+        unsafe { std::mem::transmute(data) }
+    }
+
+    unsafe fn from_internal_data<'db>(data: &'db C::Fields<'static>) -> &'db C::Fields<'db> {
+        unsafe { std::mem::transmute(data) }
+    }
+
+    /// Intern data to a unique reference.
+    ///
+    /// If `key` is already interned, returns the existing [`Id`] for the interned data without
+    /// invoking `assemble`.
+    /// Otherwise, invokes `assemble` with the given `key` and the [`Id`] to be allocated for this
+    /// interned value. The resulting [`C::Data`] will then be interned.
+    ///
+    /// Note: Using the database within the `assemble` function may result in a deadlock if
+    /// the database ends up trying to intern or allocate a new value.
+    pub fn intern<'db, Key>(
+        &'db self,
+        db: &'db dyn crate::Database,
+        key: Key,
+        assemble: impl FnOnce(Id, Key) -> C::Fields<'db>,
+    ) -> C::Struct<'db>
+    where
+        Key: Hash,
+        C::Fields<'db>: HashEqLike<Key>,
+    {
+        FromId::from_id(self.intern_id(db, key, assemble))
+    }
+
+    /// Intern data to a unique reference.
+    ///
+    /// If `key` is already interned, returns the existing [`Id`] for the interned data without
+    /// invoking `assemble`.
+    /// Otherwise, invokes `assemble` with the given `key` and the [`Id`] to be allocated for this
+    /// interned value. The resulting [`C::Data`] will then be interned.
+    ///
+    /// Note: Using the database within the `assemble` function may result in a deadlock if
+    /// the database ends up trying to intern or allocate a new value.
+    pub fn intern_id<'db, Key>(
+        &'db self,
+        db: &'db dyn crate::Database,
+        key: Key,
+        assemble: impl FnOnce(Id, Key) -> C::Fields<'db>,
+    ) -> crate::Id
+    where
+        Key: Hash,
+        // We'd want the following predicate, but this currently implies `'static` due to a rustc
+        // bug
+        // for<'db> C::Data<'db>: HashEqLike<Key>,
+        // so instead we go with this and transmute the lifetime in the `eq` closure
+        C::Fields<'db>: HashEqLike<Key>,
+    {
+        let (zalsa, zalsa_local) = db.zalsas();
+        let current_revision = zalsa.current_revision();
+        let table = zalsa.table();
+
+        // Optimization to only get read lock on the map if the data has already been interned.
+        let data_hash = self.key_map.hasher().hash_one(&key);
+        let shard = &self.key_map.shards()[self.key_map.determine_shard(data_hash as _)];
+        let found_value = Cell::new(None);
+        let eq = |(id, _): &_| {
+            let data = table.get::<Value<C>>(*id);
+            found_value.set(Some(data));
+            // SAFETY: it's safe to go from Data<'static> to Data<'db>
+            // shrink lifetime here to use a single lifetime in Lookup::eq(&StructKey<'db>, &C::Data<'db>)
+            let data = unsafe {
+                std::mem::transmute::<&C::Fields<'static>, &C::Fields<'db>>(&data.fields)
+            };
+            HashEqLike::eq(data, &key)
+        };
+
+        {
+            let lock = shard.read();
+            if let Some(bucket) = lock.find(data_hash, eq) {
+                // SAFETY: Read lock on map is held during this block
+                let id = unsafe { bucket.as_ref().0 };
+
+                let value = found_value
+                    .get()
+                    .expect("found the interned, so `found_value` should be set");
+
+                let index = self.database_key_index(id);
+
+                // Sync the value's revision.
+                if value.last_interned_at.load() < current_revision {
+                    value.last_interned_at.store(current_revision);
+                    zalsa.event(&|| {
+                        Event::new(EventKind::DidReinternValue {
+                            key: index,
+                            revision: current_revision,
+                        })
+                    });
+                }
+
+                let durability = if let Some((_, stamp)) = zalsa_local.active_query() {
+                    // Record the maximum durability across all queries that intern this value.
+                    let previous_durability = value
+                        .durability
+                        .fetch_max(stamp.durability.as_u8(), Ordering::AcqRel);
+
+                    Durability::from_u8(previous_durability).max(stamp.durability)
+                } else {
+                    value.durability()
+                };
+
+                // Record a dependency on this value.
+                zalsa_local.report_tracked_read_simple(index, durability, value.first_interned_at);
+
+                return id;
+            }
+        }
+
+        let mut lock = shard.write();
+        match lock.find_or_find_insert_slot(data_hash, eq, |(id, _)| {
+            // This closure is only called if the table is resized. So while it's expensive to lookup all values,
+            // it will only happen rarely.
+            self.key_map
+                .hasher()
+                .hash_one(&table.get::<Value<C>>(*id).fields)
+        }) {
+            // Data has been interned by a racing call, use that ID instead
+            Ok(slot) => {
+                let id = unsafe { slot.as_ref().0 };
+                let value = zalsa.table().get::<Value<C>>(id);
+                let index = self.database_key_index(id);
+
+                // Sync the value's revision.
+                if value.last_interned_at.load() < current_revision {
+                    value.last_interned_at.store(current_revision);
+                    zalsa.event(&|| {
+                        Event::new(EventKind::DidReinternValue {
+                            key: index,
+                            revision: current_revision,
+                        })
+                    });
+                }
+
+                let durability = if let Some((_, stamp)) = zalsa_local.active_query() {
+                    // Record the maximum durability across all queries that intern this value.
+                    let previous_durability = value
+                        .durability
+                        .fetch_max(stamp.durability.as_u8(), Ordering::AcqRel);
+
+                    Durability::from_u8(previous_durability).max(stamp.durability)
+                } else {
+                    value.durability()
+                };
+
+                // Record a dependency on this value.
+                zalsa_local.report_tracked_read_simple(index, durability, value.first_interned_at);
+
+                id
+            }
+
+            // We won any races so should intern the data
+            Err(slot) => {
+                // Record the durability of the current query on the interned value.
+                let (durability, last_interned_at) = zalsa_local
+                    .active_query()
+                    .map(|(_, stamp)| (stamp.durability, current_revision))
+                    // If there is no active query this durability does not actually matter.
+                    // `last_interned_at` needs to be `Revision::MAX`, see the intern_access_in_different_revision test.
+                    .unwrap_or((Durability::MAX, Revision::max()));
+
+                let id = zalsa_local.allocate(zalsa, self.ingredient_index, |id| Value::<C> {
+                    fields: unsafe { self.to_internal_data(assemble(id, key)) },
+                    memos: Default::default(),
+                    durability: AtomicU8::new(durability.as_u8()),
+                    // Record the revision we are interning in.
+                    first_interned_at: current_revision,
+                    last_interned_at: AtomicRevision::from(last_interned_at),
+                });
+
+                let value = zalsa.table().get::<Value<C>>(id);
+
+                unsafe { lock.insert_in_slot(data_hash, slot, (id, SharedValue::new(()))) };
+
+                debug_assert_eq!(
+                    data_hash,
+                    self.key_map
+                        .hasher()
+                        .hash_one(zalsa.table().get::<Value<C>>(id).fields.clone())
+                );
+
+                // Record a dependency on this value.
+                let index = self.database_key_index(id);
+                zalsa_local.report_tracked_read_simple(index, durability, value.first_interned_at);
+
+                zalsa.event(&|| {
+                    Event::new(EventKind::DidInternValue {
+                        key: index,
+                        revision: current_revision,
+                    })
+                });
+
+                id
+            }
+        }
+    }
+
+    /// Returns the database key index for an interned value with the given id.
+    pub fn database_key_index(&self, id: Id) -> DatabaseKeyIndex {
+        DatabaseKeyIndex::new(self.ingredient_index, id)
+    }
+
+    /// Lookup the data for an interned value based on its id.
+    /// Rarely used since end-users generally carry a struct with a pointer directly
+    /// to the interned item.
+    pub fn data<'db>(&'db self, db: &'db dyn Database, id: Id) -> &'db C::Fields<'db> {
+        let zalsa = db.zalsa();
+        let internal_data = zalsa.table().get::<Value<C>>(id);
+        let last_changed_revision = zalsa.last_changed_revision(internal_data.durability());
+
+        assert!(
+            internal_data.last_interned_at.load() >= last_changed_revision,
+            "Data {:?} was not interned in the latest revision for its durability.",
+            self.database_key_index(id)
+        );
+
+        unsafe { Self::from_internal_data(&internal_data.fields) }
+    }
+
+    /// Lookup the fields from an interned struct.
+    /// Note that this is not "leaking" since no dependency edge is required.
+    pub fn fields<'db>(&'db self, db: &'db dyn Database, s: C::Struct<'db>) -> &'db C::Fields<'db> {
+        self.data(db, AsId::as_id(&s))
+    }
+
+    pub fn reset(&mut self, db: &mut dyn Database) {
+        _ = db.zalsa_mut();
+        // We can clear the key_map now that we have cancelled all other handles.
+        self.key_map.clear();
+    }
+
+    #[cfg(feature = "salsa_unstable")]
+    /// Returns all data corresponding to the interned struct.
+    pub fn entries<'db>(
+        &'db self,
+        db: &'db dyn crate::Database,
+    ) -> impl Iterator<Item = &'db Value<C>> {
+        db.zalsa().table().slots_of::<Value<C>>()
+    }
+}
+
+impl<C> Ingredient for IngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn location(&self) -> &'static crate::ingredient::Location {
+        &C::LOCATION
+    }
+
+    fn ingredient_index(&self) -> IngredientIndex {
+        self.ingredient_index
+    }
+
+    unsafe fn maybe_changed_after(
+        &self,
+        db: &dyn Database,
+        input: Id,
+        revision: Revision,
+        _cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        let zalsa = db.zalsa();
+        let value = zalsa.table().get::<Value<C>>(input);
+        if value.first_interned_at > revision {
+            // The slot was reused.
+            return VerifyResult::Changed;
+        }
+
+        // The slot is valid in this revision but we have to sync the value's revision.
+        let current_revision = zalsa.current_revision();
+        // No `if` to be branchless.
+        value.last_interned_at.store(std::cmp::max(
+            current_revision,
+            value.last_interned_at.load(),
+        ));
+
+        zalsa.event(&|| {
+            let index = self.database_key_index(input);
+
+            Event::new(EventKind::DidReinternValue {
+                key: index,
+                revision: current_revision,
+            })
+        });
+
+        VerifyResult::unchanged()
+    }
+
+    fn debug_name(&self) -> &'static str {
+        C::DEBUG_NAME
+    }
+
+    fn memo_table_types(&self) -> Arc<MemoTableTypes> {
+        self.memo_table_types.clone()
+    }
+}
+
+impl<C> std::fmt::Debug for IngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct(std::any::type_name::<Self>())
+            .field("index", &self.ingredient_index)
+            .finish()
+    }
+}
+
+impl<C> Slot for Value<C>
+where
+    C: Configuration,
+{
+    #[inline(always)]
+    unsafe fn memos(&self, _current_revision: Revision) -> &MemoTable {
+        &self.memos
+    }
+
+    #[inline(always)]
+    fn memos_mut(&mut self) -> &mut MemoTable {
+        &mut self.memos
+    }
+}
+
+/// A trait for types that hash and compare like `O`.
+pub trait HashEqLike<O> {
+    fn hash<H: Hasher>(&self, h: &mut H);
+    fn eq(&self, data: &O) -> bool;
+}
+
+/// The `Lookup` trait is a more flexible variant on [`std::borrow::Borrow`]
+/// and [`std::borrow::ToOwned`].
+///
+/// It is implemented by "some type that can be used as the lookup key for `O`".
+/// This means that `self` can be hashed and compared for equality with values
+/// of type `O` without actually creating an owned value. It `self` needs to be interned,
+/// it can be converted into an equivalent value of type `O`.
+///
+/// The canonical example is `&str: Lookup<String>`. However, this example
+/// alone can be handled by [`std::borrow::Borrow`][]. In our case, we may have
+/// multiple keys accumulated into a struct, like `ViewStruct: Lookup<(K1, ...)>`,
+/// where `struct ViewStruct<L1: Lookup<K1>...>(K1...)`. The `Borrow` trait
+/// requires that `&(K1...)` be convertible to `&ViewStruct` which just isn't
+/// possible. `Lookup` instead offers direct `hash` and `eq` methods.
+pub trait Lookup<O> {
+    fn into_owned(self) -> O;
+}
+
+impl<T> Lookup<T> for T {
+    fn into_owned(self) -> T {
+        self
+    }
+}
+
+impl<T> HashEqLike<T> for T
+where
+    T: Hash + Eq,
+{
+    fn hash<H: Hasher>(&self, h: &mut H) {
+        Hash::hash(self, &mut *h);
+    }
+
+    fn eq(&self, data: &T) -> bool {
+        self == data
+    }
+}
+
+impl<T> HashEqLike<T> for &T
+where
+    T: Hash + Eq,
+{
+    fn hash<H: Hasher>(&self, h: &mut H) {
+        Hash::hash(*self, &mut *h);
+    }
+
+    fn eq(&self, data: &T) -> bool {
+        **self == *data
+    }
+}
+
+impl<T> HashEqLike<&T> for T
+where
+    T: Hash + Eq,
+{
+    fn hash<H: Hasher>(&self, h: &mut H) {
+        Hash::hash(self, &mut *h);
+    }
+
+    fn eq(&self, data: &&T) -> bool {
+        *self == **data
+    }
+}
+
+impl<T> Lookup<T> for &T
+where
+    T: Clone,
+{
+    fn into_owned(self) -> T {
+        Clone::clone(self)
+    }
+}
+
+impl<'a, T> HashEqLike<&'a T> for Box<T>
+where
+    T: ?Sized + Hash + Eq,
+    Box<T>: From<&'a T>,
+{
+    fn hash<H: Hasher>(&self, h: &mut H) {
+        Hash::hash(self, &mut *h)
+    }
+    fn eq(&self, data: &&T) -> bool {
+        **self == **data
+    }
+}
+
+impl<'a, T> Lookup<Box<T>> for &'a T
+where
+    T: ?Sized + Hash + Eq,
+    Box<T>: From<&'a T>,
+{
+    fn into_owned(self) -> Box<T> {
+        Box::from(self)
+    }
+}
+
+impl<'a, T> HashEqLike<&'a T> for Arc<T>
+where
+    T: ?Sized + Hash + Eq,
+    Arc<T>: From<&'a T>,
+{
+    fn hash<H: Hasher>(&self, h: &mut H) {
+        Hash::hash(&**self, &mut *h)
+    }
+    fn eq(&self, data: &&T) -> bool {
+        **self == **data
+    }
+}
+
+impl<'a, T> Lookup<Arc<T>> for &'a T
+where
+    T: ?Sized + Hash + Eq,
+    Arc<T>: From<&'a T>,
+{
+    fn into_owned(self) -> Arc<T> {
+        Arc::from(self)
+    }
+}
+
+impl Lookup<String> for &str {
+    fn into_owned(self) -> String {
+        self.to_owned()
+    }
+}
+impl HashEqLike<&str> for String {
+    fn hash<H: Hasher>(&self, h: &mut H) {
+        Hash::hash(self, &mut *h)
+    }
+
+    fn eq(&self, data: &&str) -> bool {
+        self == *data
+    }
+}
+
+impl<A, T: Hash + Eq + PartialEq<A>> HashEqLike<&[A]> for Vec<T> {
+    fn hash<H: Hasher>(&self, h: &mut H) {
+        Hash::hash(self, h);
+    }
+
+    fn eq(&self, data: &&[A]) -> bool {
+        self.len() == data.len() && data.iter().enumerate().all(|(i, a)| &self[i] == a)
+    }
+}
+impl<A: Hash + Eq + PartialEq<T> + Clone + Lookup<T>, T> Lookup<Vec<T>> for &[A] {
+    fn into_owned(self) -> Vec<T> {
+        self.iter().map(|a| Lookup::into_owned(a.clone())).collect()
+    }
+}
+
+impl<const N: usize, A, T: Hash + Eq + PartialEq<A>> HashEqLike<[A; N]> for Vec<T> {
+    fn hash<H: Hasher>(&self, h: &mut H) {
+        Hash::hash(self, h);
+    }
+
+    fn eq(&self, data: &[A; N]) -> bool {
+        self.len() == data.len() && data.iter().enumerate().all(|(i, a)| &self[i] == a)
+    }
+}
+impl<const N: usize, A: Hash + Eq + PartialEq<T> + Clone + Lookup<T>, T> Lookup<Vec<T>> for [A; N] {
+    fn into_owned(self) -> Vec<T> {
+        self.into_iter()
+            .map(|a| Lookup::into_owned(a.clone()))
+            .collect()
+    }
+}
+
+impl HashEqLike<&Path> for PathBuf {
+    fn hash<H: Hasher>(&self, h: &mut H) {
+        Hash::hash(self, h);
+    }
+
+    fn eq(&self, data: &&Path) -> bool {
+        self == data
+    }
+}
+impl Lookup<PathBuf> for &Path {
+    fn into_owned(self) -> PathBuf {
+        self.to_owned()
+    }
+}
diff --git a/crates/salsa/src/key.rs b/crates/salsa/src/key.rs
new file mode 100644
index 000000000..92372b8c7
--- /dev/null
+++ b/crates/salsa/src/key.rs
@@ -0,0 +1,82 @@
+use core::fmt;
+
+use crate::cycle::CycleHeads;
+use crate::function::VerifyResult;
+use crate::zalsa::{IngredientIndex, Zalsa};
+use crate::{Database, Id};
+
+// ANCHOR: DatabaseKeyIndex
+/// An integer that uniquely identifies a particular query instance within the
+/// database. Used to track input and output dependencies between queries. Fully
+/// ordered and equatable but those orderings are arbitrary, and meant to be used
+/// only for inserting into maps and the like.
+#[derive(Copy, Clone, PartialEq, Eq, Hash)]
+pub struct DatabaseKeyIndex {
+    ingredient_index: IngredientIndex,
+    key_index: Id,
+}
+// ANCHOR_END: DatabaseKeyIndex
+
+impl DatabaseKeyIndex {
+    #[inline]
+    pub(crate) fn new(ingredient_index: IngredientIndex, key_index: Id) -> Self {
+        Self {
+            key_index,
+            ingredient_index,
+        }
+    }
+
+    pub fn ingredient_index(self) -> IngredientIndex {
+        self.ingredient_index
+    }
+
+    pub fn key_index(self) -> Id {
+        self.key_index
+    }
+
+    pub(crate) fn maybe_changed_after(
+        &self,
+        db: &dyn Database,
+        zalsa: &Zalsa,
+        last_verified_at: crate::Revision,
+        cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        // SAFETY: The `db` belongs to the ingredient
+        unsafe {
+            zalsa
+                .lookup_ingredient(self.ingredient_index)
+                .maybe_changed_after(db, self.key_index, last_verified_at, cycle_heads)
+        }
+    }
+
+    pub(crate) fn remove_stale_output(&self, zalsa: &Zalsa, executor: DatabaseKeyIndex) {
+        zalsa
+            .lookup_ingredient(self.ingredient_index)
+            .remove_stale_output(zalsa, executor, self.key_index)
+    }
+
+    pub(crate) fn mark_validated_output(
+        &self,
+        zalsa: &Zalsa,
+        database_key_index: DatabaseKeyIndex,
+    ) {
+        zalsa
+            .lookup_ingredient(self.ingredient_index)
+            .mark_validated_output(zalsa, database_key_index, self.key_index)
+    }
+}
+
+impl fmt::Debug for DatabaseKeyIndex {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        crate::attach::with_attached_database(|db| {
+            let ingredient = db.zalsa().lookup_ingredient(self.ingredient_index);
+            ingredient.fmt_index(self.key_index, f)
+        })
+        .unwrap_or_else(|| {
+            f.debug_tuple("DatabaseKeyIndex")
+                .field(&self.ingredient_index)
+                .field(&self.key_index)
+                .finish()
+        })
+    }
+}
diff --git a/crates/salsa/src/lib.rs b/crates/salsa/src/lib.rs
new file mode 100644
index 000000000..1b5cbf6a3
--- /dev/null
+++ b/crates/salsa/src/lib.rs
@@ -0,0 +1,135 @@
+#![deny(clippy::undocumented_unsafe_blocks)]
+#![forbid(unsafe_op_in_unsafe_fn)]
+
+mod accumulator;
+mod active_query;
+mod attach;
+mod cancelled;
+mod cycle;
+mod database;
+mod database_impl;
+mod durability;
+mod event;
+mod function;
+mod hash;
+mod id;
+mod ingredient;
+mod input;
+mod interned;
+mod key;
+mod loom;
+mod memo_ingredient_indices;
+mod nonce;
+#[cfg(feature = "rayon")]
+mod parallel;
+mod return_mode;
+mod revision;
+mod runtime;
+mod salsa_struct;
+mod storage;
+mod table;
+mod tracked_struct;
+mod update;
+mod views;
+mod zalsa;
+mod zalsa_local;
+
+#[cfg(feature = "rayon")]
+pub use parallel::{join, par_map};
+#[cfg(feature = "macros")]
+pub use salsa_macros::{accumulator, db, input, interned, tracked, Supertype, Update};
+
+pub use self::accumulator::Accumulator;
+pub use self::active_query::Backtrace;
+pub use self::cancelled::Cancelled;
+pub use self::cycle::CycleRecoveryAction;
+pub use self::database::{AsDynDatabase, Database};
+pub use self::database_impl::DatabaseImpl;
+pub use self::durability::Durability;
+pub use self::event::{Event, EventKind};
+pub use self::id::Id;
+pub use self::input::setter::Setter;
+pub use self::key::DatabaseKeyIndex;
+pub use self::return_mode::SalsaAsDeref;
+pub use self::return_mode::SalsaAsRef;
+pub use self::revision::Revision;
+pub use self::runtime::Runtime;
+pub use self::storage::{Storage, StorageHandle};
+pub use self::update::Update;
+pub use self::zalsa::IngredientIndex;
+pub use crate::attach::{attach, with_attached_database};
+
+pub mod prelude {
+    pub use crate::{Accumulator, Database, Setter};
+}
+
+/// Internal names used by salsa macros.
+///
+/// # WARNING
+///
+/// The contents of this module are NOT subject to semver.
+#[doc(hidden)]
+pub mod plumbing {
+    pub use std::any::TypeId;
+    pub use std::option::Option::{self, None, Some};
+
+    pub use salsa_macro_rules::{
+        macro_if, maybe_backdate, maybe_default, maybe_default_tt, return_mode_expression,
+        return_mode_ty, setup_accumulator_impl, setup_input_struct, setup_interned_struct,
+        setup_method_body, setup_tracked_fn, setup_tracked_struct, unexpected_cycle_initial,
+        unexpected_cycle_recovery,
+    };
+
+    pub use crate::__maybe_lazy_static;
+    pub use crate::accumulator::Accumulator;
+    pub use crate::attach::{attach, with_attached_database};
+    pub use crate::cycle::{CycleRecoveryAction, CycleRecoveryStrategy};
+    pub use crate::database::{current_revision, Database};
+    pub use crate::id::{AsId, FromId, FromIdWithDb, Id};
+    pub use crate::ingredient::{Ingredient, Jar, Location};
+    pub use crate::key::DatabaseKeyIndex;
+    pub use crate::memo_ingredient_indices::{
+        IngredientIndices, MemoIngredientIndices, MemoIngredientMap, MemoIngredientSingletonIndex,
+        NewMemoIngredientIndices,
+    };
+    pub use crate::revision::Revision;
+    pub use crate::runtime::{stamp, Runtime, Stamp, StampedValue};
+    pub use crate::salsa_struct::SalsaStructInDb;
+    pub use crate::storage::{HasStorage, Storage};
+    pub use crate::tracked_struct::TrackedStructInDb;
+    pub use crate::update::helper::{Dispatch as UpdateDispatch, Fallback as UpdateFallback};
+    pub use crate::update::{always_update, Update};
+    pub use crate::zalsa::{
+        transmute_data_ptr, views, IngredientCache, IngredientIndex, Zalsa, ZalsaDatabase,
+    };
+    pub use crate::zalsa_local::ZalsaLocal;
+
+    pub mod accumulator {
+        pub use crate::accumulator::{IngredientImpl, JarImpl};
+    }
+
+    pub mod input {
+        pub use crate::input::input_field::FieldIngredientImpl;
+        pub use crate::input::setter::SetterImpl;
+        pub use crate::input::singleton::{NotSingleton, Singleton};
+        pub use crate::input::{Configuration, HasBuilder, IngredientImpl, JarImpl, Value};
+    }
+
+    pub mod interned {
+        pub use crate::interned::{
+            Configuration, HashEqLike, IngredientImpl, JarImpl, Lookup, Value,
+        };
+    }
+
+    pub mod function {
+        pub use crate::function::Configuration;
+        pub use crate::function::IngredientImpl;
+        pub use crate::function::Memo;
+        pub use crate::table::memo::MemoEntryType;
+    }
+
+    pub mod tracked_struct {
+        pub use crate::tracked_struct::tracked_field::FieldIngredientImpl;
+        pub use crate::tracked_struct::{Configuration, IngredientImpl, JarImpl, Value};
+    }
+}
diff --git a/crates/salsa/src/loom.rs b/crates/salsa/src/loom.rs
new file mode 100644
index 000000000..e951cb501
--- /dev/null
+++ b/crates/salsa/src/loom.rs
@@ -0,0 +1,274 @@
+#[cfg(loom)]
+pub use loom::{cell, thread, thread_local};
+
+/// A helper macro to work around the fact that most loom types are not `const` constructable.
+#[doc(hidden)]
+#[macro_export]
+#[cfg(loom)]
+macro_rules! __maybe_lazy_static {
+    (static $name:ident: $t:ty = $init:expr $(;)?) => {
+        loom::lazy_static! { static ref $name: $t = $init; }
+    };
+}
+/// A helper macro to work around the fact that most loom types are not `const` constructable.
+#[doc(hidden)]
+#[macro_export]
+#[cfg(not(loom))]
+macro_rules! __maybe_lazy_static {
+    (static $name:ident: $t:ty = $init:expr $(;)?) => {
+        static $name: $t = $init;
+    };
+}
+
+pub(crate) use crate::__maybe_lazy_static as maybe_lazy_static;
+
+/// A polyfill for `Atomic*::get_mut`, which loom does not support.
+pub trait AtomicMut<T> {
+    fn read_mut(&mut self) -> T;
+    fn write_mut(&mut self, value: T);
+}
+
+#[cfg(loom)]
+pub mod sync {
+    pub use super::AtomicMut;
+    pub use loom::sync::*;
+
+    /// A wrapper around loom's `Mutex` to mirror parking-lot's API.
+    #[derive(Default, Debug)]
+    pub struct Mutex<T>(loom::sync::Mutex<T>);
+
+    impl<T> Mutex<T> {
+        pub fn new(value: T) -> Mutex<T> {
+            Mutex(loom::sync::Mutex::new(value))
+        }
+
+        pub fn lock(&self) -> MutexGuard<'_, T> {
+            self.0.lock().unwrap()
+        }
+
+        pub fn get_mut(&mut self) -> &mut T {
+            self.0.get_mut().unwrap()
+        }
+    }
+
+    /// A wrapper around loom's `RwLock` to mirror parking-lot's API.
+    #[derive(Default, Debug)]
+    pub struct RwLock<T>(loom::sync::RwLock<T>);
+
+    impl<T> RwLock<T> {
+        pub fn read(&self) -> RwLockReadGuard<'_, T> {
+            self.0.read().unwrap()
+        }
+
+        pub fn write(&self) -> RwLockWriteGuard<'_, T> {
+            self.0.write().unwrap()
+        }
+
+        pub fn get_mut(&mut self) -> &mut T {
+            self.0.get_mut().unwrap()
+        }
+    }
+
+    /// A wrapper around loom's `Condvar` to mirror parking-lot's API.
+    #[derive(Default, Debug)]
+    pub struct Condvar(loom::sync::Condvar);
+
+    impl Condvar {
+        // We cannot match parking-lot identically because loom's version takes ownership of the `MutexGuard`.
+        pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>) -> MutexGuard<'a, T> {
+            self.0.wait(guard).unwrap()
+        }
+
+        pub fn notify_one(&self) {
+            self.0.notify_one();
+        }
+
+        pub fn notify_all(&self) {
+            self.0.notify_all();
+        }
+    }
+
+    use loom::cell::UnsafeCell;
+    use std::mem::MaybeUninit;
+
+    /// A polyfill for `std::sync::OnceLock`.
+    pub struct OnceLock<T>(Mutex<bool>, UnsafeCell<MaybeUninit<T>>);
+
+    impl<T> OnceLock<T> {
+        pub fn new() -> OnceLock<T> {
+            OnceLock(Mutex::new(false), UnsafeCell::new(MaybeUninit::uninit()))
+        }
+
+        pub fn get(&self) -> Option<&T> {
+            let initialized = self.0.lock();
+            if *initialized {
+                // SAFETY: The value is initialized and write-once.
+                Some(self.1.with(|ptr| unsafe { (*ptr).assume_init_ref() }))
+            } else {
+                None
+            }
+        }
+
+        pub fn set(&self, value: T) -> Result<(), T> {
+            let mut initialized = self.0.lock();
+            if *initialized {
+                Err(value)
+            } else {
+                self.1.with_mut(|ptr| {
+                    // SAFETY: We hold the lock.
+                    unsafe { ptr.write(MaybeUninit::new(value)) }
+                });
+                *initialized = true;
+                Ok(())
+            }
+        }
+    }
+
+    impl<T> From<T> for OnceLock<T> {
+        fn from(value: T) -> OnceLock<T> {
+            OnceLock(Mutex::new(true), UnsafeCell::new(MaybeUninit::new(value)))
+        }
+    }
+
+    // SAFETY: Mirroring `std::sync::OnceLock`.
+    unsafe impl<T: Send> Send for OnceLock<T> {}
+    // SAFETY: Mirroring `std::sync::OnceLock`.
+    unsafe impl<T: Sync + Send> Sync for OnceLock<T> {}
+
+    /// Extend `Atomic*` with mutable accessors.
+    macro_rules! impl_loom_atomic_mut {
+        ($($atomic_ty:ident $(<$generic:ident>)? => $ty:ty),*) => {$(
+            impl $(<$generic>)? super::AtomicMut<$ty> for atomic::$atomic_ty $(<$generic>)? {
+                fn read_mut(&mut self) -> $ty {
+                    self.load(atomic::Ordering::Relaxed)
+                }
+
+                fn write_mut(&mut self, value: $ty) {
+                    self.store(value, atomic::Ordering::Relaxed)
+                }
+            }
+        )*};
+    }
+
+    impl_loom_atomic_mut! { AtomicBool => bool, AtomicUsize => usize, AtomicPtr<T> => *mut T }
+}
+
+#[cfg(not(loom))]
+pub use std::{thread, thread_local};
+
+#[cfg(not(loom))]
+pub mod cell {
+    pub use std::cell::*;
+
+    pub(crate) struct UnsafeCell<T>(core::cell::UnsafeCell<T>);
+
+    // this is not derived because it confuses rust-analyzer ... https://github.com/rust-lang/rust-analyzer/issues/19755
+    impl<T: std::fmt::Debug> std::fmt::Debug for UnsafeCell<T> {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            f.debug_tuple("UnsafeCell").field(&self.0).finish()
+        }
+    }
+
+    impl<T> UnsafeCell<T> {
+        pub const fn new(data: T) -> UnsafeCell<T> {
+            UnsafeCell(core::cell::UnsafeCell::new(data))
+        }
+
+        #[inline(always)]
+        pub fn with<F, R>(&self, f: F) -> R
+        where
+            F: FnOnce(*const T) -> R,
+        {
+            f(self.0.get())
+        }
+
+        #[inline(always)]
+        pub fn with_mut<F, R>(&self, f: F) -> R
+        where
+            F: FnOnce(*mut T) -> R,
+        {
+            f(self.0.get())
+        }
+
+        #[inline(always)]
+        pub(crate) fn get_mut(&self) -> MutPtr<T> {
+            MutPtr(self.0.get())
+        }
+    }
+
+    #[derive(Debug)]
+    pub(crate) struct MutPtr<T: ?Sized>(*mut T);
+
+    impl<T: ?Sized> MutPtr<T> {
+        #[inline(always)]
+        pub fn with<F, R>(&self, f: F) -> R
+        where
+            F: FnOnce(*mut T) -> R,
+        {
+            f(self.0)
+        }
+    }
+}
+
+#[cfg(not(loom))]
+pub mod sync {
+    pub use super::AtomicMut;
+    pub use parking_lot::{Mutex, MutexGuard, RwLock};
+    pub use std::sync::*;
+
+    pub mod atomic {
+        pub use portable_atomic::AtomicU64;
+        pub use std::sync::atomic::*;
+    }
+
+    /// A wrapper around parking-lot's `Condvar` to mirror loom's API.
+    pub struct Condvar(parking_lot::Condvar);
+
+    // this is not derived because it confuses rust-analyzer ... https://github.com/rust-lang/rust-analyzer/issues/19755
+    #[allow(clippy::derivable_impls)]
+    impl Default for Condvar {
+        fn default() -> Self {
+            Self(Default::default())
+        }
+    }
+
+    // this is not derived because it confuses rust-analyzer ... https://github.com/rust-lang/rust-analyzer/issues/19755
+    impl std::fmt::Debug for Condvar {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            f.debug_tuple("Condvar").field(&self.0).finish()
+        }
+    }
+
+    impl Condvar {
+        pub fn wait<'a, T>(&self, mut guard: MutexGuard<'a, T>) -> MutexGuard<'a, T> {
+            self.0.wait(&mut guard);
+            guard
+        }
+
+        pub fn notify_one(&self) {
+            self.0.notify_one();
+        }
+
+        pub fn notify_all(&self) {
+            self.0.notify_all();
+        }
+    }
+}
+
+/// Extend `Atomic*` with mutable accessors.
+macro_rules! impl_std_atomic_mut {
+    ($($atomic_ty:ident $(<$generic:ident>)? => $ty:ty),*) => {$(
+        #[cfg(not(loom))]
+        impl $(<$generic>)? AtomicMut<$ty> for sync::atomic::$atomic_ty $(<$generic>)? {
+            fn read_mut(&mut self) -> $ty {
+                *self.get_mut()
+            }
+
+            fn write_mut(&mut self, value: $ty) {
+                *self.get_mut() = value;
+            }
+        }
+    )*};
+}
+
+impl_std_atomic_mut! { AtomicBool => bool, AtomicUsize => usize, AtomicPtr<T> => *mut T }
diff --git a/crates/salsa/src/memo_ingredient_indices.rs b/crates/salsa/src/memo_ingredient_indices.rs
new file mode 100644
index 000000000..927c8cd05
--- /dev/null
+++ b/crates/salsa/src/memo_ingredient_indices.rs
@@ -0,0 +1,174 @@
+use crate::loom::sync::Arc;
+use crate::table::memo::{MemoEntryType, MemoTableTypes};
+use crate::zalsa::{MemoIngredientIndex, Zalsa};
+use crate::{Id, IngredientIndex};
+
+/// An ingredient has an [ingredient index][IngredientIndex]. However, Salsa also supports
+/// enums of salsa structs (and other salsa enums), and those don't have a constant ingredient index,
+/// because they are not ingredients by themselves but rather composed of them. However, an enum can
+/// be viewed as a *set* of [`IngredientIndex`], where each instance of the enum can belong
+/// to one, potentially different, index. This is what this type represents: a set of
+/// `IngredientIndex`.
+#[derive(Clone)]
+pub struct IngredientIndices {
+    indices: Box<[IngredientIndex]>,
+}
+
+impl From<IngredientIndex> for IngredientIndices {
+    #[inline]
+    fn from(value: IngredientIndex) -> Self {
+        Self {
+            indices: Box::new([value]),
+        }
+    }
+}
+
+impl IngredientIndices {
+    #[inline]
+    pub fn empty() -> Self {
+        Self {
+            indices: Box::default(),
+        }
+    }
+
+    pub fn merge(iter: impl IntoIterator<Item = Self>) -> Self {
+        let mut indices = Vec::new();
+        for index in iter {
+            indices.extend(index.indices);
+        }
+        indices.sort_unstable();
+        indices.dedup();
+        Self {
+            indices: indices.into_boxed_slice(),
+        }
+    }
+}
+
+pub trait NewMemoIngredientIndices {
+    /// # Safety
+    ///
+    /// The memo types must be correct.
+    unsafe fn create(
+        zalsa: &Zalsa,
+        struct_indices: IngredientIndices,
+        ingredient: IngredientIndex,
+        memo_type: MemoEntryType,
+        intern_ingredient_memo_types: Option<Arc<MemoTableTypes>>,
+    ) -> Self;
+}
+
+impl NewMemoIngredientIndices for MemoIngredientIndices {
+    /// # Safety
+    ///
+    /// The memo types must be correct.
+    unsafe fn create(
+        zalsa: &Zalsa,
+        struct_indices: IngredientIndices,
+        ingredient: IngredientIndex,
+        memo_type: MemoEntryType,
+        _intern_ingredient_memo_types: Option<Arc<MemoTableTypes>>,
+    ) -> Self {
+        debug_assert!(
+            _intern_ingredient_memo_types.is_none(),
+            "intern ingredient can only have a singleton memo ingredient"
+        );
+        let Some(&last) = struct_indices.indices.last() else {
+            unreachable!("Attempting to construct struct memo mapping for non tracked function?")
+        };
+        let mut indices = Vec::new();
+        indices.resize(
+            last.as_usize() + 1,
+            MemoIngredientIndex::from_usize((u32::MAX - 1) as usize),
+        );
+        for &struct_ingredient in &struct_indices.indices {
+            let memo_types = zalsa
+                .lookup_ingredient(struct_ingredient)
+                .memo_table_types();
+
+            let mi = zalsa.next_memo_ingredient_index(struct_ingredient, ingredient);
+            memo_types.set(mi, &memo_type);
+
+            indices[struct_ingredient.as_usize()] = mi;
+        }
+        MemoIngredientIndices {
+            indices: indices.into_boxed_slice(),
+        }
+    }
+}
+
+/// This type is to [`MemoIngredientIndex`] what [`IngredientIndices`] is to [`IngredientIndex`]:
+/// since enums can contain different ingredient indices, they can also have different memo indices,
+/// so we need to keep track of them.
+///
+/// This acts a map from [`IngredientIndex`] to [`MemoIngredientIndex`] but implemented
+/// via a slice for fast lookups, trading memory for speed. With these changes, lookups are `O(1)`
+/// instead of `O(n)`.
+///
+/// A database tends to have few ingredients (i), less function ingredients and even less
+/// function ingredients targeting `#[derive(Supertype)]` enums (e).
+/// While this is bounded as `O(i * e)` memory usage, the average case is significantly smaller: a
+/// function ingredient targeting enums only stores a slice whose length corresponds to the largest
+/// ingredient index's _value_. For example, if we have the ingredient indices `[2, 6, 17]`, then we
+/// will allocate a slice whose length is `17 + 1`.
+///
+/// Assuming a heavy example scenario of 1000 ingredients (500 of which are function ingredients, 100
+/// of which are enum targeting functions) this would come out to a maximum possibly memory usage of
+/// 4bytes * 1000 * 100 ~= 0.38MB which is negligible.
+pub struct MemoIngredientIndices {
+    indices: Box<[MemoIngredientIndex]>,
+}
+
+impl MemoIngredientMap for MemoIngredientIndices {
+    #[inline(always)]
+    fn get_zalsa_id(&self, zalsa: &Zalsa, id: Id) -> MemoIngredientIndex {
+        self.get(zalsa.ingredient_index(id))
+    }
+    #[inline(always)]
+    fn get(&self, index: IngredientIndex) -> MemoIngredientIndex {
+        self.indices[index.as_usize()]
+    }
+}
+
+#[derive(Debug)]
+pub struct MemoIngredientSingletonIndex(MemoIngredientIndex);
+
+impl MemoIngredientMap for MemoIngredientSingletonIndex {
+    #[inline(always)]
+    fn get_zalsa_id(&self, _: &Zalsa, _: Id) -> MemoIngredientIndex {
+        self.0
+    }
+    #[inline(always)]
+    fn get(&self, _: IngredientIndex) -> MemoIngredientIndex {
+        self.0
+    }
+}
+
+impl NewMemoIngredientIndices for MemoIngredientSingletonIndex {
+    #[inline]
+    unsafe fn create(
+        zalsa: &Zalsa,
+        indices: IngredientIndices,
+        ingredient: IngredientIndex,
+        memo_type: MemoEntryType,
+        intern_ingredient_memo_types: Option<Arc<MemoTableTypes>>,
+    ) -> Self {
+        let &[struct_ingredient] = &*indices.indices else {
+            unreachable!("Attempting to construct struct memo mapping from enum?")
+        };
+
+        let memo_types = intern_ingredient_memo_types.unwrap_or_else(|| {
+            zalsa
+                .lookup_ingredient(struct_ingredient)
+                .memo_table_types()
+        });
+
+        let mi = zalsa.next_memo_ingredient_index(struct_ingredient, ingredient);
+        memo_types.set(mi, &memo_type);
+        Self(mi)
+    }
+}
+
+pub trait MemoIngredientMap: Send + Sync {
+    fn get_zalsa_id(&self, zalsa: &Zalsa, id: Id) -> MemoIngredientIndex;
+    fn get(&self, index: IngredientIndex) -> MemoIngredientIndex;
+}
diff --git a/crates/salsa/src/nonce.rs b/crates/salsa/src/nonce.rs
new file mode 100644
index 000000000..e09f1acdc
--- /dev/null
+++ b/crates/salsa/src/nonce.rs
@@ -0,0 +1,53 @@
+use crate::loom::sync::atomic::{AtomicU32, Ordering};
+use std::marker::PhantomData;
+use std::num::NonZeroU32;
+
+/// A type to generate nonces. Store it in a static and each nonce it produces will be unique from other nonces.
+/// The type parameter `T` just serves to distinguish different kinds of nonces.
+pub(crate) struct NonceGenerator<T> {
+    value: AtomicU32,
+    phantom: PhantomData<T>,
+}
+
+/// A "nonce" is a value that gets created exactly once.
+/// We use it to mark the database storage so we can be sure we're seeing the same database.
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
+pub struct Nonce<T>(NonZeroU32, PhantomData<T>);
+
+impl<T> NonceGenerator<T> {
+    #[cfg(not(loom))]
+    pub(crate) const fn new() -> Self {
+        Self {
+            // start at 1 so we can detect rollover more easily
+            value: AtomicU32::new(1),
+            phantom: PhantomData,
+        }
+    }
+
+    #[cfg(loom)]
+    pub(crate) fn new() -> Self {
+        Self {
+            // start at 1 so we can detect rollover more easily
+            value: AtomicU32::new(1),
+            phantom: PhantomData,
+        }
+    }
+
+    pub(crate) fn nonce(&self) -> Nonce<T> {
+        let value = self.value.fetch_add(1, Ordering::Relaxed);
+
+        assert!(value != 0, "nonce rolled over");
+
+        Nonce(NonZeroU32::new(value).unwrap(), self.phantom)
+    }
+}
+
+impl<T> Nonce<T> {
+    pub(crate) fn into_u32(self) -> NonZeroU32 {
+        self.0
+    }
+
+    pub(crate) fn from_u32(u32: NonZeroU32) -> Self {
+        Self(u32, PhantomData)
+    }
+}
diff --git a/crates/salsa/src/parallel.rs b/crates/salsa/src/parallel.rs
new file mode 100644
index 000000000..1d2504b77
--- /dev/null
+++ b/crates/salsa/src/parallel.rs
@@ -0,0 +1,44 @@
+use rayon::iter::{FromParallelIterator, IntoParallelIterator, ParallelIterator};
+
+use crate::Database;
+
+pub fn par_map<Db, F, T, R, C>(db: &Db, inputs: impl IntoParallelIterator<Item = T>, op: F) -> C
+where
+    Db: Database + ?Sized,
+    F: Fn(&Db, T) -> R + Sync + Send,
+    T: Send,
+    R: Send + Sync,
+    C: FromParallelIterator<R>,
+{
+    inputs
+        .into_par_iter()
+        .map_with(DbForkOnClone(db.fork_db()), |db, element| {
+            op(db.0.as_view(), element)
+        })
+        .collect()
+}
+
+struct DbForkOnClone(Box<dyn Database>);
+
+impl Clone for DbForkOnClone {
+    fn clone(&self) -> Self {
+        DbForkOnClone(self.0.fork_db())
+    }
+}
+
+pub fn join<A, B, RA, RB, Db: Database + ?Sized>(db: &Db, a: A, b: B) -> (RA, RB)
+where
+    A: FnOnce(&Db) -> RA + Send,
+    B: FnOnce(&Db) -> RB + Send,
+    RA: Send,
+    RB: Send,
+{
+    // we need to fork eagerly, as `rayon::join_context` gives us no option to tell whether we get
+    // moved to another thread before the closure is executed
+    let db_a = db.fork_db();
+    let db_b = db.fork_db();
+    rayon::join(
+        move || a(db_a.as_view::<Db>()),
+        move || b(db_b.as_view::<Db>()),
+    )
+}
diff --git a/crates/salsa/src/return_mode.rs b/crates/salsa/src/return_mode.rs
new file mode 100644
index 000000000..d5dcca79c
--- /dev/null
+++ b/crates/salsa/src/return_mode.rs
@@ -0,0 +1,69 @@
+//! User-implementable salsa traits for refining the return type via `returns(as_ref)` and `returns(as_deref)`.
+
+use std::ops::Deref;
+
+/// Used to determine the return type and value for tracked fields and functions annotated with `returns(as_ref)`.
+pub trait SalsaAsRef {
+    // The type returned by tracked fields and functions annotated with `returns(as_ref)`.
+    type AsRef<'a>
+    where
+        Self: 'a;
+
+    // The value returned by tracked fields and functions annotated with `returns(as_ref)`.
+    fn as_ref(&self) -> Self::AsRef<'_>;
+}
+
+impl<T> SalsaAsRef for Option<T> {
+    type AsRef<'a>
+        = Option<&'a T>
+    where
+        Self: 'a;
+
+    fn as_ref(&self) -> Self::AsRef<'_> {
+        self.as_ref()
+    }
+}
+
+impl<T, E> SalsaAsRef for Result<T, E> {
+    type AsRef<'a>
+        = Result<&'a T, &'a E>
+    where
+        Self: 'a;
+
+    fn as_ref(&self) -> Self::AsRef<'_> {
+        self.as_ref()
+    }
+}
+
+/// Used to determine the return type and value for tracked fields and functions annotated with `returns(as_deref)`.
+pub trait SalsaAsDeref {
+    // The type returned by tracked fields and functions annotated with `returns(as_deref)`.
+    type AsDeref<'a>
+    where
+        Self: 'a;
+
+    // The value returned by tracked fields and functions annotated with `returns(as_deref)`.
+    fn as_deref(&self) -> Self::AsDeref<'_>;
+}
+
+impl<T: Deref> SalsaAsDeref for Option<T> {
+    type AsDeref<'a>
+        = Option<&'a T::Target>
+    where
+        Self: 'a;
+
+    fn as_deref(&self) -> Self::AsDeref<'_> {
+        self.as_deref()
+    }
+}
+
+impl<T: Deref, E> SalsaAsDeref for Result<T, E> {
+    type AsDeref<'a>
+        = Result<&'a T::Target, &'a E>
+    where
+        Self: 'a;
+
+    fn as_deref(&self) -> Self::AsDeref<'_> {
+        self.as_deref()
+    }
+}
diff --git a/crates/salsa/src/revision.rs b/crates/salsa/src/revision.rs
new file mode 100644
index 000000000..c2f0edde9
--- /dev/null
+++ b/crates/salsa/src/revision.rs
@@ -0,0 +1,156 @@
+use std::num::NonZeroUsize;
+
+use crate::loom::sync::atomic::{AtomicUsize, Ordering};
+
+/// Value of the initial revision, as a u64. We don't use 0
+/// because we want to use a `NonZeroUsize`.
+const START: usize = 1;
+
+/// A unique identifier for the current version of the database.
+///
+/// Each time an input is changed, the revision number is incremented.
+/// `Revision` is used internally to track which values may need to be
+/// recomputed, but is not something you should have to interact with
+/// directly as a user of salsa.
+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord)]
+pub struct Revision {
+    generation: NonZeroUsize,
+}
+
+impl Revision {
+    #[inline]
+    pub(crate) fn max() -> Self {
+        Self::from(usize::MAX)
+    }
+
+    #[inline]
+    pub(crate) fn start() -> Self {
+        Self::from(START)
+    }
+
+    #[inline]
+    pub(crate) fn from(g: usize) -> Self {
+        Self {
+            generation: NonZeroUsize::new(g).unwrap(),
+        }
+    }
+
+    #[inline]
+    pub(crate) fn from_opt(g: usize) -> Option<Self> {
+        NonZeroUsize::new(g).map(|generation| Self { generation })
+    }
+
+    #[inline]
+    pub(crate) fn next(self) -> Revision {
+        Self::from(self.generation.get() + 1)
+    }
+
+    #[inline]
+    fn as_usize(self) -> usize {
+        self.generation.get()
+    }
+}
+
+impl std::fmt::Debug for Revision {
+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(fmt, "R{}", self.generation)
+    }
+}
+
+#[derive(Debug)]
+pub(crate) struct AtomicRevision {
+    data: AtomicUsize,
+}
+
+impl From<Revision> for AtomicRevision {
+    fn from(value: Revision) -> Self {
+        Self {
+            data: AtomicUsize::new(value.as_usize()),
+        }
+    }
+}
+
+impl AtomicRevision {
+    pub(crate) fn load(&self) -> Revision {
+        Revision {
+            // SAFETY: We know that the value is non-zero because we only ever store `START` which 1, or a
+            // Revision which is guaranteed to be non-zero.
+            generation: unsafe { NonZeroUsize::new_unchecked(self.data.load(Ordering::Acquire)) },
+        }
+    }
+
+    pub(crate) fn store(&self, r: Revision) {
+        self.data.store(r.as_usize(), Ordering::Release);
+    }
+}
+
+#[derive(Debug)]
+pub(crate) struct OptionalAtomicRevision {
+    data: AtomicUsize,
+}
+
+impl From<Revision> for OptionalAtomicRevision {
+    fn from(value: Revision) -> Self {
+        Self {
+            data: AtomicUsize::new(value.as_usize()),
+        }
+    }
+}
+
+impl OptionalAtomicRevision {
+    pub(crate) fn new(revision: Option<Revision>) -> Self {
+        Self {
+            data: AtomicUsize::new(revision.map_or(0, |r| r.as_usize())),
+        }
+    }
+
+    pub(crate) fn load(&self) -> Option<Revision> {
+        Revision::from_opt(self.data.load(Ordering::Acquire))
+    }
+
+    pub(crate) fn swap(&self, val: Option<Revision>) -> Option<Revision> {
+        Revision::from_opt(
+            self.data
+                .swap(val.map_or(0, |r| r.as_usize()), Ordering::AcqRel),
+        )
+    }
+
+    pub(crate) fn compare_exchange(
+        &self,
+        current: Option<Revision>,
+        new: Option<Revision>,
+    ) -> Result<Option<Revision>, Option<Revision>> {
+        self.data
+            .compare_exchange(
+                current.map_or(0, |r| r.as_usize()),
+                new.map_or(0, |r| r.as_usize()),
+                Ordering::AcqRel,
+                Ordering::Acquire,
+            )
+            .map(Revision::from_opt)
+            .map_err(Revision::from_opt)
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn optional_atomic_revision() {
+        let val = OptionalAtomicRevision::new(Some(Revision::start()));
+        assert_eq!(val.load(), Some(Revision::start()));
+        assert_eq!(val.swap(None), Some(Revision::start()));
+        assert_eq!(val.load(), None);
+        assert_eq!(val.swap(Some(Revision::start())), None);
+        assert_eq!(val.load(), Some(Revision::start()));
+        assert_eq!(
+            val.compare_exchange(Some(Revision::start()), None),
+            Ok(Some(Revision::start()))
+        );
+        assert_eq!(
+            val.compare_exchange(Some(Revision::start()), None),
+            Err(None)
+        );
+    }
+}
diff --git a/crates/salsa/src/runtime.rs b/crates/salsa/src/runtime.rs
new file mode 100644
index 000000000..84e1bae96
--- /dev/null
+++ b/crates/salsa/src/runtime.rs
@@ -0,0 +1,216 @@
+use self::dependency_graph::DependencyGraph;
+use crate::durability::Durability;
+use crate::key::DatabaseKeyIndex;
+use crate::loom::sync::atomic::{AtomicBool, Ordering};
+use crate::loom::sync::{AtomicMut, Mutex};
+use crate::loom::thread::{self, ThreadId};
+use crate::table::Table;
+use crate::{Cancelled, Event, EventKind, Revision};
+
+mod dependency_graph;
+
+pub struct Runtime {
+    /// Set to true when the current revision has been canceled.
+    /// This is done when we an input is being changed. The flag
+    /// is set back to false once the input has been changed.
+    revision_canceled: AtomicBool,
+
+    /// Stores the "last change" revision for values of each duration.
+    /// This vector is always of length at least 1 (for Durability 0)
+    /// but its total length depends on the number of durations. The
+    /// element at index 0 is special as it represents the "current
+    /// revision".  In general, we have the invariant that revisions
+    /// in here are *declining* -- that is, `revisions[i] >=
+    /// revisions[i + 1]`, for all `i`. This is because when you
+    /// modify a value with durability D, that implies that values
+    /// with durability less than D may have changed too.
+    revisions: [Revision; Durability::LEN],
+
+    /// The dependency graph tracks which runtimes are blocked on one
+    /// another, waiting for queries to terminate.
+    dependency_graph: Mutex<DependencyGraph>,
+
+    /// Data for instances
+    table: Table,
+}
+
+#[derive(Clone, Debug)]
+pub(crate) enum WaitResult {
+    Completed,
+    Panicked,
+}
+
+#[derive(Clone, Debug)]
+pub(crate) enum BlockResult {
+    Completed,
+    Cycle,
+}
+
+#[derive(Copy, Clone, Debug)]
+pub struct StampedValue<V> {
+    pub value: V,
+    pub durability: Durability,
+    pub changed_at: Revision,
+}
+
+pub type Stamp = StampedValue<()>;
+
+pub fn stamp(revision: Revision, durability: Durability) -> Stamp {
+    StampedValue {
+        value: (),
+        durability,
+        changed_at: revision,
+    }
+}
+
+impl<V> StampedValue<V> {
+    // FIXME: Use or remove this.
+    #[allow(dead_code)]
+    pub(crate) fn merge_revision_info<U>(&mut self, other: &StampedValue<U>) {
+        self.durability = self.durability.min(other.durability);
+        self.changed_at = self.changed_at.max(other.changed_at);
+    }
+}
+
+impl Default for Runtime {
+    fn default() -> Self {
+        Runtime {
+            revisions: [Revision::start(); Durability::LEN],
+            revision_canceled: Default::default(),
+            dependency_graph: Default::default(),
+            table: Default::default(),
+        }
+    }
+}
+
+impl std::fmt::Debug for Runtime {
+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        fmt.debug_struct("Runtime")
+            .field("revisions", &self.revisions)
+            .field("revision_canceled", &self.revision_canceled)
+            .field("dependency_graph", &self.dependency_graph)
+            .finish()
+    }
+}
+
+impl Runtime {
+    #[inline]
+    pub(crate) fn current_revision(&self) -> Revision {
+        self.revisions[0]
+    }
+
+    /// Reports that an input with durability `durability` changed.
+    /// This will update the 'last changed at' values for every durability
+    /// less than or equal to `durability` to the current revision.
+    pub(crate) fn report_tracked_write(&mut self, durability: Durability) {
+        let new_revision = self.current_revision();
+        self.revisions[1..=durability.index()].fill(new_revision);
+    }
+
+    /// The revision in which values with durability `d` may have last
+    /// changed.  For D0, this is just the current revision. But for
+    /// higher levels of durability, this value may lag behind the
+    /// current revision. If we encounter a value of durability Di,
+    /// then, we can check this function to get a "bound" on when the
+    /// value may have changed, which allows us to skip walking its
+    /// dependencies.
+    #[inline]
+    pub(crate) fn last_changed_revision(&self, d: Durability) -> Revision {
+        self.revisions[d.index()]
+    }
+
+    pub(crate) fn load_cancellation_flag(&self) -> bool {
+        self.revision_canceled.load(Ordering::Acquire)
+    }
+
+    pub(crate) fn set_cancellation_flag(&self) {
+        tracing::trace!("set_cancellation_flag");
+        self.revision_canceled.store(true, Ordering::Release);
+    }
+
+    pub(crate) fn reset_cancellation_flag(&mut self) {
+        self.revision_canceled.write_mut(false);
+    }
+
+    /// Returns the [`Table`] used to store the value of salsa structs
+    #[inline]
+    pub(crate) fn table(&self) -> &Table {
+        &self.table
+    }
+
+    pub(crate) fn table_mut(&mut self) -> &mut Table {
+        &mut self.table
+    }
+
+    /// Increments the "current revision" counter and clears
+    /// the cancellation flag.
+    ///
+    /// This should only be done by the storage when the state is "quiescent".
+    pub(crate) fn new_revision(&mut self) -> Revision {
+        let r_old = self.current_revision();
+        let r_new = r_old.next();
+        self.revisions[0] = r_new;
+        tracing::debug!("new_revision: {r_old:?} -> {r_new:?}");
+        r_new
+    }
+
+    /// Block until `other_id` completes executing `database_key`, or return `BlockResult::Cycle`
+    /// immediately in case of a cycle.
+    ///
+    /// `query_mutex_guard` is the guard for the current query's state;
+    /// it will be dropped after we have successfully registered the
+    /// dependency.
+    ///
+    /// # Propagating panics
+    ///
+    /// If the thread `other_id` panics, then our thread is considered
+    /// cancelled, so this function will panic with a `Cancelled` value.
+    pub(crate) fn block_on<QueryMutexGuard>(
+        &self,
+        zalsa: &crate::zalsa::Zalsa,
+        database_key: DatabaseKeyIndex,
+        other_id: ThreadId,
+        query_mutex_guard: QueryMutexGuard,
+    ) -> BlockResult {
+        let dg = self.dependency_graph.lock();
+        let thread_id = thread::current().id();
+
+        if dg.depends_on(other_id, thread_id) {
+            return BlockResult::Cycle;
+        }
+
+        zalsa.event(&|| {
+            Event::new(EventKind::WillBlockOn {
+                other_thread_id: other_id,
+                database_key,
+            })
+        });
+
+        let result =
+            DependencyGraph::block_on(dg, thread_id, database_key, other_id, query_mutex_guard);
+
+        match result {
+            WaitResult::Completed => BlockResult::Completed,
+
+            // If the other thread panicked, then we consider this thread
+            // cancelled. The assumption is that the panic will be detected
+            // by the other thread and responded to appropriately.
+            WaitResult::Panicked => Cancelled::PropagatedPanic.throw(),
+        }
+    }
+
+    /// Invoked when this runtime completed computing `database_key` with
+    /// the given result `wait_result` (`wait_result` should be `None` if
+    /// computing `database_key` panicked and could not complete).
+    /// This function unblocks any dependent queries and allows them
+    /// to continue executing.
+    pub(crate) fn unblock_queries_blocked_on(
+        &self,
+        database_key: DatabaseKeyIndex,
+        wait_result: WaitResult,
+    ) {
+        self.dependency_graph
+            .lock()
+            .unblock_runtimes_blocked_on(database_key, wait_result);
+    }
+}
diff --git a/crates/salsa/src/runtime/dependency_graph.rs b/crates/salsa/src/runtime/dependency_graph.rs
new file mode 100644
index 000000000..f5fa78033
--- /dev/null
+++ b/crates/salsa/src/runtime/dependency_graph.rs
@@ -0,0 +1,191 @@
+use std::pin::Pin;
+
+use rustc_hash::FxHashMap;
+use smallvec::SmallVec;
+
+use crate::key::DatabaseKeyIndex;
+use crate::loom::sync::MutexGuard;
+use crate::loom::thread::ThreadId;
+use crate::runtime::dependency_graph::edge::EdgeCondvar;
+use crate::runtime::WaitResult;
+
+#[derive(Debug, Default)]
+pub(super) struct DependencyGraph {
+    /// A `(K -> V)` pair in this map indicates that the runtime
+    /// `K` is blocked on some query executing in the runtime `V`.
+    /// This encodes a graph that must be acyclic (or else deadlock
+    /// will result).
+    edges: FxHashMap<ThreadId, edge::Edge>,
+
+    /// Encodes the `ThreadId` that are blocked waiting for the result
+    /// of a given query.
+    query_dependents: FxHashMap<DatabaseKeyIndex, SmallVec<[ThreadId; 4]>>,
+
+    /// When a key K completes which had dependent queries Qs blocked on it,
+    /// it stores its `WaitResult` here. As they wake up, each query Q in Qs will
+    /// come here to fetch their results.
+    wait_results: FxHashMap<ThreadId, WaitResult>,
+}
+
+impl DependencyGraph {
+    /// True if `from_id` depends on `to_id`.
+    ///
+    /// (i.e., there is a path from `from_id` to `to_id` in the graph.)
+    pub(super) fn depends_on(&self, from_id: ThreadId, to_id: ThreadId) -> bool {
+        let mut p = from_id;
+        while let Some(q) = self.edges.get(&p).map(|edge| edge.blocked_on_id) {
+            if q == to_id {
+                return true;
+            }
+
+            p = q;
+        }
+        p == to_id
+    }
+
+    /// Modifies the graph so that `from_id` is blocked
+    /// on `database_key`, which is being computed by
+    /// `to_id`.
+    ///
+    /// For this to be reasonable, the lock on the
+    /// results table for `database_key` must be held.
+    /// This ensures that computing `database_key` doesn't
+    /// complete before `block_on` executes.
+    ///
+    /// Preconditions:
+    /// * No path from `to_id` to `from_id`
+    ///   (i.e., `me.depends_on(to_id, from_id)` is false)
+    /// * `held_mutex` is a read lock (or stronger) on `database_key`
+    pub(super) fn block_on<QueryMutexGuard>(
+        mut me: MutexGuard<'_, Self>,
+        from_id: ThreadId,
+        database_key: DatabaseKeyIndex,
+        to_id: ThreadId,
+        query_mutex_guard: QueryMutexGuard,
+    ) -> WaitResult {
+        let cvar = std::pin::pin!(EdgeCondvar::default());
+        let cvar = cvar.as_ref();
+        // SAFETY: We are blocking until the result is removed from `DependencyGraph::wait_results`
+        // at which point the `edge` won't signal the condvar anymore.
+        // As such we are keeping the cond var alive until the reference in the edge drops.
+        unsafe { me.add_edge(from_id, database_key, to_id, cvar) };
+
+        // Release the mutex that prevents `database_key`
+        // from completing, now that the edge has been added.
+        drop(query_mutex_guard);
+
+        loop {
+            if let Some(result) = me.wait_results.remove(&from_id) {
+                debug_assert!(!me.edges.contains_key(&from_id));
+                return result;
+            }
+            me = cvar.wait(me);
+        }
+    }
+
+    /// Helper for `block_on`: performs actual graph modification
+    /// to add a dependency edge from `from_id` to `to_id`, which is
+    /// computing `database_key`.
+    ///
+    /// # Safety
+    ///
+    /// The caller needs to keep the referent of `cvar` alive until the corresponding
+    /// [`Self::wait_results`] entry has been inserted.
+    unsafe fn add_edge(
+        &mut self,
+        from_id: ThreadId,
+        database_key: DatabaseKeyIndex,
+        to_id: ThreadId,
+        cvar: Pin<&EdgeCondvar>,
+    ) {
+        assert_ne!(from_id, to_id);
+        debug_assert!(!self.edges.contains_key(&from_id));
+        debug_assert!(!self.depends_on(to_id, from_id));
+        // SAFETY: The caller is responsible for ensuring that the `EdgeGuard` outlives the `Edge`.
+        let edge = unsafe { edge::Edge::new(to_id, cvar) };
+        self.edges.insert(from_id, edge);
+        self.query_dependents
+            .entry(database_key)
+            .or_default()
+            .push(from_id);
+    }
+
+    /// Invoked when runtime `to_id` completes executing
+    /// `database_key`.
+    pub(super) fn unblock_runtimes_blocked_on(
+        &mut self,
+        database_key: DatabaseKeyIndex,
+        wait_result: WaitResult,
+    ) {
+        let dependents = self
+            .query_dependents
+            .remove(&database_key)
+            .unwrap_or_default();
+
+        for from_id in dependents {
+            self.unblock_runtime(from_id, wait_result.clone());
+        }
+    }
+
+    /// Unblock the runtime with the given id with the given wait-result.
+    /// This will cause it resume execution (though it will have to grab
+    /// the lock on this data structure first, to recover the wait result).
+    fn unblock_runtime(&mut self, id: ThreadId, wait_result: WaitResult) {
+        let edge = self.edges.remove(&id).expect("not blocked");
+        self.wait_results.insert(id, wait_result);
+
+        // Now that we have inserted the `wait_results`,
+        // notify the thread.
+        edge.notify();
+    }
+}
+
+mod edge {
+    use crate::loom::sync::{Condvar, MutexGuard};
+    use crate::loom::thread::ThreadId;
+
+    use std::pin::Pin;
+
+    #[derive(Default, Debug)]
+    pub(super) struct EdgeCondvar {
+        condvar: Condvar,
+        _phantom_pin: std::marker::PhantomPinned,
+    }
+
+    impl EdgeCondvar {
+        #[inline]
+        pub(super) fn wait<'a, T>(&self, mutex_guard: MutexGuard<'a, T>) -> MutexGuard<'a, T> {
+            self.condvar.wait(mutex_guard)
+        }
+    }
+
+    #[derive(Debug)]
+    pub(super) struct Edge {
+        pub(super) blocked_on_id: ThreadId,
+
+        /// Signalled whenever a query with dependents completes.
+        /// Allows those dependents to check if they are ready to unblock.
+        // condvar: unsafe<'stack_frame> Pin<&'stack_frame Condvar>,
+        condvar: Pin<&'static EdgeCondvar>,
+    }
+
+    impl Edge {
+        /// # SAFETY
+        ///
+        /// The caller must ensure that the [`EdgeCondvar`] is kept alive until the [`Edge`] is dropped.
+        pub(super) unsafe fn new(blocked_on_id: ThreadId, condvar: Pin<&EdgeCondvar>) -> Self {
+            Self {
+                blocked_on_id,
+                // SAFETY: The caller is responsible for ensuring that the `EdgeCondvar` outlives the `Edge`.
+                condvar: unsafe {
+                    std::mem::transmute::<Pin<&EdgeCondvar>, Pin<&'static EdgeCondvar>>(condvar)
+                },
+            }
+        }
+
+        #[inline]
+        pub(super) fn notify(self) {
+            self.condvar.condvar.notify_one();
+        }
+    }
+}
diff --git a/crates/salsa/src/salsa_struct.rs b/crates/salsa/src/salsa_struct.rs
new file mode 100644
index 000000000..642dbe75c
--- /dev/null
+++ b/crates/salsa/src/salsa_struct.rs
@@ -0,0 +1,65 @@
+use std::any::TypeId;
+
+use crate::memo_ingredient_indices::{IngredientIndices, MemoIngredientMap};
+use crate::zalsa::Zalsa;
+use crate::Id;
+
+pub trait SalsaStructInDb: Sized {
+    type MemoIngredientMap: MemoIngredientMap;
+
+    /// Lookup or create ingredient indices.
+    ///
+    /// Note that this method does *not* create the ingredients themselves, this is handled by
+    /// [`Zalsa::add_or_lookup_jar_by_type()`]. This method only creates
+    /// or looks up the indices corresponding to the ingredients.
+    ///
+    /// While implementors of this trait may call [`Zalsa::add_or_lookup_jar_by_type()`]
+    /// to create the ingredient, they aren't required to. For example, supertypes recursively
+    /// call [`Zalsa::add_or_lookup_jar_by_type()`] for their variants and combine them.
+    fn lookup_or_create_ingredient_index(zalsa: &Zalsa) -> IngredientIndices;
+
+    /// Plumbing to support nested salsa supertypes.
+    ///
+    /// In the example below, there are two supertypes: `InnerEnum` and `OuterEnum`,
+    /// where the former is a supertype of `Input` and `Interned1` and the latter
+    /// is a supertype of `InnerEnum` and `Interned2`.
+    ///
+    /// ```ignore
+    /// #[salsa::input]
+    /// struct Input {}
+    ///
+    /// #[salsa::interned]
+    /// struct Interned1 {}
+    ///
+    /// #[salsa::interned]
+    /// struct Interned2 {}
+    ///
+    /// #[derive(Debug, salsa::Enum)]
+    /// enum InnerEnum {
+    ///     Input(Input),
+    ///     Interned1(Interned1),
+    /// }
+    ///
+    /// #[derive(Debug, salsa::Enum)]
+    /// enum OuterEnum {
+    ///     InnerEnum(InnerEnum),
+    ///     Interned2(Interned2),
+    /// }
+    /// ```
+    ///
+    /// Imagine `OuterEnum` got a [`salsa::Id`][Id] and it wants to know which variant it belongs to.
+    ///
+    /// `OuterEnum` cannot ask each variant "what is your ingredient index?" and compare because `InnerEnum`
+    /// has *multiple*, possible ingredient indices. Alternatively, `OuterEnum` could ask eaach variant
+    /// "is this value yours?" and then invoke [`FromId`][crate::id::FromId] with the correct variant,
+    /// but this duplicates work: now, `InnerEnum` will have to repeat this check-and-cast for *its*
+    /// variants.
+    ///
+    /// Instead, the implementor keeps track of the [`std::any::TypeId`] of the ID struct, and ask each
+    /// variant to "cast" to it. If it succeeds, `cast` returns that value; if not, we
+    /// go to the next variant.
+    ///
+    /// Why `TypeId` and not `IngredientIndex`? Because it's cheaper and easier: the `TypeId` is readily
+    /// available at compile time, while the `IngredientIndex` requires a runtime lookup.
+    fn cast(id: Id, type_id: TypeId) -> Option<Self>;
+}
diff --git a/crates/salsa/src/storage.rs b/crates/salsa/src/storage.rs
new file mode 100644
index 000000000..ab2e4907e
--- /dev/null
+++ b/crates/salsa/src/storage.rs
@@ -0,0 +1,217 @@
+//! Public API facades for the implementation details of [`Zalsa`] and [`ZalsaLocal`].
+use std::marker::PhantomData;
+use std::panic::RefUnwindSafe;
+
+use crate::loom::sync::{Arc, Condvar, Mutex};
+use crate::zalsa::{Zalsa, ZalsaDatabase};
+use crate::zalsa_local::{self, ZalsaLocal};
+use crate::{Database, Event, EventKind};
+
+/// A handle to non-local database state.
+pub struct StorageHandle<Db> {
+    // Note: Drop order is important, zalsa_impl needs to drop before coordinate
+    /// Reference to the database.
+    zalsa_impl: Arc<Zalsa>,
+
+    // Note: Drop order is important, coordinate needs to drop after zalsa_impl
+    /// Coordination data for cancellation of other handles when `zalsa_mut` is called.
+    /// This could be stored in Zalsa but it makes things marginally cleaner to keep it separate.
+    coordinate: CoordinateDrop,
+
+    /// We store references to `Db`
+    phantom: PhantomData<fn() -> Db>,
+}
+
+impl<Db> Clone for StorageHandle<Db> {
+    fn clone(&self) -> Self {
+        *self.coordinate.clones.lock() += 1;
+
+        Self {
+            zalsa_impl: self.zalsa_impl.clone(),
+            coordinate: CoordinateDrop(Arc::clone(&self.coordinate)),
+            phantom: PhantomData,
+        }
+    }
+}
+
+impl<Db: Database> Default for StorageHandle<Db> {
+    fn default() -> Self {
+        Self::new(None)
+    }
+}
+
+impl<Db: Database> StorageHandle<Db> {
+    pub fn new(event_callback: Option<Box<dyn Fn(crate::Event) + Send + Sync + 'static>>) -> Self {
+        Self {
+            zalsa_impl: Arc::new(Zalsa::new::<Db>(event_callback)),
+            coordinate: CoordinateDrop(Arc::new(Coordinate {
+                clones: Mutex::new(1),
+                cvar: Default::default(),
+            })),
+            phantom: PhantomData,
+        }
+    }
+
+    pub fn into_storage(self) -> Storage<Db> {
+        Storage {
+            handle: self,
+            zalsa_local: ZalsaLocal::new(),
+        }
+    }
+}
+
+/// Access the "storage" of a Salsa database: this is an internal plumbing trait
+/// automatically implemented by `#[salsa::db]` applied to a struct.
+///
+/// # Safety
+///
+/// The `storage` and `storage_mut` fields must both return a reference to the same
+/// storage field which must be owned by `self`.
+pub unsafe trait HasStorage: Database + Clone + Sized {
+    fn storage(&self) -> &Storage<Self>;
+    fn storage_mut(&mut self) -> &mut Storage<Self>;
+}
+
+/// Concrete implementation of the [`Database`] trait with local state that can be used to drive computations.
+pub struct Storage<Db> {
+    handle: StorageHandle<Db>,
+
+    /// Per-thread state
+    zalsa_local: zalsa_local::ZalsaLocal,
+}
+
+impl<Db> Drop for Storage<Db> {
+    fn drop(&mut self) {
+        self.zalsa_local
+            .record_unfilled_pages(self.handle.zalsa_impl.table());
+    }
+}
+
+struct Coordinate {
+    /// Counter of the number of clones of actor. Begins at 1.
+    /// Incremented when cloned, decremented when dropped.
+    clones: Mutex<usize>,
+    cvar: Condvar,
+}
+
+// We cannot panic while holding a lock to `clones: Mutex<usize>` and therefore we cannot enter an
+// inconsistent state.
+impl RefUnwindSafe for Coordinate {}
+
+impl<Db: Database> Default for Storage<Db> {
+    fn default() -> Self {
+        Self::new(None)
+    }
+}
+
+impl<Db: Database> Storage<Db> {
+    /// Create a new database storage.
+    ///
+    /// The `event_callback` function is invoked by the salsa runtime at various points during execution.
+    pub fn new(event_callback: Option<Box<dyn Fn(crate::Event) + Send + Sync + 'static>>) -> Self {
+        Self {
+            handle: StorageHandle::new(event_callback),
+            zalsa_local: ZalsaLocal::new(),
+        }
+    }
+
+    /// Convert this instance of [`Storage`] into a [`StorageHandle`].
+    ///
+    /// This will discard the local state of this [`Storage`], thereby returning a value that
+    /// is both [`Sync`] and [`std::panic::UnwindSafe`].
+    pub fn into_zalsa_handle(mut self) -> StorageHandle<Db> {
+        self.zalsa_local
+            .record_unfilled_pages(self.handle.zalsa_impl.table());
+        let Self {
+            handle,
+            zalsa_local: _,
+        } = &self;
+        // Avoid rust's annoying destructure prevention rules for `Drop` types
+        // SAFETY: We forget `Self` afterwards to discard the original copy, and the destructure
+        // above makes sure we won't forget to take into account newly added fields.
+        let handle = unsafe { std::ptr::read(handle) };
+        std::mem::forget::<Self>(self);
+        handle
+    }
+
+    // ANCHOR: cancel_other_workers
+    /// Sets cancellation flag and blocks until all other workers with access
+    /// to this storage have completed.
+    ///
+    /// This could deadlock if there is a single worker with two handles to the
+    /// same database!
+    ///
+    /// Needs to be paired with a call to `reset_cancellation_flag`.
+    fn cancel_others(&mut self) -> &mut Zalsa {
+        debug_assert!(
+            self.zalsa_local
+                .try_with_query_stack(|stack| stack.is_empty())
+                == Some(true),
+            "attempted to cancel within query computation, this is a deadlock"
+        );
+        self.handle.zalsa_impl.runtime().set_cancellation_flag();
+
+        self.handle
+            .zalsa_impl
+            .event(&|| Event::new(EventKind::DidSetCancellationFlag));
+
+        let mut clones = self.handle.coordinate.clones.lock();
+        while *clones != 1 {
+            clones = self.handle.coordinate.cvar.wait(clones);
+        }
+        // The ref count on the `Arc` should now be 1
+        let zalsa = Arc::get_mut(&mut self.handle.zalsa_impl).unwrap();
+        // cancellation is done, so reset the flag
+        zalsa.runtime_mut().reset_cancellation_flag();
+        zalsa
+    }
+    // ANCHOR_END: cancel_other_workers
+}
+
+#[allow(clippy::undocumented_unsafe_blocks)] // TODO(#697) document safety
+unsafe impl<T: HasStorage> ZalsaDatabase for T {
+    #[inline(always)]
+    fn zalsa(&self) -> &Zalsa {
+        &self.storage().handle.zalsa_impl
+    }
+
+    fn zalsa_mut(&mut self) -> &mut Zalsa {
+        self.storage_mut().cancel_others()
+    }
+
+    #[inline(always)]
+    fn zalsa_local(&self) -> &ZalsaLocal {
+        &self.storage().zalsa_local
+    }
+
+    #[inline(always)]
+    fn fork_db(&self) -> Box<dyn Database> {
+        Box::new(self.clone())
+    }
+}
+
+impl<Db: Database> Clone for Storage<Db> {
+    fn clone(&self) -> Self {
+        Self {
+            handle: self.handle.clone(),
+            zalsa_local: ZalsaLocal::new(),
+        }
+    }
+}
+
+struct CoordinateDrop(Arc<Coordinate>);
+
+impl std::ops::Deref for CoordinateDrop {
+    type Target = Arc<Coordinate>;
+
+    fn deref(&self) -> &Self::Target {
+        &self.0
+    }
+}
+
+impl Drop for CoordinateDrop {
+    fn drop(&mut self) {
+        *self.0.clones.lock() -= 1;
+        self.0.cvar.notify_all();
+    }
+}
diff --git a/crates/salsa/src/table.rs b/crates/salsa/src/table.rs
new file mode 100644
index 000000000..c4b65d1b0
--- /dev/null
+++ b/crates/salsa/src/table.rs
@@ -0,0 +1,412 @@
+use std::alloc::Layout;
+use std::any::{Any, TypeId};
+use std::marker::PhantomData;
+use std::mem::{self, MaybeUninit};
+use std::ptr::{self, NonNull};
+use std::slice;
+
+use memo::MemoTable;
+use rustc_hash::FxHashMap;
+
+use crate::loom::cell::UnsafeCell;
+use crate::loom::sync::atomic::{AtomicUsize, Ordering};
+use crate::loom::sync::{Arc, AtomicMut, Mutex};
+use crate::table::memo::{MemoTableTypes, MemoTableWithTypes, MemoTableWithTypesMut};
+use crate::{Id, IngredientIndex, Revision};
+
+pub(crate) mod memo;
+
+const PAGE_LEN_BITS: usize = 10;
+const PAGE_LEN_MASK: usize = PAGE_LEN - 1;
+const PAGE_LEN: usize = 1 << PAGE_LEN_BITS;
+const MAX_PAGES: usize = 1 << (u32::BITS as usize - PAGE_LEN_BITS);
+
+/// A typed [`Page`] view.
+pub(crate) struct PageView<'p, T: Slot>(&'p Page, PhantomData<&'p T>);
+
+pub struct Table {
+    pages: boxcar::Vec<Page>,
+    /// Map from ingredient to non-full pages that are up for grabs
+    non_full_pages: Mutex<FxHashMap<IngredientIndex, Vec<PageIndex>>>,
+}
+
+pub(crate) trait Slot: Any + Send + Sync {
+    /// Access the [`MemoTable`][] for this slot.
+    ///
+    /// # Safety condition
+    ///
+    /// The current revision MUST be the current revision of the database containing this slot.
+    unsafe fn memos(&self, current_revision: Revision) -> &MemoTable;
+
+    /// Mutably access the [`MemoTable`] for this slot.
+    fn memos_mut(&mut self) -> &mut MemoTable;
+}
+
+/// [Slot::memos]
+type SlotMemosFnRaw = unsafe fn(*const (), current_revision: Revision) -> *const MemoTable;
+/// [Slot::memos]
+type SlotMemosFn<T> = unsafe fn(&T, current_revision: Revision) -> &MemoTable;
+/// [Slot::memos_mut]
+type SlotMemosMutFnRaw = unsafe fn(*mut ()) -> *mut MemoTable;
+/// [Slot::memos_mut]
+type SlotMemosMutFn<T> = fn(&mut T) -> &mut MemoTable;
+
+struct SlotVTable {
+    layout: Layout,
+    /// [`Slot`] methods
+    memos: SlotMemosFnRaw,
+    memos_mut: SlotMemosMutFnRaw,
+    /// A drop impl to call when the own page drops
+    /// SAFETY: The caller is required to supply a correct data pointer to a `Box<PageDataEntry<T>>` and initialized length,
+    /// and correct memo types.
+    drop_impl: unsafe fn(data: *mut (), initialized: usize, memo_types: &MemoTableTypes),
+}
+
+impl SlotVTable {
+    const fn of<T: Slot>() -> &'static Self {
+        const {
+            &Self {
+                drop_impl: |data, initialized, memo_types|
+                // SAFETY: The caller is required to supply a correct data pointer and initialized length
+                unsafe {
+                    let data = Box::from_raw(data.cast::<PageData<T>>());
+                    for i in 0..initialized {
+                        data[i].with_mut(|item| {
+                            let item = item.cast::<T>();
+                            memo_types.attach_memos_mut((*item).memos_mut()).drop();
+                            ptr::drop_in_place(item);
+                        });
+                    }
+                },
+                layout: Layout::new::<T>(),
+                // SAFETY: The signatures are compatible
+                memos: unsafe { mem::transmute::<SlotMemosFn<T>, SlotMemosFnRaw>(T::memos) },
+                // SAFETY: The signatures are compatible
+                memos_mut: unsafe {
+                    mem::transmute::<SlotMemosMutFn<T>, SlotMemosMutFnRaw>(T::memos_mut)
+                },
+            }
+        }
+    }
+}
+
+type PageDataEntry<T> = UnsafeCell<MaybeUninit<T>>;
+type PageData<T> = [PageDataEntry<T>; PAGE_LEN];
+
+struct Page {
+    /// The ingredient for elements on this page.
+    ingredient: IngredientIndex,
+
+    /// Number of elements of `data` that are initialized.
+    allocated: AtomicUsize,
+
+    /// The "allocation lock" is held when we allocate a new entry.
+    ///
+    /// It ensures that we can load the index, initialize it, and then update the length atomically
+    /// with respect to other allocations.
+    ///
+    /// We could avoid it if we wanted, we'd just have to be a bit fancier in our reasoning
+    /// (for example, the bounds check in `Page::get` no longer suffices to truly guarantee
+    /// that the data is initialized).
+    allocation_lock: Mutex<()>,
+
+    /// The potentially uninitialized data of this page. As we initialize new entries, we increment `allocated`.
+    /// This is a box allocated `PageData<SlotType>`
+    data: NonNull<()>,
+
+    /// A vtable for the slot type stored in this page.
+    slot_vtable: &'static SlotVTable,
+    /// The type id of what is stored as entries in data.
+    // FIXME: Move this into SlotVTable once const stable
+    slot_type_id: TypeId,
+    /// The type name of what is stored as entries in data.
+    // FIXME: Move this into SlotVTable once const stable
+    slot_type_name: &'static str,
+
+    memo_types: Arc<MemoTableTypes>,
+}
+
+// SAFETY: `Page` is `Send` as we make sure to only ever store `Slot` types in it which
+// requires `Send`.`
+unsafe impl Send for Page /* where for<M: Memo> M: Send */ {}
+// SAFETY: `Page` is `Sync` as we make sure to only ever store `Slot` types in it which
+// requires `Sync`.`
+unsafe impl Sync for Page /* where for<M: Memo> M: Sync */ {}
+
+#[derive(Copy, Clone, Debug)]
+pub struct PageIndex(usize);
+
+impl PageIndex {
+    #[inline]
+    fn new(idx: usize) -> Self {
+        debug_assert!(idx < MAX_PAGES);
+        Self(idx)
+    }
+}
+
+#[derive(Copy, Clone, Debug)]
+struct SlotIndex(usize);
+
+impl SlotIndex {
+    #[inline]
+    fn new(idx: usize) -> Self {
+        debug_assert!(idx < PAGE_LEN);
+        Self(idx)
+    }
+}
+
+impl Default for Table {
+    fn default() -> Self {
+        Self {
+            pages: boxcar::Vec::new(),
+            non_full_pages: Default::default(),
+        }
+    }
+}
+
+impl Table {
+    /// Returns the [`IngredientIndex`] for an [`Id`].
+    #[inline]
+    pub fn ingredient_index(&self, id: Id) -> IngredientIndex {
+        let (page_idx, _) = split_id(id);
+        self.pages[page_idx.0].ingredient
+    }
+
+    /// Get a reference to the data for `id`, which must have been allocated from this table with type `T`.
+    ///
+    /// # Panics
+    ///
+    /// If `id` is out of bounds or the does not have the type `T`.
+    pub(crate) fn get<T: Slot>(&self, id: Id) -> &T {
+        let (page, slot) = split_id(id);
+        let page_ref = self.page::<T>(page);
+        &page_ref.data()[slot.0]
+    }
+
+    /// Get a raw pointer to the data for `id`, which must have been allocated from this table.
+    ///
+    /// # Panics
+    ///
+    /// If `id` is out of bounds or the does not have the type `T`.
+    ///
+    /// # Safety
+    ///
+    /// See [`Page::get_raw`][].
+    // TODO: This could return an `&UnsafeCell<T>` directly, but loom's `UnsafeCell` is not `repr(C)`
+    pub(crate) fn get_raw<T: Slot>(&self, id: Id) -> &UnsafeCell<MaybeUninit<T>> {
+        let (page, slot) = split_id(id);
+        let page_ref = self.page::<T>(page);
+        &page_ref.page_data()[slot.0]
+    }
+
+    /// Gets a reference to the page which has slots of type `T`
+    ///
+    /// # Panics
+    ///
+    /// If `page` is out of bounds or the type `T` is incorrect.
+    #[inline]
+    pub(crate) fn page<T: Slot>(&self, page: PageIndex) -> PageView<'_, T> {
+        self.pages[page.0].assert_type::<T>()
+    }
+
+    /// Allocate a new page for the given ingredient and with slots of type `T`
+    #[inline]
+    pub(crate) fn push_page<T: Slot>(
+        &self,
+        ingredient: IngredientIndex,
+        memo_types: Arc<MemoTableTypes>,
+    ) -> PageIndex {
+        PageIndex::new(self.pages.push(Page::new::<T>(ingredient, memo_types)))
+    }
+
+    /// Get the memo table associated with `id`
+    ///
+    /// # Safety condition
+    ///
+    /// The parameter `current_revision` MUST be the current revision
+    /// of the owner of database owning this table.
+    pub(crate) unsafe fn memos(
+        &self,
+        id: Id,
+        current_revision: Revision,
+    ) -> MemoTableWithTypes<'_> {
+        let (page, slot) = split_id(id);
+        let page = &self.pages[page.0];
+        // SAFETY: We supply a proper slot pointer and the caller is required to pass the `current_revision`.
+        let memos = unsafe { &*(page.slot_vtable.memos)(page.get(slot), current_revision) };
+        // SAFETY: The `Page` keeps the correct memo types.
+        unsafe { page.memo_types.attach_memos(memos) }
+    }
+
+    /// Get the memo table associated with `id`
+    pub(crate) fn memos_mut(&mut self, id: Id) -> MemoTableWithTypesMut<'_> {
+        let (page, slot) = split_id(id);
+        let page_index = page.0;
+        let page = self
+            .pages
+            .get_mut(page_index)
+            .unwrap_or_else(|| panic!("index `{page_index}` is uninitialized"));
+        // SAFETY: We supply a proper slot pointer and the caller is required to pass the `current_revision`.
+        let memos = unsafe { &mut *(page.slot_vtable.memos_mut)(page.get(slot)) };
+        // SAFETY: The `Page` keeps the correct memo types.
+        unsafe { page.memo_types.attach_memos_mut(memos) }
+    }
+
+    pub(crate) fn slots_of<T: Slot>(&self) -> impl Iterator<Item = &T> + '_ {
+        self.pages
+            .iter()
+            .filter_map(|(_, page)| page.cast_type::<T>())
+            .flat_map(|view| view.data())
+    }
+
+    pub(crate) fn fetch_or_push_page<T: Slot>(
+        &self,
+        ingredient: IngredientIndex,
+        memo_types: impl FnOnce() -> Arc<MemoTableTypes>,
+    ) -> PageIndex {
+        if let Some(page) = self
+            .non_full_pages
+            .lock()
+            .get_mut(&ingredient)
+            .and_then(Vec::pop)
+        {
+            return page;
+        }
+        self.push_page::<T>(ingredient, memo_types())
+    }
+
+    pub(crate) fn record_unfilled_page(&self, ingredient: IngredientIndex, page: PageIndex) {
+        self.non_full_pages
+            .lock()
+            .entry(ingredient)
+            .or_default()
+            .push(page);
+    }
+}
+
+impl<'p, T: Slot> PageView<'p, T> {
+    #[inline]
+    fn page_data(&self) -> &'p [PageDataEntry<T>] {
+        let len = self.0.allocated.load(Ordering::Acquire);
+        // SAFETY: `len` is the initialized length of the page
+        unsafe { slice::from_raw_parts(self.0.data.cast::<PageDataEntry<T>>().as_ptr(), len) }
+    }
+
+    #[inline]
+    fn data(&self) -> &'p [T] {
+        let len = self.0.allocated.load(Ordering::Acquire);
+        // SAFETY: `len` is the initialized length of the page
+        unsafe { slice::from_raw_parts(self.0.data.cast::<T>().as_ptr(), len) }
+    }
+
+    pub(crate) fn allocate<V>(&self, page: PageIndex, value: V) -> Result<Id, V>
+    where
+        V: FnOnce(Id) -> T,
+    {
+        let _guard = self.0.allocation_lock.lock();
+        let index = self.0.allocated.load(Ordering::Acquire);
+        if index >= PAGE_LEN {
+            return Err(value);
+        }
+
+        // Initialize entry `index`
+        let id = make_id(page, SlotIndex::new(index));
+        let data = self.0.data.cast::<PageDataEntry<T>>();
+        // SAFETY: We acquired the allocation lock, so we have unique access to the UnsafeCell
+        // interior.
+        // `index` is also guaranteed to be in bounds as per the check above.
+        unsafe { (*data.as_ptr().add(index)).with_mut(|ptr| (*ptr).write(value(id))) };
+
+        // Update the length (this must be done after initialization as otherwise an uninitialized
+        // read could occur!)
+        self.0.allocated.store(index + 1, Ordering::Release);
+
+        Ok(id)
+    }
+}
+
+impl Page {
+    #[inline]
+    fn new<T: Slot>(ingredient: IngredientIndex, memo_types: Arc<MemoTableTypes>) -> Self {
+        #[cfg(not(loom))]
+        let data: Box<PageData<T>> =
+            Box::new([const { UnsafeCell::new(MaybeUninit::uninit()) }; PAGE_LEN]);
+
+        #[cfg(loom)]
+        let data: Box<PageData<T>> =
+            Box::new([const { MaybeUninit::uninit() }; PAGE_LEN].map(UnsafeCell::new));
+
+        Self {
+            slot_vtable: SlotVTable::of::<T>(),
+            slot_type_id: TypeId::of::<T>(),
+            slot_type_name: std::any::type_name::<T>(),
+            ingredient,
+            allocated: Default::default(),
+            allocation_lock: Default::default(),
+            data: NonNull::from(Box::leak(data)).cast::<()>(),
+            memo_types,
+        }
+    }
+
+    /// Retrieves the pointer for the given slot.
+    ///
+    /// # Panics
+    ///
+    /// If slot is out of bounds
+    fn get(&self, slot: SlotIndex) -> *mut () {
+        let len = self.allocated.load(Ordering::Acquire);
+        assert!(
+            slot.0 < len,
+            "out of bounds access `{slot:?}` (maximum slot `{len}`)"
+        );
+        // SAFETY: We have checked that the resulting pointer will be within bounds.
+        unsafe {
+            self.data
+                .as_ptr()
+                .byte_add(slot.0 * self.slot_vtable.layout.size())
+        }
+    }
+
+    #[inline]
+    fn assert_type<T: Slot>(&self) -> PageView<T> {
+        assert_eq!(
+            self.slot_type_id,
+            TypeId::of::<T>(),
+            "page has slot type `{:?}` but `{:?}` was expected",
+            self.slot_type_name,
+            std::any::type_name::<T>(),
+        );
+        PageView(self, PhantomData)
+    }
+
+    fn cast_type<T: Slot>(&self) -> Option<PageView<T>> {
+        if self.slot_type_id == TypeId::of::<T>() {
+            Some(PageView(self, PhantomData))
+        } else {
+            None
+        }
+    }
+}
+
+impl Drop for Page {
+    fn drop(&mut self) {
+        let len = self.allocated.read_mut();
+        // SAFETY: We supply the data pointer and the initialized length
+        unsafe { (self.slot_vtable.drop_impl)(self.data.as_ptr(), len, &self.memo_types) };
+    }
+}
+
+fn make_id(page: PageIndex, slot: SlotIndex) -> Id {
+    let page = page.0 as u32;
+    let slot = slot.0 as u32;
+    // SAFETY: `slot` is guaranteed to be small enough that the resulting Id won't be bigger than `Id::MAX_U32`
+    unsafe { Id::from_u32((page << PAGE_LEN_BITS) | slot) }
+}
+
+#[inline]
+fn split_id(id: Id) -> (PageIndex, SlotIndex) {
+    let id = id.as_u32() as usize;
+    let slot = id & PAGE_LEN_MASK;
+    let page = id >> PAGE_LEN_BITS;
+    (PageIndex::new(page), SlotIndex::new(slot))
+}
diff --git a/crates/salsa/src/table/memo.rs b/crates/salsa/src/table/memo.rs
new file mode 100644
index 000000000..f6d49cb89
--- /dev/null
+++ b/crates/salsa/src/table/memo.rs
@@ -0,0 +1,362 @@
+use std::{
+    any::{Any, TypeId},
+    fmt::Debug,
+    mem,
+    ptr::{self, NonNull},
+};
+
+use thin_vec::ThinVec;
+
+use crate::loom::sync::atomic::{AtomicPtr, Ordering};
+use crate::loom::sync::{AtomicMut, OnceLock, RwLock};
+use crate::{zalsa::MemoIngredientIndex, zalsa_local::QueryOrigin};
+
+/// The "memo table" stores the memoized results of tracked function calls.
+/// Every tracked function must take a salsa struct as its first argument
+/// and memo tables are attached to those salsa structs as auxiliary data.
+#[derive(Default)]
+pub(crate) struct MemoTable {
+    memos: RwLock<ThinVec<MemoEntry>>,
+}
+
+pub trait Memo: Any + Send + Sync {
+    /// Returns the `origin` of this memo
+    fn origin(&self) -> &QueryOrigin;
+}
+
+/// Data for a memoized entry.
+/// This is a type-erased `Box<M>`, where `M` is the type of memo associated
+/// with that particular ingredient index.
+///
+/// # Implementation note
+///
+/// Every entry is associated with some ingredient that has been added to the database.
+/// That ingredient has a fixed type of values that it produces etc.
+/// Therefore, once a given entry goes from `Empty` to `Full`,
+/// the type-id associated with that entry should never change.
+///
+/// We take advantage of this and use an `AtomicPtr` to store the actual memo.
+/// This allows us to store into the memo-entry without acquiring a write-lock.
+/// However, using `AtomicPtr` means we cannot use a `Box<dyn Any>` or any other wide pointer.
+/// Therefore, we hide the type by transmuting to `DummyMemo`; but we must then be very careful
+/// when freeing `MemoEntryData` values to transmute things back. See the `Drop` impl for
+/// [`MemoEntry`][] for details.
+#[derive(Default)]
+struct MemoEntry {
+    /// An [`AtomicPtr`][] to a `Box<M>` for the erased memo type `M`
+    atomic_memo: AtomicPtr<DummyMemo>,
+}
+
+pub struct MemoEntryType {
+    data: OnceLock<MemoEntryTypeData>,
+}
+
+#[derive(Clone, Copy)]
+struct MemoEntryTypeData {
+    /// The `type_id` of the erased memo type `M`
+    type_id: TypeId,
+
+    /// A type-coercion function for the erased memo type `M`
+    to_dyn_fn: fn(NonNull<DummyMemo>) -> NonNull<dyn Memo>,
+}
+
+impl MemoEntryType {
+    fn to_dummy<M: Memo>(memo: NonNull<M>) -> NonNull<DummyMemo> {
+        memo.cast()
+    }
+
+    unsafe fn from_dummy<M: Memo>(memo: NonNull<DummyMemo>) -> NonNull<M> {
+        memo.cast()
+    }
+
+    const fn to_dyn_fn<M: Memo>() -> fn(NonNull<DummyMemo>) -> NonNull<dyn Memo> {
+        let f: fn(NonNull<M>) -> NonNull<dyn Memo> = |x| x;
+
+        // SAFETY: `M: Sized` and `DummyMemo: Sized`, as such they are ABI compatible behind a
+        // `NonNull` making it safe to do type erasure.
+        unsafe {
+            mem::transmute::<
+                fn(NonNull<M>) -> NonNull<dyn Memo>,
+                fn(NonNull<DummyMemo>) -> NonNull<dyn Memo>,
+            >(f)
+        }
+    }
+
+    #[inline]
+    pub fn of<M: Memo>() -> Self {
+        Self {
+            data: OnceLock::from(MemoEntryTypeData {
+                type_id: TypeId::of::<M>(),
+                to_dyn_fn: Self::to_dyn_fn::<M>(),
+            }),
+        }
+    }
+
+    #[inline]
+    fn load(&self) -> Option<&MemoEntryTypeData> {
+        self.data.get()
+    }
+}
+
+/// Dummy placeholder type that we use when erasing the memo type `M` in [`MemoEntryData`][].
+#[derive(Debug)]
+struct DummyMemo {}
+
+impl Memo for DummyMemo {
+    fn origin(&self) -> &QueryOrigin {
+        unreachable!("should not get here")
+    }
+}
+
+#[derive(Default)]
+pub struct MemoTableTypes {
+    types: boxcar::Vec<MemoEntryType>,
+}
+
+impl MemoTableTypes {
+    pub(crate) fn set(
+        &self,
+        memo_ingredient_index: MemoIngredientIndex,
+        memo_type: &MemoEntryType,
+    ) {
+        let memo_ingredient_index = memo_ingredient_index.as_usize();
+        while memo_ingredient_index >= self.types.count() {
+            self.types.push(MemoEntryType {
+                data: OnceLock::new(),
+            });
+        }
+        let memo_entry_type = self.types.get(memo_ingredient_index).unwrap();
+        memo_entry_type
+            .data
+            .set(
+                *memo_type
+                    .data
+                    .get()
+                    .expect("cannot provide an empty `MemoEntryType` for `MemoEntryType::set()`"),
+            )
+            .ok()
+            .expect("memo type should only be set once");
+    }
+
+    /// # Safety
+    ///
+    /// The types table must be the correct one of `memos`.
+    #[inline]
+    pub(super) unsafe fn attach_memos<'a>(
+        &'a self,
+        memos: &'a MemoTable,
+    ) -> MemoTableWithTypes<'a> {
+        MemoTableWithTypes { types: self, memos }
+    }
+
+    /// # Safety
+    ///
+    /// The types table must be the correct one of `memos`.
+    #[inline]
+    pub(crate) unsafe fn attach_memos_mut<'a>(
+        &'a self,
+        memos: &'a mut MemoTable,
+    ) -> MemoTableWithTypesMut<'a> {
+        MemoTableWithTypesMut { types: self, memos }
+    }
+}
+
+pub(crate) struct MemoTableWithTypes<'a> {
+    types: &'a MemoTableTypes,
+    memos: &'a MemoTable,
+}
+
+impl MemoTableWithTypes<'_> {
+    pub(crate) fn insert<M: Memo>(
+        self,
+        memo_ingredient_index: MemoIngredientIndex,
+        memo: NonNull<M>,
+    ) -> Option<NonNull<M>> {
+        // The type must already exist, we insert it when creating the memo ingredient.
+        assert_eq!(
+            self.types
+                .types
+                .get(memo_ingredient_index.as_usize())
+                .and_then(MemoEntryType::load)?
+                .type_id,
+            TypeId::of::<M>(),
+            "inconsistent type-id for `{memo_ingredient_index:?}`"
+        );
+
+        // If the memo slot is already occupied, it must already have the
+        // right type info etc, and we only need the read-lock.
+        if let Some(MemoEntry { atomic_memo }) = self
+            .memos
+            .memos
+            .read()
+            .get(memo_ingredient_index.as_usize())
+        {
+            let old_memo =
+                atomic_memo.swap(MemoEntryType::to_dummy(memo).as_ptr(), Ordering::AcqRel);
+
+            let old_memo = NonNull::new(old_memo);
+
+            // SAFETY: `type_id` check asserted above
+            return old_memo.map(|old_memo| unsafe { MemoEntryType::from_dummy(old_memo) });
+        }
+
+        // Otherwise we need the write lock.
+        self.insert_cold(memo_ingredient_index, memo)
+    }
+
+    #[cold]
+    fn insert_cold<M: Memo>(
+        self,
+        memo_ingredient_index: MemoIngredientIndex,
+        memo: NonNull<M>,
+    ) -> Option<NonNull<M>> {
+        let memo_ingredient_index = memo_ingredient_index.as_usize();
+        let mut memos = self.memos.memos.write();
+
+        // Grow the table if needed.
+        if memos.len() <= memo_ingredient_index {
+            let additional_len = memo_ingredient_index - memos.len() + 1;
+            memos.reserve(additional_len);
+            while memos.len() <= memo_ingredient_index {
+                memos.push(MemoEntry::default());
+            }
+        }
+
+        let memo_entry = &mut memos[memo_ingredient_index].atomic_memo;
+        let old_entry = memo_entry.read_mut();
+        memo_entry.write_mut(MemoEntryType::to_dummy(memo).as_ptr());
+
+        // SAFETY: The `TypeId` is asserted in `insert()`.
+        NonNull::new(old_entry).map(|memo| unsafe { MemoEntryType::from_dummy(memo) })
+    }
+
+    #[inline]
+    pub(crate) fn get<M: Memo>(
+        self,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) -> Option<NonNull<M>> {
+        let read = self.memos.memos.read();
+        let memo = read.get(memo_ingredient_index.as_usize())?;
+        let type_ = self
+            .types
+            .types
+            .get(memo_ingredient_index.as_usize())
+            .and_then(MemoEntryType::load)?;
+        assert_eq!(
+            type_.type_id,
+            TypeId::of::<M>(),
+            "inconsistent type-id for `{memo_ingredient_index:?}`"
+        );
+        let memo = NonNull::new(memo.atomic_memo.load(Ordering::Acquire))?;
+        // SAFETY: `type_id` check asserted above
+        Some(unsafe { MemoEntryType::from_dummy(memo) })
+    }
+}
+
+pub(crate) struct MemoTableWithTypesMut<'a> {
+    types: &'a MemoTableTypes,
+    memos: &'a mut MemoTable,
+}
+
+impl MemoTableWithTypesMut<'_> {
+    /// Calls `f` on the memo at `memo_ingredient_index`.
+    ///
+    /// If the memo is not present, `f` is not called.
+    pub(crate) fn map_memo<M: Memo>(
+        self,
+        memo_ingredient_index: MemoIngredientIndex,
+        f: impl FnOnce(&mut M),
+    ) {
+        let Some(type_) = self
+            .types
+            .types
+            .get(memo_ingredient_index.as_usize())
+            .and_then(MemoEntryType::load)
+        else {
+            return;
+        };
+        assert_eq!(
+            type_.type_id,
+            TypeId::of::<M>(),
+            "inconsistent type-id for `{memo_ingredient_index:?}`"
+        );
+
+        // If the memo slot is already occupied, it must already have the
+        // right type info etc, and we only need the read-lock.
+        let memos = self.memos.memos.get_mut();
+        let Some(MemoEntry { atomic_memo }) = memos.get_mut(memo_ingredient_index.as_usize())
+        else {
+            return;
+        };
+        let Some(memo) = NonNull::new(atomic_memo.read_mut()) else {
+            return;
+        };
+
+        // SAFETY: `type_id` check asserted above
+        f(unsafe { MemoEntryType::from_dummy(memo).as_mut() });
+    }
+
+    /// To drop an entry, we need its type, so we don't implement `Drop`, and instead have this method.
+    ///
+    /// Note that calling this multiple times is safe, dropping an uninitialized entry is a no-op.
+    ///
+    /// # Safety
+    ///
+    /// The caller needs to make sure to not call this function until no more references into
+    /// the database exist as there may be outstanding borrows into the pointer contents.
+    #[inline]
+    pub unsafe fn drop(&mut self) {
+        let types = self.types.types.iter();
+        for ((_, type_), memo) in std::iter::zip(types, self.memos.memos.get_mut()) {
+            // SAFETY: The types match as per our constructor invariant.
+            unsafe { memo.take(type_) };
+        }
+    }
+
+    /// # Safety
+    ///
+    /// The caller needs to make sure to not call this function until no more references into
+    /// the database exist as there may be outstanding borrows into the pointer contents.
+    pub(crate) unsafe fn take_memos(
+        &mut self,
+        mut f: impl FnMut(MemoIngredientIndex, Box<dyn Memo>),
+    ) {
+        let memos = self.memos.memos.get_mut();
+        memos
+            .iter_mut()
+            .zip(self.types.types.iter())
+            .enumerate()
+            .filter_map(|(index, (memo, (_, type_)))| {
+                // SAFETY: The types match as per our constructor invariant.
+                let memo = unsafe { memo.take(type_)? };
+                Some((MemoIngredientIndex::from_usize(index), memo))
+            })
+            .for_each(|(index, memo)| f(index, memo));
+    }
+}
+
+impl MemoEntry {
+    /// # Safety
+    ///
+    /// The type must match.
+    #[inline]
+    unsafe fn take(&mut self, type_: &MemoEntryType) -> Option<Box<dyn Memo>> {
+        let memo = NonNull::new(self.atomic_memo.read_mut());
+        self.atomic_memo.write_mut(ptr::null_mut());
+        let type_ = type_.load()?;
+        // SAFETY: Our preconditions.
+        Some(unsafe { Box::from_raw((type_.to_dyn_fn)(memo?).as_ptr()) })
+    }
+}
+
+impl Drop for DummyMemo {
+    fn drop(&mut self) {
+        unreachable!("should never get here")
+    }
+}
+
+impl std::fmt::Debug for MemoTable {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("MemoTable").finish_non_exhaustive()
+    }
+}
diff --git a/crates/salsa/src/tracked_struct.rs b/crates/salsa/src/tracked_struct.rs
new file mode 100644
index 000000000..cb2959b51
--- /dev/null
+++ b/crates/salsa/src/tracked_struct.rs
@@ -0,0 +1,982 @@
+#![allow(clippy::undocumented_unsafe_blocks)] // TODO(#697) document safety
+
+use std::any::TypeId;
+use std::hash::Hash;
+use std::marker::PhantomData;
+use std::mem::MaybeUninit;
+use std::ops::Index;
+use std::{fmt, mem};
+
+use crossbeam_queue::SegQueue;
+use tracked_field::FieldIngredientImpl;
+
+use crate::cycle::CycleHeads;
+use crate::function::VerifyResult;
+use crate::id::{AsId, FromId};
+use crate::ingredient::{Ingredient, Jar};
+use crate::key::DatabaseKeyIndex;
+use crate::loom::cell::UnsafeCell;
+use crate::loom::sync::Arc;
+use crate::plumbing::ZalsaLocal;
+use crate::revision::OptionalAtomicRevision;
+use crate::runtime::StampedValue;
+use crate::salsa_struct::SalsaStructInDb;
+use crate::table::memo::{MemoTable, MemoTableTypes, MemoTableWithTypesMut};
+use crate::table::{Slot, Table};
+use crate::zalsa::{IngredientIndex, Zalsa};
+use crate::{Database, Durability, Event, EventKind, Id, Revision};
+
+pub mod tracked_field;
+
+// ANCHOR: Configuration
+/// Trait that defines the key properties of a tracked struct.
+/// Implemented by the `#[salsa::tracked]` macro when applied
+/// to a struct.
+pub trait Configuration: Sized + 'static {
+    const LOCATION: crate::ingredient::Location;
+
+    /// The debug name of the tracked struct.
+    const DEBUG_NAME: &'static str;
+
+    /// The debug names of any tracked fields.
+    const TRACKED_FIELD_NAMES: &'static [&'static str];
+
+    /// The relative indices of any tracked fields.
+    const TRACKED_FIELD_INDICES: &'static [usize];
+
+    /// A (possibly empty) tuple of the fields for this struct.
+    type Fields<'db>: Send + Sync;
+
+    /// A array of [`Revision`][] values, one per each of the tracked value fields.
+    /// When a struct is re-recreated in a new revision, the corresponding
+    /// entries for each field are updated to the new revision if their
+    /// values have changed (or if the field is marked as `#[no_eq]`).
+    type Revisions: Send + Sync + Index<usize, Output = Revision>;
+
+    type Struct<'db>: Copy + FromId + AsId;
+
+    fn untracked_fields(fields: &Self::Fields<'_>) -> impl Hash;
+
+    /// Create a new value revision array where each element is set to `current_revision`.
+    fn new_revisions(current_revision: Revision) -> Self::Revisions;
+
+    /// Update the field data and, if the value has changed,
+    /// the appropriate entry in the `revisions` array (tracked fields only).
+    ///
+    /// Returns `true` if any untracked field was updated and
+    /// the struct should be considered re-created.
+    ///
+    /// # Safety
+    ///
+    /// Requires the same conditions as the `maybe_update`
+    /// method on [the `Update` trait](`crate::update::Update`).
+    ///
+    /// In short, requires that `old_fields` be a pointer into
+    /// storage from a previous revision.
+    /// It must meet its validity invariant.
+    /// Owned content must meet safety invariant.
+    /// `*mut` here is not strictly needed;
+    /// it is used to signal that the content
+    /// is not guaranteed to recursively meet
+    /// its safety invariant and
+    /// hence this must be dereferenced with caution.
+    ///
+    /// Ensures that `old_fields` is fully updated and valid
+    /// after it returns and that `revisions` has been updated
+    /// for any field that changed.
+    unsafe fn update_fields<'db>(
+        current_revision: Revision,
+        revisions: &mut Self::Revisions,
+        old_fields: *mut Self::Fields<'db>,
+        new_fields: Self::Fields<'db>,
+    ) -> bool;
+}
+// ANCHOR_END: Configuration
+
+pub struct JarImpl<C>
+where
+    C: Configuration,
+{
+    phantom: PhantomData<C>,
+}
+
+impl<C: Configuration> Default for JarImpl<C> {
+    fn default() -> Self {
+        Self {
+            phantom: Default::default(),
+        }
+    }
+}
+
+impl<C: Configuration> Jar for JarImpl<C> {
+    fn create_ingredients(
+        _zalsa: &Zalsa,
+        struct_index: crate::zalsa::IngredientIndex,
+        _dependencies: crate::memo_ingredient_indices::IngredientIndices,
+    ) -> Vec<Box<dyn Ingredient>> {
+        let struct_ingredient = <IngredientImpl<C>>::new(struct_index);
+
+        let tracked_field_ingredients =
+            C::TRACKED_FIELD_INDICES
+                .iter()
+                .copied()
+                .map(|tracked_index| {
+                    Box::new(<FieldIngredientImpl<C>>::new(
+                        tracked_index,
+                        struct_index.successor(tracked_index),
+                    )) as _
+                });
+
+        std::iter::once(Box::new(struct_ingredient) as _)
+            .chain(tracked_field_ingredients)
+            .collect()
+    }
+
+    fn id_struct_type_id() -> TypeId {
+        TypeId::of::<C::Struct<'static>>()
+    }
+}
+
+pub trait TrackedStructInDb: SalsaStructInDb {
+    /// Converts the identifier for this tracked struct into a `DatabaseKeyIndex`.
+    fn database_key_index(zalsa: &Zalsa, id: Id) -> DatabaseKeyIndex;
+}
+
+/// Created for each tracked struct.
+///
+/// This ingredient only stores the "id" fields. It is a kind of "dressed up" interner;
+/// the active query + values of id fields are hashed to create the tracked
+/// struct id. The value fields are stored in [`crate::function::IngredientImpl`]
+/// instances keyed by the tracked struct id. Unlike normal interners, tracked
+/// struct indices can be deleted and reused aggressively: when a tracked
+/// function re-executes, any tracked structs that it created before but did
+/// not create this time can be deleted.
+pub struct IngredientImpl<C>
+where
+    C: Configuration,
+{
+    /// Our index in the database.
+    ingredient_index: IngredientIndex,
+
+    /// Phantom data: we fetch `Value<C>` out from `Table`
+    phantom: PhantomData<fn() -> Value<C>>,
+
+    /// Store freed ids
+    free_list: SegQueue<Id>,
+
+    memo_table_types: Arc<MemoTableTypes>,
+}
+
+/// Defines the identity of a tracked struct.
+/// This is the key to a hashmap that is (initially)
+/// stored in the [`ActiveQuery`](`crate::active_query::ActiveQuery`)
+/// struct and later moved to the [`Memo`](`crate::function::memo::Memo`).
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Clone)]
+pub(crate) struct Identity {
+    // Conceptually, this contains an `IdentityHash`, but using `IdentityHash` directly will grow the size
+    // of this struct struct by a `std::mem::size_of::<usize>()` due to unusable padding. To avoid this increase
+    // in size, we inline the fields of `IdentityHash`.
+    /// Index of the tracked struct ingredient.
+    ingredient_index: IngredientIndex,
+
+    /// Hash of the id fields.
+    hash: u64,
+
+    /// The unique disambiguator assigned within the active query
+    /// to distinguish distinct tracked structs with the same identity_hash.
+    disambiguator: Disambiguator,
+}
+
+impl Identity {
+    pub(crate) fn ingredient_index(&self) -> IngredientIndex {
+        self.ingredient_index
+    }
+}
+
+/// Stores the data that (almost) uniquely identifies a tracked struct.
+/// This includes the ingredient index of that struct type plus the hash of its untracked fields.
+/// This is mapped to a disambiguator -- a value that starts as 0 but increments each round,
+/// allowing for multiple tracked structs with the same hash and ingredient_index
+/// created within the query to each have a unique id.
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Clone)]
+pub struct IdentityHash {
+    /// Index of the tracked struct ingredient.
+    ingredient_index: IngredientIndex,
+
+    /// Hash of the id fields.
+    hash: u64,
+}
+
+#[derive(Default, Debug)]
+pub(crate) struct IdentityMap {
+    // we use a non-hasher hashmap here as our key contains its own hash (`Identity::hash`)
+    // so we use the raw entry api instead to avoid the overhead of hashing unnecessarily
+    map: hashbrown::HashMap<Identity, Id, ()>,
+}
+
+impl Clone for IdentityMap {
+    fn clone(&self) -> Self {
+        Self {
+            map: self.map.clone(),
+        }
+    }
+    fn clone_from(&mut self, source: &Self) {
+        self.map.clone_from(&source.map);
+    }
+}
+
+impl IdentityMap {
+    pub(crate) fn insert(&mut self, key: Identity, id: Id) -> Option<Id> {
+        use hashbrown::hash_map::RawEntryMut;
+
+        let entry = self.map.raw_entry_mut().from_hash(key.hash, |k| *k == key);
+        match entry {
+            RawEntryMut::Occupied(mut occupied) => Some(occupied.insert(id)),
+            RawEntryMut::Vacant(vacant) => {
+                vacant.insert_with_hasher(key.hash, key, id, |k| k.hash);
+                None
+            }
+        }
+    }
+
+    pub(crate) fn get(&self, key: &Identity) -> Option<Id> {
+        self.map
+            .raw_entry()
+            .from_hash(key.hash, |k| *k == *key)
+            .map(|(_, &v)| v)
+    }
+
+    pub(crate) fn is_empty(&self) -> bool {
+        self.map.is_empty()
+    }
+
+    pub(crate) fn retain(&mut self, f: impl FnMut(&Identity, &mut Id) -> bool) {
+        self.map.retain(f);
+    }
+
+    pub fn clear(&mut self) {
+        self.map.clear()
+    }
+}
+
+// ANCHOR: ValueStruct
+#[derive(Debug)]
+pub struct Value<C>
+where
+    C: Configuration,
+{
+    /// The minimum durability of all inputs consumed by the creator
+    /// query prior to creating this tracked struct. If any of those
+    /// inputs changes, then the creator query may create this struct
+    /// with different values.
+    durability: Durability,
+
+    /// The revision in which the tracked struct was first created.
+    ///
+    /// Unlike `updated_at`, which gets bumped on every read,
+    /// `created_at` is updated whenever an untracked field is updated.
+    /// This is necessary to detect reused tracked struct ids _after_
+    /// they've been freed in a prior revision or tracked structs that have been updated
+    /// in-place because of a bad `Hash` implementation.
+    created_at: Revision,
+
+    /// The revision when this tracked struct was last updated.
+    /// This field also acts as a kind of "lock". Once it is equal
+    /// to `Some(current_revision)`, the fields are locked and
+    /// cannot change further. This makes it safe to give out `&`-references
+    /// so long as they do not live longer than the current revision
+    /// (which is assured by tying their lifetime to the lifetime of an `&`-ref
+    /// to the database).
+    ///
+    /// The struct is updated from an older revision `R0` to the current revision `R1`
+    /// when the struct is first accessed in `R1`, whether that be because the original
+    /// query re-created the struct (i.e., by user calling `Struct::new`) or because
+    /// the struct was read from. (Structs may not be recreated in the new revision if
+    /// the inputs to the query have not changed.)
+    ///
+    /// When re-creating the struct, the field is temporarily set to `None`.
+    /// This is signal that there is an active `&mut` modifying the other fields:
+    /// even reading from those fields in that situation would create UB.
+    /// This `None` value should never be observable by users unless they have
+    /// leaked a reference across threads somehow.
+    updated_at: OptionalAtomicRevision,
+
+    /// Fields of this tracked struct. They can change across revisions,
+    /// but they do not change within a particular revision.
+    fields: C::Fields<'static>,
+
+    /// The revision information for each field: when did this field last change.
+    /// When tracked structs are re-created, this revision may be updated to the
+    /// current revision if the value is different.
+    revisions: C::Revisions,
+
+    /// Memo table storing the results of query functions etc.
+    /*unsafe */
+    memos: MemoTable,
+}
+// ANCHOR_END: ValueStruct
+
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Copy, Clone)]
+pub struct Disambiguator(u32);
+
+#[derive(Default, Debug)]
+pub(crate) struct DisambiguatorMap {
+    // we use a non-hasher hashmap here as our key contains its own hash (in a sense)
+    // so we use the raw entry api instead to avoid the overhead of hashing unnecessarily
+    map: hashbrown::HashMap<IdentityHash, Disambiguator, ()>,
+}
+
+impl DisambiguatorMap {
+    pub(crate) fn disambiguate(&mut self, key: IdentityHash) -> Disambiguator {
+        use hashbrown::hash_map::RawEntryMut;
+
+        let entry = self.map.raw_entry_mut().from_hash(key.hash, |k| *k == key);
+        let disambiguator = match entry {
+            RawEntryMut::Occupied(occupied) => occupied.into_mut(),
+            RawEntryMut::Vacant(vacant) => {
+                vacant
+                    .insert_with_hasher(key.hash, key, Disambiguator(0), |k| k.hash)
+                    .1
+            }
+        };
+        let result = *disambiguator;
+        disambiguator.0 += 1;
+        result
+    }
+
+    pub fn clear(&mut self) {
+        self.map.clear()
+    }
+
+    pub fn is_empty(&self) -> bool {
+        self.map.is_empty()
+    }
+}
+
+impl<C> IngredientImpl<C>
+where
+    C: Configuration,
+{
+    /// Create a tracked struct ingredient. Generated by the `#[tracked]` macro,
+    /// not meant to be called directly by end-users.
+    fn new(index: IngredientIndex) -> Self {
+        Self {
+            ingredient_index: index,
+            phantom: PhantomData,
+            free_list: Default::default(),
+            memo_table_types: Arc::new(MemoTableTypes::default()),
+        }
+    }
+
+    /// Returns the database key index for a tracked struct with the given id.
+    pub fn database_key_index(&self, id: Id) -> DatabaseKeyIndex {
+        DatabaseKeyIndex::new(self.ingredient_index, id)
+    }
+
+    pub fn new_struct<'db>(
+        &'db self,
+        db: &'db dyn Database,
+        fields: C::Fields<'db>,
+    ) -> C::Struct<'db> {
+        let (zalsa, zalsa_local) = db.zalsas();
+
+        let identity_hash = IdentityHash {
+            ingredient_index: self.ingredient_index,
+            hash: crate::hash::hash(&C::untracked_fields(&fields)),
+        };
+
+        let (current_deps, disambiguator) = zalsa_local.disambiguate(identity_hash);
+
+        let identity = Identity {
+            hash: identity_hash.hash,
+            ingredient_index: identity_hash.ingredient_index,
+            disambiguator,
+        };
+
+        let current_revision = zalsa.current_revision();
+        match zalsa_local.tracked_struct_id(&identity) {
+            Some(id) => {
+                let index = self.database_key_index(id);
+                tracing::trace!("Reuse tracked struct {id:?}", id = index);
+                // The struct already exists in the intern map.
+                zalsa_local.add_output(index);
+                self.update(zalsa, current_revision, id, &current_deps, fields);
+                FromId::from_id(id)
+            }
+
+            None => {
+                // This is a new tracked struct, so create an entry in the struct map.
+                let id = self.allocate(zalsa, zalsa_local, current_revision, &current_deps, fields);
+                let key = self.database_key_index(id);
+                tracing::trace!("Allocated new tracked struct {key:?}");
+                zalsa_local.add_output(key);
+                zalsa_local.store_tracked_struct_id(identity, id);
+                FromId::from_id(id)
+            }
+        }
+    }
+
+    fn allocate<'db>(
+        &'db self,
+        zalsa: &'db Zalsa,
+        zalsa_local: &'db ZalsaLocal,
+        current_revision: Revision,
+        current_deps: &StampedValue<()>,
+        fields: C::Fields<'db>,
+    ) -> Id {
+        let value = |_| Value {
+            created_at: current_revision,
+            updated_at: OptionalAtomicRevision::new(Some(current_revision)),
+            durability: current_deps.durability,
+            // lifetime erase for storage
+            fields: unsafe { mem::transmute::<C::Fields<'db>, C::Fields<'static>>(fields) },
+            revisions: C::new_revisions(current_deps.changed_at),
+            memos: Default::default(),
+        };
+
+        if let Some(id) = self.free_list.pop() {
+            Self::data_raw(zalsa.table(), id).with_mut(|data_raw| {
+                let data_raw = data_raw.cast::<Value<C>>();
+
+                assert!(
+                    unsafe { (*data_raw).updated_at.load().is_none() },
+                    "free list entry for `{id:?}` does not have `None` for `updated_at`"
+                );
+
+                // Overwrite the free-list entry. Use `*foo = ` because the entry
+                // has been previously initialized and we want to free the old contents.
+                unsafe {
+                    *data_raw = value(id);
+                }
+
+                id
+            })
+        } else {
+            zalsa_local.allocate::<Value<C>>(zalsa, self.ingredient_index, value)
+        }
+    }
+
+    /// Get mutable access to the data for `id` -- this holds a write lock for the duration
+    /// of the returned value.
+    ///
+    /// # Panics
+    ///
+    /// * If the value is not present in the map.
+    /// * If the value is already updated in this revision.
+    fn update<'db>(
+        &'db self,
+        zalsa: &'db Zalsa,
+        current_revision: Revision,
+        id: Id,
+        current_deps: &StampedValue<()>,
+        fields: C::Fields<'db>,
+    ) {
+        let data_raw = Self::data_raw(zalsa.table(), id);
+
+        // The protocol is:
+        //
+        // * When we begin updating, we store `None` in the `updated_at` field
+        // * When completed, we store `Some(current_revision)` in `updated_at`
+        //
+        // No matter what mischief users get up to, it should be impossible for us to
+        // observe `None` in `updated_at`. The `id` should only be associated with one
+        // query and that query can only be running in one thread at a time.
+        //
+        // We *can* observe `Some(current_revision)` however, which means that this
+        // tracked struct is already updated for this revision in two ways.
+        // In that case we should not modify or touch it because there may be
+        // `&`-references to its contents floating around.
+        //
+        // Observing `Some(current_revision)` can happen in two scenarios: leaks (tsk tsk)
+        // but also the scenario embodied by the test test `test_run_5_then_20` in `specify_tracked_fn_in_rev_1_but_not_2.rs`:
+        //
+        // * Revision 1:
+        //   * Tracked function F creates tracked struct S
+        //   * F reads input I
+        // * Revision 2: I is changed, F is re-executed
+        //
+        // When F is re-executed in rev 2, we first try to validate F's inputs/outputs,
+        // which is the list [output: S, input: I]. As no inputs have changed by the time
+        // we reach S, we mark it as verified. But then input I is seen to have changed,
+        // and so we re-execute F. Note that we *know* that S will have the same value
+        // (barring program bugs).
+        //
+        // Further complicating things: it is possible that F calls F2
+        // and gives it (e.g.) S as one of its arguments. Validating F2 may cause F2 to
+        // re-execute which means that it may indeed have read from S's fields
+        // during the current revision and thus obtained an `&` reference to those fields
+        // that is still live.
+
+        // UNSAFE: Marking as mut requires exclusive access for the duration of
+        // the `mut`. We have now *claimed* this data by swapping in `None`,
+        // any attempt to read concurrently will panic.
+        let locked = data_raw.with(|data| {
+            let data = data.cast::<Value<C>>();
+
+            let last_updated_at = unsafe { (*data).updated_at.load() };
+            assert!(
+                last_updated_at.is_some(),
+                "two concurrent writers to {id:?}, should not be possible"
+            );
+            if last_updated_at == Some(current_revision) {
+                // already read-locked
+                return false;
+            }
+
+            // Acquire the write-lock. This can only fail if there is a parallel thread
+            // reading from this same `id`, which can only happen if the user has leaked it.
+            // Tsk tsk.
+            let swapped_out = unsafe { (*data).updated_at.swap(None) };
+            if swapped_out != last_updated_at {
+                panic!(
+                "failed to acquire write lock, id `{id:?}` must have been leaked across threads"
+            );
+            }
+
+            true
+        });
+
+        if !locked {
+            return;
+        }
+
+        data_raw.with_mut(|data| {
+            // UNSAFE: Marking as mut requires exclusive access for the duration of
+            // the `mut`. We have now *claimed* this data by swapping in `None`,
+            // any attempt to read concurrently will panic.
+            let data = unsafe { (*data).assume_init_mut() };
+
+            // SAFETY: We assert that the pointer to `data.revisions`
+            // is a pointer into the database referencing a value
+            // from a previous revision. As such, it continues to meet
+            // its validity invariant and any owned content also continues
+            // to meet its safety invariant.
+            unsafe {
+                if C::update_fields(
+                    current_deps.changed_at,
+                    &mut data.revisions,
+                    mem::transmute::<*mut C::Fields<'static>, *mut C::Fields<'db>>(
+                        std::ptr::addr_of_mut!(data.fields),
+                    ),
+                    fields,
+                ) {
+                    // Consider this a new tracked-struct (even though it still uses the same id)
+                    // when any non-tracked field got updated.
+                    // This should be rare and only ever happen if there's a hash collision
+                    // which makes Salsa consider two tracked structs to still be the same
+                    // even though the fields are different.
+                    // See `tracked-struct-id-field-bad-hash` for more details.
+                    data.created_at = current_revision;
+                }
+            }
+            if current_deps.durability < data.durability {
+                data.revisions = C::new_revisions(current_deps.changed_at);
+                data.created_at = current_revision;
+            }
+            data.durability = current_deps.durability;
+            let swapped_out = data.updated_at.swap(Some(current_revision));
+            assert!(swapped_out.is_none());
+        })
+    }
+
+    /// Fetch the data for a given id created by this ingredient from the table,
+    /// -giving it the appropriate type.
+    fn data(table: &Table, id: Id) -> &Value<C> {
+        table.get(id)
+    }
+
+    fn data_raw(table: &Table, id: Id) -> &UnsafeCell<MaybeUninit<Value<C>>> {
+        table.get_raw(id)
+    }
+
+    /// Deletes the given entities. This is used after a query `Q` executes and we can compare
+    /// the entities `E_now` that it produced in this revision vs the entities
+    /// `E_prev` it produced in the last revision. Any missing entities `E_prev - E_new` can be
+    /// deleted.
+    ///
+    /// # Warning
+    ///
+    /// Using this method on an entity id that MAY be used in the current revision will lead to
+    /// unspecified results (but not UB). See [`InternedIngredient::delete_index`] for more
+    /// discussion and important considerations.
+    pub(crate) fn delete_entity(&self, zalsa: &Zalsa, id: Id) {
+        zalsa.event(&|| {
+            Event::new(crate::EventKind::DidDiscard {
+                key: self.database_key_index(id),
+            })
+        });
+
+        let current_revision = zalsa.current_revision();
+        let data_raw = Self::data_raw(zalsa.table(), id);
+
+        data_raw.with(|data| {
+            let data = data.cast::<Value<C>>();
+
+            // We want to set `updated_at` to `None`, signalling that other field values
+            // cannot be read. The current value should be `Some(R0)` for some older revision.
+            let updated_at = unsafe { &(*data).updated_at };
+            match updated_at.load() {
+                None => {
+                    panic!("cannot delete write-locked id `{id:?}`; value leaked across threads");
+                }
+                Some(r) if r == current_revision => panic!(
+                    "cannot delete read-locked id `{id:?}`; value leaked across threads or user functions not deterministic"
+                ),
+                Some(r) => {
+                    if updated_at.compare_exchange(Some(r), None).is_err() {
+                        panic!("race occurred when deleting value `{id:?}`")
+                    }
+                }
+            }
+        });
+
+        let mut memo_table = data_raw.with_mut(|data| {
+            // SAFETY: We have acquired the write lock
+            unsafe { (*data).assume_init_mut() }.take_memo_table()
+        });
+
+        // SAFETY: We use the correct types table.
+        let table = unsafe { self.memo_table_types.attach_memos_mut(&mut memo_table) };
+        // `Database::salsa_event` is a user supplied callback which may panic
+        // in that case we need a drop guard to free the memo table
+        struct TableDropGuard<'a>(MemoTableWithTypesMut<'a>);
+        impl Drop for TableDropGuard<'_> {
+            fn drop(&mut self) {
+                // SAFETY: We have verified that no more references to these memos exist and so we are good
+                // to drop them.
+                unsafe { self.0.drop() };
+            }
+        }
+        let mut table_guard = TableDropGuard(table);
+        // SAFETY: We have verified that no more references to these memos exist and so we are good
+        // to drop them.
+        unsafe {
+            table_guard.0.take_memos(|memo_ingredient_index, memo| {
+                let ingredient_index =
+                    zalsa.ingredient_index_for_memo(self.ingredient_index, memo_ingredient_index);
+
+                let executor = DatabaseKeyIndex::new(ingredient_index, id);
+
+                zalsa.event(&|| Event::new(EventKind::DidDiscard { key: executor }));
+
+                for stale_output in memo.origin().outputs() {
+                    stale_output.remove_stale_output(zalsa, executor);
+                }
+            })
+        };
+        mem::forget(table_guard);
+
+        // now that all cleanup has occurred, make available for re-use
+        self.free_list.push(id);
+    }
+
+    /// Return reference to the field data ignoring dependency tracking.
+    /// Used for debugging.
+    pub fn leak_fields<'db>(
+        &'db self,
+        db: &'db dyn Database,
+        s: C::Struct<'db>,
+    ) -> &'db C::Fields<'db> {
+        let id = AsId::as_id(&s);
+        let data = Self::data(db.zalsa().table(), id);
+        data.fields()
+    }
+
+    /// Access to this tracked field.
+    ///
+    /// Note that this function returns the entire tuple of value fields.
+    /// The caller is responsible for selecting the appropriate element.
+    pub fn tracked_field<'db>(
+        &'db self,
+        db: &'db dyn crate::Database,
+        s: C::Struct<'db>,
+        relative_tracked_index: usize,
+    ) -> &'db C::Fields<'db> {
+        let (zalsa, zalsa_local) = db.zalsas();
+        let id = AsId::as_id(&s);
+        let field_ingredient_index = self.ingredient_index.successor(relative_tracked_index);
+        let data = Self::data(zalsa.table(), id);
+
+        data.read_lock(zalsa.current_revision());
+
+        let field_changed_at = data.revisions[relative_tracked_index];
+
+        zalsa_local.report_tracked_read_simple(
+            DatabaseKeyIndex::new(field_ingredient_index, id),
+            data.durability,
+            field_changed_at,
+        );
+
+        data.fields()
+    }
+
+    /// Access to this untracked field.
+    ///
+    /// Note that this function returns the entire tuple of value fields.
+    /// The caller is responsible for selecting the appropriate element.
+    pub fn untracked_field<'db>(
+        &'db self,
+        db: &'db dyn crate::Database,
+        s: C::Struct<'db>,
+    ) -> &'db C::Fields<'db> {
+        let (zalsa, zalsa_local) = db.zalsas();
+        let id = AsId::as_id(&s);
+        let data = Self::data(zalsa.table(), id);
+
+        data.read_lock(zalsa.current_revision());
+
+        // Add a dependency on the tracked struct itself.
+        zalsa_local.report_tracked_read_simple(
+            DatabaseKeyIndex::new(self.ingredient_index, id),
+            data.durability,
+            data.created_at,
+        );
+
+        data.fields()
+    }
+
+    #[cfg(feature = "salsa_unstable")]
+    /// Returns all data corresponding to the tracked struct.
+    pub fn entries<'db>(
+        &'db self,
+        db: &'db dyn crate::Database,
+    ) -> impl Iterator<Item = &'db Value<C>> {
+        db.zalsa().table().slots_of::<Value<C>>()
+    }
+}
+
+impl<C> Ingredient for IngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn location(&self) -> &'static crate::ingredient::Location {
+        &C::LOCATION
+    }
+
+    fn ingredient_index(&self) -> IngredientIndex {
+        self.ingredient_index
+    }
+
+    unsafe fn maybe_changed_after(
+        &self,
+        db: &dyn Database,
+        input: Id,
+        revision: Revision,
+        _cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        let zalsa = db.zalsa();
+        let data = Self::data(zalsa.table(), input);
+
+        VerifyResult::changed_if(data.created_at > revision)
+    }
+
+    fn mark_validated_output(
+        &self,
+        _zalsa: &Zalsa,
+        _executor: DatabaseKeyIndex,
+        _output_key: crate::Id,
+    ) {
+        // we used to update `update_at` field but now we do it lazilly when data is accessed
+        //
+        // FIXME: delete this method
+    }
+
+    fn remove_stale_output(
+        &self,
+        zalsa: &Zalsa,
+        _executor: DatabaseKeyIndex,
+        stale_output_key: crate::Id,
+    ) {
+        // This method is called when, in prior revisions,
+        // `executor` creates a tracked struct `salsa_output_key`,
+        // but it did not in the current revision.
+        // In that case, we can delete `stale_output_key` and any data associated with it.
+        self.delete_entity(zalsa, stale_output_key);
+    }
+
+    fn debug_name(&self) -> &'static str {
+        C::DEBUG_NAME
+    }
+
+    fn memo_table_types(&self) -> Arc<MemoTableTypes> {
+        self.memo_table_types.clone()
+    }
+}
+
+impl<C> std::fmt::Debug for IngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        f.debug_struct(std::any::type_name::<Self>())
+            .field("ingredient_index", &self.ingredient_index)
+            .finish()
+    }
+}
+
+impl<C> Value<C>
+where
+    C: Configuration,
+{
+    /// Fields of this tracked struct.
+    ///
+    /// They can change across revisions, but they do not change within
+    /// a particular revision.
+    #[cfg_attr(not(feature = "salsa_unstable"), doc(hidden))]
+    pub fn fields(&self) -> &C::Fields<'_> {
+        // SAFETY: We are shrinking the lifetime from storage back to the db lifetime.
+        unsafe { mem::transmute::<&C::Fields<'static>, &C::Fields<'_>>(&self.fields) }
+    }
+
+    fn take_memo_table(&mut self) -> MemoTable {
+        // This fn is only called after `updated_at` has been set to `None`;
+        // this ensures that there is no concurrent access
+        // (and that the `&mut self` is accurate...).
+        assert!(self.updated_at.load().is_none());
+
+        mem::take(&mut self.memos)
+    }
+
+    fn read_lock(&self, current_revision: Revision) {
+        loop {
+            match self.updated_at.load() {
+                None => {
+                    panic!("access to field whilst the value is being initialized");
+                }
+                Some(r) => {
+                    if r == current_revision {
+                        return;
+                    }
+
+                    if self
+                        .updated_at
+                        .compare_exchange(Some(r), Some(current_revision))
+                        .is_ok()
+                    {
+                        break;
+                    }
+                }
+            }
+        }
+    }
+}
+
+impl<C> Slot for Value<C>
+where
+    C: Configuration,
+{
+    #[inline(always)]
+    unsafe fn memos(&self, current_revision: Revision) -> &crate::table::memo::MemoTable {
+        // Acquiring the read lock here with the current revision
+        // ensures that there is no danger of a race
+        // when deleting a tracked struct.
+        self.read_lock(current_revision);
+        &self.memos
+    }
+
+    #[inline(always)]
+    fn memos_mut(&mut self) -> &mut crate::table::memo::MemoTable {
+        &mut self.memos
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn disambiguate_map_works() {
+        let mut d = DisambiguatorMap::default();
+        // set up all 4 permutations of differing field values
+        let h1 = IdentityHash {
+            ingredient_index: IngredientIndex::from(0),
+            hash: 0,
+        };
+        let h2 = IdentityHash {
+            ingredient_index: IngredientIndex::from(1),
+            hash: 0,
+        };
+        let h3 = IdentityHash {
+            ingredient_index: IngredientIndex::from(0),
+            hash: 1,
+        };
+        let h4 = IdentityHash {
+            ingredient_index: IngredientIndex::from(1),
+            hash: 1,
+        };
+        assert_eq!(d.disambiguate(h1), Disambiguator(0));
+        assert_eq!(d.disambiguate(h1), Disambiguator(1));
+        assert_eq!(d.disambiguate(h2), Disambiguator(0));
+        assert_eq!(d.disambiguate(h2), Disambiguator(1));
+        assert_eq!(d.disambiguate(h3), Disambiguator(0));
+        assert_eq!(d.disambiguate(h3), Disambiguator(1));
+        assert_eq!(d.disambiguate(h4), Disambiguator(0));
+        assert_eq!(d.disambiguate(h4), Disambiguator(1));
+    }
+
+    #[test]
+    fn identity_map_works() {
+        let mut d = IdentityMap::default();
+        // set up all 8 permutations of differing field values
+        let i1 = Identity {
+            ingredient_index: IngredientIndex::from(0),
+            hash: 0,
+            disambiguator: Disambiguator(0),
+        };
+        let i2 = Identity {
+            ingredient_index: IngredientIndex::from(1),
+            hash: 0,
+            disambiguator: Disambiguator(0),
+        };
+        let i3 = Identity {
+            ingredient_index: IngredientIndex::from(0),
+            hash: 1,
+            disambiguator: Disambiguator(0),
+        };
+        let i4 = Identity {
+            ingredient_index: IngredientIndex::from(1),
+            hash: 1,
+            disambiguator: Disambiguator(0),
+        };
+        let i5 = Identity {
+            ingredient_index: IngredientIndex::from(0),
+            hash: 0,
+            disambiguator: Disambiguator(1),
+        };
+        let i6 = Identity {
+            ingredient_index: IngredientIndex::from(1),
+            hash: 0,
+            disambiguator: Disambiguator(1),
+        };
+        let i7 = Identity {
+            ingredient_index: IngredientIndex::from(0),
+            hash: 1,
+            disambiguator: Disambiguator(1),
+        };
+        let i8 = Identity {
+            ingredient_index: IngredientIndex::from(1),
+            hash: 1,
+            disambiguator: Disambiguator(1),
+        };
+        // SAFETY: We don't use the IDs within salsa internals so this is fine
+        unsafe {
+            assert_eq!(d.insert(i1, Id::from_u32(0)), None);
+            assert_eq!(d.insert(i2, Id::from_u32(1)), None);
+            assert_eq!(d.insert(i3, Id::from_u32(2)), None);
+            assert_eq!(d.insert(i4, Id::from_u32(3)), None);
+            assert_eq!(d.insert(i5, Id::from_u32(4)), None);
+            assert_eq!(d.insert(i6, Id::from_u32(5)), None);
+            assert_eq!(d.insert(i7, Id::from_u32(6)), None);
+            assert_eq!(d.insert(i8, Id::from_u32(7)), None);
+
+            assert_eq!(d.get(&i1), Some(Id::from_u32(0)));
+            assert_eq!(d.get(&i2), Some(Id::from_u32(1)));
+            assert_eq!(d.get(&i3), Some(Id::from_u32(2)));
+            assert_eq!(d.get(&i4), Some(Id::from_u32(3)));
+            assert_eq!(d.get(&i5), Some(Id::from_u32(4)));
+            assert_eq!(d.get(&i6), Some(Id::from_u32(5)));
+            assert_eq!(d.get(&i7), Some(Id::from_u32(6)));
+            assert_eq!(d.get(&i8), Some(Id::from_u32(7)));
+        };
+    }
+}
diff --git a/crates/salsa/src/tracked_struct/tracked_field.rs b/crates/salsa/src/tracked_struct/tracked_field.rs
new file mode 100644
index 000000000..048a02b2f
--- /dev/null
+++ b/crates/salsa/src/tracked_struct/tracked_field.rs
@@ -0,0 +1,100 @@
+use std::marker::PhantomData;
+
+use crate::cycle::CycleHeads;
+use crate::function::VerifyResult;
+use crate::ingredient::Ingredient;
+use crate::loom::sync::Arc;
+use crate::table::memo::MemoTableTypes;
+use crate::tracked_struct::{Configuration, Value};
+use crate::zalsa::IngredientIndex;
+use crate::{Database, Id};
+
+/// Created for each tracked struct.
+///
+/// This ingredient only stores the "id" fields.
+/// It is a kind of "dressed up" interner;
+/// the active query + values of id fields are hashed to create the tracked struct id.
+/// The value fields are stored in [`crate::function::IngredientImpl`] instances keyed by the tracked struct id.
+/// Unlike normal interners, tracked struct indices can be deleted and reused aggressively:
+/// when a tracked function re-executes,
+/// any tracked structs that it created before but did not create this time can be deleted.
+pub struct FieldIngredientImpl<C>
+where
+    C: Configuration,
+{
+    /// Index of this ingredient in the database (used to construct database-ids, etc).
+    ingredient_index: IngredientIndex,
+
+    /// The index of this field on the tracked struct relative to all other tracked fields.
+    field_index: usize,
+    phantom: PhantomData<fn() -> Value<C>>,
+}
+
+impl<C> FieldIngredientImpl<C>
+where
+    C: Configuration,
+{
+    pub(super) fn new(field_index: usize, ingredient_index: IngredientIndex) -> Self {
+        Self {
+            field_index,
+            ingredient_index,
+            phantom: PhantomData,
+        }
+    }
+}
+
+impl<C> Ingredient for FieldIngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn location(&self) -> &'static crate::ingredient::Location {
+        &C::LOCATION
+    }
+
+    fn ingredient_index(&self) -> IngredientIndex {
+        self.ingredient_index
+    }
+
+    unsafe fn maybe_changed_after<'db>(
+        &'db self,
+        db: &'db dyn Database,
+        input: Id,
+        revision: crate::Revision,
+        _cycle_heads: &mut CycleHeads,
+    ) -> VerifyResult {
+        let zalsa = db.zalsa();
+        let data = <super::IngredientImpl<C>>::data(zalsa.table(), input);
+        let field_changed_at = data.revisions[self.field_index];
+        VerifyResult::changed_if(field_changed_at > revision)
+    }
+
+    fn fmt_index(&self, index: crate::Id, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        write!(
+            fmt,
+            "{}.{}({:?})",
+            C::DEBUG_NAME,
+            C::TRACKED_FIELD_NAMES[self.field_index],
+            index
+        )
+    }
+
+    fn debug_name(&self) -> &'static str {
+        C::TRACKED_FIELD_NAMES[self.field_index]
+    }
+
+    fn memo_table_types(&self) -> Arc<MemoTableTypes> {
+        unreachable!("tracked field does not allocate pages")
+    }
+}
+
+impl<C> std::fmt::Debug for FieldIngredientImpl<C>
+where
+    C: Configuration,
+{
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct(std::any::type_name::<Self>())
+            .field("ingredient_index", &self.ingredient_index)
+            .field("field_index", &self.field_index)
+            .finish()
+    }
+}
diff --git a/crates/salsa/src/update.rs b/crates/salsa/src/update.rs
new file mode 100644
index 000000000..50ece8c95
--- /dev/null
+++ b/crates/salsa/src/update.rs
@@ -0,0 +1,553 @@
+#![allow(clippy::undocumented_unsafe_blocks)] // TODO(#697) document safety
+
+use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};
+use std::hash::{BuildHasher, Hash};
+use std::marker::PhantomData;
+use std::path::PathBuf;
+
+#[cfg(feature = "rayon")]
+use rayon::iter::Either;
+
+use crate::loom::sync::Arc;
+use crate::Revision;
+
+/// This is used by the macro generated code.
+/// If possible, uses `Update` trait, but else requires `'static`.
+///
+/// To use:
+///
+/// ```rust,ignore
+/// use crate::update::helper::Fallback;
+/// update::helper::Dispatch::<$ty>::maybe_update(pointer, new_value);
+/// ```
+///
+/// It is important that you specify the `$ty` explicitly.
+///
+/// This uses the ["method dispatch hack"](https://github.com/nvzqz/impls#how-it-works)
+/// to use the `Update` trait if it is available and else fallback to `'static`.
+pub mod helper {
+    use std::marker::PhantomData;
+
+    use super::{update_fallback, Update};
+
+    pub struct Dispatch<D>(PhantomData<D>);
+
+    #[allow(clippy::new_without_default)]
+    impl<D> Dispatch<D> {
+        pub fn new() -> Self {
+            Dispatch(PhantomData)
+        }
+    }
+
+    impl<D> Dispatch<D>
+    where
+        D: Update,
+    {
+        /// # Safety
+        ///
+        /// See the `maybe_update` method in the [`Update`][] trait.
+        pub unsafe fn maybe_update(old_pointer: *mut D, new_value: D) -> bool {
+            // SAFETY: Same safety conditions as `Update::maybe_update`
+            unsafe { D::maybe_update(old_pointer, new_value) }
+        }
+    }
+
+    /// # Safety
+    ///
+    /// Impl will fulfill the postconditions of `maybe_update`
+    pub unsafe trait Fallback<T> {
+        /// # Safety
+        ///
+        /// Same safety conditions as `Update::maybe_update`
+        unsafe fn maybe_update(old_pointer: *mut T, new_value: T) -> bool;
+    }
+
+    // SAFETY: Same safety conditions as `Update::maybe_update`
+    unsafe impl<T: 'static + PartialEq> Fallback<T> for Dispatch<T> {
+        unsafe fn maybe_update(old_pointer: *mut T, new_value: T) -> bool {
+            // SAFETY: Same safety conditions as `Update::maybe_update`
+            unsafe { update_fallback(old_pointer, new_value) }
+        }
+    }
+}
+
+/// "Fallback" for maybe-update that is suitable for fully owned T
+/// that implement `Eq`. In this version, we update only if the new value
+/// is not `Eq` to the old one. Note that given `Eq` impls that are not just
+/// structurally comparing fields, this may cause us not to update even if
+/// the value has changed (presumably because this change is not semantically
+/// significant).
+///
+/// # Safety
+///
+/// See `Update::maybe_update`
+pub unsafe fn update_fallback<T>(old_pointer: *mut T, new_value: T) -> bool
+where
+    T: 'static + PartialEq,
+{
+    // SAFETY: Because everything is owned, this ref is simply a valid `&mut`
+    let old_ref: &mut T = unsafe { &mut *old_pointer };
+
+    if *old_ref != new_value {
+        *old_ref = new_value;
+        true
+    } else {
+        // Subtle but important: Eq impls can be buggy or define equality
+        // in surprising ways. If it says that the value has not changed,
+        // we do not modify the existing value, and thus do not have to
+        // update the revision, as downstream code will not see the new value.
+        false
+    }
+}
+
+/// Helper for generated code. Updates `*old_pointer` with `new_value`
+/// and updates `*old_revision` with `new_revision.` Used for fields
+/// tagged with `#[no_eq]`
+pub fn always_update<T>(
+    old_revision: &mut Revision,
+    new_revision: Revision,
+    old_pointer: &mut T,
+    new_value: T,
+) {
+    *old_revision = new_revision;
+    *old_pointer = new_value;
+}
+
+/// # Safety
+///
+/// Implementing this trait requires the implementor to verify:
+///
+/// * `maybe_update` ensures the properties it is intended to ensure.
+/// * If the value implements `Eq`, it is safe to compare an instance
+///   of the value from an older revision with one from the newer
+///   revision. If the value compares as equal, no update is needed to
+///   bring it into the newer revision.
+///
+/// NB: The second point implies that `Update` cannot be implemented for any
+/// `&'db T` -- (i.e., any Rust reference tied to the database).
+/// Such a value could refer to memory that was freed in some
+/// earlier revision. Even if the memory is still valid, it could also
+/// have been part of a tracked struct whose values were mutated,
+/// thus invalidating the `'db` lifetime (from a stacked borrows perspective).
+/// Either way, the `Eq` implementation would be invalid.
+pub unsafe trait Update {
+    /// # Returns
+    ///
+    /// True if the value should be considered to have changed in the new revision.
+    ///
+    /// # Safety
+    ///
+    /// ## Requires
+    ///
+    /// Informally, requires that `old_value` points to a value in the
+    /// database that is potentially from a previous revision and `new_value`
+    /// points to a value produced in this revision.
+    ///
+    /// More formally, requires that
+    ///
+    /// * all parameters meet the [validity and safety invariants][i] for their type
+    /// * `old_value` further points to allocated memory that meets the [validity invariant][i] for `Self`
+    /// * all data *owned* by `old_value` further meets its safety invariant
+    ///     * not that borrowed data in `old_value` only meets its validity invariant
+    ///       and hence cannot be dereferenced; essentially, a `&T` may point to memory
+    ///       in the database which has been modified or even freed in the newer revision.
+    ///
+    /// [i]: https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html
+    ///
+    /// ## Ensures
+    ///
+    /// That `old_value` is updated with
+    unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool;
+}
+
+unsafe impl Update for std::convert::Infallible {
+    unsafe fn maybe_update(_old_pointer: *mut Self, new_value: Self) -> bool {
+        match new_value {}
+    }
+}
+
+macro_rules! maybe_update_vec {
+    ($old_pointer: expr, $new_vec: expr, $elem_ty: ty) => {{
+        let old_pointer = $old_pointer;
+        let new_vec = $new_vec;
+
+        let old_vec: &mut Self = unsafe { &mut *old_pointer };
+
+        if old_vec.len() != new_vec.len() {
+            old_vec.clear();
+            old_vec.extend(new_vec);
+            return true;
+        }
+
+        let mut changed = false;
+        for (old_element, new_element) in old_vec.iter_mut().zip(new_vec) {
+            changed |= unsafe { <$elem_ty>::maybe_update(old_element, new_element) };
+        }
+
+        changed
+    }};
+}
+
+unsafe impl<T> Update for Vec<T>
+where
+    T: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_vec: Self) -> bool {
+        maybe_update_vec!(old_pointer, new_vec, T)
+    }
+}
+
+unsafe impl<T> Update for thin_vec::ThinVec<T>
+where
+    T: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_vec: Self) -> bool {
+        maybe_update_vec!(old_pointer, new_vec, T)
+    }
+}
+
+unsafe impl<A> Update for smallvec::SmallVec<A>
+where
+    A: smallvec::Array,
+    A::Item: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_vec: Self) -> bool {
+        maybe_update_vec!(old_pointer, new_vec, A::Item)
+    }
+}
+
+macro_rules! maybe_update_set {
+    ($old_pointer: expr, $new_set: expr) => {{
+        let old_pointer = $old_pointer;
+        let new_set = $new_set;
+
+        let old_set: &mut Self = unsafe { &mut *old_pointer };
+
+        if *old_set == new_set {
+            false
+        } else {
+            old_set.clear();
+            old_set.extend(new_set);
+            return true;
+        }
+    }};
+}
+
+unsafe impl<K, S> Update for HashSet<K, S>
+where
+    K: Update + Eq + Hash,
+    S: BuildHasher,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_set: Self) -> bool {
+        maybe_update_set!(old_pointer, new_set)
+    }
+}
+
+unsafe impl<K> Update for BTreeSet<K>
+where
+    K: Update + Eq + Ord,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_set: Self) -> bool {
+        maybe_update_set!(old_pointer, new_set)
+    }
+}
+
+// Duck typing FTW, it was too annoying to make a proper function out of this.
+macro_rules! maybe_update_map {
+    ($old_pointer: expr, $new_map: expr) => {
+        'function: {
+            let old_pointer = $old_pointer;
+            let new_map = $new_map;
+            let old_map: &mut Self = unsafe { &mut *old_pointer };
+
+            // To be considered "equal", the set of keys
+            // must be the same between the two maps.
+            let same_keys =
+                old_map.len() == new_map.len() && old_map.keys().all(|k| new_map.contains_key(k));
+
+            // If the set of keys has changed, then just pull in the new values
+            // from new_map and discard the old ones.
+            if !same_keys {
+                old_map.clear();
+                old_map.extend(new_map);
+                break 'function true;
+            }
+
+            // Otherwise, recursively descend to the values.
+            // We do not invoke `K::update` because we assume
+            // that if the values are `Eq` they must not need
+            // updating (see the trait criteria).
+            let mut changed = false;
+            for (key, new_value) in new_map.into_iter() {
+                let old_value = old_map.get_mut(&key).unwrap();
+                changed |= unsafe { V::maybe_update(old_value, new_value) };
+            }
+            changed
+        }
+    };
+}
+
+unsafe impl<K, V, S> Update for HashMap<K, V, S>
+where
+    K: Update + Eq + Hash,
+    V: Update,
+    S: BuildHasher,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_map: Self) -> bool {
+        maybe_update_map!(old_pointer, new_map)
+    }
+}
+
+unsafe impl<K, V, S> Update for hashbrown::HashMap<K, V, S>
+where
+    K: Update + Eq + Hash,
+    V: Update,
+    S: BuildHasher,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_map: Self) -> bool {
+        maybe_update_map!(old_pointer, new_map)
+    }
+}
+
+unsafe impl<K, S> Update for hashbrown::HashSet<K, S>
+where
+    K: Update + Eq + Hash,
+    S: BuildHasher,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_set: Self) -> bool {
+        maybe_update_set!(old_pointer, new_set)
+    }
+}
+
+unsafe impl<K, V, S> Update for indexmap::IndexMap<K, V, S>
+where
+    K: Update + Eq + Hash,
+    V: Update,
+    S: BuildHasher,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_map: Self) -> bool {
+        maybe_update_map!(old_pointer, new_map)
+    }
+}
+
+unsafe impl<K, S> Update for indexmap::IndexSet<K, S>
+where
+    K: Update + Eq + Hash,
+    S: BuildHasher,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_set: Self) -> bool {
+        maybe_update_set!(old_pointer, new_set)
+    }
+}
+
+unsafe impl<K, V> Update for BTreeMap<K, V>
+where
+    K: Update + Eq + Ord,
+    V: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_map: Self) -> bool {
+        maybe_update_map!(old_pointer, new_map)
+    }
+}
+
+unsafe impl<T> Update for Box<T>
+where
+    T: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_box: Self) -> bool {
+        let old_box: &mut Box<T> = unsafe { &mut *old_pointer };
+
+        unsafe { T::maybe_update(&mut **old_box, *new_box) }
+    }
+}
+
+unsafe impl<T> Update for Box<[T]>
+where
+    T: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_box: Self) -> bool {
+        let old_box: &mut Box<[T]> = unsafe { &mut *old_pointer };
+
+        if old_box.len() == new_box.len() {
+            let mut changed = false;
+            for (old_element, new_element) in old_box.iter_mut().zip(new_box) {
+                changed |= unsafe { T::maybe_update(old_element, new_element) };
+            }
+            changed
+        } else {
+            *old_box = new_box;
+            true
+        }
+    }
+}
+
+unsafe impl<T> Update for Arc<T>
+where
+    T: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_arc: Self) -> bool {
+        let old_arc: &mut Arc<T> = unsafe { &mut *old_pointer };
+
+        if Arc::ptr_eq(old_arc, &new_arc) {
+            return false;
+        }
+
+        if let Some(inner) = Arc::get_mut(old_arc) {
+            match Arc::try_unwrap(new_arc) {
+                Ok(new_inner) => unsafe { T::maybe_update(inner, new_inner) },
+                Err(new_arc) => {
+                    // We can't unwrap the new arc, so we have to update the old one in place.
+                    *old_arc = new_arc;
+                    true
+                }
+            }
+        } else {
+            unsafe { *old_pointer = new_arc };
+            true
+        }
+    }
+}
+
+unsafe impl<T, const N: usize> Update for [T; N]
+where
+    T: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_vec: Self) -> bool {
+        let old_pointer: *mut T = unsafe { std::ptr::addr_of_mut!((*old_pointer)[0]) };
+        let mut changed = false;
+        for (new_element, i) in new_vec.into_iter().zip(0..) {
+            changed |= unsafe { T::maybe_update(old_pointer.add(i), new_element) };
+        }
+        changed
+    }
+}
+
+unsafe impl<T, E> Update for Result<T, E>
+where
+    T: Update,
+    E: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool {
+        let old_value = unsafe { &mut *old_pointer };
+        match (old_value, new_value) {
+            (Ok(old), Ok(new)) => unsafe { T::maybe_update(old, new) },
+            (Err(old), Err(new)) => unsafe { E::maybe_update(old, new) },
+            (old_value, new_value) => {
+                *old_value = new_value;
+                true
+            }
+        }
+    }
+}
+
+#[cfg(feature = "rayon")]
+unsafe impl<L, R> Update for Either<L, R>
+where
+    L: Update,
+    R: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool {
+        let old_value = unsafe { &mut *old_pointer };
+        match (old_value, new_value) {
+            (Either::Left(old), Either::Left(new)) => unsafe { L::maybe_update(old, new) },
+            (Either::Right(old), Either::Right(new)) => unsafe { R::maybe_update(old, new) },
+            (old_value, new_value) => {
+                *old_value = new_value;
+                true
+            }
+        }
+    }
+}
+
+macro_rules! fallback_impl {
+    ($($t:ty,)*) => {
+        $(
+            unsafe impl Update for $t {
+                unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool {
+                    unsafe { update_fallback(old_pointer, new_value) }
+                }
+            }
+        )*
+    }
+}
+
+fallback_impl! {
+    String,
+    i64,
+    u64,
+    i32,
+    u32,
+    i16,
+    u16,
+    i8,
+    u8,
+    bool,
+    f32,
+    f64,
+    usize,
+    isize,
+    PathBuf,
+}
+
+#[cfg(feature = "compact_str")]
+fallback_impl! { compact_str::CompactString, }
+
+macro_rules! tuple_impl {
+    ($($t:ident),*; $($u:ident),*) => {
+        unsafe impl<$($t),*> Update for ($($t,)*)
+        where
+            $($t: Update,)*
+        {
+            #[allow(non_snake_case)]
+            unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool {
+                let ($($t,)*) = new_value;
+                let ($($u,)*) = unsafe { &mut *old_pointer };
+
+                #[allow(unused_mut)]
+                let mut changed = false;
+                $(
+                    unsafe { changed |= Update::maybe_update($u, $t); }
+                )*
+                changed
+            }
+        }
+    }
+}
+
+// Create implementations for tuples up to arity 12
+tuple_impl!(;);
+tuple_impl!(A; a);
+tuple_impl!(A, B; a, b);
+tuple_impl!(A, B, C; a, b, c);
+tuple_impl!(A, B, C, D; a, b, c, d);
+tuple_impl!(A, B, C, D, E; a, b, c, d, e);
+tuple_impl!(A, B, C, D, E, F; a, b, c, d, e, f);
+tuple_impl!(A, B, C, D, E, F, G; a, b, c, d, e, f, g);
+tuple_impl!(A, B, C, D, E, F, G, H; a, b, c, d, e, f, g, h);
+tuple_impl!(A, B, C, D, E, F, G, H, I; a, b, c, d, e, f, g, h, i);
+tuple_impl!(A, B, C, D, E, F, G, H, I, J; a, b, c, d, e, f, g, h, i, j);
+tuple_impl!(A, B, C, D, E, F, G, H, I, J, K; a, b, c, d, e, f, g, h, i, j, k);
+tuple_impl!(A, B, C, D, E, F, G, H, I, J, K, L; a, b, c, d, e, f, g, h, i, j, k, l);
+
+unsafe impl<T> Update for Option<T>
+where
+    T: Update,
+{
+    unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool {
+        let old_value = unsafe { &mut *old_pointer };
+        match (old_value, new_value) {
+            (Some(old), Some(new)) => unsafe { T::maybe_update(old, new) },
+            (None, None) => false,
+            (old_value, new_value) => {
+                *old_value = new_value;
+                true
+            }
+        }
+    }
+}
+
+unsafe impl<T> Update for PhantomData<T> {
+    unsafe fn maybe_update(_old_pointer: *mut Self, _new_value: Self) -> bool {
+        false
+    }
+}
diff --git a/crates/salsa/src/views.rs b/crates/salsa/src/views.rs
new file mode 100644
index 000000000..a14852898
--- /dev/null
+++ b/crates/salsa/src/views.rs
@@ -0,0 +1,135 @@
+use std::any::{Any, TypeId};
+
+use crate::Database;
+
+/// A `Views` struct is associated with some specific database type
+/// (a `DatabaseImpl<U>` for some existential `U`). It contains functions
+/// to downcast from `dyn Database` to `dyn DbView` for various traits `DbView` via this specific
+/// database type.
+/// None of these types are known at compilation time, they are all checked
+/// dynamically through `TypeId` magic.
+pub struct Views {
+    source_type_id: TypeId,
+    view_casters: boxcar::Vec<ViewCaster>,
+}
+
+struct ViewCaster {
+    /// The id of the target type `dyn DbView` that we can cast to.
+    target_type_id: TypeId,
+
+    /// The name of the target type `dyn DbView` that we can cast to.
+    type_name: &'static str,
+
+    /// Type-erased function pointer that downcasts from `dyn Database` to `dyn DbView`.
+    cast: ErasedDatabaseDownCasterSig,
+}
+
+impl ViewCaster {
+    fn new<DbView: ?Sized + Any>(func: unsafe fn(&dyn Database) -> &DbView) -> ViewCaster {
+        ViewCaster {
+            target_type_id: TypeId::of::<DbView>(),
+            type_name: std::any::type_name::<DbView>(),
+            // SAFETY: We are type erasing for storage, taking care of unerasing before we call
+            // the function pointer.
+            cast: unsafe {
+                std::mem::transmute::<DatabaseDownCasterSig<DbView>, ErasedDatabaseDownCasterSig>(
+                    func,
+                )
+            },
+        }
+    }
+}
+
+type ErasedDatabaseDownCasterSig = unsafe fn(&dyn Database) -> *const ();
+type DatabaseDownCasterSig<DbView> = unsafe fn(&dyn Database) -> &DbView;
+
+pub struct DatabaseDownCaster<DbView: ?Sized>(TypeId, DatabaseDownCasterSig<DbView>);
+
+impl<DbView: ?Sized + Any> DatabaseDownCaster<DbView> {
+    pub fn downcast<'db>(&self, db: &'db dyn Database) -> &'db DbView {
+        assert_eq!(
+            self.0,
+            db.type_id(),
+            "Database type does not match the expected type for this `Views` instance"
+        );
+        // SAFETY: We've asserted that the database is correct.
+        unsafe { (self.1)(db) }
+    }
+
+    /// Downcast `db` to `DbView`.
+    ///
+    /// # Safety
+    ///
+    /// The caller must ensure that `db` is of the correct type.
+    pub unsafe fn downcast_unchecked<'db>(&self, db: &'db dyn Database) -> &'db DbView {
+        // SAFETY: The caller must ensure that `db` is of the correct type.
+        unsafe { (self.1)(db) }
+    }
+}
+
+impl Views {
+    pub(crate) fn new<Db: Database>() -> Self {
+        let source_type_id = TypeId::of::<Db>();
+        let view_casters = boxcar::Vec::new();
+        // special case the no-op transformation, that way we skip out on reconstructing the wide pointer
+        view_casters.push(ViewCaster::new::<dyn Database>(|db| db));
+        Self {
+            source_type_id,
+            view_casters,
+        }
+    }
+
+    /// Add a new downcaster from `dyn Database` to `dyn DbView`.
+    pub fn add<DbView: ?Sized + Any>(&self, func: DatabaseDownCasterSig<DbView>) {
+        let target_type_id = TypeId::of::<DbView>();
+        if self
+            .view_casters
+            .iter()
+            .any(|(_, u)| u.target_type_id == target_type_id)
+        {
+            return;
+        }
+        self.view_casters.push(ViewCaster::new::<DbView>(func));
+    }
+
+    /// Retrieve an downcaster function from `dyn Database` to `dyn DbView`.
+    ///
+    /// # Panics
+    ///
+    /// If the underlying type of `db` is not the same as the database type this upcasts was created for.
+    pub fn downcaster_for<DbView: ?Sized + Any>(&self) -> DatabaseDownCaster<DbView> {
+        let view_type_id = TypeId::of::<DbView>();
+        for (_idx, view) in self.view_casters.iter() {
+            if view.target_type_id == view_type_id {
+                // SAFETY: We are unerasing the type erased function pointer having made sure the
+                // TypeId matches.
+                return DatabaseDownCaster(self.source_type_id, unsafe {
+                    std::mem::transmute::<ErasedDatabaseDownCasterSig, DatabaseDownCasterSig<DbView>>(
+                        view.cast,
+                    )
+                });
+            }
+        }
+
+        panic!(
+            "No downcaster registered for type `{}` in `Views`",
+            std::any::type_name::<DbView>(),
+        );
+    }
+}
+
+impl std::fmt::Debug for Views {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_struct("Views")
+            .field("view_casters", &self.view_casters)
+            .finish()
+    }
+}
+
+impl std::fmt::Debug for ViewCaster {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_tuple("DynViewCaster")
+            .field(&self.type_name)
+            .finish()
+    }
+}
diff --git a/crates/salsa/src/zalsa.rs b/crates/salsa/src/zalsa.rs
new file mode 100644
index 000000000..78b2fc44b
--- /dev/null
+++ b/crates/salsa/src/zalsa.rs
@@ -0,0 +1,532 @@
+use std::any::{Any, TypeId};
+use std::collections::hash_map;
+use std::marker::PhantomData;
+use std::mem;
+use std::num::NonZeroU32;
+use std::panic::RefUnwindSafe;
+
+use rustc_hash::FxHashMap;
+
+use crate::ingredient::{Ingredient, Jar};
+use crate::loom::sync::atomic::{AtomicU64, Ordering};
+use crate::loom::sync::{Mutex, RwLock};
+use crate::nonce::{Nonce, NonceGenerator};
+use crate::runtime::Runtime;
+use crate::table::memo::MemoTableWithTypes;
+use crate::table::Table;
+use crate::views::Views;
+use crate::zalsa_local::ZalsaLocal;
+use crate::{Database, Durability, Id, Revision};
+
+/// Internal plumbing trait.
+///
+/// [`ZalsaDatabase`] is created automatically when [`#[salsa::db]`](`crate::db`)
+/// is attached to a database struct. it Contains methods that give access
+/// to the internal data from the `storage` field.
+///
+/// # Safety
+///
+/// The system assumes this is implemented by a salsa procedural macro
+/// which makes use of private data from the [`Storage`](`crate::storage::Storage`) struct.
+/// Do not implement this yourself, instead, apply the [`#[salsa::db]`](`crate::db`) macro
+/// to your database.
+pub unsafe trait ZalsaDatabase: Any {
+    /// Plumbing method: access both zalsa and zalsa-local at once.
+    /// More efficient if you need both as it does only a single vtable dispatch.
+    #[doc(hidden)]
+    fn zalsas(&self) -> (&Zalsa, &ZalsaLocal) {
+        (self.zalsa(), self.zalsa_local())
+    }
+
+    /// Plumbing method: Access the internal salsa methods.
+    #[doc(hidden)]
+    fn zalsa(&self) -> &Zalsa;
+
+    /// Plumbing method: Access the internal salsa methods for mutating the database.
+    ///
+    /// **WARNING:** Triggers cancellation to other database handles.
+    /// This can lead to deadlock!
+    #[doc(hidden)]
+    fn zalsa_mut(&mut self) -> &mut Zalsa;
+
+    /// Access the thread-local state associated with this database
+    #[doc(hidden)]
+    fn zalsa_local(&self) -> &ZalsaLocal;
+
+    /// Clone the database.
+    #[doc(hidden)]
+    fn fork_db(&self) -> Box<dyn Database>;
+}
+
+pub fn views<Db: ?Sized + Database>(db: &Db) -> &Views {
+    db.zalsa().views()
+}
+
+/// Nonce type representing the underlying database storage.
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
+pub struct StorageNonce;
+
+// Generator for storage nonces.
+crate::loom::maybe_lazy_static! {
+    static NONCE: NonceGenerator<StorageNonce> = NonceGenerator::new();
+}
+
+/// An ingredient index identifies a particular [`Ingredient`] in the database.
+///
+/// The database contains a number of jars, and each jar contains a number of ingredients.
+/// Each ingredient is given a unique index as the database is being created.
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
+pub struct IngredientIndex(u32);
+
+impl IngredientIndex {
+    /// Create an ingredient index from a usize.
+    pub(crate) fn from(v: usize) -> Self {
+        assert!(v <= u32::MAX as usize);
+        Self(v as u32)
+    }
+
+    /// Convert the ingredient index back into a usize.
+    pub(crate) fn as_usize(self) -> usize {
+        self.0 as usize
+    }
+
+    pub fn successor(self, index: usize) -> Self {
+        IngredientIndex(self.0 + 1 + index as u32)
+    }
+}
+
+/// A special secondary index *just* for ingredients that attach
+/// "memos" to salsa structs (currently: just tracked functions).
+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
+pub struct MemoIngredientIndex(u32);
+
+impl MemoIngredientIndex {
+    pub(crate) fn from_usize(u: usize) -> Self {
+        assert!(u <= u32::MAX as usize);
+        MemoIngredientIndex(u as u32)
+    }
+
+    #[inline]
+    pub(crate) fn as_usize(self) -> usize {
+        self.0 as usize
+    }
+}
+
+/// The "plumbing interface" to the Salsa database. Stores all the ingredients and other data.
+///
+/// **NOT SEMVER STABLE.**
+pub struct Zalsa {
+    views_of: Views,
+
+    nonce: Nonce<StorageNonce>,
+
+    /// Map from the [`IngredientIndex::as_usize`][] of a salsa struct to a list of
+    /// [ingredient-indices](`IngredientIndex`) for tracked functions that have this salsa struct
+    /// as input.
+    memo_ingredient_indices: RwLock<Vec<Vec<IngredientIndex>>>,
+
+    /// Map from the type-id of an `impl Jar` to the index of its first ingredient.
+    /// This is using a `Mutex<FxHashMap>` (versus, say, a `FxDashMap`)
+    /// so that we can protect `ingredients_vec` as well and predict what the
+    /// first ingredient index will be. This allows ingredients to store their own indices.
+    /// This may be worth refactoring in the future because it naturally adds more overhead to
+    /// adding new kinds of ingredients.
+    jar_map: Mutex<FxHashMap<TypeId, IngredientIndex>>,
+
+    /// A map from the `IngredientIndex` to the `TypeId` of its ID struct.
+    ///
+    /// Notably this is not the reverse mapping of `jar_map`.
+    ingredient_to_id_struct_type_id_map: RwLock<FxHashMap<IngredientIndex, TypeId>>,
+
+    /// Vector of ingredients.
+    ///
+    /// Immutable unless the mutex on `ingredients_map` is held.
+    ingredients_vec: boxcar::Vec<Box<dyn Ingredient>>,
+
+    /// Indices of ingredients that require reset when a new revision starts.
+    ingredients_requiring_reset: boxcar::Vec<IngredientIndex>,
+
+    /// The runtime for this particular salsa database handle.
+    /// Each handle gets its own runtime, but the runtimes have shared state between them.
+    runtime: Runtime,
+
+    event_callback: Option<Box<dyn Fn(crate::Event) + Send + Sync>>,
+}
+
+/// All fields on Zalsa are locked behind [`Mutex`]es and [`RwLock`]s and cannot enter
+/// inconsistent states. The contents of said fields are largely ID mappings, with the exception
+/// of [`Runtime::dependency_graph`]. However, [`Runtime::dependency_graph`] does not
+/// invoke any queries and as such there will be no panic from code downstream of Salsa. It can only
+/// panic if an assertion inside of Salsa fails.
+impl RefUnwindSafe for Zalsa {}
+
+impl Zalsa {
+    pub(crate) fn new<Db: Database>(
+        event_callback: Option<Box<dyn Fn(crate::Event) + Send + Sync + 'static>>,
+    ) -> Self {
+        Self {
+            views_of: Views::new::<Db>(),
+            nonce: NONCE.nonce(),
+            jar_map: Default::default(),
+            ingredient_to_id_struct_type_id_map: Default::default(),
+            ingredients_vec: boxcar::Vec::new(),
+            ingredients_requiring_reset: boxcar::Vec::new(),
+            runtime: Runtime::default(),
+            memo_ingredient_indices: Default::default(),
+            event_callback,
+        }
+    }
+
+    pub(crate) fn nonce(&self) -> Nonce<StorageNonce> {
+        self.nonce
+    }
+
+    pub(crate) fn runtime(&self) -> &Runtime {
+        &self.runtime
+    }
+
+    pub(crate) fn runtime_mut(&mut self) -> &mut Runtime {
+        &mut self.runtime
+    }
+
+    /// Returns the [`Table`] used to store the value of salsa structs
+    #[inline]
+    pub(crate) fn table(&self) -> &Table {
+        self.runtime.table()
+    }
+
+    /// Returns the [`MemoTable`][] for the salsa struct with the given id
+    pub(crate) fn memo_table_for(&self, id: Id) -> MemoTableWithTypes<'_> {
+        let table = self.table();
+        // SAFETY: We are supplying the correct current revision
+        unsafe { table.memos(id, self.current_revision()) }
+    }
+
+    #[inline]
+    pub(crate) fn lookup_ingredient(&self, index: IngredientIndex) -> &dyn Ingredient {
+        let index = index.as_usize();
+        self.ingredients_vec
+            .get(index)
+            .unwrap_or_else(|| panic!("index `{index}` is uninitialized"))
+            .as_ref()
+    }
+
+    pub(crate) fn ingredient_index_for_memo(
+        &self,
+        struct_ingredient_index: IngredientIndex,
+        memo_ingredient_index: MemoIngredientIndex,
+    ) -> IngredientIndex {
+        self.memo_ingredient_indices.read()[struct_ingredient_index.as_usize()]
+            [memo_ingredient_index.as_usize()]
+    }
+
+    /// Starts unwinding the stack if the current revision is cancelled.
+    ///
+    /// This method can be called by query implementations that perform
+    /// potentially expensive computations, in order to speed up propagation of
+    /// cancellation.
+    ///
+    /// Cancellation will automatically be triggered by salsa on any query
+    /// invocation.
+    #[inline]
+    pub(crate) fn unwind_if_revision_cancelled(&self, zalsa_local: &ZalsaLocal) {
+        self.event(&|| crate::Event::new(crate::EventKind::WillCheckCancellation));
+        if self.runtime().load_cancellation_flag() {
+            zalsa_local.unwind_cancelled(self.current_revision());
+        }
+    }
+
+    pub(crate) fn next_memo_ingredient_index(
+        &self,
+        struct_ingredient_index: IngredientIndex,
+        ingredient_index: IngredientIndex,
+    ) -> MemoIngredientIndex {
+        let mut memo_ingredients = self.memo_ingredient_indices.write();
+        let idx = struct_ingredient_index.as_usize();
+        let memo_ingredients = if let Some(memo_ingredients) = memo_ingredients.get_mut(idx) {
+            memo_ingredients
+        } else {
+            memo_ingredients.resize_with(idx + 1, Vec::new);
+            memo_ingredients.get_mut(idx).unwrap()
+        };
+        let mi = MemoIngredientIndex::from_usize(memo_ingredients.len());
+        memo_ingredients.push(ingredient_index);
+
+        mi
+    }
+}
+
+/// Semver unstable APIs used by the macro expansions
+impl Zalsa {
+    /// **NOT SEMVER STABLE**
+    pub fn views(&self) -> &Views {
+        &self.views_of
+    }
+
+    /// **NOT SEMVER STABLE**
+    #[inline]
+    pub fn lookup_page_type_id(&self, id: Id) -> TypeId {
+        let ingredient_index = self.ingredient_index(id);
+        *self
+            .ingredient_to_id_struct_type_id_map
+            .read()
+            .get(&ingredient_index)
+            .expect("should have the ingredient index available")
+    }
+
+    /// **NOT SEMVER STABLE**
+    #[doc(hidden)]
+    #[inline]
+    pub fn add_or_lookup_jar_by_type<J: Jar>(&self) -> IngredientIndex {
+        let jar_type_id = TypeId::of::<J>();
+        if let Some(index) = self.jar_map.lock().get(&jar_type_id) {
+            return *index;
+        };
+        self.add_or_lookup_jar_by_type_slow::<J>(jar_type_id)
+    }
+
+    #[inline(never)]
+    fn add_or_lookup_jar_by_type_slow<J: Jar>(&self, jar_type_id: TypeId) -> IngredientIndex {
+        let dependencies = J::create_dependencies(self);
+        let mut jar_map = self.jar_map.lock();
+        let index = IngredientIndex::from(self.ingredients_vec.count());
+        match jar_map.entry(jar_type_id) {
+            hash_map::Entry::Occupied(entry) => {
+                // Someone made it earlier than us.
+                return *entry.get();
+            }
+            hash_map::Entry::Vacant(entry) => entry.insert(index),
+        };
+        let ingredients = J::create_ingredients(self, index, dependencies);
+        for ingredient in ingredients {
+            let expected_index = ingredient.ingredient_index();
+
+            if ingredient.requires_reset_for_new_revision() {
+                self.ingredients_requiring_reset.push(expected_index);
+            }
+
+            let actual_index = self.ingredients_vec.push(ingredient);
+            assert_eq!(
+                expected_index.as_usize(),
+                actual_index,
+                "ingredient `{:?}` was predicted to have index `{:?}` but actually has index `{:?}`",
+                self.ingredients_vec[actual_index],
+                expected_index,
+                actual_index,
+            );
+        }
+
+        drop(jar_map);
+        self.ingredient_to_id_struct_type_id_map
+            .write()
+            .insert(index, J::id_struct_type_id());
+
+        index
+    }
+
+    /// **NOT SEMVER STABLE**
+    #[doc(hidden)]
+    pub fn lookup_ingredient_mut(
+        &mut self,
+        index: IngredientIndex,
+    ) -> (&mut dyn Ingredient, &mut Runtime) {
+        let index = index.as_usize();
+        let ingredient = self
+            .ingredients_vec
+            .get_mut(index)
+            .unwrap_or_else(|| panic!("index `{index}` is uninitialized"));
+        (ingredient.as_mut(), &mut self.runtime)
+    }
+
+    /// **NOT SEMVER STABLE**
+    #[doc(hidden)]
+    #[inline]
+    pub fn current_revision(&self) -> Revision {
+        self.runtime.current_revision()
+    }
+
+    /// **NOT SEMVER STABLE**
+    #[doc(hidden)]
+    #[inline]
+    pub fn last_changed_revision(&self, durability: Durability) -> Revision {
+        self.runtime.last_changed_revision(durability)
+    }
+
+    /// **NOT SEMVER STABLE**
+    /// Triggers a new revision.
+    #[doc(hidden)]
+    pub fn new_revision(&mut self) -> Revision {
+        let new_revision = self.runtime.new_revision();
+
+        for (_, index) in self.ingredients_requiring_reset.iter() {
+            let index = index.as_usize();
+            let ingredient = self
+                .ingredients_vec
+                .get_mut(index)
+                .unwrap_or_else(|| panic!("index `{index}` is uninitialized"));
+
+            ingredient.reset_for_new_revision(self.runtime.table_mut());
+        }
+
+        new_revision
+    }
+
+    /// **NOT SEMVER STABLE**
+    #[doc(hidden)]
+    pub fn evict_lru(&mut self) {
+        for (_, index) in self.ingredients_requiring_reset.iter() {
+            let index = index.as_usize();
+            self.ingredients_vec
+                .get_mut(index)
+                .unwrap_or_else(|| panic!("index `{index}` is uninitialized"))
+                .reset_for_new_revision(self.runtime.table_mut());
+        }
+    }
+
+    #[inline]
+    pub fn ingredient_index(&self, id: Id) -> IngredientIndex {
+        self.table().ingredient_index(id)
+    }
+
+    #[inline(always)]
+    pub fn event(&self, event: &dyn Fn() -> crate::Event) {
+        if let Some(event_callback) = &self.event_callback {
+            event_callback(event());
+        }
+    }
+}
+
+/// Caches a pointer to an ingredient in a database.
+/// Optimized for the case of a single database.
+pub struct IngredientCache<I>
+where
+    I: Ingredient,
+{
+    // A packed representation of `Option<(Nonce<StorageNonce>, IngredientIndex)>`.
+    //
+    // This allows us to replace a lock in favor of an atomic load. This works thanks to `Nonce`
+    // having a niche, which means the entire type can fit into an `AtomicU64`.
+    cached_data: AtomicU64,
+    phantom: PhantomData<fn() -> I>,
+}
+
+impl<I> Default for IngredientCache<I>
+where
+    I: Ingredient,
+{
+    fn default() -> Self {
+        Self::new()
+    }
+}
+
+impl<I> IngredientCache<I>
+where
+    I: Ingredient,
+{
+    const UNINITIALIZED: u64 = 0;
+
+    /// Create a new cache
+    #[cfg(not(loom))]
+    pub const fn new() -> Self {
+        Self {
+            cached_data: AtomicU64::new(Self::UNINITIALIZED),
+            phantom: PhantomData,
+        }
+    }
+
+    #[cfg(loom)]
+    pub fn new() -> Self {
+        Self {
+            cached_data: AtomicU64::new(Self::UNINITIALIZED),
+            phantom: PhantomData,
+        }
+    }
+
+    /// Get a reference to the ingredient in the database.
+    /// If the ingredient is not already in the cache, it will be created.
+    #[inline(always)]
+    pub fn get_or_create<'db>(
+        &self,
+        zalsa: &'db Zalsa,
+        create_index: impl Fn() -> IngredientIndex,
+    ) -> &'db I {
+        let index = self.get_or_create_index(zalsa, create_index);
+        zalsa.lookup_ingredient(index).assert_type::<I>()
+    }
+
+    /// Get a reference to the ingredient in the database.
+    /// If the ingredient is not already in the cache, it will be created.
+    #[inline(always)]
+    pub fn get_or_create_index(
+        &self,
+        zalsa: &Zalsa,
+        create_index: impl Fn() -> IngredientIndex,
+    ) -> IngredientIndex {
+        const _: () = assert!(
+            mem::size_of::<(Nonce<StorageNonce>, IngredientIndex)>() == mem::size_of::<u64>()
+        );
+        let cached_data = self.cached_data.load(Ordering::Acquire);
+        if cached_data == Self::UNINITIALIZED {
+            #[inline(never)]
+            fn get_or_create_index_slow<I: Ingredient>(
+                this: &IngredientCache<I>,
+                zalsa: &Zalsa,
+                create_index: impl Fn() -> IngredientIndex,
+            ) -> IngredientIndex {
+                let index = create_index();
+                let nonce = zalsa.nonce().into_u32().get() as u64;
+                let packed = (nonce << u32::BITS) | (index.0 as u64);
+                debug_assert_ne!(packed, IngredientCache::<I>::UNINITIALIZED);
+
+                // Discard the result, whether we won over the cache or not does not matter
+                // we know that something has been cached now
+                _ = this.cached_data.compare_exchange(
+                    IngredientCache::<I>::UNINITIALIZED,
+                    packed,
+                    Ordering::Release,
+                    Ordering::Acquire,
+                );
+                // and we already have our index computed so we can just use that
+                index
+            }
+
+            return get_or_create_index_slow(self, zalsa, create_index);
+        };
+
+        // unpack our u64
+        // SAFETY: We've checked against `UNINITIALIZED` (0) above and so the upper bits must be non-zero
+        let nonce = Nonce::<StorageNonce>::from_u32(unsafe {
+            NonZeroU32::new_unchecked((cached_data >> u32::BITS) as u32)
+        });
+        let mut index = IngredientIndex(cached_data as u32);
+
+        if zalsa.nonce() != nonce {
+            index = create_index();
+        }
+        index
+    }
+}
+
+/// Given a wide pointer `T`, extracts the data pointer (typed as `U`).
+///
+/// # Safety
+///
+/// `U` must be correct type for the data pointer.
+pub unsafe fn transmute_data_ptr<T: ?Sized, U>(t: &T) -> &U {
+    let t: *const T = t;
+    let u: *const U = t as *const U;
+    // SAFETY: the caller must guarantee that `T` is a wide pointer for `U`
+    unsafe { &*u }
+}
+
+/// Given a wide pointer `T`, extracts the data pointer (typed as `U`).
+///
+/// # Safety
+///
+/// `U` must be correct type for the data pointer.
+pub(crate) unsafe fn transmute_data_mut_ptr<T: ?Sized, U>(t: &mut T) -> &mut U {
+    let t: *mut T = t;
+    let u: *mut U = t as *mut U;
+    // SAFETY: the caller must guarantee that `T` is a wide pointer for `U`
+    unsafe { &mut *u }
+}
diff --git a/crates/salsa/src/zalsa_local.rs b/crates/salsa/src/zalsa_local.rs
new file mode 100644
index 000000000..03d41851f
--- /dev/null
+++ b/crates/salsa/src/zalsa_local.rs
@@ -0,0 +1,568 @@
+use std::cell::RefCell;
+use std::panic::UnwindSafe;
+
+use rustc_hash::FxHashMap;
+use tracing::debug;
+
+use crate::accumulator::accumulated_map::{AccumulatedMap, AtomicInputAccumulatedValues};
+use crate::active_query::QueryStack;
+use crate::cycle::CycleHeads;
+use crate::durability::Durability;
+use crate::key::DatabaseKeyIndex;
+use crate::loom::sync::atomic::AtomicBool;
+use crate::runtime::Stamp;
+use crate::table::{PageIndex, Slot, Table};
+use crate::tracked_struct::{Disambiguator, Identity, IdentityHash, IdentityMap};
+use crate::zalsa::{IngredientIndex, Zalsa};
+use crate::{Accumulator, Cancelled, Id, Revision};
+
+/// State that is specific to a single execution thread.
+///
+/// Internally, this type uses ref-cells.
+///
+/// **Note also that all mutations to the database handle (and hence
+/// to the local-state) must be undone during unwinding.**
+pub struct ZalsaLocal {
+    /// Vector of active queries.
+    ///
+    /// Unwinding note: pushes onto this vector must be popped -- even
+    /// during unwinding.
+    query_stack: RefCell<QueryStack>,
+
+    /// Stores the most recent page for a given ingredient.
+    /// This is thread-local to avoid contention.
+    most_recent_pages: RefCell<FxHashMap<IngredientIndex, PageIndex>>,
+}
+
+impl ZalsaLocal {
+    pub(crate) fn new() -> Self {
+        ZalsaLocal {
+            query_stack: RefCell::new(QueryStack::default()),
+            most_recent_pages: RefCell::new(FxHashMap::default()),
+        }
+    }
+
+    pub(crate) fn record_unfilled_pages(&mut self, table: &Table) {
+        let most_recent_pages = self.most_recent_pages.get_mut();
+        most_recent_pages
+            .drain()
+            .for_each(|(ingredient, page)| table.record_unfilled_page(ingredient, page));
+    }
+
+    /// Allocate a new id in `table` for the given ingredient
+    /// storing `value`. Remembers the most recent page from this
+    /// thread and attempts to reuse it.
+    pub(crate) fn allocate<T: Slot>(
+        &self,
+        zalsa: &Zalsa,
+        ingredient: IngredientIndex,
+        mut value: impl FnOnce(Id) -> T,
+    ) -> Id {
+        let memo_types = || {
+            zalsa
+                .lookup_ingredient(ingredient)
+                .memo_table_types()
+                .clone()
+        };
+        // Find the most recent page, pushing a page if needed
+        let mut page = *self
+            .most_recent_pages
+            .borrow_mut()
+            .entry(ingredient)
+            .or_insert_with(|| {
+                zalsa
+                    .table()
+                    .fetch_or_push_page::<T>(ingredient, memo_types)
+            });
+
+        loop {
+            // Try to allocate an entry on that page
+            let page_ref = zalsa.table().page::<T>(page);
+            match page_ref.allocate(page, value) {
+                // If successful, return
+                Ok(id) => return id,
+
+                // Otherwise, create a new page and try again
+                // Note that we could try fetching a page again, but as we just filled one up
+                // it is unlikely that there is a non-full one available.
+                Err(v) => {
+                    value = v;
+                    page = zalsa.table().push_page::<T>(ingredient, memo_types());
+                    self.most_recent_pages.borrow_mut().insert(ingredient, page);
+                }
+            }
+        }
+    }
+
+    #[inline]
+    pub(crate) fn push_query(
+        &self,
+        database_key_index: DatabaseKeyIndex,
+        iteration_count: u32,
+    ) -> ActiveQueryGuard<'_> {
+        let mut query_stack = self.query_stack.borrow_mut();
+        query_stack.push_new_query(database_key_index, iteration_count);
+        ActiveQueryGuard {
+            local_state: self,
+            database_key_index,
+            #[cfg(debug_assertions)]
+            push_len: query_stack.len(),
+        }
+    }
+
+    /// Executes a closure within the context of the current active query stacks (mutable).
+    #[inline(always)]
+    pub(crate) fn with_query_stack_mut<R>(
+        &self,
+        c: impl UnwindSafe + FnOnce(&mut QueryStack) -> R,
+    ) -> R {
+        c(&mut self.query_stack.borrow_mut())
+    }
+
+    #[inline(always)]
+    pub(crate) fn with_query_stack<R>(&self, c: impl UnwindSafe + FnOnce(&QueryStack) -> R) -> R {
+        c(&mut self.query_stack.borrow())
+    }
+
+    #[inline(always)]
+    pub(crate) fn try_with_query_stack<R>(
+        &self,
+        c: impl UnwindSafe + FnOnce(&QueryStack) -> R,
+    ) -> Option<R> {
+        self.query_stack
+            .try_borrow()
+            .ok()
+            .as_ref()
+            .map(|stack| c(stack))
+    }
+
+    /// Returns the index of the active query along with its *current* durability/changed-at
+    /// information. As the query continues to execute, naturally, that information may change.
+    pub(crate) fn active_query(&self) -> Option<(DatabaseKeyIndex, Stamp)> {
+        self.with_query_stack(|stack| {
+            stack
+                .last()
+                .map(|active_query| (active_query.database_key_index, active_query.stamp()))
+        })
+    }
+
+    /// Add an output to the current query's list of dependencies
+    ///
+    /// Returns `Err` if not in a query.
+    pub(crate) fn accumulate<A: Accumulator>(
+        &self,
+        index: IngredientIndex,
+        value: A,
+    ) -> Result<(), ()> {
+        self.with_query_stack_mut(|stack| {
+            if let Some(top_query) = stack.last_mut() {
+                top_query.accumulate(index, value);
+                Ok(())
+            } else {
+                Err(())
+            }
+        })
+    }
+
+    /// Add an output to the current query's list of dependencies
+    pub(crate) fn add_output(&self, entity: DatabaseKeyIndex) {
+        self.with_query_stack_mut(|stack| {
+            if let Some(top_query) = stack.last_mut() {
+                top_query.add_output(entity)
+            }
+        })
+    }
+
+    /// Check whether `entity` is an output of the currently active query (if any)
+    pub(crate) fn is_output_of_active_query(&self, entity: DatabaseKeyIndex) -> bool {
+        self.with_query_stack_mut(|stack| {
+            if let Some(top_query) = stack.last_mut() {
+                top_query.is_output(entity)
+            } else {
+                false
+            }
+        })
+    }
+
+    /// Register that currently active query reads the given input
+    #[inline(always)]
+    pub(crate) fn report_tracked_read(
+        &self,
+        input: DatabaseKeyIndex,
+        durability: Durability,
+        changed_at: Revision,
+        has_accumulated: bool,
+        accumulated_inputs: &AtomicInputAccumulatedValues,
+        cycle_heads: &CycleHeads,
+    ) {
+        debug!(
+            "report_tracked_read(input={:?}, durability={:?}, changed_at={:?})",
+            input, durability, changed_at
+        );
+        self.with_query_stack_mut(|stack| {
+            if let Some(top_query) = stack.last_mut() {
+                top_query.add_read(
+                    input,
+                    durability,
+                    changed_at,
+                    has_accumulated,
+                    accumulated_inputs,
+                    cycle_heads,
+                );
+            }
+        })
+    }
+
+    /// Register that currently active query reads the given input
+    #[inline(always)]
+    pub(crate) fn report_tracked_read_simple(
+        &self,
+        input: DatabaseKeyIndex,
+        durability: Durability,
+        changed_at: Revision,
+    ) {
+        debug!(
+            "report_tracked_read(input={:?}, durability={:?}, changed_at={:?})",
+            input, durability, changed_at
+        );
+        self.with_query_stack_mut(|stack| {
+            if let Some(top_query) = stack.last_mut() {
+                top_query.add_read_simple(input, durability, changed_at);
+            }
+        })
+    }
+
+    /// Register that the current query read an untracked value
+    ///
+    /// # Parameters
+    ///
+    /// * `current_revision`, the current revision
+    #[inline(always)]
+    pub(crate) fn report_untracked_read(&self, current_revision: Revision) {
+        self.with_query_stack_mut(|stack| {
+            if let Some(top_query) = stack.last_mut() {
+                top_query.add_untracked_read(current_revision);
+            }
+        })
+    }
+
+    /// Update the top query on the stack to act as though it read a value
+    /// of durability `durability` which changed in `revision`.
+    // FIXME: Use or remove this.
+    #[allow(dead_code)]
+    pub(crate) fn report_synthetic_read(&self, durability: Durability, revision: Revision) {
+        self.with_query_stack_mut(|stack| {
+            if let Some(top_query) = stack.last_mut() {
+                top_query.add_synthetic_read(durability, revision);
+            }
+        })
+    }
+
+    /// Called when the active queries creates an index from the
+    /// entity table with the index `entity_index`. Has the following effects:
+    ///
+    /// * Add a query read on `DatabaseKeyIndex::for_table(entity_index)`
+    /// * Identify a unique disambiguator for the hash within the current query,
+    ///   adding the hash to the current query's disambiguator table.
+    /// * Returns a tuple of:
+    ///   * the id of the current query
+    ///   * the current dependencies (durability, changed_at) of current query
+    ///   * the disambiguator index
+    #[track_caller]
+    pub(crate) fn disambiguate(&self, key: IdentityHash) -> (Stamp, Disambiguator) {
+        self.with_query_stack_mut(|stack| {
+            let top_query = stack.last_mut().expect(
+                "cannot create a tracked struct disambiguator outside of a tracked function",
+            );
+            let disambiguator = top_query.disambiguate(key);
+            (top_query.stamp(), disambiguator)
+        })
+    }
+
+    #[track_caller]
+    pub(crate) fn tracked_struct_id(&self, identity: &Identity) -> Option<Id> {
+        self.with_query_stack(|stack| {
+            let top_query = stack
+                .last()
+                .expect("cannot create a tracked struct ID outside of a tracked function");
+            top_query.tracked_struct_ids.get(identity)
+        })
+    }
+
+    #[track_caller]
+    pub(crate) fn store_tracked_struct_id(&self, identity: Identity, id: Id) {
+        self.with_query_stack_mut(|stack| {
+            let top_query = stack
+                .last_mut()
+                .expect("cannot store a tracked struct ID outside of a tracked function");
+            let old_id = top_query.tracked_struct_ids.insert(identity, id);
+            assert!(
+                old_id.is_none(),
+                "overwrote a previous id for `{identity:?}`"
+            );
+        })
+    }
+
+    #[cold]
+    pub(crate) fn unwind_cancelled(&self, current_revision: Revision) {
+        // Why is this reporting an untracked read? We do not store the query revisions on unwind do we?
+        self.report_untracked_read(current_revision);
+        Cancelled::PendingWrite.throw();
+    }
+}
+
+// Okay to implement as `ZalsaLocal`` is !Sync
+// - `most_recent_pages` can't observe broken states as we cannot panic such that we enter an
+//   inconsistent state
+// - neither can `query_stack` as we require the closures accessing it to be `UnwindSafe`
+impl std::panic::RefUnwindSafe for ZalsaLocal {}
+
+/// Summarizes "all the inputs that a query used"
+/// and "all the outputs it has written to"
+#[derive(Debug)]
+// #[derive(Clone)] cloning this is expensive, so we don't derive
+pub(crate) struct QueryRevisions {
+    /// The most revision in which some input changed.
+    pub(crate) changed_at: Revision,
+
+    /// Minimum durability of the inputs to this query.
+    pub(crate) durability: Durability,
+
+    /// How was this query computed?
+    pub(crate) origin: QueryOrigin,
+
+    /// The ids of tracked structs created by this query.
+    ///
+    /// This table plays an important role when queries are
+    /// re-executed:
+    /// * A clone of this field is used as the initial set of
+    ///   `TrackedStructId`s for the query on the next execution.
+    /// * The query will thus re-use the same ids if it creates
+    ///   tracked structs with the same `KeyStruct` as before.
+    ///   It may also create new tracked structs.
+    /// * One tricky case involves deleted structs. If
+    ///   the old revision created a struct S but the new
+    ///   revision did not, there will still be a map entry
+    ///   for S. This is because queries only ever grow the map
+    ///   and they start with the same entries as from the
+    ///   previous revision. To handle this, `diff_outputs` compares
+    ///   the structs from the old/new revision and retains
+    ///   only entries that appeared in the new revision.
+    pub(super) tracked_struct_ids: IdentityMap,
+
+    pub(super) accumulated: Option<Box<AccumulatedMap>>,
+
+    /// [`InputAccumulatedValues::Empty`] if any input read during the query's execution
+    /// has any direct or indirect accumulated values.
+    pub(super) accumulated_inputs: AtomicInputAccumulatedValues,
+
+    /// Are the `cycle_heads` verified to not be provisional anymore?
+    pub(super) verified_final: AtomicBool,
+
+    /// This result was computed based on provisional values from
+    /// these cycle heads. The "cycle head" is the query responsible
+    /// for managing a fixpoint iteration. In a cycle like
+    /// `--> A --> B --> C --> A`, the cycle head is query `A`: it is
+    /// the query whose value is requested while it is executing,
+    /// which must provide the initial provisional value and decide,
+    /// after each iteration, whether the cycle has converged or must
+    /// iterate again.
+    pub(super) cycle_heads: CycleHeads,
+}
+
+impl QueryRevisions {
+    pub(crate) fn fixpoint_initial(query: DatabaseKeyIndex) -> Self {
+        Self {
+            changed_at: Revision::start(),
+            durability: Durability::MAX,
+            origin: QueryOrigin::FixpointInitial,
+            tracked_struct_ids: Default::default(),
+            accumulated: Default::default(),
+            accumulated_inputs: Default::default(),
+            verified_final: AtomicBool::new(false),
+            cycle_heads: CycleHeads::initial(query),
+        }
+    }
+}
+
+/// Tracks the way that a memoized value for a query was created.
+#[derive(Debug, Clone)]
+pub enum QueryOrigin {
+    /// The value was assigned as the output of another query (e.g., using `specify`).
+    /// The `DatabaseKeyIndex` is the identity of the assigning query.
+    Assigned(DatabaseKeyIndex),
+
+    /// The value was derived by executing a function
+    /// and we were able to track ALL of that function's inputs.
+    /// Those inputs are described in [`QueryEdges`].
+    Derived(QueryEdges),
+
+    /// The value was derived by executing a function
+    /// but that function also reported that it read untracked inputs.
+    /// The [`QueryEdges`] argument contains a listing of all the inputs we saw
+    /// (but we know there were more).
+    DerivedUntracked(QueryEdges),
+
+    /// The value is an initial provisional value for a query that supports fixpoint iteration.
+    FixpointInitial,
+}
+
+impl QueryOrigin {
+    /// Indices for queries *read* by this query
+    pub(crate) fn inputs(&self) -> impl DoubleEndedIterator<Item = DatabaseKeyIndex> + '_ {
+        let opt_edges = match self {
+            QueryOrigin::Derived(edges) | QueryOrigin::DerivedUntracked(edges) => Some(edges),
+            QueryOrigin::Assigned(_) | QueryOrigin::FixpointInitial => None,
+        };
+        opt_edges.into_iter().flat_map(|edges| edges.inputs())
+    }
+
+    /// Indices for queries *written* by this query (if any)
+    pub(crate) fn outputs(&self) -> impl DoubleEndedIterator<Item = DatabaseKeyIndex> + '_ {
+        let opt_edges = match self {
+            QueryOrigin::Derived(edges) | QueryOrigin::DerivedUntracked(edges) => Some(edges),
+            QueryOrigin::Assigned(_) | QueryOrigin::FixpointInitial => None,
+        };
+        opt_edges.into_iter().flat_map(|edges| edges.outputs())
+    }
+
+    pub(crate) fn edges(&self) -> &[QueryEdge] {
+        let opt_edges = match self {
+            QueryOrigin::Derived(edges) | QueryOrigin::DerivedUntracked(edges) => Some(edges),
+            QueryOrigin::Assigned(_) | QueryOrigin::FixpointInitial => None,
+        };
+        opt_edges
+            .map(|edges| &*edges.input_outputs)
+            .unwrap_or_default()
+    }
+}
+
+/// The edges between a memoized value and other queries in the dependency graph.
+/// These edges include both dependency edges
+/// e.g., when creating the memoized value for Q0 executed another function Q1)
+/// and output edges
+/// (e.g., when Q0 specified the value for another query Q2).
+#[derive(Debug, Clone)]
+pub struct QueryEdges {
+    /// The list of outgoing edges from this node.
+    /// This list combines *both* inputs and outputs.
+    ///
+    /// Note that we always track input dependencies even when there are untracked reads.
+    /// Untracked reads mean that we can't verify values, so we don't use the list of inputs for that,
+    /// but we still use it for finding the transitive inputs to an accumulator.
+    ///
+    /// You can access the input/output list via the methods [`inputs`] and [`outputs`] respectively.
+    ///
+    /// Important:
+    ///
+    /// * The inputs must be in **execution order** for the red-green algorithm to work.
+    // pub input_outputs: ThinBox<[DependencyEdge]>, once that is a thing
+    pub input_outputs: Box<[QueryEdge]>,
+}
+
+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
+pub enum QueryEdge {
+    Input(DatabaseKeyIndex),
+    Output(DatabaseKeyIndex),
+}
+
+impl QueryEdges {
+    /// Returns the (tracked) inputs that were executed in computing this memoized value.
+    ///
+    /// These will always be in execution order.
+    pub(crate) fn inputs(&self) -> impl DoubleEndedIterator<Item = DatabaseKeyIndex> + '_ {
+        self.input_outputs.iter().filter_map(|&edge| match edge {
+            QueryEdge::Input(dependency_index) => Some(dependency_index),
+            QueryEdge::Output(_) => None,
+        })
+    }
+
+    /// Returns the (tracked) outputs that were executed in computing this memoized value.
+    ///
+    /// These will always be in execution order.
+    pub(crate) fn outputs(&self) -> impl DoubleEndedIterator<Item = DatabaseKeyIndex> + '_ {
+        self.input_outputs.iter().filter_map(|&edge| match edge {
+            QueryEdge::Output(dependency_index) => Some(dependency_index),
+            QueryEdge::Input(_) => None,
+        })
+    }
+
+    /// Creates a new `QueryEdges`; the values given for each field must meet struct invariants.
+    pub(crate) fn new(input_outputs: impl IntoIterator<Item = QueryEdge>) -> Self {
+        Self {
+            input_outputs: input_outputs.into_iter().collect(),
+        }
+    }
+}
+
+/// When a query is pushed onto the `active_query` stack, this guard
+/// is returned to represent its slot. The guard can be used to pop
+/// the query from the stack -- in the case of unwinding, the guard's
+/// destructor will also remove the query.
+pub(crate) struct ActiveQueryGuard<'me> {
+    local_state: &'me ZalsaLocal,
+    #[cfg(debug_assertions)]
+    push_len: usize,
+    pub(crate) database_key_index: DatabaseKeyIndex,
+}
+
+impl ActiveQueryGuard<'_> {
+    /// Initialize the tracked struct ids with the values from the prior execution.
+    pub(crate) fn seed_tracked_struct_ids(&self, tracked_struct_ids: &IdentityMap) {
+        self.local_state.with_query_stack_mut(|stack| {
+            #[cfg(debug_assertions)]
+            assert_eq!(stack.len(), self.push_len);
+            let frame = stack.last_mut().unwrap();
+            assert!(frame.tracked_struct_ids.is_empty());
+            frame.tracked_struct_ids.clone_from(tracked_struct_ids);
+        })
+    }
+
+    /// Append the given `outputs` to the query's output list.
+    pub(crate) fn seed_iteration(&self, previous: &QueryRevisions) {
+        let durability = previous.durability;
+        let changed_at = previous.changed_at;
+        let edges = previous.origin.edges();
+        let untracked_read = matches!(previous.origin, QueryOrigin::DerivedUntracked(_));
+
+        self.local_state.with_query_stack_mut(|stack| {
+            #[cfg(debug_assertions)]
+            assert_eq!(stack.len(), self.push_len);
+            let frame = stack.last_mut().unwrap();
+            frame.seed_iteration(durability, changed_at, edges, untracked_read);
+        })
+    }
+
+    /// Invoked when the query has successfully completed execution.
+    fn complete(self) -> QueryRevisions {
+        let query = self.local_state.with_query_stack_mut(|stack| {
+            stack.pop_into_revisions(
+                self.database_key_index,
+                #[cfg(debug_assertions)]
+                self.push_len,
+            )
+        });
+        std::mem::forget(self);
+        query
+    }
+
+    /// Pops an active query from the stack. Returns the [`QueryRevisions`]
+    /// which summarizes the other queries that were accessed during this
+    /// query's execution.
+    #[inline]
+    pub(crate) fn pop(self) -> QueryRevisions {
+        self.complete()
+    }
+}
+
+impl Drop for ActiveQueryGuard<'_> {
+    fn drop(&mut self) {
+        self.local_state.with_query_stack_mut(|stack| {
+            stack.pop(
+                self.database_key_index,
+                #[cfg(debug_assertions)]
+                self.push_len,
+            );
+        });
+    }
+}
diff --git a/crates/salsa/tests/accumulate-chain.rs b/crates/salsa/tests/accumulate-chain.rs
new file mode 100644
index 000000000..d51e67c14
--- /dev/null
+++ b/crates/salsa/tests/accumulate-chain.rs
@@ -0,0 +1,58 @@
+//! Test that when having nested tracked functions
+//! we don't drop any values when accumulating.
+
+mod common;
+
+use expect_test::expect;
+use salsa::{Accumulator, Database, DatabaseImpl};
+use test_log::test;
+
+#[salsa::accumulator]
+#[derive(Debug)]
+struct Log(#[allow(dead_code)] String);
+
+#[salsa::tracked]
+fn push_logs(db: &dyn Database) {
+    push_a_logs(db);
+}
+
+#[salsa::tracked]
+fn push_a_logs(db: &dyn Database) {
+    Log("log a".to_string()).accumulate(db);
+    push_b_logs(db);
+}
+
+#[salsa::tracked]
+fn push_b_logs(db: &dyn Database) {
+    // No logs
+    push_c_logs(db);
+}
+
+#[salsa::tracked]
+fn push_c_logs(db: &dyn Database) {
+    // No logs
+    push_d_logs(db);
+}
+
+#[salsa::tracked]
+fn push_d_logs(db: &dyn Database) {
+    Log("log d".to_string()).accumulate(db);
+}
+
+#[test]
+fn accumulate_chain() {
+    DatabaseImpl::new().attach(|db| {
+        let logs = push_logs::accumulated::<Log>(db);
+        // Check that we get all the logs.
+        expect![[r#"
+            [
+                Log(
+                    "log a",
+                ),
+                Log(
+                    "log d",
+                ),
+            ]"#]]
+        .assert_eq(&format!("{logs:#?}"));
+    })
+}
diff --git a/crates/salsa/tests/accumulate-custom-debug.rs b/crates/salsa/tests/accumulate-custom-debug.rs
new file mode 100644
index 000000000..a4c078ab7
--- /dev/null
+++ b/crates/salsa/tests/accumulate-custom-debug.rs
@@ -0,0 +1,45 @@
+mod common;
+
+use expect_test::expect;
+use salsa::{Accumulator, Database};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct MyInput {
+    count: u32,
+}
+
+#[salsa::accumulator]
+struct Log(String);
+
+impl std::fmt::Debug for Log {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        f.debug_tuple("CustomLog").field(&self.0).finish()
+    }
+}
+
+#[salsa::tracked]
+fn push_logs(db: &dyn salsa::Database, input: MyInput) {
+    for i in 0..input.count(db) {
+        Log(format!("#{i}")).accumulate(db);
+    }
+}
+
+#[test]
+fn accumulate_custom_debug() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = MyInput::new(db, 2);
+        let logs = push_logs::accumulated::<Log>(db, input);
+        expect![[r##"
+            [
+                CustomLog(
+                    "#0",
+                ),
+                CustomLog(
+                    "#1",
+                ),
+            ]
+        "##]]
+        .assert_debug_eq(&logs);
+    })
+}
diff --git a/crates/salsa/tests/accumulate-dag.rs b/crates/salsa/tests/accumulate-dag.rs
new file mode 100644
index 000000000..6786d0f8e
--- /dev/null
+++ b/crates/salsa/tests/accumulate-dag.rs
@@ -0,0 +1,67 @@
+mod common;
+
+use expect_test::expect;
+use salsa::{Accumulator, Database};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct MyInput {
+    field_a: u32,
+    field_b: u32,
+}
+
+#[salsa::accumulator]
+#[derive(Debug)]
+struct Log(#[allow(dead_code)] String);
+
+#[salsa::tracked]
+fn push_logs(db: &dyn Database, input: MyInput) {
+    push_a_logs(db, input);
+    push_b_logs(db, input);
+}
+
+#[salsa::tracked]
+fn push_a_logs(db: &dyn Database, input: MyInput) {
+    let count = input.field_a(db);
+    for i in 0..count {
+        Log(format!("log_a({i} of {count})")).accumulate(db);
+    }
+}
+
+#[salsa::tracked]
+fn push_b_logs(db: &dyn Database, input: MyInput) {
+    // Note that b calls a
+    push_a_logs(db, input);
+    let count = input.field_b(db);
+    for i in 0..count {
+        Log(format!("log_b({i} of {count})")).accumulate(db);
+    }
+}
+
+#[test]
+fn accumulate_a_called_twice() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = MyInput::new(db, 2, 3);
+        let logs = push_logs::accumulated::<Log>(db, input);
+        // Check that we don't see logs from `a` appearing twice in the input.
+        expect![[r#"
+            [
+                Log(
+                    "log_a(0 of 2)",
+                ),
+                Log(
+                    "log_a(1 of 2)",
+                ),
+                Log(
+                    "log_b(0 of 3)",
+                ),
+                Log(
+                    "log_b(1 of 3)",
+                ),
+                Log(
+                    "log_b(2 of 3)",
+                ),
+            ]"#]]
+        .assert_eq(&format!("{logs:#?}"));
+    })
+}
diff --git a/crates/salsa/tests/accumulate-execution-order.rs b/crates/salsa/tests/accumulate-execution-order.rs
new file mode 100644
index 000000000..28aeb5d7b
--- /dev/null
+++ b/crates/salsa/tests/accumulate-execution-order.rs
@@ -0,0 +1,65 @@
+//! Demonstrates that accumulation is done in the order
+//! in which things were originally executed.
+
+mod common;
+
+use expect_test::expect;
+use salsa::{Accumulator, Database};
+use test_log::test;
+
+#[salsa::accumulator]
+#[derive(Debug)]
+struct Log(#[allow(dead_code)] String);
+
+#[salsa::tracked]
+fn push_logs(db: &dyn Database) {
+    push_a_logs(db);
+}
+
+#[salsa::tracked]
+fn push_a_logs(db: &dyn Database) {
+    Log("log a".to_string()).accumulate(db);
+    push_b_logs(db);
+    push_c_logs(db);
+    push_d_logs(db);
+}
+
+#[salsa::tracked]
+fn push_b_logs(db: &dyn Database) {
+    Log("log b".to_string()).accumulate(db);
+    push_d_logs(db);
+}
+
+#[salsa::tracked]
+fn push_c_logs(db: &dyn Database) {
+    Log("log c".to_string()).accumulate(db);
+}
+
+#[salsa::tracked]
+fn push_d_logs(db: &dyn Database) {
+    Log("log d".to_string()).accumulate(db);
+}
+
+#[test]
+fn accumulate_execution_order() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let logs = push_logs::accumulated::<Log>(db);
+        // Check that we get logs in execution order
+        expect![[r#"
+            [
+                Log(
+                    "log a",
+                ),
+                Log(
+                    "log b",
+                ),
+                Log(
+                    "log d",
+                ),
+                Log(
+                    "log c",
+                ),
+            ]"#]]
+        .assert_eq(&format!("{logs:#?}"));
+    })
+}
diff --git a/crates/salsa/tests/accumulate-from-tracked-fn.rs b/crates/salsa/tests/accumulate-from-tracked-fn.rs
new file mode 100644
index 000000000..5fba8a688
--- /dev/null
+++ b/crates/salsa/tests/accumulate-from-tracked-fn.rs
@@ -0,0 +1,73 @@
+//! Accumulate values from within a tracked function.
+//! Then mutate the values so that the tracked function re-executes.
+//! Check that we accumulate the appropriate, new values.
+
+use expect_test::expect;
+use salsa::{Accumulator, Setter};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct List {
+    value: u32,
+    next: Option<List>,
+}
+
+#[salsa::accumulator]
+#[derive(Copy, Clone, Debug)]
+struct Integers(u32);
+
+#[salsa::tracked]
+fn compute(db: &dyn salsa::Database, input: List) {
+    eprintln!(
+        "{:?}(value={:?}, next={:?})",
+        input,
+        input.value(db),
+        input.next(db)
+    );
+    let result = if let Some(next) = input.next(db) {
+        let next_integers = compute::accumulated::<Integers>(db, next);
+        eprintln!("{next_integers:?}");
+        let v = input.value(db) + next_integers.iter().map(|a| a.0).sum::<u32>();
+        eprintln!("input={:?} v={:?}", input.value(db), v);
+        v
+    } else {
+        input.value(db)
+    };
+    Integers(result).accumulate(db);
+    eprintln!("pushed result {result:?}");
+}
+
+#[test]
+fn test1() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let l0 = List::new(&db, 1, None);
+    let l1 = List::new(&db, 10, Some(l0));
+
+    compute(&db, l1);
+    expect![[r#"
+        [
+            Integers(
+                11,
+            ),
+            Integers(
+                1,
+            ),
+        ]
+    "#]]
+    .assert_debug_eq(&compute::accumulated::<Integers>(&db, l1));
+
+    l0.set_value(&mut db).to(2);
+    compute(&db, l1);
+    expect![[r#"
+        [
+            Integers(
+                12,
+            ),
+            Integers(
+                2,
+            ),
+        ]
+    "#]]
+    .assert_debug_eq(&compute::accumulated::<Integers>(&db, l1));
+}
diff --git a/crates/salsa/tests/accumulate-no-duplicates.rs b/crates/salsa/tests/accumulate-no-duplicates.rs
new file mode 100644
index 000000000..0907c469d
--- /dev/null
+++ b/crates/salsa/tests/accumulate-no-duplicates.rs
@@ -0,0 +1,105 @@
+//! Test that we don't get duplicate accumulated values
+
+mod common;
+
+use expect_test::expect;
+use salsa::{Accumulator, Database};
+use test_log::test;
+
+// A(1) {
+//   B
+//   B
+//   C {
+//     D {
+//       A(2) {
+//         B
+//       }
+//       B
+//     }
+//     E
+//   }
+//   B
+// }
+
+#[salsa::accumulator]
+#[derive(Debug)]
+struct Log(#[allow(dead_code)] String);
+
+#[salsa::input(debug)]
+struct MyInput {
+    n: u32,
+}
+
+#[salsa::tracked]
+fn push_logs(db: &dyn Database) {
+    push_a_logs(db, MyInput::new(db, 1));
+}
+
+#[salsa::tracked]
+fn push_a_logs(db: &dyn Database, input: MyInput) {
+    Log("log a".to_string()).accumulate(db);
+    if input.n(db) == 1 {
+        push_b_logs(db);
+        push_b_logs(db);
+        push_c_logs(db);
+        push_b_logs(db);
+    } else {
+        push_b_logs(db);
+    }
+}
+
+#[salsa::tracked]
+fn push_b_logs(db: &dyn Database) {
+    Log("log b".to_string()).accumulate(db);
+}
+
+#[salsa::tracked]
+fn push_c_logs(db: &dyn Database) {
+    Log("log c".to_string()).accumulate(db);
+    push_d_logs(db);
+    push_e_logs(db);
+}
+
+// Note this isn't tracked
+fn push_d_logs(db: &dyn Database) {
+    Log("log d".to_string()).accumulate(db);
+    push_a_logs(db, MyInput::new(db, 2));
+    push_b_logs(db);
+}
+
+#[salsa::tracked]
+fn push_e_logs(db: &dyn Database) {
+    Log("log e".to_string()).accumulate(db);
+}
+
+#[test]
+fn accumulate_no_duplicates() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let logs = push_logs::accumulated::<Log>(db);
+        // Test that there aren't duplicate B logs.
+        // Note that log A appears twice, because they both come
+        // from different inputs.
+        expect![[r#"
+            [
+                Log(
+                    "log a",
+                ),
+                Log(
+                    "log b",
+                ),
+                Log(
+                    "log c",
+                ),
+                Log(
+                    "log d",
+                ),
+                Log(
+                    "log a",
+                ),
+                Log(
+                    "log e",
+                ),
+            ]"#]]
+        .assert_eq(&format!("{logs:#?}"));
+    })
+}
diff --git a/crates/salsa/tests/accumulate-reuse-workaround.rs b/crates/salsa/tests/accumulate-reuse-workaround.rs
new file mode 100644
index 000000000..915a14c1c
--- /dev/null
+++ b/crates/salsa/tests/accumulate-reuse-workaround.rs
@@ -0,0 +1,74 @@
+//! Demonstrates the workaround of wrapping calls to
+//! `accumulated` in a tracked function to get better
+//! reuse.
+
+mod common;
+use common::{LogDatabase, LoggerDatabase};
+use expect_test::expect;
+use salsa::{Accumulator, Setter};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct List {
+    value: u32,
+    next: Option<List>,
+}
+
+#[salsa::accumulator]
+#[derive(Copy, Clone, Debug)]
+struct Integers(u32);
+
+#[salsa::tracked]
+fn compute(db: &dyn LogDatabase, input: List) -> u32 {
+    db.push_log(format!("compute({input:?})",));
+
+    // always pushes 0
+    Integers(0).accumulate(db);
+
+    let result = if let Some(next) = input.next(db) {
+        let next_integers = accumulated(db, next);
+        let v = input.value(db) + next_integers.iter().sum::<u32>();
+        v
+    } else {
+        input.value(db)
+    };
+
+    // return value changes
+    result
+}
+
+#[salsa::tracked(returns(ref))]
+fn accumulated(db: &dyn LogDatabase, input: List) -> Vec<u32> {
+    db.push_log(format!("accumulated({input:?})"));
+    compute::accumulated::<Integers>(db, input)
+        .into_iter()
+        .map(|a| a.0)
+        .collect()
+}
+
+#[test]
+fn test1() {
+    let mut db = LoggerDatabase::default();
+
+    let l1 = List::new(&db, 1, None);
+    let l2 = List::new(&db, 2, Some(l1));
+
+    assert_eq!(compute(&db, l2), 2);
+    db.assert_logs(expect![[r#"
+        [
+            "compute(List { [salsa id]: Id(1), value: 2, next: Some(List { [salsa id]: Id(0), value: 1, next: None }) })",
+            "accumulated(List { [salsa id]: Id(0), value: 1, next: None })",
+            "compute(List { [salsa id]: Id(0), value: 1, next: None })",
+        ]"#]]);
+
+    // When we mutate `l1`, we should re-execute `compute` for `l1`,
+    // and we re-execute accumulated for `l1`, but we do NOT re-execute
+    // `compute` for `l2`.
+    l1.set_value(&mut db).to(2);
+    assert_eq!(compute(&db, l2), 2);
+    db.assert_logs(expect![[r#"
+        [
+            "accumulated(List { [salsa id]: Id(0), value: 2, next: None })",
+            "compute(List { [salsa id]: Id(0), value: 2, next: None })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/accumulate-reuse.rs b/crates/salsa/tests/accumulate-reuse.rs
new file mode 100644
index 000000000..b7d918870
--- /dev/null
+++ b/crates/salsa/tests/accumulate-reuse.rs
@@ -0,0 +1,65 @@
+//! Accumulator re-use test.
+//!
+//! Tests behavior when a query's only inputs
+//! are the accumulated values from another query.
+
+mod common;
+use common::{LogDatabase, LoggerDatabase};
+use expect_test::expect;
+use salsa::{Accumulator, Setter};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct List {
+    value: u32,
+    next: Option<List>,
+}
+
+#[salsa::accumulator]
+struct Integers(u32);
+
+#[salsa::tracked]
+fn compute(db: &dyn LogDatabase, input: List) -> u32 {
+    db.push_log(format!("compute({input:?})",));
+
+    // always pushes 0
+    Integers(0).accumulate(db);
+
+    let result = if let Some(next) = input.next(db) {
+        let next_integers = compute::accumulated::<Integers>(db, next);
+        let v = input.value(db) + next_integers.iter().map(|i| i.0).sum::<u32>();
+        v
+    } else {
+        input.value(db)
+    };
+
+    // return value changes
+    result
+}
+
+#[test]
+fn test1() {
+    let mut db = LoggerDatabase::default();
+
+    let l1 = List::new(&db, 1, None);
+    let l2 = List::new(&db, 2, Some(l1));
+
+    assert_eq!(compute(&db, l2), 2);
+    db.assert_logs(expect![[r#"
+        [
+            "compute(List { [salsa id]: Id(1), value: 2, next: Some(List { [salsa id]: Id(0), value: 1, next: None }) })",
+            "compute(List { [salsa id]: Id(0), value: 1, next: None })",
+        ]"#]]);
+
+    // When we mutate `l1`, we should re-execute `compute` for `l1`,
+    // but we should not have to re-execute `compute` for `l2`.
+    // The only input for `compute(l1)` is the accumulated values from `l1`,
+    // which have not changed.
+    l1.set_value(&mut db).to(2);
+    assert_eq!(compute(&db, l2), 2);
+    db.assert_logs(expect![[r#"
+        [
+            "compute(List { [salsa id]: Id(1), value: 2, next: Some(List { [salsa id]: Id(0), value: 2, next: None }) })",
+            "compute(List { [salsa id]: Id(0), value: 2, next: None })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/accumulate.rs b/crates/salsa/tests/accumulate.rs
new file mode 100644
index 000000000..dcacfb7ad
--- /dev/null
+++ b/crates/salsa/tests/accumulate.rs
@@ -0,0 +1,244 @@
+mod common;
+use common::{LogDatabase, LoggerDatabase};
+use expect_test::expect;
+use salsa::{Accumulator, Setter};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct MyInput {
+    field_a: u32,
+    field_b: u32,
+}
+
+#[salsa::accumulator]
+#[derive(Debug)]
+struct Log(#[allow(dead_code)] String);
+
+#[salsa::tracked]
+fn push_logs(db: &dyn LogDatabase, input: MyInput) {
+    db.push_log(format!(
+        "push_logs(a = {}, b = {})",
+        input.field_a(db),
+        input.field_b(db)
+    ));
+
+    // We don't invoke `push_a_logs` (or `push_b_logs`) with a value of 0.
+    // This allows us to test what happens a change in inputs causes a function not to be called at all.
+    if input.field_a(db) > 0 {
+        push_a_logs(db, input);
+    }
+
+    if input.field_b(db) > 0 {
+        push_b_logs(db, input);
+    }
+}
+
+#[salsa::tracked]
+fn push_a_logs(db: &dyn LogDatabase, input: MyInput) {
+    let field_a = input.field_a(db);
+    db.push_log(format!("push_a_logs({field_a})"));
+
+    for i in 0..field_a {
+        Log(format!("log_a({i} of {field_a})")).accumulate(db);
+    }
+}
+
+#[salsa::tracked]
+fn push_b_logs(db: &dyn LogDatabase, input: MyInput) {
+    let field_a = input.field_b(db);
+    db.push_log(format!("push_b_logs({field_a})"));
+
+    for i in 0..field_a {
+        Log(format!("log_b({i} of {field_a})")).accumulate(db);
+    }
+}
+
+#[test]
+fn accumulate_once() {
+    let db = common::LoggerDatabase::default();
+
+    // Just call accumulate on a base input to see what happens.
+    let input = MyInput::new(&db, 2, 3);
+    let logs = push_logs::accumulated::<Log>(&db, input);
+    db.assert_logs(expect![[r#"
+        [
+            "push_logs(a = 2, b = 3)",
+            "push_a_logs(2)",
+            "push_b_logs(3)",
+        ]"#]]);
+    // Check that we see logs from `a` first and then logs from `b`
+    // (execution order).
+    expect![[r#"
+        [
+            Log(
+                "log_a(0 of 2)",
+            ),
+            Log(
+                "log_a(1 of 2)",
+            ),
+            Log(
+                "log_b(0 of 3)",
+            ),
+            Log(
+                "log_b(1 of 3)",
+            ),
+            Log(
+                "log_b(2 of 3)",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{logs:#?}"));
+}
+
+#[test]
+fn change_a_from_2_to_0() {
+    let mut db = common::LoggerDatabase::default();
+
+    // Accumulate logs for `a = 2` and `b = 3`
+    let input = MyInput::new(&db, 2, 3);
+    let logs = push_logs::accumulated::<Log>(&db, input);
+    expect![[r#"
+        [
+            Log(
+                "log_a(0 of 2)",
+            ),
+            Log(
+                "log_a(1 of 2)",
+            ),
+            Log(
+                "log_b(0 of 3)",
+            ),
+            Log(
+                "log_b(1 of 3)",
+            ),
+            Log(
+                "log_b(2 of 3)",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{logs:#?}"));
+    db.assert_logs(expect![[r#"
+        [
+            "push_logs(a = 2, b = 3)",
+            "push_a_logs(2)",
+            "push_b_logs(3)",
+        ]"#]]);
+
+    // Change to `a = 0`, which means `push_logs` does not call `push_a_logs` at all
+    input.set_field_a(&mut db).to(0);
+    let logs = push_logs::accumulated::<Log>(&db, input);
+    expect![[r#"
+        [
+            Log(
+                "log_b(0 of 3)",
+            ),
+            Log(
+                "log_b(1 of 3)",
+            ),
+            Log(
+                "log_b(2 of 3)",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{logs:#?}"));
+    db.assert_logs(expect![[r#"
+        [
+            "push_logs(a = 0, b = 3)",
+        ]"#]]);
+}
+
+#[test]
+fn change_a_from_2_to_1() {
+    let mut db = LoggerDatabase::default();
+
+    // Accumulate logs for `a = 2` and `b = 3`
+    let input = MyInput::new(&db, 2, 3);
+    let logs = push_logs::accumulated::<Log>(&db, input);
+    expect![[r#"
+        [
+            Log(
+                "log_a(0 of 2)",
+            ),
+            Log(
+                "log_a(1 of 2)",
+            ),
+            Log(
+                "log_b(0 of 3)",
+            ),
+            Log(
+                "log_b(1 of 3)",
+            ),
+            Log(
+                "log_b(2 of 3)",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{logs:#?}"));
+    db.assert_logs(expect![[r#"
+        [
+            "push_logs(a = 2, b = 3)",
+            "push_a_logs(2)",
+            "push_b_logs(3)",
+        ]"#]]);
+
+    // Change to `a = 1`, which means `push_logs` does not call `push_a_logs` at all
+    input.set_field_a(&mut db).to(1);
+    let logs = push_logs::accumulated::<Log>(&db, input);
+    expect![[r#"
+        [
+            Log(
+                "log_a(0 of 1)",
+            ),
+            Log(
+                "log_b(0 of 3)",
+            ),
+            Log(
+                "log_b(1 of 3)",
+            ),
+            Log(
+                "log_b(2 of 3)",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{logs:#?}"));
+    db.assert_logs(expect![[r#"
+        [
+            "push_logs(a = 1, b = 3)",
+            "push_a_logs(1)",
+        ]"#]]);
+}
+
+#[test]
+fn get_a_logs_after_changing_b() {
+    let mut db = common::LoggerDatabase::default();
+
+    // Invoke `push_a_logs` with `a = 2` and `b = 3` (but `b` doesn't matter)
+    let input = MyInput::new(&db, 2, 3);
+    let logs = push_a_logs::accumulated::<Log>(&db, input);
+    expect![[r#"
+        [
+            Log(
+                "log_a(0 of 2)",
+            ),
+            Log(
+                "log_a(1 of 2)",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{logs:#?}"));
+    db.assert_logs(expect![[r#"
+        [
+            "push_a_logs(2)",
+        ]"#]]);
+
+    // Changing `b` does not cause `push_a_logs` to re-execute
+    // and we still get the same result
+    input.set_field_b(&mut db).to(5);
+    let logs = push_a_logs::accumulated::<Log>(&db, input);
+    expect![[r#"
+        [
+            Log(
+                "log_a(0 of 2)",
+            ),
+            Log(
+                "log_a(1 of 2)",
+            ),
+        ]
+    "#]]
+    .assert_debug_eq(&logs);
+    db.assert_logs(expect!["[]"]);
+}
diff --git a/crates/salsa/tests/accumulated_backdate.rs b/crates/salsa/tests/accumulated_backdate.rs
new file mode 100644
index 000000000..ce8f6580f
--- /dev/null
+++ b/crates/salsa/tests/accumulated_backdate.rs
@@ -0,0 +1,77 @@
+//! Tests that accumulated values are correctly accounted for
+//! when backdating a value.
+
+mod common;
+use common::LogDatabase;
+use expect_test::expect;
+use salsa::{Accumulator, Setter};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct File {
+    content: String,
+}
+
+#[salsa::accumulator]
+#[derive(Debug)]
+struct Log(#[allow(dead_code)] String);
+
+#[salsa::tracked]
+fn compile(db: &dyn LogDatabase, input: File) -> u32 {
+    parse(db, input)
+}
+
+#[salsa::tracked]
+fn parse(db: &dyn LogDatabase, input: File) -> u32 {
+    let value: Result<u32, _> = input.content(db).parse();
+
+    match value {
+        Ok(value) => value,
+        Err(error) => {
+            Log(error.to_string()).accumulate(db);
+            0
+        }
+    }
+}
+
+#[test]
+fn backdate() {
+    let mut db = common::LoggerDatabase::default();
+
+    let input = File::new(&db, "0".to_string());
+
+    let logs = compile::accumulated::<Log>(&db, input);
+    expect![[r#"[]"#]].assert_eq(&format!("{logs:#?}"));
+
+    input.set_content(&mut db).to("a".to_string());
+    let logs = compile::accumulated::<Log>(&db, input);
+
+    expect![[r#"
+        [
+            Log(
+                "invalid digit found in string",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{logs:#?}"));
+}
+
+#[test]
+fn backdate_no_diagnostics() {
+    let mut db = common::LoggerDatabase::default();
+
+    let input = File::new(&db, "a".to_string());
+
+    let logs = compile::accumulated::<Log>(&db, input);
+    expect![[r#"
+        [
+            Log(
+                "invalid digit found in string",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{logs:#?}"));
+
+    input.set_content(&mut db).to("0".to_string());
+    let logs = compile::accumulated::<Log>(&db, input);
+
+    expect![[r#"[]"#]].assert_eq(&format!("{logs:#?}"));
+}
diff --git a/crates/salsa/tests/backtrace.rs b/crates/salsa/tests/backtrace.rs
new file mode 100644
index 000000000..74990663e
--- /dev/null
+++ b/crates/salsa/tests/backtrace.rs
@@ -0,0 +1,127 @@
+use expect_test::expect;
+use salsa::{Backtrace, Database, DatabaseImpl};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct Thing {
+    detailed: bool,
+}
+
+#[salsa::tracked]
+fn query_a(db: &dyn Database, thing: Thing) -> String {
+    query_b(db, thing)
+}
+
+#[salsa::tracked]
+fn query_b(db: &dyn Database, thing: Thing) -> String {
+    query_c(db, thing)
+}
+
+#[salsa::tracked]
+fn query_c(db: &dyn Database, thing: Thing) -> String {
+    query_d(db, thing)
+}
+
+#[salsa::tracked]
+fn query_d(db: &dyn Database, thing: Thing) -> String {
+    query_e(db, thing)
+}
+
+#[salsa::tracked]
+fn query_e(db: &dyn Database, thing: Thing) -> String {
+    if thing.detailed(db) {
+        format!("{:#}", Backtrace::capture().unwrap())
+    } else {
+        format!("{}", Backtrace::capture().unwrap())
+    }
+}
+#[salsa::tracked]
+fn query_f(db: &dyn Database, thing: Thing) -> String {
+    query_cycle(db, thing)
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=cycle_initial)]
+fn query_cycle(db: &dyn Database, thing: Thing) -> String {
+    let backtrace = query_cycle(db, thing);
+    if backtrace.is_empty() {
+        query_e(db, thing)
+    } else {
+        backtrace
+    }
+}
+
+fn cycle_initial(_db: &dyn salsa::Database, _thing: Thing) -> String {
+    String::new()
+}
+
+fn cycle_fn(
+    _db: &dyn salsa::Database,
+    _value: &str,
+    _count: u32,
+    _thing: Thing,
+) -> salsa::CycleRecoveryAction<String> {
+    salsa::CycleRecoveryAction::Iterate
+}
+
+#[test]
+fn backtrace_works() {
+    let db = DatabaseImpl::default();
+
+    let backtrace = query_a(&db, Thing::new(&db, false)).replace("\\", "/");
+    expect![[r#"
+        query stacktrace:
+           0: query_e(Id(0))
+                     at tests/backtrace.rs:30
+           1: query_d(Id(0))
+                     at tests/backtrace.rs:25
+           2: query_c(Id(0))
+                     at tests/backtrace.rs:20
+           3: query_b(Id(0))
+                     at tests/backtrace.rs:15
+           4: query_a(Id(0))
+                     at tests/backtrace.rs:10
+    "#]]
+    .assert_eq(&backtrace);
+
+    let backtrace = query_a(&db, Thing::new(&db, true)).replace("\\", "/");
+    expect![[r#"
+        query stacktrace:
+           0: query_e(Id(1)) -> (R1, Durability::LOW)
+                     at tests/backtrace.rs:30
+           1: query_d(Id(1)) -> (R1, Durability::HIGH)
+                     at tests/backtrace.rs:25
+           2: query_c(Id(1)) -> (R1, Durability::HIGH)
+                     at tests/backtrace.rs:20
+           3: query_b(Id(1)) -> (R1, Durability::HIGH)
+                     at tests/backtrace.rs:15
+           4: query_a(Id(1)) -> (R1, Durability::HIGH)
+                     at tests/backtrace.rs:10
+    "#]]
+    .assert_eq(&backtrace);
+
+    let backtrace = query_f(&db, Thing::new(&db, false)).replace("\\", "/");
+    expect![[r#"
+        query stacktrace:
+           0: query_e(Id(2))
+                     at tests/backtrace.rs:30
+           1: query_cycle(Id(2))
+                     at tests/backtrace.rs:43
+                     cycle heads: query_cycle(Id(2)) -> 0
+           2: query_f(Id(2))
+                     at tests/backtrace.rs:38
+    "#]]
+    .assert_eq(&backtrace);
+
+    let backtrace = query_f(&db, Thing::new(&db, true)).replace("\\", "/");
+    expect![[r#"
+        query stacktrace:
+           0: query_e(Id(3)) -> (R1, Durability::LOW)
+                     at tests/backtrace.rs:30
+           1: query_cycle(Id(3)) -> (R1, Durability::HIGH, iteration = 0)
+                     at tests/backtrace.rs:43
+                     cycle heads: query_cycle(Id(3)) -> 0
+           2: query_f(Id(3)) -> (R1, Durability::HIGH)
+                     at tests/backtrace.rs:38
+    "#]]
+    .assert_eq(&backtrace);
+}
diff --git a/crates/salsa/tests/check_auto_traits.rs b/crates/salsa/tests/check_auto_traits.rs
new file mode 100644
index 000000000..6e9c62c62
--- /dev/null
+++ b/crates/salsa/tests/check_auto_traits.rs
@@ -0,0 +1,50 @@
+//! Test that auto trait impls exist as expected.
+
+use std::panic::UnwindSafe;
+
+use salsa::Database;
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    field: String,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: MyInterned<'db>,
+}
+
+#[salsa::interned]
+struct MyInterned<'db> {
+    field: String,
+}
+
+#[salsa::tracked]
+fn test(db: &dyn Database, input: MyInput) {
+    let input = is_send(is_sync(input));
+    let interned = is_send(is_sync(MyInterned::new(db, input.field(db).clone())));
+    let _tracked_struct = is_send(is_sync(MyTracked::new(db, interned)));
+}
+
+fn is_send<T: Send>(t: T) -> T {
+    t
+}
+
+fn is_sync<T: Send>(t: T) -> T {
+    t
+}
+
+fn is_unwind_safe<T: UnwindSafe>(t: T) -> T {
+    t
+}
+
+#[test]
+fn execute() {
+    let db = is_send(salsa::DatabaseImpl::new());
+    let _handle = is_send(is_sync(is_unwind_safe(
+        db.storage().clone().into_zalsa_handle(),
+    )));
+    let input = MyInput::new(&db, "Hello".to_string());
+    test(&db, input);
+}
diff --git a/crates/salsa/tests/common/mod.rs b/crates/salsa/tests/common/mod.rs
new file mode 100644
index 000000000..2852c04bd
--- /dev/null
+++ b/crates/salsa/tests/common/mod.rs
@@ -0,0 +1,207 @@
+//! Utility for tests that lets us log when notable events happen.
+
+#![allow(dead_code)]
+
+use std::sync::{Arc, Mutex};
+
+use salsa::{Database, Storage};
+
+/// Logging userdata: provides [`LogDatabase`][] trait.
+///
+/// If you wish to use it along with other userdata,
+/// you can also embed it in another struct and implement [`HasLogger`][] for that struct.
+#[derive(Clone, Default)]
+pub struct Logger {
+    logs: Arc<Mutex<Vec<String>>>,
+}
+
+impl Logger {
+    pub fn push_log(&self, string: String) {
+        self.logs.lock().unwrap().push(string);
+    }
+}
+
+/// Trait implemented by databases that lets them log events.
+pub trait HasLogger {
+    /// Return a reference to the logger from the database.
+    fn logger(&self) -> &Logger;
+}
+
+#[salsa::db]
+pub trait LogDatabase: HasLogger + Database {
+    /// Log an event from inside a tracked function.
+    fn push_log(&self, string: String) {
+        self.logger().logs.lock().unwrap().push(string);
+    }
+
+    /// Asserts what the (formatted) logs should look like,
+    /// clearing the logged events. This takes `&mut self` because
+    /// it is meant to be run from outside any tracked functions.
+    fn assert_logs(&self, expected: expect_test::Expect) {
+        let logs = std::mem::take(&mut *self.logger().logs.lock().unwrap());
+        expected.assert_eq(&format!("{logs:#?}"));
+    }
+
+    /// Asserts the length of the logs,
+    /// clearing the logged events. This takes `&mut self` because
+    /// it is meant to be run from outside any tracked functions.
+    fn assert_logs_len(&self, expected: usize) {
+        let logs = std::mem::take(&mut *self.logger().logs.lock().unwrap());
+        assert_eq!(logs.len(), expected, "Actual logs: {logs:#?}");
+    }
+}
+
+#[salsa::db]
+impl<Db: HasLogger + Database> LogDatabase for Db {}
+
+/// Database that provides logging but does not log salsa event.
+#[salsa::db]
+#[derive(Clone, Default)]
+pub struct LoggerDatabase {
+    storage: Storage<Self>,
+    logger: Logger,
+}
+
+impl HasLogger for LoggerDatabase {
+    fn logger(&self) -> &Logger {
+        &self.logger
+    }
+}
+
+#[salsa::db]
+impl Database for LoggerDatabase {}
+
+/// Database that provides logging and logs salsa events.
+#[salsa::db]
+#[derive(Clone)]
+pub struct EventLoggerDatabase {
+    storage: Storage<Self>,
+    logger: Logger,
+}
+
+impl Default for EventLoggerDatabase {
+    fn default() -> Self {
+        let logger = Logger::default();
+        Self {
+            storage: Storage::new(Some(Box::new({
+                let logger = logger.clone();
+                move |event| logger.push_log(format!("{:?}", event.kind))
+            }))),
+            logger,
+        }
+    }
+}
+
+#[salsa::db]
+impl Database for EventLoggerDatabase {}
+
+impl HasLogger for EventLoggerDatabase {
+    fn logger(&self) -> &Logger {
+        &self.logger
+    }
+}
+
+#[salsa::db]
+#[derive(Clone)]
+pub struct DiscardLoggerDatabase {
+    storage: Storage<Self>,
+    logger: Logger,
+}
+
+impl Default for DiscardLoggerDatabase {
+    fn default() -> Self {
+        let logger = Logger::default();
+        Self {
+            storage: Storage::new(Some(Box::new({
+                let logger = logger.clone();
+                move |event| match event.kind {
+                    salsa::EventKind::WillDiscardStaleOutput { .. }
+                    | salsa::EventKind::DidDiscard { .. } => {
+                        logger.push_log(format!("salsa_event({:?})", event.kind));
+                    }
+                    _ => {}
+                }
+            }))),
+            logger,
+        }
+    }
+}
+
+#[salsa::db]
+impl Database for DiscardLoggerDatabase {}
+
+impl HasLogger for DiscardLoggerDatabase {
+    fn logger(&self) -> &Logger {
+        &self.logger
+    }
+}
+
+#[salsa::db]
+#[derive(Clone)]
+pub struct ExecuteValidateLoggerDatabase {
+    storage: Storage<Self>,
+    logger: Logger,
+}
+
+impl Default for ExecuteValidateLoggerDatabase {
+    fn default() -> Self {
+        let logger = Logger::default();
+        Self {
+            storage: Storage::new(Some(Box::new({
+                let logger = logger.clone();
+                move |event| match event.kind {
+                    salsa::EventKind::WillExecute { .. }
+                    | salsa::EventKind::WillIterateCycle { .. }
+                    | salsa::EventKind::DidValidateMemoizedValue { .. } => {
+                        logger.push_log(format!("salsa_event({:?})", event.kind));
+                    }
+                    _ => {}
+                }
+            }))),
+            logger,
+        }
+    }
+}
+impl Database for ExecuteValidateLoggerDatabase {}
+
+impl HasLogger for ExecuteValidateLoggerDatabase {
+    fn logger(&self) -> &Logger {
+        &self.logger
+    }
+}
+
+/// Trait implemented by databases that lets them provide a fixed u32 value.
+pub trait HasValue {
+    fn get_value(&self) -> u32;
+}
+
+#[salsa::db]
+pub trait ValueDatabase: HasValue + Database {}
+
+#[salsa::db]
+impl<Db: HasValue + Database> ValueDatabase for Db {}
+
+#[salsa::db]
+#[derive(Clone, Default)]
+pub struct DatabaseWithValue {
+    storage: Storage<Self>,
+    value: u32,
+}
+
+impl HasValue for DatabaseWithValue {
+    fn get_value(&self) -> u32 {
+        self.value
+    }
+}
+
+#[salsa::db]
+impl Database for DatabaseWithValue {}
+
+impl DatabaseWithValue {
+    pub fn new(value: u32) -> Self {
+        Self {
+            storage: Default::default(),
+            value,
+        }
+    }
+}
diff --git a/crates/salsa/tests/compile-fail/accumulator_incompatibles.rs b/crates/salsa/tests/compile-fail/accumulator_incompatibles.rs
new file mode 100644
index 000000000..d453ab6f5
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/accumulator_incompatibles.rs
@@ -0,0 +1,25 @@
+#[salsa::accumulator(returns(ref))]
+struct AccWithRetRef(u32);
+
+#[salsa::accumulator(specify)]
+struct AccWithSpecify(u32);
+
+#[salsa::accumulator(no_eq)]
+struct AccWithNoEq(u32);
+
+#[salsa::accumulator(data = MyAcc)]
+struct AccWithData(u32);
+
+#[salsa::accumulator(db = Db)]
+struct AcWithcDb(u32);
+
+#[salsa::accumulator(recover_fn = recover)]
+struct AccWithRecover(u32);
+
+#[salsa::accumulator(lru = 12)]
+struct AccWithLru(u32);
+
+#[salsa::accumulator(constructor = Constructor)]
+struct AccWithConstructor(u32);
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/accumulator_incompatibles.stderr b/crates/salsa/tests/compile-fail/accumulator_incompatibles.stderr
new file mode 100644
index 000000000..8853f4f65
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/accumulator_incompatibles.stderr
@@ -0,0 +1,47 @@
+error: `returns` option not allowed here
+ --> tests/compile-fail/accumulator_incompatibles.rs:1:22
+  |
+1 | #[salsa::accumulator(returns(ref))]
+  |                      ^^^^^^^
+
+error: `specify` option not allowed here
+ --> tests/compile-fail/accumulator_incompatibles.rs:4:22
+  |
+4 | #[salsa::accumulator(specify)]
+  |                      ^^^^^^^
+
+error: `no_eq` option not allowed here
+ --> tests/compile-fail/accumulator_incompatibles.rs:7:22
+  |
+7 | #[salsa::accumulator(no_eq)]
+  |                      ^^^^^
+
+error: `data` option not allowed here
+  --> tests/compile-fail/accumulator_incompatibles.rs:10:22
+   |
+10 | #[salsa::accumulator(data = MyAcc)]
+   |                      ^^^^
+
+error: `db` option not allowed here
+  --> tests/compile-fail/accumulator_incompatibles.rs:13:22
+   |
+13 | #[salsa::accumulator(db = Db)]
+   |                      ^^
+
+error: unrecognized option `recover_fn`
+  --> tests/compile-fail/accumulator_incompatibles.rs:16:22
+   |
+16 | #[salsa::accumulator(recover_fn = recover)]
+   |                      ^^^^^^^^^^
+
+error: `lru` option not allowed here
+  --> tests/compile-fail/accumulator_incompatibles.rs:19:22
+   |
+19 | #[salsa::accumulator(lru = 12)]
+   |                      ^^^
+
+error: `constructor` option not allowed here
+  --> tests/compile-fail/accumulator_incompatibles.rs:22:22
+   |
+22 | #[salsa::accumulator(constructor = Constructor)]
+   |                      ^^^^^^^^^^^
diff --git a/crates/salsa/tests/compile-fail/get-on-private-interned-field.rs b/crates/salsa/tests/compile-fail/get-on-private-interned-field.rs
new file mode 100644
index 000000000..560e51747
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/get-on-private-interned-field.rs
@@ -0,0 +1,12 @@
+mod a {
+    #[salsa::interned]
+    pub struct MyInterned<'db> {
+        field: u32,
+    }
+}
+
+fn test<'db>(db: &'db dyn salsa::Database, interned: a::MyInterned<'db>) {
+    interned.field(db);
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/get-on-private-interned-field.stderr b/crates/salsa/tests/compile-fail/get-on-private-interned-field.stderr
new file mode 100644
index 000000000..0833db61a
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/get-on-private-interned-field.stderr
@@ -0,0 +1,8 @@
+error[E0624]: method `field` is private
+ --> tests/compile-fail/get-on-private-interned-field.rs:9:14
+  |
+2 |     #[salsa::interned]
+  |     ------------------ private method defined here
+...
+9 |     interned.field(db);
+  |              ^^^^^ private method
diff --git a/crates/salsa/tests/compile-fail/get-on-private-tracked-field.rs b/crates/salsa/tests/compile-fail/get-on-private-tracked-field.rs
new file mode 100644
index 000000000..930c75de2
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/get-on-private-tracked-field.rs
@@ -0,0 +1,12 @@
+mod a {
+    #[salsa::tracked]
+    pub struct MyTracked<'db> {
+        field: u32,
+    }
+}
+
+fn test<'db>(db: &'db dyn salsa::Database, tracked: a::MyTracked<'db>) {
+    tracked.field(db);
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/get-on-private-tracked-field.stderr b/crates/salsa/tests/compile-fail/get-on-private-tracked-field.stderr
new file mode 100644
index 000000000..e43a7d138
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/get-on-private-tracked-field.stderr
@@ -0,0 +1,8 @@
+error[E0624]: method `field` is private
+ --> tests/compile-fail/get-on-private-tracked-field.rs:9:13
+  |
+2 |     #[salsa::tracked]
+  |     ----------------- private method defined here
+...
+9 |     tracked.field(db);
+  |             ^^^^^ private method
diff --git a/crates/salsa/tests/compile-fail/get-set-on-private-input-field.rs b/crates/salsa/tests/compile-fail/get-set-on-private-input-field.rs
new file mode 100644
index 000000000..345590b75
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/get-set-on-private-input-field.rs
@@ -0,0 +1,14 @@
+mod a {
+    #[salsa::input]
+    pub struct MyInput {
+        field: u32,
+    }
+}
+
+fn main() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = a::MyInput::new(&mut db, 22);
+
+    input.field(&db);
+    input.set_field(&mut db).to(23);
+}
diff --git a/crates/salsa/tests/compile-fail/get-set-on-private-input-field.stderr b/crates/salsa/tests/compile-fail/get-set-on-private-input-field.stderr
new file mode 100644
index 000000000..40acd8c2d
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/get-set-on-private-input-field.stderr
@@ -0,0 +1,17 @@
+error[E0624]: method `field` is private
+  --> tests/compile-fail/get-set-on-private-input-field.rs:12:11
+   |
+2  |     #[salsa::input]
+   |     --------------- private method defined here
+...
+12 |     input.field(&db);
+   |           ^^^^^ private method
+
+error[E0624]: method `set_field` is private
+  --> tests/compile-fail/get-set-on-private-input-field.rs:13:11
+   |
+2  |     #[salsa::input]
+   |     --------------- private method defined here
+...
+13 |     input.set_field(&mut db).to(23);
+   |           ^^^^^^^^^ private method
diff --git a/crates/salsa/tests/compile-fail/input_struct_incompatibles.rs b/crates/salsa/tests/compile-fail/input_struct_incompatibles.rs
new file mode 100644
index 000000000..8bc3a7e3a
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/input_struct_incompatibles.rs
@@ -0,0 +1,25 @@
+#[salsa::input(returns(ref))]
+struct InputWithRetRef(u32);
+
+#[salsa::input(specify)]
+struct InputWithSpecify(u32);
+
+#[salsa::input(no_eq)]
+struct InputNoWithEq(u32);
+
+#[salsa::input(db = Db)]
+struct InputWithDb(u32);
+
+#[salsa::input(recover_fn = recover)]
+struct InputWithRecover(u32);
+
+#[salsa::input(lru =12)]
+struct InputWithLru(u32);
+
+#[salsa::input]
+struct InputWithTrackedField {
+    #[tracked]
+    field: u32,
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/input_struct_incompatibles.stderr b/crates/salsa/tests/compile-fail/input_struct_incompatibles.stderr
new file mode 100644
index 000000000..8a868c146
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/input_struct_incompatibles.stderr
@@ -0,0 +1,55 @@
+error: `returns` option not allowed here
+ --> tests/compile-fail/input_struct_incompatibles.rs:1:16
+  |
+1 | #[salsa::input(returns(ref))]
+  |                ^^^^^^^
+
+error: `specify` option not allowed here
+ --> tests/compile-fail/input_struct_incompatibles.rs:4:16
+  |
+4 | #[salsa::input(specify)]
+  |                ^^^^^^^
+
+error: `no_eq` option not allowed here
+ --> tests/compile-fail/input_struct_incompatibles.rs:7:16
+  |
+7 | #[salsa::input(no_eq)]
+  |                ^^^^^
+
+error: `db` option not allowed here
+  --> tests/compile-fail/input_struct_incompatibles.rs:10:16
+   |
+10 | #[salsa::input(db = Db)]
+   |                ^^
+
+error: unrecognized option `recover_fn`
+  --> tests/compile-fail/input_struct_incompatibles.rs:13:16
+   |
+13 | #[salsa::input(recover_fn = recover)]
+   |                ^^^^^^^^^^
+
+error: `lru` option not allowed here
+  --> tests/compile-fail/input_struct_incompatibles.rs:16:16
+   |
+16 | #[salsa::input(lru =12)]
+   |                ^^^
+
+error: `#[tracked]` cannot be used with `#[salsa::input]`
+  --> tests/compile-fail/input_struct_incompatibles.rs:21:5
+   |
+21 | /     #[tracked]
+22 | |     field: u32,
+   | |______________^
+
+error: cannot find attribute `tracked` in this scope
+  --> tests/compile-fail/input_struct_incompatibles.rs:21:7
+   |
+21 |     #[tracked]
+   |       ^^^^^^^
+   |
+help: consider importing one of these attribute macros
+   |
+1  + use salsa::tracked;
+   |
+1  + use salsa_macros::tracked;
+   |
diff --git a/crates/salsa/tests/compile-fail/interned_struct_incompatibles.rs b/crates/salsa/tests/compile-fail/interned_struct_incompatibles.rs
new file mode 100644
index 000000000..65dbb3e0f
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/interned_struct_incompatibles.rs
@@ -0,0 +1,37 @@
+#[salsa::interned(returns(ref))]
+struct InternedWithRetRef {
+    field: u32,
+}
+
+#[salsa::interned(specify)]
+struct InternedWithSpecify {
+    field: u32,
+}
+
+#[salsa::interned(no_eq)]
+struct InternedWithNoEq {
+    field: u32,
+}
+
+#[salsa::interned(db = Db)]
+struct InternedWithDb {
+    field: u32,
+}
+
+#[salsa::interned(recover_fn = recover)]
+struct InternedWithRecover {
+    field: u32,
+}
+
+#[salsa::interned(lru = 12)]
+struct InternedWithLru {
+    field: u32,
+}
+
+#[salsa::interned]
+struct InternedWithTrackedField {
+    #[tracked]
+    field: u32,
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/interned_struct_incompatibles.stderr b/crates/salsa/tests/compile-fail/interned_struct_incompatibles.stderr
new file mode 100644
index 000000000..482e38b46
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/interned_struct_incompatibles.stderr
@@ -0,0 +1,55 @@
+error: `returns` option not allowed here
+ --> tests/compile-fail/interned_struct_incompatibles.rs:1:19
+  |
+1 | #[salsa::interned(returns(ref))]
+  |                   ^^^^^^^
+
+error: `specify` option not allowed here
+ --> tests/compile-fail/interned_struct_incompatibles.rs:6:19
+  |
+6 | #[salsa::interned(specify)]
+  |                   ^^^^^^^
+
+error: `no_eq` option not allowed here
+  --> tests/compile-fail/interned_struct_incompatibles.rs:11:19
+   |
+11 | #[salsa::interned(no_eq)]
+   |                   ^^^^^
+
+error: `db` option not allowed here
+  --> tests/compile-fail/interned_struct_incompatibles.rs:16:19
+   |
+16 | #[salsa::interned(db = Db)]
+   |                   ^^
+
+error: unrecognized option `recover_fn`
+  --> tests/compile-fail/interned_struct_incompatibles.rs:21:19
+   |
+21 | #[salsa::interned(recover_fn = recover)]
+   |                   ^^^^^^^^^^
+
+error: `lru` option not allowed here
+  --> tests/compile-fail/interned_struct_incompatibles.rs:26:19
+   |
+26 | #[salsa::interned(lru = 12)]
+   |                   ^^^
+
+error: `#[tracked]` cannot be used with `#[salsa::interned]`
+  --> tests/compile-fail/interned_struct_incompatibles.rs:33:5
+   |
+33 | /     #[tracked]
+34 | |     field: u32,
+   | |______________^
+
+error: cannot find attribute `tracked` in this scope
+  --> tests/compile-fail/interned_struct_incompatibles.rs:33:7
+   |
+33 |     #[tracked]
+   |       ^^^^^^^
+   |
+help: consider importing one of these attribute macros
+   |
+1  + use salsa::tracked;
+   |
+1  + use salsa_macros::tracked;
+   |
diff --git a/crates/salsa/tests/compile-fail/invalid_return_mode.rs b/crates/salsa/tests/compile-fail/invalid_return_mode.rs
new file mode 100644
index 000000000..c69287f2a
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/invalid_return_mode.rs
@@ -0,0 +1,20 @@
+use salsa::Database as Db;
+
+#[salsa::input]
+struct MyInput {
+    #[returns(clone)]
+    text: String,
+}
+
+#[salsa::tracked(returns(not_a_return_mode))]
+fn tracked_fn_invalid_return_mode(db: &dyn Db, input: MyInput) -> String {
+    input.text(db)
+}
+
+#[salsa::input]
+struct MyInvalidInput {
+    #[returns(not_a_return_mode)]
+    text: String,
+}
+
+fn main() { }
\ No newline at end of file
diff --git a/crates/salsa/tests/compile-fail/invalid_return_mode.stderr b/crates/salsa/tests/compile-fail/invalid_return_mode.stderr
new file mode 100644
index 000000000..fd3390909
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/invalid_return_mode.stderr
@@ -0,0 +1,17 @@
+error: Invalid return mode. Allowed modes are: ["copy", "clone", "ref", "deref", "as_ref", "as_deref"]
+ --> tests/compile-fail/invalid_return_mode.rs:9:26
+  |
+9 | #[salsa::tracked(returns(not_a_return_mode))]
+  |                          ^^^^^^^^^^^^^^^^^
+
+error: Invalid return mode. Allowed modes are: ["copy", "clone", "ref", "deref", "as_ref", "as_deref"]
+  --> tests/compile-fail/invalid_return_mode.rs:16:15
+   |
+16 |     #[returns(not_a_return_mode)]
+   |               ^^^^^^^^^^^^^^^^^
+
+error: cannot find attribute `returns` in this scope
+  --> tests/compile-fail/invalid_return_mode.rs:16:7
+   |
+16 |     #[returns(not_a_return_mode)]
+   |       ^^^^^^^
diff --git a/crates/salsa/tests/compile-fail/lru_can_not_be_used_with_specify.rs b/crates/salsa/tests/compile-fail/lru_can_not_be_used_with_specify.rs
new file mode 100644
index 000000000..f38cb1bd8
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/lru_can_not_be_used_with_specify.rs
@@ -0,0 +1,11 @@
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked(lru = 3, specify)]
+fn lru_can_not_be_used_with_specify(db: &dyn salsa::Database, input: MyInput) -> u32 {
+    input.field(db)
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/lru_can_not_be_used_with_specify.stderr b/crates/salsa/tests/compile-fail/lru_can_not_be_used_with_specify.stderr
new file mode 100644
index 000000000..310437683
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/lru_can_not_be_used_with_specify.stderr
@@ -0,0 +1,5 @@
+error: the `specify` and `lru` options cannot be used together
+ --> tests/compile-fail/lru_can_not_be_used_with_specify.rs:6:27
+  |
+6 | #[salsa::tracked(lru = 3, specify)]
+  |                           ^^^^^^^
diff --git a/crates/salsa/tests/compile-fail/panic-when-reading-fields-of-tracked-structs-from-older-revisions.rs b/crates/salsa/tests/compile-fail/panic-when-reading-fields-of-tracked-structs-from-older-revisions.rs
new file mode 100644
index 000000000..3dbb4f2f5
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/panic-when-reading-fields-of-tracked-structs-from-older-revisions.rs
@@ -0,0 +1,24 @@
+use salsa::prelude::*;
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn<'db>(db: &'db dyn salsa::Database, input: MyInput) -> MyTracked<'db> {
+    MyTracked::new(db, input.field(db) / 2)
+}
+
+fn main() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, 22);
+    let tracked = tracked_fn(&db, input);
+    input.set_field(&mut db).to(24);
+    tracked.field(&db); // tracked comes from prior revision
+}
diff --git a/crates/salsa/tests/compile-fail/panic-when-reading-fields-of-tracked-structs-from-older-revisions.stderr b/crates/salsa/tests/compile-fail/panic-when-reading-fields-of-tracked-structs-from-older-revisions.stderr
new file mode 100644
index 000000000..d353dd649
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/panic-when-reading-fields-of-tracked-structs-from-older-revisions.stderr
@@ -0,0 +1,9 @@
+error[E0502]: cannot borrow `db` as mutable because it is also borrowed as immutable
+  --> tests/compile-fail/panic-when-reading-fields-of-tracked-structs-from-older-revisions.rs:22:21
+   |
+21 |     let tracked = tracked_fn(&db, input);
+   |                              --- immutable borrow occurs here
+22 |     input.set_field(&mut db).to(24);
+   |                     ^^^^^^^ mutable borrow occurs here
+23 |     tracked.field(&db); // tracked comes from prior revision
+   |     ------- immutable borrow later used here
diff --git a/crates/salsa/tests/compile-fail/salsa_fields_incompatibles.rs b/crates/salsa/tests/compile-fail/salsa_fields_incompatibles.rs
new file mode 100644
index 000000000..04aec97fb
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/salsa_fields_incompatibles.rs
@@ -0,0 +1,13 @@
+// Banned field name: `from`
+#[salsa::input]
+struct InputWithBannedName1 {
+    from: u32,
+}
+
+// Banned field name: `new`
+#[salsa::input]
+struct InputWithBannedName2 {
+    new: u32,
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/salsa_fields_incompatibles.stderr b/crates/salsa/tests/compile-fail/salsa_fields_incompatibles.stderr
new file mode 100644
index 000000000..8ad3b6098
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/salsa_fields_incompatibles.stderr
@@ -0,0 +1,11 @@
+error: the field name `from` is disallowed in salsa structs
+ --> tests/compile-fail/salsa_fields_incompatibles.rs:4:5
+  |
+4 |     from: u32,
+  |     ^^^^
+
+error: the field name `new` is disallowed in salsa structs
+  --> tests/compile-fail/salsa_fields_incompatibles.rs:10:5
+   |
+10 |     new: u32,
+   |     ^^^
diff --git a/crates/salsa/tests/compile-fail/singleton_only_for_input.rs b/crates/salsa/tests/compile-fail/singleton_only_for_input.rs
new file mode 100644
index 000000000..c0a3af902
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/singleton_only_for_input.rs
@@ -0,0 +1,25 @@
+//! Compile Singleton struct test:
+//!
+//! Singleton flags are only allowed for input structs. If applied on any other Salsa struct compilation must fail
+
+#[salsa::input(singleton)]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked(singleton)]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked(singleton)]
+fn create_tracked_structs(db: &dyn salsa::Database, input: MyInput) -> Vec<MyTracked> {
+    (0..input.field(db))
+        .map(|i| MyTracked::new(db, i))
+        .collect()
+}
+
+#[salsa::accumulator(singleton)]
+struct Integers(u32);
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/singleton_only_for_input.stderr b/crates/salsa/tests/compile-fail/singleton_only_for_input.stderr
new file mode 100644
index 000000000..ba425fe36
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/singleton_only_for_input.stderr
@@ -0,0 +1,11 @@
+error: `singleton` option not allowed here
+  --> tests/compile-fail/singleton_only_for_input.rs:15:18
+   |
+15 | #[salsa::tracked(singleton)]
+   |                  ^^^^^^^^^
+
+error: `singleton` option not allowed here
+  --> tests/compile-fail/singleton_only_for_input.rs:22:22
+   |
+22 | #[salsa::accumulator(singleton)]
+   |                      ^^^^^^^^^
diff --git a/crates/salsa/tests/compile-fail/span-input-setter.rs b/crates/salsa/tests/compile-fail/span-input-setter.rs
new file mode 100644
index 000000000..9abf4b6c8
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/span-input-setter.rs
@@ -0,0 +1,11 @@
+#[salsa::input]
+pub struct MyInput {
+    field: u32,
+}
+
+fn main() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&mut db, 22);
+    input.field(&db);
+    input.set_field(22);
+}
diff --git a/crates/salsa/tests/compile-fail/span-input-setter.stderr b/crates/salsa/tests/compile-fail/span-input-setter.stderr
new file mode 100644
index 000000000..b43d07df3
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/span-input-setter.stderr
@@ -0,0 +1,22 @@
+error[E0308]: mismatched types
+  --> tests/compile-fail/span-input-setter.rs:10:21
+   |
+10 |     input.set_field(22);
+   |           --------- ^^ expected `&mut _`, found integer
+   |           |
+   |           arguments to this method are incorrect
+   |
+   = note: expected mutable reference `&mut _`
+                           found type `{integer}`
+note: method defined here
+  --> tests/compile-fail/span-input-setter.rs:3:5
+   |
+1  | #[salsa::input]
+   | ---------------
+2  | pub struct MyInput {
+3  |     field: u32,
+   |     ^^^^^
+help: consider mutably borrowing here
+   |
+10 |     input.set_field(&mut 22);
+   |                     ++++
diff --git a/crates/salsa/tests/compile-fail/span-tracked-getter.rs b/crates/salsa/tests/compile-fail/span-tracked-getter.rs
new file mode 100644
index 000000000..245fd1008
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/span-tracked-getter.rs
@@ -0,0 +1,15 @@
+#[salsa::tracked]
+pub struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn my_fn(db: &dyn salsa::Database) {
+    let x = MyTracked::new(db, 22);
+    x.field(22);
+}
+
+fn main() {
+    let mut db = salsa::DatabaseImpl::new();
+    my_fn(&db);
+}
diff --git a/crates/salsa/tests/compile-fail/span-tracked-getter.stderr b/crates/salsa/tests/compile-fail/span-tracked-getter.stderr
new file mode 100644
index 000000000..fcf546c72
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/span-tracked-getter.stderr
@@ -0,0 +1,32 @@
+error[E0308]: mismatched types
+ --> tests/compile-fail/span-tracked-getter.rs:9:13
+  |
+9 |     x.field(22);
+  |       ----- ^^ expected `&_`, found integer
+  |       |
+  |       arguments to this method are incorrect
+  |
+  = note: expected reference `&_`
+                  found type `{integer}`
+note: method defined here
+ --> tests/compile-fail/span-tracked-getter.rs:3:5
+  |
+1 | #[salsa::tracked]
+  | -----------------
+2 | pub struct MyTracked<'db> {
+3 |     field: u32,
+  |     ^^^^^
+help: consider borrowing here
+  |
+9 |     x.field(&22);
+  |             +
+
+warning: variable does not need to be mutable
+  --> tests/compile-fail/span-tracked-getter.rs:13:9
+   |
+13 |     let mut db = salsa::DatabaseImpl::new();
+   |         ----^^
+   |         |
+   |         help: remove this `mut`
+   |
+   = note: `#[warn(unused_mut)]` on by default
diff --git a/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-input.rs b/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-input.rs
new file mode 100644
index 000000000..97e279cde
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-input.rs
@@ -0,0 +1,20 @@
+//! Test that `specify` does not work if the key is a `salsa::input`
+//! compilation fails
+#![allow(warnings)]
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked(specify)]
+fn tracked_fn<'db>(db: &'db dyn salsa::Database, input: MyInput) -> MyTracked<'db> {
+    MyTracked::new(db, input.field(db) * 2)
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-input.stderr b/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-input.stderr
new file mode 100644
index 000000000..580ea67bf
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-input.stderr
@@ -0,0 +1,16 @@
+error[E0277]: the trait bound `MyInput: TrackedStructInDb` is not satisfied
+  --> tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-input.rs:15:1
+   |
+15 | #[salsa::tracked(specify)]
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `TrackedStructInDb` is not implemented for `MyInput`
+   |
+   = help: the trait `TrackedStructInDb` is implemented for `MyTracked<'_>`
+note: required by a bound in `salsa::function::specify::<impl salsa::function::IngredientImpl<C>>::specify_and_record`
+  --> src/function/specify.rs
+   |
+   |     pub fn specify_and_record<'db>(&'db self, db: &'db C::DbView, key: Id, value: C::Output<'db>)
+   |            ------------------ required by a bound in this associated function
+   |     where
+   |         C::Input<'db>: TrackedStructInDb,
+   |                        ^^^^^^^^^^^^^^^^^ required by this bound in `salsa::function::specify::<impl IngredientImpl<C>>::specify_and_record`
+   = note: this error originates in the macro `salsa::plumbing::setup_tracked_fn` which comes from the expansion of the attribute macro `salsa::tracked` (in Nightly builds, run with -Z macro-backtrace for more info)
diff --git a/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-interned.rs b/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-interned.rs
new file mode 100644
index 000000000..5c5feef8f
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-interned.rs
@@ -0,0 +1,20 @@
+//! Test that `specify` does not work if the key is a `salsa::interned`
+//! compilation fails
+#![allow(warnings)]
+
+#[salsa::interned]
+struct MyInterned<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked(specify)]
+fn tracked_fn<'db>(db: &'db dyn salsa::Database, input: MyInterned<'db>) -> MyTracked<'db> {
+    MyTracked::new(db, input.field(db) * 2)
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-interned.stderr b/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-interned.stderr
new file mode 100644
index 000000000..01a4b8f60
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-interned.stderr
@@ -0,0 +1,16 @@
+error[E0277]: the trait bound `MyInterned<'_>: TrackedStructInDb` is not satisfied
+  --> tests/compile-fail/specify-does-not-work-if-the-key-is-a-salsa-interned.rs:15:1
+   |
+15 | #[salsa::tracked(specify)]
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `TrackedStructInDb` is not implemented for `MyInterned<'_>`
+   |
+   = help: the trait `TrackedStructInDb` is implemented for `MyTracked<'_>`
+note: required by a bound in `salsa::function::specify::<impl salsa::function::IngredientImpl<C>>::specify_and_record`
+  --> src/function/specify.rs
+   |
+   |     pub fn specify_and_record<'db>(&'db self, db: &'db C::DbView, key: Id, value: C::Output<'db>)
+   |            ------------------ required by a bound in this associated function
+   |     where
+   |         C::Input<'db>: TrackedStructInDb,
+   |                        ^^^^^^^^^^^^^^^^^ required by this bound in `salsa::function::specify::<impl IngredientImpl<C>>::specify_and_record`
+   = note: this error originates in the macro `salsa::plumbing::setup_tracked_fn` which comes from the expansion of the attribute macro `salsa::tracked` (in Nightly builds, run with -Z macro-backtrace for more info)
diff --git a/crates/salsa/tests/compile-fail/tracked_fn_incompatibles.rs b/crates/salsa/tests/compile-fail/tracked_fn_incompatibles.rs
new file mode 100644
index 000000000..5f587bf3d
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_fn_incompatibles.rs
@@ -0,0 +1,71 @@
+use salsa::Database as Db;
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked(data = Data)]
+fn tracked_fn_with_data(db: &dyn Db, input: MyInput) -> u32 {
+    input.field(db) * 2
+}
+
+#[salsa::tracked(db = Db)]
+fn tracked_fn_with_db(db: &dyn Db, input: MyInput) -> u32 {
+    input.field(db) * 2
+}
+
+#[salsa::tracked(constructor = TrackedFn3)]
+fn tracked_fn_with_constructor(db: &dyn Db, input: MyInput) -> u32 {
+    input.field(db) * 2
+}
+
+#[salsa::tracked]
+fn tracked_fn_with_one_input(db: &dyn Db) -> u32 {}
+
+#[salsa::tracked]
+fn tracked_fn_with_receiver_not_applied_to_impl_block(&self, db: &dyn Db) -> u32 {}
+
+#[salsa::tracked(specify)]
+fn tracked_fn_with_too_many_arguments_for_specify(
+    db: &dyn Db,
+    input: MyInput,
+    input: MyInput,
+) -> u32 {
+}
+
+#[salsa::interned]
+struct MyInterned<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn_with_lt_param_and_elided_lt_on_db_arg1<'db>(
+    db: &dyn Db,
+    interned: MyInterned<'db>,
+) -> u32 {
+    interned.field(db) * 2
+}
+
+#[salsa::tracked]
+fn tracked_fn_with_lt_param_and_elided_lt_on_db_arg2<'db_lifetime>(
+    db: &dyn Db,
+    interned: MyInterned<'db_lifetime>,
+) -> u32 {
+    interned.field(db) * 2
+}
+
+#[salsa::tracked]
+fn tracked_fn_with_lt_param_and_elided_lt_on_input<'db>(
+    db: &'db dyn Db,
+    interned: MyInterned,
+) -> u32 {
+    interned.field(db) * 2
+}
+
+#[salsa::tracked]
+fn tracked_fn_with_multiple_lts<'db1, 'db2>(db: &'db1 dyn Db, interned: MyInterned<'db2>) -> u32 {
+    interned.field(db) * 2
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/tracked_fn_incompatibles.stderr b/crates/salsa/tests/compile-fail/tracked_fn_incompatibles.stderr
new file mode 100644
index 000000000..dbdb3827c
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_fn_incompatibles.stderr
@@ -0,0 +1,97 @@
+error: `data` option not allowed here
+ --> tests/compile-fail/tracked_fn_incompatibles.rs:8:18
+  |
+8 | #[salsa::tracked(data = Data)]
+  |                  ^^^^
+
+error: `db` option not allowed here
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:13:18
+   |
+13 | #[salsa::tracked(db = Db)]
+   |                  ^^
+
+error: `constructor` option not allowed here
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:18:18
+   |
+18 | #[salsa::tracked(constructor = TrackedFn3)]
+   |                  ^^^^^^^^^^^
+
+error: #[salsa::tracked] must also be applied to the impl block for tracked methods
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:27:55
+   |
+27 | fn tracked_fn_with_receiver_not_applied_to_impl_block(&self, db: &dyn Db) -> u32 {}
+   |                                                       ^^^^^
+
+error: only functions with a single salsa struct as their input can be specified
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:29:18
+   |
+29 | #[salsa::tracked(specify)]
+   |                  ^^^^^^^
+
+error: must have a `'db` lifetime
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:44:9
+   |
+44 |     db: &dyn Db,
+   |         ^
+
+error: must have a `'db_lifetime` lifetime
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:52:9
+   |
+52 |     db: &dyn Db,
+   |         ^
+
+error: only a single lifetime parameter is accepted
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:67:39
+   |
+67 | fn tracked_fn_with_multiple_lts<'db1, 'db2>(db: &'db1 dyn Db, interned: MyInterned<'db2>) -> u32 {
+   |                                       ^^^^
+
+error: `self` parameter is only allowed in associated functions
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:27:55
+   |
+27 | fn tracked_fn_with_receiver_not_applied_to_impl_block(&self, db: &dyn Db) -> u32 {}
+   |                                                       ^^^^^ not semantically valid as function parameter
+   |
+   = note: associated functions are those in `impl` or `trait` definitions
+
+error[E0415]: identifier `input` is bound more than once in this parameter list
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:33:5
+   |
+33 |     input: MyInput,
+   |     ^^^^^ used as parameter more than once
+
+error[E0106]: missing lifetime specifier
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:61:15
+   |
+61 |     interned: MyInterned,
+   |               ^^^^^^^^^^ expected named lifetime parameter
+   |
+help: consider using the `'db` lifetime
+   |
+61 |     interned: MyInterned<'db>,
+   |                         +++++
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:24:46
+   |
+23 | #[salsa::tracked]
+   | ----------------- implicitly returns `()` as its body has no tail or `return` expression
+24 | fn tracked_fn_with_one_input(db: &dyn Db) -> u32 {}
+   |                                              ^^^ expected `u32`, found `()`
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:27:78
+   |
+27 | fn tracked_fn_with_receiver_not_applied_to_impl_block(&self, db: &dyn Db) -> u32 {}
+   |    --------------------------------------------------                        ^^^ expected `u32`, found `()`
+   |    |
+   |    implicitly returns `()` as its body has no tail or `return` expression
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_fn_incompatibles.rs:34:6
+   |
+30 | fn tracked_fn_with_too_many_arguments_for_specify(
+   |    ---------------------------------------------- implicitly returns `()` as its body has no tail or `return` expression
+...
+34 | ) -> u32 {
+   |      ^^^ expected `u32`, found `()`
diff --git a/crates/salsa/tests/compile-fail/tracked_fn_return_not_update.rs b/crates/salsa/tests/compile-fail/tracked_fn_return_not_update.rs
new file mode 100644
index 000000000..a25c41c74
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_fn_return_not_update.rs
@@ -0,0 +1,15 @@
+use salsa::Database as Db;
+
+#[salsa::input]
+struct MyInput {}
+
+#[derive(Clone, Debug)]
+struct NotUpdate;
+
+#[salsa::tracked]
+fn tracked_fn<'db>(db: &'db dyn Db, input: MyInput) -> NotUpdate {
+    _ = (db, input);
+    NotUpdate
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/tracked_fn_return_not_update.stderr b/crates/salsa/tests/compile-fail/tracked_fn_return_not_update.stderr
new file mode 100644
index 000000000..805f05916
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_fn_return_not_update.stderr
@@ -0,0 +1,45 @@
+error[E0369]: binary operation `==` cannot be applied to type `&NotUpdate`
+  --> tests/compile-fail/tracked_fn_return_not_update.rs:10:56
+   |
+10 | fn tracked_fn<'db>(db: &'db dyn Db, input: MyInput) -> NotUpdate {
+   |                                                        ^^^^^^^^^
+   |
+note: an implementation of `PartialEq` might be missing for `NotUpdate`
+  --> tests/compile-fail/tracked_fn_return_not_update.rs:7:1
+   |
+7  | struct NotUpdate;
+   | ^^^^^^^^^^^^^^^^ must implement `PartialEq`
+help: consider annotating `NotUpdate` with `#[derive(PartialEq)]`
+   |
+7  + #[derive(PartialEq)]
+8  | struct NotUpdate;
+   |
+
+error[E0599]: the function or associated item `maybe_update` exists for struct `UpdateDispatch<NotUpdate>`, but its trait bounds were not satisfied
+  --> tests/compile-fail/tracked_fn_return_not_update.rs:10:56
+   |
+7  | struct NotUpdate;
+   | ---------------- doesn't satisfy `NotUpdate: PartialEq` or `NotUpdate: Update`
+...
+10 | fn tracked_fn<'db>(db: &'db dyn Db, input: MyInput) -> NotUpdate {
+   |                                                        ^^^^^^^^^ function or associated item cannot be called on `UpdateDispatch<NotUpdate>` due to unsatisfied trait bounds
+   |
+  ::: src/update.rs
+   |
+   |     pub struct Dispatch<D>(PhantomData<D>);
+   |     ---------------------- doesn't satisfy `_: UpdateFallback<NotUpdate>`
+   |
+   = note: the following trait bounds were not satisfied:
+           `NotUpdate: Update`
+           `NotUpdate: PartialEq`
+           which is required by `UpdateDispatch<NotUpdate>: UpdateFallback<NotUpdate>`
+note: the trait `Update` must be implemented
+  --> src/update.rs
+   |
+   | pub unsafe trait Update {
+   | ^^^^^^^^^^^^^^^^^^^^^^^
+help: consider annotating `NotUpdate` with `#[derive(PartialEq)]`
+   |
+7   + #[derive(PartialEq)]
+8   | struct NotUpdate;
+    |
diff --git a/crates/salsa/tests/compile-fail/tracked_fn_return_ref.rs b/crates/salsa/tests/compile-fail/tracked_fn_return_ref.rs
new file mode 100644
index 000000000..1f4f61392
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_fn_return_ref.rs
@@ -0,0 +1,49 @@
+use salsa::Database as Db;
+
+#[salsa::input]
+struct MyInput {
+    #[returns(ref)]
+    text: String,
+}
+
+#[derive(Clone, Debug, PartialEq, Eq)]
+struct ContainsRef<'db> {
+    text: &'db str,
+}
+
+#[salsa::tracked]
+fn tracked_fn_return_ref<'db>(db: &'db dyn Db, input: MyInput) -> &'db str {
+    input.text(db)
+}
+
+#[salsa::tracked]
+fn tracked_fn_return_struct_containing_ref<'db>(
+    db: &'db dyn Db,
+    input: MyInput,
+) -> ContainsRef<'db> {
+    ContainsRef {
+        text: input.text(db),
+    }
+}
+
+#[salsa::tracked]
+fn tracked_fn_return_struct_containing_ref_elided_implicit<'db>(
+    db: &'db dyn Db,
+    input: MyInput,
+) -> ContainsRef {
+    ContainsRef {
+        text: input.text(db),
+    }
+}
+
+#[salsa::tracked]
+fn tracked_fn_return_struct_containing_ref_elided_explicit<'db>(
+    db: &'db dyn Db,
+    input: MyInput,
+) -> ContainsRef<'_> {
+    ContainsRef {
+        text: input.text(db),
+    }
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/tracked_fn_return_ref.stderr b/crates/salsa/tests/compile-fail/tracked_fn_return_ref.stderr
new file mode 100644
index 000000000..ee8595edc
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_fn_return_ref.stderr
@@ -0,0 +1,54 @@
+error[E0106]: missing lifetime specifier
+  --> tests/compile-fail/tracked_fn_return_ref.rs:33:6
+   |
+33 | ) -> ContainsRef {
+   |      ^^^^^^^^^^^ expected named lifetime parameter
+   |
+help: consider using the `'db` lifetime
+   |
+33 | ) -> ContainsRef<'db> {
+   |                 +++++
+
+warning: elided lifetime has a name
+  --> tests/compile-fail/tracked_fn_return_ref.rs:33:6
+   |
+30 | fn tracked_fn_return_struct_containing_ref_elided_implicit<'db>(
+   |                                                            --- lifetime `'db` declared here
+...
+33 | ) -> ContainsRef {
+   |      ^^^^^^^^^^^ this elided lifetime gets resolved as `'db`
+   |
+   = note: `#[warn(elided_named_lifetimes)]` on by default
+
+warning: elided lifetime has a name
+  --> tests/compile-fail/tracked_fn_return_ref.rs:43:18
+   |
+40 | fn tracked_fn_return_struct_containing_ref_elided_explicit<'db>(
+   |                                                            --- lifetime `'db` declared here
+...
+43 | ) -> ContainsRef<'_> {
+   |                  ^^ this elided lifetime gets resolved as `'db`
+
+error: lifetime may not live long enough
+  --> tests/compile-fail/tracked_fn_return_ref.rs:15:67
+   |
+15 | fn tracked_fn_return_ref<'db>(db: &'db dyn Db, input: MyInput) -> &'db str {
+   |                          --- lifetime `'db` defined here          ^ requires that `'db` must outlive `'static`
+
+error: lifetime may not live long enough
+  --> tests/compile-fail/tracked_fn_return_ref.rs:23:6
+   |
+20 | fn tracked_fn_return_struct_containing_ref<'db>(
+   |                                            --- lifetime `'db` defined here
+...
+23 | ) -> ContainsRef<'db> {
+   |      ^^^^^^^^^^^ requires that `'db` must outlive `'static`
+
+error: lifetime may not live long enough
+  --> tests/compile-fail/tracked_fn_return_ref.rs:43:6
+   |
+40 | fn tracked_fn_return_struct_containing_ref_elided_explicit<'db>(
+   |                                                            --- lifetime `'db` defined here
+...
+43 | ) -> ContainsRef<'_> {
+   |      ^^^^^^^^^^^ requires that `'db` must outlive `'static`
diff --git a/crates/salsa/tests/compile-fail/tracked_impl_incompatibles.rs b/crates/salsa/tests/compile-fail/tracked_impl_incompatibles.rs
new file mode 100644
index 000000000..d3b66590b
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_impl_incompatibles.rs
@@ -0,0 +1,51 @@
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked(returns(ref))]
+impl<'db> std::default::Default for MyTracked<'db> {
+    fn default() -> Self {}
+}
+
+#[salsa::tracked(specify)]
+impl<'db> std::default::Default for MyTracked<'db> {
+    fn default() -> Self {}
+}
+
+#[salsa::tracked(no_eq)]
+impl<'db> std::default::Default for MyTracked<'db> {
+    fn default() -> Self {}
+}
+
+#[salsa::tracked(data = Data)]
+impl<'db> std::default::Default for MyTracked<'db> {
+    fn default() -> Self {}
+}
+
+#[salsa::tracked(db = Db)]
+impl<'db> std::default::Default for MyTracked<'db> {
+    fn default() -> Self {}
+}
+
+#[salsa::tracked(recover_fn = recover)]
+impl<'db> std::default::Default for MyTracked<'db> {
+    fn default() -> Self {}
+}
+
+#[salsa::tracked(lru = 32)]
+impl<'db> std::default::Default for MyTracked<'db> {
+    fn default() -> Self {}
+}
+
+#[salsa::tracked(constructor = Constructor)]
+impl<'db> std::default::Default for MyTracked<'db> {
+    fn default() -> Self {}
+}
+
+#[salsa::tracked]
+impl<'db> std::default::Default for [MyTracked<'db>; 12] {
+    fn default() -> Self {}
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/tracked_impl_incompatibles.stderr b/crates/salsa/tests/compile-fail/tracked_impl_incompatibles.stderr
new file mode 100644
index 000000000..fa4227011
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_impl_incompatibles.stderr
@@ -0,0 +1,197 @@
+error: unexpected token
+ --> tests/compile-fail/tracked_impl_incompatibles.rs:6:18
+  |
+6 | #[salsa::tracked(returns(ref))]
+  |                  ^^^^^^^
+
+error: unexpected token
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:11:18
+   |
+11 | #[salsa::tracked(specify)]
+   |                  ^^^^^^^
+
+error: unexpected token
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:16:18
+   |
+16 | #[salsa::tracked(no_eq)]
+   |                  ^^^^^
+
+error: unexpected token
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:21:18
+   |
+21 | #[salsa::tracked(data = Data)]
+   |                  ^^^^
+
+error: unexpected token
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:26:18
+   |
+26 | #[salsa::tracked(db = Db)]
+   |                  ^^
+
+error: unexpected token
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:31:18
+   |
+31 | #[salsa::tracked(recover_fn = recover)]
+   |                  ^^^^^^^^^^
+
+error: unexpected token
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:36:18
+   |
+36 | #[salsa::tracked(lru = 32)]
+   |                  ^^^
+
+error: unexpected token
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:41:18
+   |
+41 | #[salsa::tracked(constructor = Constructor)]
+   |                  ^^^^^^^^^^^
+
+error[E0119]: conflicting implementations of trait `Default` for type `MyTracked<'_>`
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:12:1
+   |
+7  | impl<'db> std::default::Default for MyTracked<'db> {
+   | -------------------------------------------------- first implementation here
+...
+12 | impl<'db> std::default::Default for MyTracked<'db> {
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `MyTracked<'_>`
+
+error[E0119]: conflicting implementations of trait `Default` for type `MyTracked<'_>`
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:17:1
+   |
+7  | impl<'db> std::default::Default for MyTracked<'db> {
+   | -------------------------------------------------- first implementation here
+...
+17 | impl<'db> std::default::Default for MyTracked<'db> {
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `MyTracked<'_>`
+
+error[E0119]: conflicting implementations of trait `Default` for type `MyTracked<'_>`
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:22:1
+   |
+7  | impl<'db> std::default::Default for MyTracked<'db> {
+   | -------------------------------------------------- first implementation here
+...
+22 | impl<'db> std::default::Default for MyTracked<'db> {
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `MyTracked<'_>`
+
+error[E0119]: conflicting implementations of trait `Default` for type `MyTracked<'_>`
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:27:1
+   |
+7  | impl<'db> std::default::Default for MyTracked<'db> {
+   | -------------------------------------------------- first implementation here
+...
+27 | impl<'db> std::default::Default for MyTracked<'db> {
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `MyTracked<'_>`
+
+error[E0119]: conflicting implementations of trait `Default` for type `MyTracked<'_>`
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:32:1
+   |
+7  | impl<'db> std::default::Default for MyTracked<'db> {
+   | -------------------------------------------------- first implementation here
+...
+32 | impl<'db> std::default::Default for MyTracked<'db> {
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `MyTracked<'_>`
+
+error[E0119]: conflicting implementations of trait `Default` for type `MyTracked<'_>`
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:37:1
+   |
+7  | impl<'db> std::default::Default for MyTracked<'db> {
+   | -------------------------------------------------- first implementation here
+...
+37 | impl<'db> std::default::Default for MyTracked<'db> {
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `MyTracked<'_>`
+
+error[E0119]: conflicting implementations of trait `Default` for type `MyTracked<'_>`
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:42:1
+   |
+7  | impl<'db> std::default::Default for MyTracked<'db> {
+   | -------------------------------------------------- first implementation here
+...
+42 | impl<'db> std::default::Default for MyTracked<'db> {
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `MyTracked<'_>`
+
+error[E0117]: only traits defined in the current crate can be implemented for arbitrary types
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:47:1
+   |
+47 | impl<'db> std::default::Default for [MyTracked<'db>; 12] {
+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^--------------------
+   |                                     |
+   |                                     this is not defined in the current crate because arrays are always foreign
+   |
+   = note: impl doesn't have any local type before any uncovered type parameters
+   = note: for more information see https://doc.rust-lang.org/reference/items/implementations.html#orphan-rules
+   = note: define and implement a trait or new type instead
+
+error[E0308]: mismatched types
+ --> tests/compile-fail/tracked_impl_incompatibles.rs:8:21
+  |
+8 |     fn default() -> Self {}
+  |        -------      ^^^^ expected `MyTracked<'_>`, found `()`
+  |        |
+  |        implicitly returns `()` as its body has no tail or `return` expression
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:13:21
+   |
+13 |     fn default() -> Self {}
+   |        -------      ^^^^ expected `MyTracked<'_>`, found `()`
+   |        |
+   |        implicitly returns `()` as its body has no tail or `return` expression
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:18:21
+   |
+18 |     fn default() -> Self {}
+   |        -------      ^^^^ expected `MyTracked<'_>`, found `()`
+   |        |
+   |        implicitly returns `()` as its body has no tail or `return` expression
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:23:21
+   |
+23 |     fn default() -> Self {}
+   |        -------      ^^^^ expected `MyTracked<'_>`, found `()`
+   |        |
+   |        implicitly returns `()` as its body has no tail or `return` expression
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:28:21
+   |
+28 |     fn default() -> Self {}
+   |        -------      ^^^^ expected `MyTracked<'_>`, found `()`
+   |        |
+   |        implicitly returns `()` as its body has no tail or `return` expression
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:33:21
+   |
+33 |     fn default() -> Self {}
+   |        -------      ^^^^ expected `MyTracked<'_>`, found `()`
+   |        |
+   |        implicitly returns `()` as its body has no tail or `return` expression
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:38:21
+   |
+38 |     fn default() -> Self {}
+   |        -------      ^^^^ expected `MyTracked<'_>`, found `()`
+   |        |
+   |        implicitly returns `()` as its body has no tail or `return` expression
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:43:21
+   |
+43 |     fn default() -> Self {}
+   |        -------      ^^^^ expected `MyTracked<'_>`, found `()`
+   |        |
+   |        implicitly returns `()` as its body has no tail or `return` expression
+
+error[E0308]: mismatched types
+  --> tests/compile-fail/tracked_impl_incompatibles.rs:48:21
+   |
+48 |     fn default() -> Self {}
+   |        -------      ^^^^ expected `[MyTracked<'_>; 12]`, found `()`
+   |        |
+   |        implicitly returns `()` as its body has no tail or `return` expression
+   |
+   = note:  expected array `[MyTracked<'db>; 12]`
+           found unit type `()`
diff --git a/crates/salsa/tests/compile-fail/tracked_method_incompatibles.rs b/crates/salsa/tests/compile-fail/tracked_method_incompatibles.rs
new file mode 100644
index 000000000..c6df5f24f
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_method_incompatibles.rs
@@ -0,0 +1,32 @@
+#[salsa::tracked]
+struct Tracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+impl<'db> Tracked<'db> {
+    #[salsa::tracked]
+    fn ref_self(&self, db: &dyn salsa::Database) {}
+}
+
+#[salsa::tracked]
+impl<'db> Tracked<'db> {
+    #[salsa::tracked]
+    fn ref_mut_self(&mut self, db: &dyn salsa::Database) {}
+}
+
+#[salsa::tracked]
+impl<'db> Tracked<'db> {
+    #[salsa::tracked]
+    fn multiple_lifetimes<'db1>(&mut self, db: &'db1 dyn salsa::Database) {}
+}
+
+#[salsa::tracked]
+impl<'db> Tracked<'db> {
+    #[salsa::tracked]
+    fn type_generics<T>(&mut self, db: &dyn salsa::Database) -> T {
+        panic!()
+    }
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/tracked_method_incompatibles.stderr b/crates/salsa/tests/compile-fail/tracked_method_incompatibles.stderr
new file mode 100644
index 000000000..72a27a33b
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_method_incompatibles.stderr
@@ -0,0 +1,73 @@
+error: #[salsa::tracked] must also be applied to the impl block for tracked methods
+ --> tests/compile-fail/tracked_method_incompatibles.rs:9:17
+  |
+9 |     fn ref_self(&self, db: &dyn salsa::Database) {}
+  |                 ^^^^^
+
+error: tracked methods's first argument must be declared as `self`, not `&self` or `&mut self`
+ --> tests/compile-fail/tracked_method_incompatibles.rs:9:17
+  |
+9 |     fn ref_self(&self, db: &dyn salsa::Database) {}
+  |                 ^
+
+error: #[salsa::tracked] must also be applied to the impl block for tracked methods
+  --> tests/compile-fail/tracked_method_incompatibles.rs:15:21
+   |
+15 |     fn ref_mut_self(&mut self, db: &dyn salsa::Database) {}
+   |                     ^^^^^^^^^
+
+error: tracked methods's first argument must be declared as `self`, not `&self` or `&mut self`
+  --> tests/compile-fail/tracked_method_incompatibles.rs:15:21
+   |
+15 |     fn ref_mut_self(&mut self, db: &dyn salsa::Database) {}
+   |                     ^
+
+error: #[salsa::tracked] must also be applied to the impl block for tracked methods
+  --> tests/compile-fail/tracked_method_incompatibles.rs:21:33
+   |
+21 |     fn multiple_lifetimes<'db1>(&mut self, db: &'db1 dyn salsa::Database) {}
+   |                                 ^^^^^^^^^
+
+error: tracked method already has a lifetime parameter in scope
+  --> tests/compile-fail/tracked_method_incompatibles.rs:21:27
+   |
+21 |     fn multiple_lifetimes<'db1>(&mut self, db: &'db1 dyn salsa::Database) {}
+   |                           ^^^^
+
+error: only a single lifetime parameter is accepted
+  --> tests/compile-fail/tracked_method_incompatibles.rs:27:22
+   |
+27 |     fn type_generics<T>(&mut self, db: &dyn salsa::Database) -> T {
+   |                      ^
+
+error: tracked methods cannot have non-lifetime generic parameters
+  --> tests/compile-fail/tracked_method_incompatibles.rs:27:22
+   |
+27 |     fn type_generics<T>(&mut self, db: &dyn salsa::Database) -> T {
+   |                      ^
+
+warning: unused variable: `db`
+ --> tests/compile-fail/tracked_method_incompatibles.rs:9:24
+  |
+9 |     fn ref_self(&self, db: &dyn salsa::Database) {}
+  |                        ^^ help: if this is intentional, prefix it with an underscore: `_db`
+  |
+  = note: `#[warn(unused_variables)]` on by default
+
+warning: unused variable: `db`
+  --> tests/compile-fail/tracked_method_incompatibles.rs:15:32
+   |
+15 |     fn ref_mut_self(&mut self, db: &dyn salsa::Database) {}
+   |                                ^^ help: if this is intentional, prefix it with an underscore: `_db`
+
+warning: unused variable: `db`
+  --> tests/compile-fail/tracked_method_incompatibles.rs:21:44
+   |
+21 |     fn multiple_lifetimes<'db1>(&mut self, db: &'db1 dyn salsa::Database) {}
+   |                                            ^^ help: if this is intentional, prefix it with an underscore: `_db`
+
+warning: unused variable: `db`
+  --> tests/compile-fail/tracked_method_incompatibles.rs:27:36
+   |
+27 |     fn type_generics<T>(&mut self, db: &dyn salsa::Database) -> T {
+   |                                    ^^ help: if this is intentional, prefix it with an underscore: `_db`
diff --git a/crates/salsa/tests/compile-fail/tracked_method_on_untracked_impl.rs b/crates/salsa/tests/compile-fail/tracked_method_on_untracked_impl.rs
new file mode 100644
index 000000000..c9e897ee4
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_method_on_untracked_impl.rs
@@ -0,0 +1,13 @@
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+impl MyInput {
+    #[salsa::tracked]
+    fn tracked_method_on_untracked_impl(self, db: &dyn Db) -> u32 {
+        input.field(db)
+    }
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/tracked_method_on_untracked_impl.stderr b/crates/salsa/tests/compile-fail/tracked_method_on_untracked_impl.stderr
new file mode 100644
index 000000000..f1e006221
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_method_on_untracked_impl.stderr
@@ -0,0 +1,17 @@
+error: #[salsa::tracked] must also be applied to the impl block for tracked methods
+ --> tests/compile-fail/tracked_method_on_untracked_impl.rs:8:41
+  |
+8 |     fn tracked_method_on_untracked_impl(self, db: &dyn Db) -> u32 {
+  |                                         ^^^^
+
+error[E0405]: cannot find trait `Db` in this scope
+ --> tests/compile-fail/tracked_method_on_untracked_impl.rs:8:56
+  |
+8 |     fn tracked_method_on_untracked_impl(self, db: &dyn Db) -> u32 {
+  |                                                        ^^ not found in this scope
+
+error[E0425]: cannot find value `input` in this scope
+ --> tests/compile-fail/tracked_method_on_untracked_impl.rs:9:9
+  |
+9 |         input.field(db)
+  |         ^^^^^ not found in this scope
diff --git a/crates/salsa/tests/compile-fail/tracked_struct_incompatibles.rs b/crates/salsa/tests/compile-fail/tracked_struct_incompatibles.rs
new file mode 100644
index 000000000..a128226c0
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_struct_incompatibles.rs
@@ -0,0 +1,31 @@
+#[salsa::tracked(returns(ref))]
+struct TrackedWithRetRef {
+    field: u32,
+}
+
+#[salsa::tracked(specify)]
+struct TrackedSructWithSpecify {
+    field: u32,
+}
+
+#[salsa::tracked(no_eq)]
+struct TrackedStructWithNoEq {
+    field: u32,
+}
+
+#[salsa::tracked(db = Db)]
+struct TrackedStructWithDb {
+    field: u32,
+}
+
+#[salsa::tracked(recover_fn = recover)]
+struct TrackedStructWithRecover {
+    field: u32,
+}
+
+#[salsa::tracked(lru = 12)]
+struct TrackedStructWithLru {
+    field: u32,
+}
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/tracked_struct_incompatibles.stderr b/crates/salsa/tests/compile-fail/tracked_struct_incompatibles.stderr
new file mode 100644
index 000000000..c0fb9c30b
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_struct_incompatibles.stderr
@@ -0,0 +1,35 @@
+error: `returns` option not allowed here
+ --> tests/compile-fail/tracked_struct_incompatibles.rs:1:18
+  |
+1 | #[salsa::tracked(returns(ref))]
+  |                  ^^^^^^^
+
+error: `specify` option not allowed here
+ --> tests/compile-fail/tracked_struct_incompatibles.rs:6:18
+  |
+6 | #[salsa::tracked(specify)]
+  |                  ^^^^^^^
+
+error: `no_eq` option not allowed here
+  --> tests/compile-fail/tracked_struct_incompatibles.rs:11:18
+   |
+11 | #[salsa::tracked(no_eq)]
+   |                  ^^^^^
+
+error: `db` option not allowed here
+  --> tests/compile-fail/tracked_struct_incompatibles.rs:16:18
+   |
+16 | #[salsa::tracked(db = Db)]
+   |                  ^^
+
+error: unrecognized option `recover_fn`
+  --> tests/compile-fail/tracked_struct_incompatibles.rs:21:18
+   |
+21 | #[salsa::tracked(recover_fn = recover)]
+   |                  ^^^^^^^^^^
+
+error: `lru` option not allowed here
+  --> tests/compile-fail/tracked_struct_incompatibles.rs:26:18
+   |
+26 | #[salsa::tracked(lru = 12)]
+   |                  ^^^
diff --git a/crates/salsa/tests/compile-fail/tracked_struct_not_update.rs b/crates/salsa/tests/compile-fail/tracked_struct_not_update.rs
new file mode 100644
index 000000000..91dbc8fce
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_struct_not_update.rs
@@ -0,0 +1,9 @@
+#[salsa::tracked]
+struct MyInput<'db> {
+    field: NotUpdate,
+}
+
+#[derive(Clone, Debug, Hash)]
+struct NotUpdate;
+
+fn main() {}
diff --git a/crates/salsa/tests/compile-fail/tracked_struct_not_update.stderr b/crates/salsa/tests/compile-fail/tracked_struct_not_update.stderr
new file mode 100644
index 000000000..c67b7d8a6
--- /dev/null
+++ b/crates/salsa/tests/compile-fail/tracked_struct_not_update.stderr
@@ -0,0 +1,34 @@
+error[E0599]: the function or associated item `maybe_update` exists for struct `UpdateDispatch<NotUpdate>`, but its trait bounds were not satisfied
+ --> tests/compile-fail/tracked_struct_not_update.rs:1:1
+  |
+1 | #[salsa::tracked]
+  | ^^^^^^^^^^^^^^^^^ function or associated item cannot be called on `UpdateDispatch<NotUpdate>` due to unsatisfied trait bounds
+...
+7 | struct NotUpdate;
+  | ---------------- doesn't satisfy `NotUpdate: PartialEq` or `NotUpdate: Update`
+  |
+ ::: src/update.rs
+  |
+  |     pub struct Dispatch<D>(PhantomData<D>);
+  |     ---------------------- doesn't satisfy `_: UpdateFallback<NotUpdate>`
+  |
+note: if you're trying to build a new `UpdateDispatch<NotUpdate>`, consider using `UpdateDispatch::<D>::new` which returns `UpdateDispatch<_>`
+ --> src/update.rs
+  |
+  |         pub fn new() -> Self {
+  |         ^^^^^^^^^^^^^^^^^^^^
+  = note: the following trait bounds were not satisfied:
+          `NotUpdate: Update`
+          `NotUpdate: PartialEq`
+          which is required by `UpdateDispatch<NotUpdate>: UpdateFallback<NotUpdate>`
+note: the trait `Update` must be implemented
+ --> src/update.rs
+  |
+  | pub unsafe trait Update {
+  | ^^^^^^^^^^^^^^^^^^^^^^^
+  = note: this error originates in the macro `salsa::plumbing::setup_tracked_struct` which comes from the expansion of the attribute macro `salsa::tracked` (in Nightly builds, run with -Z macro-backtrace for more info)
+help: consider annotating `NotUpdate` with `#[derive(PartialEq)]`
+  |
+7   + #[derive(PartialEq)]
+8   | struct NotUpdate;
+    |
diff --git a/crates/salsa/tests/compile_fail.rs b/crates/salsa/tests/compile_fail.rs
new file mode 100644
index 000000000..3b4a37fcf
--- /dev/null
+++ b/crates/salsa/tests/compile_fail.rs
@@ -0,0 +1,6 @@
+#[rustversion::all(stable, since(1.84))]
+#[test]
+fn compile_fail() {
+    let t = trybuild::TestCases::new();
+    t.compile_fail("tests/compile-fail/*.rs");
+}
diff --git a/crates/salsa/tests/cycle.rs b/crates/salsa/tests/cycle.rs
new file mode 100644
index 000000000..088102e7a
--- /dev/null
+++ b/crates/salsa/tests/cycle.rs
@@ -0,0 +1,1026 @@
+//! Test cases for fixpoint iteration cycle resolution.
+//!
+//! These test cases use a generic query setup that allows constructing arbitrary dependency
+//! graphs, and attempts to achieve good coverage of various cases.
+mod common;
+use common::{ExecuteValidateLoggerDatabase, LogDatabase};
+use expect_test::expect;
+use salsa::{CycleRecoveryAction, Database as Db, DatabaseImpl as DbImpl, Durability, Setter};
+#[cfg(not(miri))]
+use test_log::test;
+
+#[derive(Clone, Copy, Debug, PartialEq, Eq, salsa::Update)]
+enum Value {
+    N(u8),
+    OutOfBounds,
+    TooManyIterations,
+}
+
+impl Value {
+    fn to_value(self) -> Option<u8> {
+        if let Self::N(val) = self {
+            Some(val)
+        } else {
+            None
+        }
+    }
+}
+
+/// A vector of inputs a query can evaluate to get an iterator of values to operate on.
+///
+/// This allows creating arbitrary query graphs between the four queries below (`min_iterate`,
+/// `max_iterate`, `min_panic`, `max_panic`) for testing cycle behaviors.
+#[salsa::input]
+struct Inputs {
+    #[returns(ref)]
+    inputs: Vec<Input>,
+}
+
+impl Inputs {
+    fn values(self, db: &dyn Db) -> impl Iterator<Item = Value> + '_ {
+        self.inputs(db).iter().map(|input| input.eval(db))
+    }
+}
+
+/// A single input, evaluating to a single [`Value`].
+#[derive(Clone)]
+enum Input {
+    /// a simple value
+    Value(Value),
+
+    /// a simple value, reported as an untracked read
+    UntrackedRead(Value),
+
+    /// minimum of the given inputs, with fixpoint iteration on cycles
+    MinIterate(Inputs),
+
+    /// maximum of the given inputs, with fixpoint iteration on cycles
+    MaxIterate(Inputs),
+
+    /// minimum of the given inputs, panicking on cycles
+    MinPanic(Inputs),
+
+    /// maximum of the given inputs, panicking on cycles
+    MaxPanic(Inputs),
+
+    /// value of the given input, plus one; propagates error values
+    Successor(Box<Input>),
+
+    /// successor, converts error values to zero
+    SuccessorOrZero(Box<Input>),
+}
+
+impl Input {
+    fn eval(&self, db: &dyn Db) -> Value {
+        match *self {
+            Self::Value(value) => value,
+            Self::UntrackedRead(value) => {
+                db.report_untracked_read();
+                value
+            }
+            Self::MinIterate(inputs) => min_iterate(db, inputs),
+            Self::MaxIterate(inputs) => max_iterate(db, inputs),
+            Self::MinPanic(inputs) => min_panic(db, inputs),
+            Self::MaxPanic(inputs) => max_panic(db, inputs),
+            Self::Successor(ref input) => match input.eval(db) {
+                Value::N(num) => Value::N(num + 1),
+                other => other,
+            },
+            Self::SuccessorOrZero(ref input) => match input.eval(db) {
+                Value::N(num) => Value::N(num + 1),
+                _ => Value::N(0),
+            },
+        }
+    }
+
+    fn assert(&self, db: &dyn Db, expected: Value) {
+        assert_eq!(self.eval(db), expected)
+    }
+
+    fn assert_value(&self, db: &dyn Db, expected: u8) {
+        self.assert(db, Value::N(expected))
+    }
+
+    fn assert_bounds(&self, db: &dyn Db) {
+        self.assert(db, Value::OutOfBounds)
+    }
+
+    fn assert_count(&self, db: &dyn Db) {
+        self.assert(db, Value::TooManyIterations)
+    }
+}
+
+const MIN_VALUE: u8 = 10;
+const MAX_VALUE: u8 = 245;
+const MAX_ITERATIONS: u32 = 3;
+
+/// Recover from a cycle by falling back to `Value::OutOfBounds` if the value is out of bounds,
+/// `Value::TooManyIterations` if we've iterated more than `MAX_ITERATIONS` times, or else
+/// iterating again.
+fn cycle_recover(
+    _db: &dyn Db,
+    value: &Value,
+    count: u32,
+    _inputs: Inputs,
+) -> CycleRecoveryAction<Value> {
+    if value
+        .to_value()
+        .is_some_and(|val| val <= MIN_VALUE || val >= MAX_VALUE)
+    {
+        CycleRecoveryAction::Fallback(Value::OutOfBounds)
+    } else if count > MAX_ITERATIONS {
+        CycleRecoveryAction::Fallback(Value::TooManyIterations)
+    } else {
+        CycleRecoveryAction::Iterate
+    }
+}
+
+/// Fold an iterator of `Value` into a `Value`, given some binary operator to apply to two `u8`.
+/// `Value::TooManyIterations` and `Value::OutOfBounds` will always propagate, with
+/// `Value::TooManyIterations` taking precedence.
+fn fold_values<F>(values: impl IntoIterator<Item = Value>, op: F) -> Value
+where
+    F: Fn(u8, u8) -> u8,
+{
+    values
+        .into_iter()
+        .fold(None, |accum, elem| {
+            let Some(accum) = accum else {
+                return Some(elem);
+            };
+            match (accum, elem) {
+                (Value::TooManyIterations, _) | (_, Value::TooManyIterations) => {
+                    Some(Value::TooManyIterations)
+                }
+                (Value::OutOfBounds, _) | (_, Value::OutOfBounds) => Some(Value::OutOfBounds),
+                (Value::N(val1), Value::N(val2)) => Some(Value::N(op(val1, val2))),
+            }
+        })
+        .expect("inputs should not be empty")
+}
+
+/// Query minimum value of inputs, with cycle recovery.
+#[salsa::tracked(cycle_fn=cycle_recover, cycle_initial=min_initial)]
+fn min_iterate<'db>(db: &'db dyn Db, inputs: Inputs) -> Value {
+    fold_values(inputs.values(db), u8::min)
+}
+
+fn min_initial(_db: &dyn Db, _inputs: Inputs) -> Value {
+    Value::N(255)
+}
+
+/// Query maximum value of inputs, with cycle recovery.
+#[salsa::tracked(cycle_fn=cycle_recover, cycle_initial=max_initial)]
+fn max_iterate<'db>(db: &'db dyn Db, inputs: Inputs) -> Value {
+    fold_values(inputs.values(db), u8::max)
+}
+
+fn max_initial(_db: &dyn Db, _inputs: Inputs) -> Value {
+    Value::N(0)
+}
+
+/// Query minimum value of inputs, without cycle recovery.
+#[salsa::tracked]
+fn min_panic<'db>(db: &'db dyn Db, inputs: Inputs) -> Value {
+    fold_values(inputs.values(db), u8::min)
+}
+
+/// Query maximum value of inputs, without cycle recovery.
+#[salsa::tracked]
+fn max_panic<'db>(db: &'db dyn Db, inputs: Inputs) -> Value {
+    fold_values(inputs.values(db), u8::max)
+}
+
+fn untracked(num: u8) -> Input {
+    Input::UntrackedRead(Value::N(num))
+}
+
+fn value(num: u8) -> Input {
+    Input::Value(Value::N(num))
+}
+
+// Diagram nomenclature for nodes: Each node is represented as a:xx(ii), where `a` is a sequential
+// identifier from `a`, `b`, `c`..., xx is one of the four query kinds:
+// - `Ni` for `min_iterate`
+// - `Xi` for `max_iterate`
+// - `Np` for `min_panic`
+// - `Xp` for `max_panic`
+//\
+// and `ii` is the inputs for that query, represented as a comma-separated list, with each
+// component representing an input:
+// - `a`, `b`, `c`... where the input is another node,
+// - `uXX` for `UntrackedRead(XX)`
+// - `vXX` for `Value(XX)`
+// - `sY` for `Successor(Y)`
+// - `zY` for `SuccessorOrZero(Y)`
+//
+// We always enter from the top left node in the diagram.
+
+/// a:Np(a) -+
+/// ^        |
+/// +--------+
+///
+/// Simple self-cycle, no iteration, should panic.
+#[test]
+#[should_panic(expected = "dependency graph cycle")]
+fn self_panic() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let a = Input::MinPanic(a_in);
+    a_in.set_inputs(&mut db).to(vec![a.clone()]);
+
+    a.eval(&db);
+}
+
+/// a:Np(u10, a) -+
+/// ^             |
+/// +-------------+
+///
+/// Simple self-cycle with untracked read, no iteration, should panic.
+#[test]
+#[should_panic(expected = "dependency graph cycle")]
+fn self_untracked_panic() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let a = Input::MinPanic(a_in);
+    a_in.set_inputs(&mut db).to(vec![untracked(10), a.clone()]);
+
+    a.eval(&db);
+}
+
+/// a:Ni(a) -+
+/// ^        |
+/// +--------+
+///
+/// Simple self-cycle, iteration converges on initial value.
+#[test]
+fn self_converge_initial_value() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    a_in.set_inputs(&mut db).to(vec![a.clone()]);
+
+    a.assert_value(&db, 255);
+}
+
+/// a:Ni(b) --> b:Np(a)
+/// ^                 |
+/// +-----------------+
+///
+/// Two-query cycle, one with iteration and one without.
+/// If we enter from the one with iteration, we converge on its initial value.
+#[test]
+fn two_mixed_converge_initial_value() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinPanic(b_in);
+    a_in.set_inputs(&mut db).to(vec![b]);
+    b_in.set_inputs(&mut db).to(vec![a.clone()]);
+
+    a.assert_value(&db, 255);
+}
+
+/// a:Np(b) --> b:Ni(a)
+/// ^                 |
+/// +-----------------+
+///
+/// Two-query cycle, one with iteration and one without.
+/// If we enter from the one with no iteration, we panic.
+#[test]
+#[should_panic(expected = "dependency graph cycle")]
+fn two_mixed_panic() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let a = Input::MinPanic(b_in);
+    let b = Input::MinIterate(a_in);
+    a_in.set_inputs(&mut db).to(vec![b]);
+    b_in.set_inputs(&mut db).to(vec![a.clone()]);
+
+    a.eval(&db);
+}
+
+/// a:Ni(b) --> b:Xi(a)
+/// ^                 |
+/// +-----------------+
+///
+/// Two-query cycle, both with iteration.
+/// We converge on the initial value of whichever we first enter from.
+#[test]
+fn two_iterate_converge_initial_value() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MaxIterate(b_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![a.clone()]);
+
+    a.assert_value(&db, 255);
+    b.assert_value(&db, 255);
+}
+
+/// a:Xi(b) --> b:Ni(a)
+/// ^                 |
+/// +-----------------+
+///
+/// Two-query cycle, both with iteration.
+/// We converge on the initial value of whichever we enter from.
+/// (Same setup as above test, different query order.)
+#[test]
+fn two_iterate_converge_initial_value_2() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxIterate(a_in);
+    let b = Input::MinIterate(b_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![a.clone()]);
+
+    a.assert_value(&db, 0);
+    b.assert_value(&db, 0);
+}
+
+/// a:Np(b) --> b:Ni(c) --> c:Xp(b)
+///             ^                 |
+///             +-----------------+
+///
+/// Two-query cycle, enter indirectly at node with iteration, converge on its initial value.
+#[test]
+fn two_indirect_iterate_converge_initial_value() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinPanic(a_in);
+    let b = Input::MinIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c]);
+    c_in.set_inputs(&mut db).to(vec![b]);
+
+    a.assert_value(&db, 255);
+}
+
+/// a:Xp(b) --> b:Np(c) --> c:Xi(b)
+///             ^                 |
+///             +-----------------+
+///
+/// Two-query cycle, enter indirectly at node without iteration, panic.
+#[test]
+#[should_panic(expected = "dependency graph cycle")]
+fn two_indirect_panic() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinPanic(a_in);
+    let b = Input::MinPanic(b_in);
+    let c = Input::MaxIterate(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c]);
+    c_in.set_inputs(&mut db).to(vec![b]);
+
+    a.eval(&db);
+}
+
+/// a:Np(b) -> b:Ni(v200,c) -> c:Xp(b)
+///            ^                     |
+///            +---------------------+
+///
+/// Two-query cycle, converges to non-initial value.
+#[test]
+fn two_converge() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinPanic(a_in);
+    let b = Input::MinIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![value(200), c]);
+    c_in.set_inputs(&mut db).to(vec![b]);
+
+    a.assert_value(&db, 200);
+}
+
+/// a:Xp(b) -> b:Xi(v20,c) -> c:Xp(sb)
+///            ^                     |
+///            +---------------------+
+///
+/// Two-query cycle, falls back due to >3 iterations.
+#[test]
+fn two_fallback_count() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxPanic(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![value(20), c]);
+    c_in.set_inputs(&mut db)
+        .to(vec![Input::Successor(Box::new(b))]);
+
+    a.assert_count(&db);
+}
+
+/// a:Xp(b) -> b:Xi(v20,c) -> c:Xp(zb)
+///            ^                     |
+///            +---------------------+
+///
+/// Two-query cycle, falls back but fallback does not converge.
+#[test]
+#[should_panic(expected = "fallback did not converge")]
+fn two_fallback_diverge() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxPanic(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![value(20), c.clone()]);
+    c_in.set_inputs(&mut db)
+        .to(vec![Input::SuccessorOrZero(Box::new(b))]);
+
+    a.assert_count(&db);
+}
+
+/// a:Xp(b) -> b:Xi(v244,c) -> c:Xp(sb)
+///            ^                     |
+///            +---------------------+
+///
+/// Two-query cycle, falls back due to value reaching >MAX_VALUE (we start at 244 and each
+/// iteration increments until we reach >245).
+#[test]
+fn two_fallback_value() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxPanic(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![value(244), c]);
+    c_in.set_inputs(&mut db)
+        .to(vec![Input::Successor(Box::new(b))]);
+
+    a.assert_bounds(&db);
+}
+
+/// a:Ni(b) -> b:Np(a, c) -> c:Np(v25, a)
+/// ^          |                        |
+/// +----------+------------------------+
+///
+/// Three-query cycle, (b) and (c) both depend on (a). We converge on 25.
+#[test]
+fn three_fork_converge() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinPanic(b_in);
+    let c = Input::MinPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b]);
+    b_in.set_inputs(&mut db).to(vec![a.clone(), c]);
+    c_in.set_inputs(&mut db).to(vec![value(25), a.clone()]);
+
+    a.assert_value(&db, 25);
+}
+
+/// a:Ni(b) -> b:Ni(a, c) -> c:Np(v25, b)
+/// ^          |        ^          |
+/// +----------+        +----------+
+///
+/// Layered cycles. We converge on 25.
+#[test]
+fn layered_converge() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinIterate(b_in);
+    let c = Input::MinPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![a.clone(), c]);
+    c_in.set_inputs(&mut db).to(vec![value(25), b]);
+
+    a.assert_value(&db, 25);
+}
+
+/// a:Xi(b) -> b:Xi(a, c) -> c:Xp(v25, sb)
+/// ^          |        ^          |
+/// +----------+        +----------+
+///
+/// Layered cycles. We hit max iterations and fall back.
+#[test]
+fn layered_fallback_count() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxIterate(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![a.clone(), c]);
+    c_in.set_inputs(&mut db)
+        .to(vec![value(25), Input::Successor(Box::new(b))]);
+    a.assert_count(&db);
+}
+
+/// a:Xi(b) -> b:Xi(a, c) -> c:Xp(v243, sb)
+/// ^          |        ^          |
+/// +----------+        +----------+
+///
+/// Layered cycles. We hit max value and fall back.
+#[test]
+fn layered_fallback_value() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxIterate(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![a.clone(), c]);
+    c_in.set_inputs(&mut db)
+        .to(vec![value(243), Input::Successor(Box::new(b))]);
+
+    a.assert_bounds(&db);
+}
+
+/// a:Ni(b) -> b:Ni(c) -> c:Np(v25, a, b)
+/// ^          ^                        |
+/// +----------+------------------------+
+///
+/// Nested cycles. We converge on 25.
+#[test]
+fn nested_converge() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinIterate(b_in);
+    let c = Input::MinPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c]);
+    c_in.set_inputs(&mut db).to(vec![value(25), a.clone(), b]);
+
+    a.assert_value(&db, 25);
+}
+
+/// a:Ni(b) -> b:Ni(c) -> c:Np(v25, b, a)
+/// ^          ^                        |
+/// +----------+------------------------+
+///
+/// Nested cycles, inner first. We converge on 25.
+#[test]
+fn nested_inner_first_converge() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinIterate(b_in);
+    let c = Input::MinPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c]);
+    c_in.set_inputs(&mut db).to(vec![value(25), b, a.clone()]);
+
+    a.assert_value(&db, 25);
+}
+
+/// a:Xi(b) -> b:Xi(c) -> c:Xp(v25, a, sb)
+/// ^          ^                         |
+/// +----------+-------------------------+
+///
+/// Nested cycles. We hit max iterations and fall back.
+#[test]
+fn nested_fallback_count() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxIterate(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c]);
+    c_in.set_inputs(&mut db)
+        .to(vec![value(25), a.clone(), Input::Successor(Box::new(b))]);
+
+    a.assert_count(&db);
+}
+
+/// a:Xi(b) -> b:Xi(c) -> c:Xp(v25, b, sa)
+/// ^          ^                         |
+/// +----------+-------------------------+
+///
+/// Nested cycles, inner first. We hit max iterations and fall back.
+#[test]
+fn nested_inner_first_fallback_count() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxIterate(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c]);
+    c_in.set_inputs(&mut db)
+        .to(vec![value(25), b, Input::Successor(Box::new(a.clone()))]);
+
+    a.assert_count(&db);
+}
+
+/// a:Xi(b) -> b:Xi(c) -> c:Xp(v243, a, sb)
+/// ^          ^                          |
+/// +----------+--------------------------+
+///
+/// Nested cycles. We hit max value and fall back.
+#[test]
+fn nested_fallback_value() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxIterate(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c.clone()]);
+    c_in.set_inputs(&mut db).to(vec![
+        value(243),
+        a.clone(),
+        Input::Successor(Box::new(b.clone())),
+    ]);
+    a.assert_bounds(&db);
+    b.assert_bounds(&db);
+    c.assert_bounds(&db);
+}
+
+/// a:Xi(b) -> b:Xi(c) -> c:Xp(v243, b, sa)
+/// ^          ^                          |
+/// +----------+--------------------------+
+///
+/// Nested cycles, inner first. We hit max value and fall back.
+#[test]
+fn nested_inner_first_fallback_value() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxIterate(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c]);
+    c_in.set_inputs(&mut db)
+        .to(vec![value(243), b, Input::Successor(Box::new(a.clone()))]);
+
+    a.assert_bounds(&db);
+}
+
+/// a:Ni(b) -> b:Ni(c, a) -> c:Np(v25, a, b)
+/// ^          ^        |                  |
+/// +----------+--------|------------------+
+/// |                   |
+/// +-------------------+
+///
+/// Nested cycles, double head. We converge on 25.
+#[test]
+fn nested_double_converge() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinIterate(b_in);
+    let c = Input::MinPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c, a.clone()]);
+    c_in.set_inputs(&mut db).to(vec![value(25), a.clone(), b]);
+
+    a.assert_value(&db, 25);
+}
+
+// Multiple-revision cycles
+
+/// a:Ni(b) --> b:Np(a)
+/// ^                 |
+/// +-----------------+
+///
+/// a:Ni(b) --> b:Np(v30)
+///
+/// Cycle becomes not-a-cycle in next revision.
+#[test]
+fn cycle_becomes_non_cycle() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinPanic(b_in);
+    a_in.set_inputs(&mut db).to(vec![b]);
+    b_in.set_inputs(&mut db).to(vec![a.clone()]);
+
+    a.assert_value(&db, 255);
+
+    b_in.set_inputs(&mut db).to(vec![value(30)]);
+
+    a.assert_value(&db, 30);
+}
+
+/// a:Ni(b) --> b:Np(v30)
+///
+/// a:Ni(b) --> b:Np(a)
+/// ^                 |
+/// +-----------------+
+///
+/// Non-cycle becomes a cycle in next revision.
+#[test]
+fn non_cycle_becomes_cycle() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinPanic(b_in);
+    a_in.set_inputs(&mut db).to(vec![b]);
+    b_in.set_inputs(&mut db).to(vec![value(30)]);
+
+    a.assert_value(&db, 30);
+
+    b_in.set_inputs(&mut db).to(vec![a.clone()]);
+
+    a.assert_value(&db, 255);
+}
+
+/// a:Xi(b) -> b:Xi(c, a) -> c:Xp(v25, a, sb)
+/// ^          ^        |                   |
+/// +----------+--------|-------------------+
+/// |                   |
+/// +-------------------+
+///
+/// Nested cycles, double head. We hit max iterations and fall back, then max value on the next
+/// revision, then converge on the next.
+#[test]
+fn nested_double_multiple_revisions() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MaxIterate(a_in);
+    let b = Input::MaxIterate(b_in);
+    let c = Input::MaxPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![c, a.clone()]);
+    c_in.set_inputs(&mut db).to(vec![
+        value(25),
+        a.clone(),
+        Input::Successor(Box::new(b.clone())),
+    ]);
+
+    a.assert_count(&db);
+
+    // next revision, we hit max value instead
+    c_in.set_inputs(&mut db).to(vec![
+        value(243),
+        a.clone(),
+        Input::Successor(Box::new(b.clone())),
+    ]);
+
+    a.assert_bounds(&db);
+
+    // and next revision, we converge
+    c_in.set_inputs(&mut db)
+        .to(vec![value(240), a.clone(), b.clone()]);
+
+    a.assert_value(&db, 240);
+
+    // one more revision, without relevant changes
+    a_in.set_inputs(&mut db).to(vec![b]);
+
+    a.assert_value(&db, 240);
+}
+
+/// a:Ni(b) -> b:Ni(c) -> c:Ni(a)
+/// ^                           |
+/// +---------------------------+
+///
+/// In a cycle with some LOW durability and some HIGH durability inputs, changing a LOW durability
+/// input still re-executes the full cycle in the next revision.
+#[test]
+fn cycle_durability() {
+    let mut db = DbImpl::new();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinIterate(b_in);
+    let c = Input::MinIterate(c_in);
+    a_in.set_inputs(&mut db)
+        .with_durability(Durability::LOW)
+        .to(vec![b.clone()]);
+    b_in.set_inputs(&mut db)
+        .with_durability(Durability::HIGH)
+        .to(vec![c]);
+    c_in.set_inputs(&mut db)
+        .with_durability(Durability::HIGH)
+        .to(vec![a.clone()]);
+
+    a.assert_value(&db, 255);
+
+    // next revision, we converge instead
+    a_in.set_inputs(&mut db)
+        .with_durability(Durability::LOW)
+        .to(vec![value(45), b]);
+
+    a.assert_value(&db, 45);
+}
+
+/// a:Np(v59, b) -> b:Ni(v60, c) -> c:Np(b)
+///                 ^                     |
+///                 +---------------------+
+///
+/// If nothing in a cycle changed in the new revision, no part of the cycle should re-execute.
+#[test]
+fn cycle_unchanged() {
+    let mut db = ExecuteValidateLoggerDatabase::default();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinPanic(a_in);
+    let b = Input::MinIterate(b_in);
+    let c = Input::MinPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![value(59), b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![value(60), c]);
+    c_in.set_inputs(&mut db).to(vec![b.clone()]);
+
+    a.assert_value(&db, 59);
+    b.assert_value(&db, 60);
+
+    db.assert_logs_len(5);
+
+    // next revision, we change only A, which is not part of the cycle and the cycle does not
+    // depend on.
+    a_in.set_inputs(&mut db).to(vec![value(45), b.clone()]);
+    b.assert_value(&db, 60);
+
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(DidValidateMemoizedValue { database_key: min_iterate(Id(1)) })",
+        ]"#]]);
+
+    a.assert_value(&db, 45);
+}
+
+/// a:Np(v59, b) -> b:Ni(v60, c) -> c:Np(d) -> d:Ni(v61, b, e) -> e:Np(d)
+///                 ^                          |   ^              |
+///                 +--------------------------+   +--------------+
+///
+/// If nothing in a nested cycle changed in the new revision, no part of the cycle should
+/// re-execute.
+#[test]
+fn cycle_unchanged_nested() {
+    let mut db = ExecuteValidateLoggerDatabase::default();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let d_in = Inputs::new(&db, vec![]);
+    let e_in = Inputs::new(&db, vec![]);
+    let a = Input::MinPanic(a_in);
+    let b = Input::MinIterate(b_in);
+    let c = Input::MinPanic(c_in);
+    let d = Input::MinIterate(d_in);
+    let e = Input::MinPanic(e_in);
+    a_in.set_inputs(&mut db).to(vec![value(59), b.clone()]);
+    b_in.set_inputs(&mut db).to(vec![value(60), c.clone()]);
+    c_in.set_inputs(&mut db).to(vec![d.clone()]);
+    d_in.set_inputs(&mut db)
+        .to(vec![value(61), b.clone(), e.clone()]);
+    e_in.set_inputs(&mut db).to(vec![d.clone()]);
+
+    a.assert_value(&db, 59);
+    b.assert_value(&db, 60);
+
+    db.assert_logs_len(13);
+
+    // next revision, we change only A, which is not part of the cycle and the cycle does not
+    // depend on.
+    a_in.set_inputs(&mut db).to(vec![value(45), b.clone()]);
+    b.assert_value(&db, 60);
+
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(DidValidateMemoizedValue { database_key: min_iterate(Id(1)) })",
+        ]"#]]);
+
+    a.assert_value(&db, 45);
+}
+
+///                                 +--------------------------------+
+///                                 |                                v
+/// a:Np(v59, b) -> b:Ni(v60, c) -> c:Np(d, e) -> d:Ni(v61, b, e) -> e:Ni(d)
+///                 ^                             |   ^              |
+///                 +-----------------------------+   +--------------+
+///
+/// If nothing in a nested cycle changed in the new revision, no part of the cycle should
+/// re-execute.
+#[test_log::test]
+fn cycle_unchanged_nested_intertwined() {
+    // We run this test twice in order to catch some subtly different cases; see below.
+    for i in 0..1 {
+        let mut db = ExecuteValidateLoggerDatabase::default();
+        let a_in = Inputs::new(&db, vec![]);
+        let b_in = Inputs::new(&db, vec![]);
+        let c_in = Inputs::new(&db, vec![]);
+        let d_in = Inputs::new(&db, vec![]);
+        let e_in = Inputs::new(&db, vec![]);
+        let a = Input::MinPanic(a_in);
+        let b = Input::MinIterate(b_in);
+        let c = Input::MinPanic(c_in);
+        let d = Input::MinIterate(d_in);
+        let e = Input::MinIterate(e_in);
+        a_in.set_inputs(&mut db).to(vec![value(59), b.clone()]);
+        b_in.set_inputs(&mut db).to(vec![value(60), c.clone()]);
+        c_in.set_inputs(&mut db).to(vec![d.clone(), e.clone()]);
+        d_in.set_inputs(&mut db)
+            .to(vec![value(61), b.clone(), e.clone()]);
+        e_in.set_inputs(&mut db).to(vec![d.clone()]);
+
+        a.assert_value(&db, 59);
+        b.assert_value(&db, 60);
+
+        // First time we run this test, don't fetch c/d/e here; this means they won't get marked
+        // `verified_final` in R6 (this revision), which will leave us in the next revision (R7)
+        // with a chain of could-be-provisional memos from the previous revision which should be
+        // final but were never confirmed as such; this triggers the case in `deep_verify_memo`
+        // where we need to double-check `validate_provisional` after traversing dependencies.
+        //
+        // Second time we run this test, fetch everything in R6, to check the behavior of
+        // `maybe_changed_after` with all validated-final memos.
+        if i == 1 {
+            c.assert_value(&db, 60);
+            d.assert_value(&db, 60);
+            e.assert_value(&db, 60);
+        }
+
+        db.assert_logs_len(15 + i);
+
+        // next revision, we change only A, which is not part of the cycle and the cycle does not
+        // depend on.
+        a_in.set_inputs(&mut db).to(vec![value(45), b.clone()]);
+        b.assert_value(&db, 60);
+
+        db.assert_logs(expect![[r#"
+            [
+                "salsa_event(DidValidateMemoizedValue { database_key: min_iterate(Id(1)) })",
+            ]"#]]);
+
+        a.assert_value(&db, 45);
+    }
+}
+
+/// Provisional query results in a cycle should still be cached within a single iteration.
+///
+/// a:Ni(v59, b) -> b:Np(v60, c, c, c) -> c:Np(a)
+/// ^                                          |
+/// +------------------------------------------+
+#[test]
+fn repeat_provisional_query() {
+    let mut db = ExecuteValidateLoggerDatabase::default();
+    let a_in = Inputs::new(&db, vec![]);
+    let b_in = Inputs::new(&db, vec![]);
+    let c_in = Inputs::new(&db, vec![]);
+    let a = Input::MinIterate(a_in);
+    let b = Input::MinPanic(b_in);
+    let c = Input::MinPanic(c_in);
+    a_in.set_inputs(&mut db).to(vec![value(59), b.clone()]);
+    b_in.set_inputs(&mut db)
+        .to(vec![value(60), c.clone(), c.clone(), c]);
+    c_in.set_inputs(&mut db).to(vec![a.clone()]);
+
+    a.assert_value(&db, 59);
+
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(WillExecute { database_key: min_iterate(Id(0)) })",
+            "salsa_event(WillExecute { database_key: min_panic(Id(1)) })",
+            "salsa_event(WillExecute { database_key: min_panic(Id(2)) })",
+            "salsa_event(WillIterateCycle { database_key: min_iterate(Id(0)), iteration_count: 1, fell_back: false })",
+            "salsa_event(WillExecute { database_key: min_panic(Id(1)) })",
+            "salsa_event(WillExecute { database_key: min_panic(Id(2)) })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/cycle_accumulate.rs b/crates/salsa/tests/cycle_accumulate.rs
new file mode 100644
index 000000000..d547b5760
--- /dev/null
+++ b/crates/salsa/tests/cycle_accumulate.rs
@@ -0,0 +1,324 @@
+use std::collections::HashSet;
+
+mod common;
+use common::{LogDatabase, LoggerDatabase};
+use expect_test::expect;
+use salsa::{Accumulator, Setter};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct File {
+    name: String,
+    dependencies: Vec<File>,
+    issues: Vec<u32>,
+}
+
+#[salsa::accumulator]
+#[derive(Debug)]
+struct Diagnostic(#[allow(dead_code)] String);
+
+#[salsa::tracked(cycle_fn = cycle_fn, cycle_initial = cycle_initial)]
+fn check_file(db: &dyn LogDatabase, file: File) -> Vec<u32> {
+    db.push_log(format!(
+        "check_file(name = {}, issues = {:?})",
+        file.name(db),
+        file.issues(db)
+    ));
+
+    let mut collected_issues = HashSet::<u32>::from_iter(file.issues(db).iter().copied());
+
+    for dep in file.dependencies(db) {
+        let issues = check_file(db, dep);
+        collected_issues.extend(issues);
+    }
+
+    let mut sorted_issues = collected_issues.iter().copied().collect::<Vec<_>>();
+    sorted_issues.sort();
+
+    for issue in &sorted_issues {
+        Diagnostic(format!("file {}: issue {}", file.name(db), issue)).accumulate(db);
+    }
+
+    sorted_issues
+}
+
+fn cycle_initial(_db: &dyn LogDatabase, _file: File) -> Vec<u32> {
+    vec![]
+}
+
+fn cycle_fn(
+    _db: &dyn LogDatabase,
+    _value: &[u32],
+    _count: u32,
+    _file: File,
+) -> salsa::CycleRecoveryAction<Vec<u32>> {
+    salsa::CycleRecoveryAction::Iterate
+}
+
+#[test]
+fn accumulate_once() {
+    let db = LoggerDatabase::default();
+
+    let file = File::new(&db, "fn".to_string(), vec![], vec![1]);
+    let diagnostics = check_file::accumulated::<Diagnostic>(&db, file);
+    db.assert_logs(expect![[r#"
+        [
+            "check_file(name = fn, issues = [1])",
+        ]"#]]);
+
+    expect![[r#"
+        [
+            Diagnostic(
+                "file fn: issue 1",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{diagnostics:#?}"));
+}
+
+#[test]
+fn accumulate_with_dep() {
+    let db = LoggerDatabase::default();
+
+    let file_a = File::new(&db, "file_a".to_string(), vec![], vec![1]);
+    let file_b = File::new(&db, "file_b".to_string(), vec![file_a], vec![2]);
+
+    let diagnostics = check_file::accumulated::<Diagnostic>(&db, file_b);
+    db.assert_logs(expect![[r#"
+        [
+            "check_file(name = file_b, issues = [2])",
+            "check_file(name = file_a, issues = [1])",
+        ]"#]]);
+
+    expect![[r#"
+        [
+            Diagnostic(
+                "file file_b: issue 1",
+            ),
+            Diagnostic(
+                "file file_b: issue 2",
+            ),
+            Diagnostic(
+                "file file_a: issue 1",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{diagnostics:#?}"));
+}
+
+#[test]
+fn accumulate_with_cycle() {
+    let mut db = LoggerDatabase::default();
+
+    let file_a = File::new(&db, "file_a".to_string(), vec![], vec![1]);
+    let file_b = File::new(&db, "file_b".to_string(), vec![file_a], vec![2]);
+    file_a.set_dependencies(&mut db).to(vec![file_b]);
+
+    let diagnostics = check_file::accumulated::<Diagnostic>(&db, file_b);
+    db.assert_logs(expect![[r#"
+        [
+            "check_file(name = file_b, issues = [2])",
+            "check_file(name = file_a, issues = [1])",
+            "check_file(name = file_b, issues = [2])",
+            "check_file(name = file_a, issues = [1])",
+        ]"#]]);
+
+    expect![[r#"
+        [
+            Diagnostic(
+                "file file_b: issue 1",
+            ),
+            Diagnostic(
+                "file file_b: issue 2",
+            ),
+            Diagnostic(
+                "file file_a: issue 1",
+            ),
+            Diagnostic(
+                "file file_a: issue 2",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{diagnostics:#?}"));
+}
+
+#[test]
+fn accumulate_with_cycle_second_revision() {
+    let mut db = LoggerDatabase::default();
+
+    let file_a = File::new(&db, "file_a".to_string(), vec![], vec![1]);
+    let file_b = File::new(&db, "file_b".to_string(), vec![file_a], vec![2]);
+    file_a.set_dependencies(&mut db).to(vec![file_b]);
+
+    let diagnostics = check_file::accumulated::<Diagnostic>(&db, file_b);
+    db.assert_logs(expect![[r#"
+        [
+            "check_file(name = file_b, issues = [2])",
+            "check_file(name = file_a, issues = [1])",
+            "check_file(name = file_b, issues = [2])",
+            "check_file(name = file_a, issues = [1])",
+        ]"#]]);
+
+    expect![[r#"
+        [
+            Diagnostic(
+                "file file_b: issue 1",
+            ),
+            Diagnostic(
+                "file file_b: issue 2",
+            ),
+            Diagnostic(
+                "file file_a: issue 1",
+            ),
+            Diagnostic(
+                "file file_a: issue 2",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{diagnostics:#?}"));
+
+    file_b.set_issues(&mut db).to(vec![2, 3]);
+
+    let diagnostics = check_file::accumulated::<Diagnostic>(&db, file_a);
+    db.assert_logs(expect![[r#"
+        [
+            "check_file(name = file_b, issues = [2, 3])",
+            "check_file(name = file_a, issues = [1])",
+            "check_file(name = file_a, issues = [1])",
+            "check_file(name = file_b, issues = [2, 3])",
+        ]"#]]);
+
+    expect![[r#"
+        [
+            Diagnostic(
+                "file file_a: issue 1",
+            ),
+            Diagnostic(
+                "file file_a: issue 2",
+            ),
+            Diagnostic(
+                "file file_a: issue 3",
+            ),
+            Diagnostic(
+                "file file_b: issue 1",
+            ),
+            Diagnostic(
+                "file file_b: issue 2",
+            ),
+            Diagnostic(
+                "file file_b: issue 3",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{diagnostics:#?}"));
+}
+
+#[test]
+fn accumulate_add_cycle() {
+    let mut db = LoggerDatabase::default();
+
+    let file_a = File::new(&db, "file_a".to_string(), vec![], vec![1]);
+    let file_b = File::new(&db, "file_b".to_string(), vec![file_a], vec![2]);
+
+    let diagnostics = check_file::accumulated::<Diagnostic>(&db, file_b);
+    db.assert_logs(expect![[r#"
+        [
+            "check_file(name = file_b, issues = [2])",
+            "check_file(name = file_a, issues = [1])",
+        ]"#]]);
+
+    expect![[r#"
+        [
+            Diagnostic(
+                "file file_b: issue 1",
+            ),
+            Diagnostic(
+                "file file_b: issue 2",
+            ),
+            Diagnostic(
+                "file file_a: issue 1",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{diagnostics:#?}"));
+
+    file_a.set_dependencies(&mut db).to(vec![file_b]);
+
+    let diagnostics = check_file::accumulated::<Diagnostic>(&db, file_a);
+    db.assert_logs(expect![[r#"
+        [
+            "check_file(name = file_a, issues = [1])",
+            "check_file(name = file_b, issues = [2])",
+            "check_file(name = file_a, issues = [1])",
+            "check_file(name = file_b, issues = [2])",
+        ]"#]]);
+
+    expect![[r#"
+        [
+            Diagnostic(
+                "file file_a: issue 1",
+            ),
+            Diagnostic(
+                "file file_a: issue 2",
+            ),
+            Diagnostic(
+                "file file_b: issue 1",
+            ),
+            Diagnostic(
+                "file file_b: issue 2",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{diagnostics:#?}"));
+}
+
+#[test]
+fn accumulate_remove_cycle() {
+    let mut db = LoggerDatabase::default();
+
+    let file_a = File::new(&db, "file_a".to_string(), vec![], vec![1]);
+    let file_b = File::new(&db, "file_b".to_string(), vec![file_a], vec![2]);
+    file_a.set_dependencies(&mut db).to(vec![file_b]);
+
+    let diagnostics = check_file::accumulated::<Diagnostic>(&db, file_b);
+    db.assert_logs(expect![[r#"
+        [
+            "check_file(name = file_b, issues = [2])",
+            "check_file(name = file_a, issues = [1])",
+            "check_file(name = file_b, issues = [2])",
+            "check_file(name = file_a, issues = [1])",
+        ]"#]]);
+
+    expect![[r#"
+        [
+            Diagnostic(
+                "file file_b: issue 1",
+            ),
+            Diagnostic(
+                "file file_b: issue 2",
+            ),
+            Diagnostic(
+                "file file_a: issue 1",
+            ),
+            Diagnostic(
+                "file file_a: issue 2",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{diagnostics:#?}"));
+
+    file_a.set_dependencies(&mut db).to(vec![]);
+
+    let diagnostics = check_file::accumulated::<Diagnostic>(&db, file_b);
+    db.assert_logs(expect![[r#"
+        [
+            "check_file(name = file_a, issues = [1])",
+            "check_file(name = file_b, issues = [2])",
+        ]"#]]);
+
+    expect![[r#"
+        [
+            Diagnostic(
+                "file file_b: issue 1",
+            ),
+            Diagnostic(
+                "file file_b: issue 2",
+            ),
+            Diagnostic(
+                "file file_a: issue 1",
+            ),
+        ]"#]]
+    .assert_eq(&format!("{diagnostics:#?}"));
+}
diff --git a/crates/salsa/tests/cycle_fallback_immediate.rs b/crates/salsa/tests/cycle_fallback_immediate.rs
new file mode 100644
index 000000000..b22767202
--- /dev/null
+++ b/crates/salsa/tests/cycle_fallback_immediate.rs
@@ -0,0 +1,49 @@
+//! It is possible to omit the `cycle_fn`, only specifying `cycle_result` in which case
+//! an immediate fallback value is used as the cycle handling opposed to doing a fixpoint resolution.
+
+use std::sync::atomic::{AtomicI32, Ordering};
+
+#[salsa::tracked(cycle_result=cycle_result)]
+fn one_o_one(db: &dyn salsa::Database) -> u32 {
+    let val = one_o_one(db);
+    val + 1
+}
+
+fn cycle_result(_db: &dyn salsa::Database) -> u32 {
+    100
+}
+
+#[test_log::test]
+fn simple() {
+    let db = salsa::DatabaseImpl::default();
+
+    assert_eq!(one_o_one(&db), 100);
+}
+
+#[salsa::tracked(cycle_result=two_queries_cycle_result)]
+fn two_queries1(db: &dyn salsa::Database) -> i32 {
+    two_queries2(db);
+    0
+}
+
+#[salsa::tracked]
+fn two_queries2(db: &dyn salsa::Database) -> i32 {
+    two_queries1(db);
+    // This is horribly against Salsa's rules, but we want to test that
+    // the value from within the cycle is not considered, and this is
+    // the only way I found.
+    static CALLS_COUNT: AtomicI32 = AtomicI32::new(0);
+    CALLS_COUNT.fetch_add(1, Ordering::Relaxed)
+}
+
+fn two_queries_cycle_result(_db: &dyn salsa::Database) -> i32 {
+    1
+}
+
+#[test]
+fn two_queries() {
+    let db = salsa::DatabaseImpl::default();
+
+    assert_eq!(two_queries1(&db), 1);
+    assert_eq!(two_queries2(&db), 1);
+}
diff --git a/crates/salsa/tests/cycle_initial_call_back_into_cycle.rs b/crates/salsa/tests/cycle_initial_call_back_into_cycle.rs
new file mode 100644
index 000000000..9dfe39a92
--- /dev/null
+++ b/crates/salsa/tests/cycle_initial_call_back_into_cycle.rs
@@ -0,0 +1,36 @@
+//! Calling back into the same cycle from your cycle initial function will trigger another cycle.
+
+#[salsa::tracked]
+fn initial_value(db: &dyn salsa::Database) -> u32 {
+    query(db)
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=cycle_initial)]
+fn query(db: &dyn salsa::Database) -> u32 {
+    let val = query(db);
+    if val < 5 {
+        val + 1
+    } else {
+        val
+    }
+}
+
+fn cycle_initial(db: &dyn salsa::Database) -> u32 {
+    initial_value(db)
+}
+
+fn cycle_fn(
+    _db: &dyn salsa::Database,
+    _value: &u32,
+    _count: u32,
+) -> salsa::CycleRecoveryAction<u32> {
+    salsa::CycleRecoveryAction::Iterate
+}
+
+#[test_log::test]
+#[should_panic(expected = "dependency graph cycle")]
+fn the_test() {
+    let db = salsa::DatabaseImpl::default();
+
+    query(&db);
+}
diff --git a/crates/salsa/tests/cycle_initial_call_query.rs b/crates/salsa/tests/cycle_initial_call_query.rs
new file mode 100644
index 000000000..4c52fff27
--- /dev/null
+++ b/crates/salsa/tests/cycle_initial_call_query.rs
@@ -0,0 +1,35 @@
+//! It's possible to call a Salsa query from within a cycle initial fn.
+
+#[salsa::tracked]
+fn initial_value(_db: &dyn salsa::Database) -> u32 {
+    0
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=cycle_initial)]
+fn query(db: &dyn salsa::Database) -> u32 {
+    let val = query(db);
+    if val < 5 {
+        val + 1
+    } else {
+        val
+    }
+}
+
+fn cycle_initial(db: &dyn salsa::Database) -> u32 {
+    initial_value(db)
+}
+
+fn cycle_fn(
+    _db: &dyn salsa::Database,
+    _value: &u32,
+    _count: u32,
+) -> salsa::CycleRecoveryAction<u32> {
+    salsa::CycleRecoveryAction::Iterate
+}
+
+#[test_log::test]
+fn the_test() {
+    let db = salsa::DatabaseImpl::default();
+
+    assert_eq!(query(&db), 5);
+}
diff --git a/crates/salsa/tests/cycle_maybe_changed_after.rs b/crates/salsa/tests/cycle_maybe_changed_after.rs
new file mode 100644
index 000000000..2759c65ff
--- /dev/null
+++ b/crates/salsa/tests/cycle_maybe_changed_after.rs
@@ -0,0 +1,212 @@
+//! Tests for incremental validation for queries involved in a cycle.
+mod common;
+
+use crate::common::EventLoggerDatabase;
+use salsa::{CycleRecoveryAction, Database, Durability, Setter};
+
+#[salsa::input(debug)]
+struct Input {
+    value: u32,
+    max: u32,
+}
+
+#[salsa::interned(debug)]
+struct Output<'db> {
+    value: u32,
+}
+
+#[salsa::tracked(cycle_fn=query_a_recover, cycle_initial=query_a_initial)]
+fn query_c<'db>(db: &'db dyn salsa::Database, input: Input) -> u32 {
+    query_d(db, input)
+}
+
+#[salsa::tracked]
+fn query_d<'db>(db: &'db dyn salsa::Database, input: Input) -> u32 {
+    let value = query_c(db, input);
+    if value < input.max(db) * 2 {
+        // Only the first iteration depends on value but the entire
+        // cycle must re-run if input changes.
+        let result = value + input.value(db);
+        Output::new(db, result);
+        result
+    } else {
+        value
+    }
+}
+
+fn query_a_initial(_db: &dyn Database, _input: Input) -> u32 {
+    0
+}
+
+fn query_a_recover(
+    _db: &dyn Database,
+    _output: &u32,
+    _count: u32,
+    _input: Input,
+) -> CycleRecoveryAction<u32> {
+    CycleRecoveryAction::Iterate
+}
+
+/// Only the first iteration depends on `input.value`. It's important that the entire query
+/// reruns if `input.value` changes. That's why salsa has to carry-over the inputs and outputs
+/// from the previous iteration.
+#[test_log::test]
+fn first_iteration_input_only() {
+    #[salsa::tracked(cycle_fn=query_a_recover, cycle_initial=query_a_initial)]
+    fn query_a<'db>(db: &'db dyn salsa::Database, input: Input) -> u32 {
+        query_b(db, input)
+    }
+
+    #[salsa::tracked]
+    fn query_b<'db>(db: &'db dyn salsa::Database, input: Input) -> u32 {
+        let value = query_a(db, input);
+
+        if value < input.max(db) {
+            // Only the first iteration depends on value but the entire
+            // cycle must re-run if input changes.
+            value + input.value(db)
+        } else {
+            value
+        }
+    }
+
+    let mut db = EventLoggerDatabase::default();
+
+    let input = Input::builder(4, 5).durability(Durability::MEDIUM).new(&db);
+
+    {
+        let result = query_a(&db, input);
+
+        assert_eq!(result, 8);
+    }
+
+    {
+        input.set_value(&mut db).to(3);
+
+        let result = query_a(&db, input);
+        assert_eq!(result, 6);
+    }
+}
+
+/// Very similar to the previous test, but the difference is that the called function
+/// isn't the cycle head and that `cycle_participant` is called from
+/// both the `cycle_head` and the `entry` function.
+#[test_log::test]
+fn nested_cycle_fewer_dependencies_in_first_iteration() {
+    #[salsa::interned(debug)]
+    struct ClassLiteral<'db> {
+        scope: Scope<'db>,
+    }
+
+    #[salsa::tracked]
+    impl<'db> ClassLiteral<'db> {
+        #[salsa::tracked]
+        fn context(self, db: &'db dyn salsa::Database) -> u32 {
+            let scope = self.scope(db);
+
+            // Access a field on `scope` that changed in the new revision.
+            scope.field(db)
+        }
+    }
+
+    #[salsa::tracked(debug)]
+    struct Scope<'db> {
+        field: u32,
+    }
+
+    #[salsa::tracked]
+    fn create_interned<'db>(db: &'db dyn salsa::Database, scope: Scope<'db>) -> ClassLiteral<'db> {
+        ClassLiteral::new(db, scope)
+    }
+
+    #[derive(Eq, PartialEq, Debug, salsa::Update)]
+    struct Index<'db> {
+        scope: Scope<'db>,
+    }
+
+    #[salsa::tracked(cycle_fn=head_recover, cycle_initial=head_initial)]
+    fn cycle_head<'db>(db: &'db dyn salsa::Database, input: Input) -> Option<ClassLiteral<'db>> {
+        let b = cycle_outer(db, input);
+        tracing::info!("query_b = {b:?}");
+
+        b.or_else(|| {
+            let index = index(db, input);
+            Some(create_interned(db, index.scope))
+        })
+    }
+
+    fn head_initial(_db: &dyn Database, _input: Input) -> Option<ClassLiteral<'_>> {
+        None
+    }
+
+    fn head_recover<'db>(
+        _db: &'db dyn Database,
+        _output: &Option<ClassLiteral<'db>>,
+        _count: u32,
+        _input: Input,
+    ) -> CycleRecoveryAction<Option<ClassLiteral<'db>>> {
+        CycleRecoveryAction::Iterate
+    }
+
+    #[salsa::tracked]
+    fn cycle_outer<'db>(db: &'db dyn salsa::Database, input: Input) -> Option<ClassLiteral<'db>> {
+        cycle_participant(db, input)
+    }
+
+    #[salsa::tracked]
+    fn cycle_participant<'db>(
+        db: &'db dyn salsa::Database,
+        input: Input,
+    ) -> Option<ClassLiteral<'db>> {
+        let value = cycle_head(db, input);
+        tracing::info!("cycle_head = {value:?}");
+
+        if let Some(value) = value {
+            value.context(db);
+            Some(value)
+        } else {
+            None
+        }
+    }
+
+    #[salsa::tracked(returns(ref))]
+    fn index<'db>(db: &'db dyn salsa::Database, input: Input) -> Index<'db> {
+        Index {
+            scope: Scope::new(db, input.value(db) * 2),
+        }
+    }
+
+    #[salsa::tracked]
+    fn entry(db: &dyn salsa::Database, input: Input) -> u32 {
+        let _ = input.value(db);
+        let head = cycle_head(db, input);
+
+        let participant = cycle_participant(db, input);
+        tracing::debug!("head: {head:?}, participant: {participant:?}");
+
+        head.or(participant)
+            .map(|class| class.scope(db).field(db))
+            .unwrap_or(0)
+    }
+
+    let mut db = EventLoggerDatabase::default();
+
+    let input = Input::builder(3, 5)
+        .max_durability(Durability::HIGH)
+        .value_durability(Durability::LOW)
+        .new(&db);
+
+    {
+        let result = entry(&db, input);
+
+        assert_eq!(result, 6);
+    }
+
+    db.synthetic_write(Durability::MEDIUM);
+
+    {
+        input.set_value(&mut db).to(4);
+        let result = entry(&db, input);
+        assert_eq!(result, 8);
+    }
+}
diff --git a/crates/salsa/tests/cycle_output.rs b/crates/salsa/tests/cycle_output.rs
new file mode 100644
index 000000000..a05c6c04b
--- /dev/null
+++ b/crates/salsa/tests/cycle_output.rs
@@ -0,0 +1,204 @@
+//! Test tracked struct output from a query in a cycle.
+mod common;
+use common::{HasLogger, LogDatabase, Logger};
+use expect_test::expect;
+use salsa::{Setter, Storage};
+
+#[salsa::tracked]
+struct Output<'db> {
+    value: u32,
+}
+
+#[salsa::input]
+struct InputValue {
+    value: u32,
+}
+
+#[salsa::tracked]
+fn read_value<'db>(db: &'db dyn Db, output: Output<'db>) -> u32 {
+    output.value(db)
+}
+
+#[salsa::tracked]
+fn query_a(db: &dyn Db, input: InputValue) -> u32 {
+    let val = query_b(db, input);
+    let output = Output::new(db, val);
+    let read = read_value(db, output);
+    assert_eq!(read, val);
+    query_d(db);
+    if val > 2 {
+        val
+    } else {
+        val + input.value(db)
+    }
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=cycle_initial)]
+fn query_b(db: &dyn Db, input: InputValue) -> u32 {
+    query_a(db, input)
+}
+
+fn cycle_initial(_db: &dyn Db, _input: InputValue) -> u32 {
+    0
+}
+
+fn cycle_fn(
+    _db: &dyn Db,
+    _value: &u32,
+    _count: u32,
+    _input: InputValue,
+) -> salsa::CycleRecoveryAction<u32> {
+    salsa::CycleRecoveryAction::Iterate
+}
+
+#[salsa::tracked]
+fn query_c(db: &dyn Db, input: InputValue) -> u32 {
+    input.value(db)
+}
+
+#[salsa::tracked]
+fn query_d(db: &dyn Db) -> u32 {
+    db.get_input().map(|input| input.value(db)).unwrap_or(0)
+}
+
+trait HasOptionInput {
+    fn get_input(&self) -> Option<InputValue>;
+    fn set_input(&mut self, input: InputValue);
+}
+
+#[salsa::db]
+trait Db: HasOptionInput + salsa::Database {}
+
+#[salsa::db]
+#[derive(Clone)]
+struct Database {
+    storage: salsa::Storage<Self>,
+    logger: Logger,
+    input: Option<InputValue>,
+}
+
+impl HasLogger for Database {
+    fn logger(&self) -> &Logger {
+        &self.logger
+    }
+}
+
+impl Default for Database {
+    fn default() -> Self {
+        let logger = Logger::default();
+        Self {
+            storage: Storage::new(Some(Box::new({
+                let logger = logger.clone();
+                move |event| match event.kind {
+                    salsa::EventKind::WillExecute { .. }
+                    | salsa::EventKind::DidValidateMemoizedValue { .. } => {
+                        logger.push_log(format!("salsa_event({:?})", event.kind));
+                    }
+                    salsa::EventKind::WillCheckCancellation => {}
+                    _ => {
+                        logger.push_log(format!("salsa_event({:?})", event.kind));
+                    }
+                }
+            }))),
+            logger,
+            input: Default::default(),
+        }
+    }
+}
+
+impl HasOptionInput for Database {
+    fn get_input(&self) -> Option<InputValue> {
+        self.input
+    }
+
+    fn set_input(&mut self, input: InputValue) {
+        self.input.replace(input);
+    }
+}
+
+#[salsa::db]
+impl salsa::Database for Database {}
+
+#[salsa::db]
+impl Db for Database {}
+
+#[test_log::test]
+fn single_revision() {
+    let db = Database::default();
+    let input = InputValue::new(&db, 1);
+
+    assert_eq!(query_b(&db, input), 3);
+}
+
+#[test_log::test]
+fn revalidate_no_changes() {
+    let mut db = Database::default();
+
+    let ab_input = InputValue::new(&db, 1);
+    let c_input = InputValue::new(&db, 10);
+    assert_eq!(query_c(&db, c_input), 10);
+    assert_eq!(query_b(&db, ab_input), 3);
+
+    db.assert_logs_len(15);
+
+    // trigger a new revision, but one that doesn't touch the query_a/query_b cycle
+    c_input.set_value(&mut db).to(20);
+
+    assert_eq!(query_b(&db, ab_input), 3);
+
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(DidSetCancellationFlag)",
+            "salsa_event(DidValidateMemoizedValue { database_key: read_value(Id(400)) })",
+            "salsa_event(DidReinternValue { key: query_d::interned_arguments(Id(800)), revision: R2 })",
+            "salsa_event(DidValidateMemoizedValue { database_key: query_d(Id(800)) })",
+            "salsa_event(DidValidateMemoizedValue { database_key: query_b(Id(0)) })",
+        ]"#]]);
+}
+
+#[test_log::test]
+fn revalidate_with_change_after_output_read() {
+    let mut db = Database::default();
+
+    let ab_input = InputValue::new(&db, 1);
+    let d_input = InputValue::new(&db, 10);
+    db.set_input(d_input);
+
+    assert_eq!(query_b(&db, ab_input), 3);
+
+    db.assert_logs_len(14);
+
+    // trigger a new revision that changes the output of query_d
+    d_input.set_value(&mut db).to(20);
+
+    assert_eq!(query_b(&db, ab_input), 3);
+
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(DidSetCancellationFlag)",
+            "salsa_event(DidValidateMemoizedValue { database_key: read_value(Id(400)) })",
+            "salsa_event(DidReinternValue { key: query_d::interned_arguments(Id(800)), revision: R2 })",
+            "salsa_event(WillExecute { database_key: query_b(Id(0)) })",
+            "salsa_event(DidReinternValue { key: query_d::interned_arguments(Id(800)), revision: R2 })",
+            "salsa_event(WillExecute { database_key: query_a(Id(0)) })",
+            "salsa_event(WillExecute { database_key: query_d(Id(800)) })",
+            "salsa_event(WillDiscardStaleOutput { execute_key: query_a(Id(0)), output_key: Output(Id(403)) })",
+            "salsa_event(DidDiscard { key: Output(Id(403)) })",
+            "salsa_event(DidDiscard { key: read_value(Id(403)) })",
+            "salsa_event(WillDiscardStaleOutput { execute_key: query_a(Id(0)), output_key: Output(Id(401)) })",
+            "salsa_event(DidDiscard { key: Output(Id(401)) })",
+            "salsa_event(DidDiscard { key: read_value(Id(401)) })",
+            "salsa_event(WillDiscardStaleOutput { execute_key: query_a(Id(0)), output_key: Output(Id(402)) })",
+            "salsa_event(DidDiscard { key: Output(Id(402)) })",
+            "salsa_event(DidDiscard { key: read_value(Id(402)) })",
+            "salsa_event(WillIterateCycle { database_key: query_b(Id(0)), iteration_count: 1, fell_back: false })",
+            "salsa_event(WillExecute { database_key: query_a(Id(0)) })",
+            "salsa_event(WillExecute { database_key: read_value(Id(403)) })",
+            "salsa_event(WillIterateCycle { database_key: query_b(Id(0)), iteration_count: 2, fell_back: false })",
+            "salsa_event(WillExecute { database_key: query_a(Id(0)) })",
+            "salsa_event(WillExecute { database_key: read_value(Id(401)) })",
+            "salsa_event(WillIterateCycle { database_key: query_b(Id(0)), iteration_count: 3, fell_back: false })",
+            "salsa_event(WillExecute { database_key: query_a(Id(0)) })",
+            "salsa_event(WillExecute { database_key: read_value(Id(402)) })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/cycle_recovery_call_back_into_cycle.rs b/crates/salsa/tests/cycle_recovery_call_back_into_cycle.rs
new file mode 100644
index 000000000..a4dc5e250
--- /dev/null
+++ b/crates/salsa/tests/cycle_recovery_call_back_into_cycle.rs
@@ -0,0 +1,43 @@
+//! Calling back into the same cycle from your cycle recovery function _can_ work out, as long as
+//! the overall cycle still converges.
+
+mod common;
+use common::{DatabaseWithValue, ValueDatabase};
+
+#[salsa::tracked]
+fn fallback_value(db: &dyn ValueDatabase) -> u32 {
+    query(db) + db.get_value()
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=cycle_initial)]
+fn query(db: &dyn ValueDatabase) -> u32 {
+    let val = query(db);
+    if val < 5 {
+        val + 1
+    } else {
+        val
+    }
+}
+
+fn cycle_initial(_db: &dyn ValueDatabase) -> u32 {
+    0
+}
+
+fn cycle_fn(db: &dyn ValueDatabase, _value: &u32, _count: u32) -> salsa::CycleRecoveryAction<u32> {
+    salsa::CycleRecoveryAction::Fallback(fallback_value(db))
+}
+
+#[test]
+fn converges() {
+    let db = DatabaseWithValue::new(10);
+
+    assert_eq!(query(&db), 10);
+}
+
+#[test]
+#[should_panic(expected = "fallback did not converge")]
+fn diverges() {
+    let db = DatabaseWithValue::new(3);
+
+    query(&db);
+}
diff --git a/crates/salsa/tests/cycle_recovery_call_query.rs b/crates/salsa/tests/cycle_recovery_call_query.rs
new file mode 100644
index 000000000..a768017c8
--- /dev/null
+++ b/crates/salsa/tests/cycle_recovery_call_query.rs
@@ -0,0 +1,35 @@
+//! It's possible to call a Salsa query from within a cycle recovery fn.
+
+#[salsa::tracked]
+fn fallback_value(_db: &dyn salsa::Database) -> u32 {
+    10
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=cycle_initial)]
+fn query(db: &dyn salsa::Database) -> u32 {
+    let val = query(db);
+    if val < 5 {
+        val + 1
+    } else {
+        val
+    }
+}
+
+fn cycle_initial(_db: &dyn salsa::Database) -> u32 {
+    0
+}
+
+fn cycle_fn(
+    db: &dyn salsa::Database,
+    _value: &u32,
+    _count: u32,
+) -> salsa::CycleRecoveryAction<u32> {
+    salsa::CycleRecoveryAction::Fallback(fallback_value(db))
+}
+
+#[test_log::test]
+fn the_test() {
+    let db = salsa::DatabaseImpl::default();
+
+    assert_eq!(query(&db), 10);
+}
diff --git a/crates/salsa/tests/cycle_regression_455.rs b/crates/salsa/tests/cycle_regression_455.rs
new file mode 100644
index 000000000..5beff8d3d
--- /dev/null
+++ b/crates/salsa/tests/cycle_regression_455.rs
@@ -0,0 +1,55 @@
+use salsa::{Database, Setter};
+
+#[salsa::tracked]
+fn memoized(db: &dyn Database, input: MyInput) -> u32 {
+    memoized_a(db, MyTracked::new(db, input.field(db)))
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=cycle_initial)]
+fn memoized_a<'db>(db: &'db dyn Database, tracked: MyTracked<'db>) -> u32 {
+    MyTracked::new(db, 0);
+    memoized_b(db, tracked)
+}
+
+fn cycle_fn<'db>(
+    _db: &'db dyn Database,
+    _value: &u32,
+    _count: u32,
+    _input: MyTracked<'db>,
+) -> salsa::CycleRecoveryAction<u32> {
+    salsa::CycleRecoveryAction::Iterate
+}
+
+fn cycle_initial(_db: &dyn Database, _input: MyTracked) -> u32 {
+    0
+}
+
+#[salsa::tracked]
+fn memoized_b<'db>(db: &'db dyn Database, tracked: MyTracked<'db>) -> u32 {
+    let incr = tracked.field(db);
+    let a = memoized_a(db, tracked);
+    if a > 8 {
+        a
+    } else {
+        a + incr
+    }
+}
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[test]
+fn cycle_memoized() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, 2);
+    assert_eq!(memoized(&db, input), 10);
+    input.set_field(&mut db).to(3);
+    assert_eq!(memoized(&db, input), 9);
+}
diff --git a/crates/salsa/tests/cycle_result_dependencies.rs b/crates/salsa/tests/cycle_result_dependencies.rs
new file mode 100644
index 000000000..e7071a029
--- /dev/null
+++ b/crates/salsa/tests/cycle_result_dependencies.rs
@@ -0,0 +1,25 @@
+use salsa::{Database, Setter};
+
+#[salsa::input]
+struct Input {
+    value: i32,
+}
+
+#[salsa::tracked(cycle_result=cycle_result)]
+fn has_cycle(db: &dyn Database, input: Input) -> i32 {
+    has_cycle(db, input)
+}
+
+fn cycle_result(db: &dyn Database, input: Input) -> i32 {
+    input.value(db)
+}
+
+#[test]
+fn cycle_result_dependencies_are_recorded() {
+    let mut db = salsa::DatabaseImpl::default();
+    let input = Input::new(&db, 123);
+    assert_eq!(has_cycle(&db, input), 123);
+
+    input.set_value(&mut db).to(456);
+    assert_eq!(has_cycle(&db, input), 456);
+}
diff --git a/crates/salsa/tests/cycle_tracked.rs b/crates/salsa/tests/cycle_tracked.rs
new file mode 100644
index 000000000..7a653f81e
--- /dev/null
+++ b/crates/salsa/tests/cycle_tracked.rs
@@ -0,0 +1,192 @@
+//! Tests for cycles where the cycle head is stored on a tracked struct
+//! and that tracked struct is freed in a later revision.
+
+mod common;
+
+use crate::common::{EventLoggerDatabase, LogDatabase};
+use expect_test::expect;
+use salsa::{CycleRecoveryAction, Database, Setter};
+
+#[derive(Clone, Debug, Eq, PartialEq, Hash, salsa::Update)]
+struct Graph<'db> {
+    nodes: Vec<Node<'db>>,
+}
+
+impl<'db> Graph<'db> {
+    fn find_node(&self, db: &dyn salsa::Database, name: &str) -> Option<Node<'db>> {
+        self.nodes
+            .iter()
+            .find(|node| node.name(db) == name)
+            .copied()
+    }
+}
+
+#[derive(Clone, Debug, Eq, PartialEq, Hash)]
+struct Edge {
+    // Index into `graph.nodes`
+    to: usize,
+    cost: usize,
+}
+
+#[salsa::tracked(debug)]
+struct Node<'db> {
+    #[returns(ref)]
+    name: String,
+
+    #[returns(deref)]
+    #[tracked]
+    edges: Vec<Edge>,
+
+    graph: GraphInput,
+}
+
+#[salsa::input(debug)]
+struct GraphInput {
+    simple: bool,
+}
+
+#[salsa::tracked(returns(ref))]
+fn create_graph(db: &dyn salsa::Database, input: GraphInput) -> Graph<'_> {
+    if input.simple(db) {
+        let a = Node::new(db, "a".to_string(), vec![], input);
+        let b = Node::new(db, "b".to_string(), vec![Edge { to: 0, cost: 20 }], input);
+        let c = Node::new(db, "c".to_string(), vec![Edge { to: 1, cost: 2 }], input);
+
+        Graph {
+            nodes: vec![a, b, c],
+        }
+    } else {
+        // ```
+        // flowchart TD
+        //
+        // A("a")
+        // B("b")
+        // C("c")
+        // D{"d"}
+        //
+        // B -- 20 --> D
+        // C -- 4 --> D
+        // D -- 4 --> A
+        // D -- 4 --> B
+        // ```
+        let a = Node::new(db, "a".to_string(), vec![], input);
+        let b = Node::new(db, "b".to_string(), vec![Edge { to: 3, cost: 20 }], input);
+        let c = Node::new(db, "c".to_string(), vec![Edge { to: 3, cost: 4 }], input);
+        let d = Node::new(
+            db,
+            "d".to_string(),
+            vec![Edge { to: 0, cost: 4 }, Edge { to: 1, cost: 4 }],
+            input,
+        );
+
+        Graph {
+            nodes: vec![a, b, c, d],
+        }
+    }
+}
+
+/// Computes the minimum cost from the node with offset `0` to the given node.
+#[salsa::tracked(cycle_fn=cycle_recover, cycle_initial=max_initial)]
+fn cost_to_start<'db>(db: &'db dyn Database, node: Node<'db>) -> usize {
+    let mut min_cost = usize::MAX;
+    let graph = create_graph(db, node.graph(db));
+
+    for edge in node.edges(db) {
+        if edge.to == 0 {
+            min_cost = min_cost.min(edge.cost);
+        }
+
+        let edge_cost_to_start = cost_to_start(db, graph.nodes[edge.to]);
+
+        // We hit a cycle, never take this edge because it will always be more expensive than
+        // any other edge
+        if edge_cost_to_start == usize::MAX {
+            continue;
+        }
+
+        min_cost = min_cost.min(edge.cost + edge_cost_to_start);
+    }
+
+    min_cost
+}
+
+fn max_initial(_db: &dyn Database, _node: Node) -> usize {
+    usize::MAX
+}
+
+fn cycle_recover(
+    _db: &dyn Database,
+    _value: &usize,
+    _count: u32,
+    _inputs: Node,
+) -> CycleRecoveryAction<usize> {
+    CycleRecoveryAction::Iterate
+}
+
+#[test]
+fn main() {
+    let mut db = EventLoggerDatabase::default();
+
+    let input = GraphInput::new(&db, false);
+    let graph = create_graph(&db, input);
+    let c = graph.find_node(&db, "c").unwrap();
+
+    // Query the cost from `c` to `a`.
+    // There's a cycle between `b` and `d`, where `d` becomes the cycle head and `b` is a provisional, non finalized result.
+    assert_eq!(cost_to_start(&db, c), 8);
+
+    // Change the graph, this will remove `d`, leaving `b` pointing to a cycle head that's now collected.
+    // Querying the cost from `c` to `a` should try to verify the result of `b` and it is important
+    // that `b` doesn't try to dereference the cycle head (because its memo is now stored on a tracked
+    // struct that has been freed).
+    input.set_simple(&mut db).to(true);
+
+    let graph = create_graph(&db, input);
+    let c = graph.find_node(&db, "c").unwrap();
+
+    assert_eq!(cost_to_start(&db, c), 22);
+
+    db.assert_logs(expect![[r#"
+        [
+            "WillCheckCancellation",
+            "WillExecute { database_key: create_graph(Id(0)) }",
+            "WillCheckCancellation",
+            "WillExecute { database_key: cost_to_start(Id(402)) }",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillExecute { database_key: cost_to_start(Id(403)) }",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillExecute { database_key: cost_to_start(Id(400)) }",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillExecute { database_key: cost_to_start(Id(401)) }",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillIterateCycle { database_key: cost_to_start(Id(403)), iteration_count: 1, fell_back: false }",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillExecute { database_key: cost_to_start(Id(401)) }",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "DidSetCancellationFlag",
+            "WillCheckCancellation",
+            "WillExecute { database_key: create_graph(Id(0)) }",
+            "WillDiscardStaleOutput { execute_key: create_graph(Id(0)), output_key: Node(Id(403)) }",
+            "DidDiscard { key: Node(Id(403)) }",
+            "DidDiscard { key: cost_to_start(Id(403)) }",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillExecute { database_key: cost_to_start(Id(402)) }",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillExecute { database_key: cost_to_start(Id(401)) }",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "WillExecute { database_key: cost_to_start(Id(400)) }",
+            "WillCheckCancellation",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/cycle_tracked_own_input.rs b/crates/salsa/tests/cycle_tracked_own_input.rs
new file mode 100644
index 000000000..cdfa43aa6
--- /dev/null
+++ b/crates/salsa/tests/cycle_tracked_own_input.rs
@@ -0,0 +1,130 @@
+//! Test for cycle handling where a tracked struct created in the first revision
+//! is stored in the final value of the cycle but isn't recreated in the second
+//! iteration of the creating query.
+//!
+//! It's important that the creating query in the last iteration keeps *owning* the
+//! tracked struct from the previous iteration, otherwise Salsa will discard it
+//! and dereferencing the value panics.
+mod common;
+
+use crate::common::{EventLoggerDatabase, LogDatabase};
+use expect_test::expect;
+use salsa::{CycleRecoveryAction, Database, Setter};
+
+#[salsa::input(debug)]
+struct ClassNode {
+    name: String,
+    type_params: Option<TypeParamNode>,
+}
+
+#[salsa::input(debug)]
+struct TypeParamNode {
+    name: String,
+    constraint: Option<ClassNode>,
+}
+
+#[salsa::interned(debug)]
+struct Class<'db> {
+    name: String,
+    type_params: Option<TypeParam<'db>>,
+}
+
+#[salsa::tracked(debug)]
+struct TypeParam<'db> {
+    name: String,
+    constraint: Option<Type<'db>>,
+}
+
+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, salsa::Update)]
+enum Type<'db> {
+    Class(Class<'db>),
+    Unknown,
+}
+
+impl Type<'_> {
+    fn class(&self) -> Option<Class> {
+        match self {
+            Type::Class(class) => Some(*class),
+            Type::Unknown => None,
+        }
+    }
+}
+
+#[salsa::tracked(cycle_fn=infer_class_recover, cycle_initial=infer_class_initial)]
+fn infer_class<'db>(db: &'db dyn salsa::Database, node: ClassNode) -> Type<'db> {
+    Type::Class(Class::new(
+        db,
+        node.name(db),
+        node.type_params(db).map(|tp| infer_type_param(db, tp)),
+    ))
+}
+
+#[salsa::tracked]
+fn infer_type_param<'db>(db: &'db dyn salsa::Database, node: TypeParamNode) -> TypeParam<'db> {
+    if let Some(constraint) = node.constraint(db) {
+        // Reuse the type param from the class if any.
+        // The example is a bit silly, because it's a reduction of what we have in Astral's type checker
+        // but including all the details doesn't make sense. What's important for the test is
+        // that this query doesn't re-create the `TypeParam` tracked struct in the second iteration
+        // and instead returns the one from the first iteration which
+        // then is returned in the overall result (Class).
+        match infer_class(db, constraint) {
+            Type::Class(class) => class
+                .type_params(db)
+                .unwrap_or_else(|| TypeParam::new(db, node.name(db), Some(Type::Unknown))),
+            Type::Unknown => TypeParam::new(db, node.name(db), Some(Type::Unknown)),
+        }
+    } else {
+        TypeParam::new(db, node.name(db), None)
+    }
+}
+
+fn infer_class_initial(_db: &dyn Database, _node: ClassNode) -> Type {
+    Type::Unknown
+}
+
+fn infer_class_recover<'db>(
+    _db: &'db dyn Database,
+    _type: &Type<'db>,
+    _count: u32,
+    _inputs: ClassNode,
+) -> CycleRecoveryAction<Type<'db>> {
+    CycleRecoveryAction::Iterate
+}
+
+#[test]
+fn main() {
+    let mut db = EventLoggerDatabase::default();
+
+    // Class with a type parameter that's constrained to itself.
+    // class Test[T: Test]: ...
+    let class_node = ClassNode::new(&db, "Test".to_string(), None);
+    let type_param_node = TypeParamNode::new(&db, "T".to_string(), Some(class_node));
+    class_node
+        .set_type_params(&mut db)
+        .to(Some(type_param_node));
+
+    let ty = infer_class(&db, class_node);
+
+    db.assert_logs(expect![[r#"
+        [
+            "DidSetCancellationFlag",
+            "WillCheckCancellation",
+            "WillExecute { database_key: infer_class(Id(0)) }",
+            "WillCheckCancellation",
+            "WillExecute { database_key: infer_type_param(Id(400)) }",
+            "WillCheckCancellation",
+            "DidInternValue { key: Class(Id(c00)), revision: R2 }",
+            "WillIterateCycle { database_key: infer_class(Id(0)), iteration_count: 1, fell_back: false }",
+            "WillCheckCancellation",
+            "WillExecute { database_key: infer_type_param(Id(400)) }",
+            "WillCheckCancellation",
+        ]"#]]);
+
+    let class = ty.class().unwrap();
+    let type_param = class.type_params(&db).unwrap();
+
+    // Now read the name from the type param struct that was created in the first iteration of
+    // `infer_type_param`. This should not panic!
+    assert_eq!(type_param.name(&db), "T");
+}
diff --git a/crates/salsa/tests/dataflow.rs b/crates/salsa/tests/dataflow.rs
new file mode 100644
index 000000000..f973e970e
--- /dev/null
+++ b/crates/salsa/tests/dataflow.rs
@@ -0,0 +1,247 @@
+//! Test case for fixpoint iteration cycle resolution.
+//!
+//! This test case is intended to simulate a (very simplified) version of a real dataflow analysis
+//! using fixpoint iteration.
+use std::collections::BTreeSet;
+use std::iter::IntoIterator;
+
+use salsa::{CycleRecoveryAction, Database as Db, Setter};
+
+/// A Use of a symbol.
+#[salsa::input]
+struct Use {
+    reaching_definitions: Vec<Definition>,
+}
+
+/// A Definition of a symbol, either of the form `base + increment` or `0 + increment`.
+#[salsa::input]
+struct Definition {
+    base: Option<Use>,
+    increment: usize,
+}
+
+#[derive(Eq, PartialEq, Clone, Debug, salsa::Update)]
+enum Type {
+    Bottom,
+    Values(Box<[usize]>),
+    Top,
+}
+
+impl Type {
+    fn join(tys: impl IntoIterator<Item = Type>) -> Type {
+        let mut result = Type::Bottom;
+        for ty in tys.into_iter() {
+            result = match (result, ty) {
+                (result, Type::Bottom) => result,
+                (_, Type::Top) => Type::Top,
+                (Type::Top, _) => Type::Top,
+                (Type::Bottom, ty) => ty,
+                (Type::Values(a_ints), Type::Values(b_ints)) => {
+                    let mut set = BTreeSet::new();
+                    set.extend(a_ints);
+                    set.extend(b_ints);
+                    Type::Values(set.into_iter().collect())
+                }
+            }
+        }
+        result
+    }
+}
+
+#[salsa::tracked(cycle_fn=use_cycle_recover, cycle_initial=use_cycle_initial)]
+fn infer_use<'db>(db: &'db dyn Db, u: Use) -> Type {
+    let defs = u.reaching_definitions(db);
+    match defs[..] {
+        [] => Type::Bottom,
+        [def] => infer_definition(db, def),
+        _ => Type::join(defs.iter().map(|&def| infer_definition(db, def))),
+    }
+}
+
+#[salsa::tracked(cycle_fn=def_cycle_recover, cycle_initial=def_cycle_initial)]
+fn infer_definition<'db>(db: &'db dyn Db, def: Definition) -> Type {
+    let increment_ty = Type::Values(Box::from([def.increment(db)]));
+    if let Some(base) = def.base(db) {
+        let base_ty = infer_use(db, base);
+        add(&base_ty, &increment_ty)
+    } else {
+        increment_ty
+    }
+}
+
+fn def_cycle_initial(_db: &dyn Db, _def: Definition) -> Type {
+    Type::Bottom
+}
+
+fn def_cycle_recover(
+    _db: &dyn Db,
+    value: &Type,
+    count: u32,
+    _def: Definition,
+) -> CycleRecoveryAction<Type> {
+    cycle_recover(value, count)
+}
+
+fn use_cycle_initial(_db: &dyn Db, _use: Use) -> Type {
+    Type::Bottom
+}
+
+fn use_cycle_recover(
+    _db: &dyn Db,
+    value: &Type,
+    count: u32,
+    _use: Use,
+) -> CycleRecoveryAction<Type> {
+    cycle_recover(value, count)
+}
+
+fn cycle_recover(value: &Type, count: u32) -> CycleRecoveryAction<Type> {
+    match value {
+        Type::Bottom => CycleRecoveryAction::Iterate,
+        Type::Values(_) => {
+            if count > 4 {
+                CycleRecoveryAction::Fallback(Type::Top)
+            } else {
+                CycleRecoveryAction::Iterate
+            }
+        }
+        Type::Top => CycleRecoveryAction::Iterate,
+    }
+}
+
+fn add(a: &Type, b: &Type) -> Type {
+    match (a, b) {
+        (Type::Bottom, _) | (_, Type::Bottom) => Type::Bottom,
+        (Type::Top, _) | (_, Type::Top) => Type::Top,
+        (Type::Values(a_ints), Type::Values(b_ints)) => {
+            let mut set = BTreeSet::new();
+            set.extend(
+                a_ints
+                    .into_iter()
+                    .flat_map(|a| b_ints.into_iter().map(move |b| a + b)),
+            );
+            Type::Values(set.into_iter().collect())
+        }
+    }
+}
+
+/// x = 1
+#[test]
+fn simple() {
+    let db = salsa::DatabaseImpl::new();
+
+    let def = Definition::new(&db, None, 1);
+    let u = Use::new(&db, vec![def]);
+
+    let ty = infer_use(&db, u);
+
+    assert_eq!(ty, Type::Values(Box::from([1])));
+}
+
+/// x = 1 if flag else 2
+#[test]
+fn union() {
+    let db = salsa::DatabaseImpl::new();
+
+    let def1 = Definition::new(&db, None, 1);
+    let def2 = Definition::new(&db, None, 2);
+    let u = Use::new(&db, vec![def1, def2]);
+
+    let ty = infer_use(&db, u);
+
+    assert_eq!(ty, Type::Values(Box::from([1, 2])));
+}
+
+/// x = 1 if flag else 2; y = x + 1
+#[test]
+fn union_add() {
+    let db = salsa::DatabaseImpl::new();
+
+    let x1 = Definition::new(&db, None, 1);
+    let x2 = Definition::new(&db, None, 2);
+    let x_use = Use::new(&db, vec![x1, x2]);
+    let y_def = Definition::new(&db, Some(x_use), 1);
+    let y_use = Use::new(&db, vec![y_def]);
+
+    let ty = infer_use(&db, y_use);
+
+    assert_eq!(ty, Type::Values(Box::from([2, 3])));
+}
+
+/// x = 1; loop { x = x + 0 }
+#[test]
+fn cycle_converges_then_diverges() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let def1 = Definition::new(&db, None, 1);
+    let def2 = Definition::new(&db, None, 0);
+    let u = Use::new(&db, vec![def1, def2]);
+    def2.set_base(&mut db).to(Some(u));
+
+    let ty = infer_use(&db, u);
+
+    // Loop converges on 1
+    assert_eq!(ty, Type::Values(Box::from([1])));
+
+    // Set the increment on x from 0 to 1
+    let new_increment = 1;
+    def2.set_increment(&mut db).to(new_increment);
+
+    // Now the loop diverges and we fall back to Top
+    assert_eq!(infer_use(&db, u), Type::Top);
+}
+
+/// x = 1; loop { x = x + 1 }
+#[test]
+fn cycle_diverges_then_converges() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let def1 = Definition::new(&db, None, 1);
+    let def2 = Definition::new(&db, None, 1);
+    let u = Use::new(&db, vec![def1, def2]);
+    def2.set_base(&mut db).to(Some(u));
+
+    let ty = infer_use(&db, u);
+
+    // Loop diverges. Cut it off and fallback to Type::Top
+    assert_eq!(ty, Type::Top);
+
+    // Set the increment from 1 to 0.
+    def2.set_increment(&mut db).to(0);
+
+    // Now the loop converges on 1.
+    assert_eq!(infer_use(&db, u), Type::Values(Box::from([1])));
+}
+
+/// x = 0; y = 0; loop { x = y + 0; y = x + 0 }
+#[test_log::test]
+fn multi_symbol_cycle_converges_then_diverges() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let defx0 = Definition::new(&db, None, 0);
+    let defy0 = Definition::new(&db, None, 0);
+    let defx1 = Definition::new(&db, None, 0);
+    let defy1 = Definition::new(&db, None, 0);
+    let use_x = Use::new(&db, vec![defx0, defx1]);
+    let use_y = Use::new(&db, vec![defy0, defy1]);
+    defx1.set_base(&mut db).to(Some(use_y));
+    defy1.set_base(&mut db).to(Some(use_x));
+
+    // Both symbols converge on 0
+    assert_eq!(infer_use(&db, use_x), Type::Values(Box::from([0])));
+    assert_eq!(infer_use(&db, use_y), Type::Values(Box::from([0])));
+
+    // Set the increment on x to 0.
+    defx1.set_increment(&mut db).to(0);
+
+    // Both symbols still converge on 0.
+    assert_eq!(infer_use(&db, use_x), Type::Values(Box::from([0])));
+    assert_eq!(infer_use(&db, use_y), Type::Values(Box::from([0])));
+
+    // Set the increment on x from 0 to 1.
+    defx1.set_increment(&mut db).to(1);
+
+    // Now the loop diverges and we fall back to Top.
+    assert_eq!(infer_use(&db, use_x), Type::Top);
+    assert_eq!(infer_use(&db, use_y), Type::Top);
+}
diff --git a/crates/salsa/tests/debug.rs b/crates/salsa/tests/debug.rs
new file mode 100644
index 000000000..03b59dcab
--- /dev/null
+++ b/crates/salsa/tests/debug.rs
@@ -0,0 +1,98 @@
+//! Test that `DeriveWithDb` is correctly derived.
+
+use expect_test::expect;
+use salsa::{Database, Setter};
+
+#[salsa::input(debug)]
+struct MyInput {
+    field: u32,
+}
+
+#[derive(Debug, Eq, PartialEq, Clone)]
+struct NotSalsa {
+    field: String,
+}
+
+#[salsa::input(debug)]
+struct ComplexStruct {
+    my_input: MyInput,
+    not_salsa: NotSalsa,
+}
+
+#[test]
+fn input() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = MyInput::new(db, 22);
+        let not_salsa = NotSalsa {
+            field: "it's salsa time".to_string(),
+        };
+        let complex_struct = ComplexStruct::new(db, input, not_salsa);
+
+        // debug includes all fields
+        let actual = format!("{complex_struct:?}");
+        let expected = expect![[r#"ComplexStruct { [salsa id]: Id(400), my_input: MyInput { [salsa id]: Id(0), field: 22 }, not_salsa: NotSalsa { field: "it's salsa time" } }"#]];
+        expected.assert_eq(&actual);
+    })
+}
+
+#[salsa::tracked]
+fn leak_debug_string(_db: &dyn salsa::Database, input: MyInput) -> String {
+    format!("{input:?}")
+}
+
+/// Test that field reads that occur as part of `Debug` are not tracked.
+/// Intentionally leaks the debug string.
+/// Don't try this at home, kids.
+#[test]
+fn untracked_dependencies() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::new(&db, 22);
+
+    let s = leak_debug_string(&db, input);
+    expect![[r#"
+        "MyInput { [salsa id]: Id(0), field: 22 }"
+    "#]]
+    .assert_debug_eq(&s);
+
+    input.set_field(&mut db).to(23);
+
+    // check that we reuse the cached result for debug string
+    // even though the dependency changed.
+    let s = leak_debug_string(&db, input);
+    assert!(s.contains(", field: 22 }"));
+}
+
+#[salsa::tracked]
+struct DerivedCustom<'db> {
+    my_input: MyInput,
+    value: u32,
+}
+
+impl std::fmt::Debug for DerivedCustom<'_> {
+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+        salsa::with_attached_database(|db| {
+            write!(f, "{:?} / {:?}", self.my_input(db), self.value(db))
+        })
+        .unwrap_or_else(|| f.debug_tuple("DerivedCustom").finish())
+    }
+}
+
+#[salsa::tracked]
+fn leak_derived_custom(db: &dyn salsa::Database, input: MyInput, value: u32) -> String {
+    let c = DerivedCustom::new(db, input, value);
+    format!("{c:?}")
+}
+
+#[test]
+fn custom_debug_impl() {
+    let db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::new(&db, 22);
+
+    let s = leak_derived_custom(&db, input, 23);
+    expect![[r#"
+        "MyInput { [salsa id]: Id(0), field: 22 } / 23"
+    "#]]
+    .assert_debug_eq(&s);
+}
diff --git a/crates/salsa/tests/debug_db_contents.rs b/crates/salsa/tests/debug_db_contents.rs
new file mode 100644
index 000000000..30efb1736
--- /dev/null
+++ b/crates/salsa/tests/debug_db_contents.rs
@@ -0,0 +1,56 @@
+#[salsa::interned(debug)]
+struct InternedStruct<'db> {
+    name: String,
+}
+
+#[salsa::input(debug)]
+struct InputStruct {
+    field: u32,
+}
+
+#[salsa::tracked(debug)]
+struct TrackedStruct<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn salsa::Database, input: InputStruct) -> TrackedStruct<'_> {
+    TrackedStruct::new(db, input.field(db) * 2)
+}
+
+#[test]
+fn execute() {
+    let db = salsa::DatabaseImpl::new();
+
+    let _ = InternedStruct::new(&db, "Salsa".to_string());
+    let _ = InternedStruct::new(&db, "Salsa2".to_string());
+
+    // test interned structs
+    let interned = InternedStruct::ingredient(&db)
+        .entries(&db)
+        .collect::<Vec<_>>();
+
+    assert_eq!(interned.len(), 2);
+    assert_eq!(interned[0].fields().0, "Salsa");
+    assert_eq!(interned[1].fields().0, "Salsa2");
+
+    // test input structs
+    let input = InputStruct::new(&db, 22);
+
+    let inputs = InputStruct::ingredient(&db)
+        .entries(&db)
+        .collect::<Vec<_>>();
+
+    assert_eq!(inputs.len(), 1);
+    assert_eq!(inputs[0].fields().0, 22);
+
+    // test tracked structs
+    let computed = tracked_fn(&db, input).field(&db);
+    assert_eq!(computed, 44);
+    let tracked = TrackedStruct::ingredient(&db)
+        .entries(&db)
+        .collect::<Vec<_>>();
+
+    assert_eq!(tracked.len(), 1);
+    assert_eq!(tracked[0].fields().0, computed);
+}
diff --git a/crates/salsa/tests/deletion-cascade.rs b/crates/salsa/tests/deletion-cascade.rs
new file mode 100644
index 000000000..1e02c42f0
--- /dev/null
+++ b/crates/salsa/tests/deletion-cascade.rs
@@ -0,0 +1,89 @@
+//! Delete cascade:
+//!
+//! * when we delete memoized data, also delete outputs from that data
+
+mod common;
+use common::LogDatabase;
+use expect_test::expect;
+use salsa::Setter;
+use test_log::test;
+
+#[salsa::input(singleton, debug)]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn final_result(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("final_result({input:?})"));
+    let mut sum = 0;
+    for tracked_struct in create_tracked_structs(db, input) {
+        sum += contribution_from_struct(db, tracked_struct);
+    }
+    sum
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn create_tracked_structs(db: &dyn LogDatabase, input: MyInput) -> Vec<MyTracked<'_>> {
+    db.push_log(format!("intermediate_result({input:?})"));
+    (0..input.field(db))
+        .map(|i| MyTracked::new(db, i))
+        .collect()
+}
+
+#[salsa::tracked]
+fn contribution_from_struct<'db>(db: &'db dyn LogDatabase, tracked: MyTracked<'db>) -> u32 {
+    let m = MyTracked::new(db, tracked.field(db));
+    copy_field(db, m) * 2
+}
+
+#[salsa::tracked]
+fn copy_field<'db>(db: &'db dyn LogDatabase, tracked: MyTracked<'db>) -> u32 {
+    tracked.field(db)
+}
+
+#[test]
+fn basic() {
+    let mut db = common::DiscardLoggerDatabase::default();
+
+    // Creates 3 tracked structs
+    let input = MyInput::new(&db, 3);
+    assert_eq!(final_result(&db, input), 2 * 2 + 2);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result(MyInput { [salsa id]: Id(0), field: 3 })",
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 3 })",
+        ]"#]]);
+
+    // Creates only 2 tracked structs in this revision, should delete 1
+    //
+    // Expect to see 6 DidDiscard events. Three from the primary struct:
+    //
+    // * the struct itself
+    // * the struct's field
+    // * the `contribution_from_struct` result
+    //
+    // and then 3 more from the struct created by `contribution_from_struct`:
+    //
+    // * the struct itself
+    // * the struct's field
+    // * the `copy_field` result
+
+    input.set_field(&mut db).to(2);
+    assert_eq!(final_result(&db, input), 2);
+    db.assert_logs(expect![[r#"
+        [
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 2 })",
+            "salsa_event(WillDiscardStaleOutput { execute_key: create_tracked_structs(Id(0)), output_key: MyTracked(Id(402)) })",
+            "salsa_event(DidDiscard { key: MyTracked(Id(402)) })",
+            "salsa_event(DidDiscard { key: contribution_from_struct(Id(402)) })",
+            "salsa_event(DidDiscard { key: MyTracked(Id(405)) })",
+            "salsa_event(DidDiscard { key: copy_field(Id(405)) })",
+            "final_result(MyInput { [salsa id]: Id(0), field: 2 })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/deletion-drops.rs b/crates/salsa/tests/deletion-drops.rs
new file mode 100644
index 000000000..52b0b5120
--- /dev/null
+++ b/crates/salsa/tests/deletion-drops.rs
@@ -0,0 +1,102 @@
+//! Basic deletion test:
+//!
+//! * entities not created in a revision are deleted, as is any memoized data keyed on them.
+
+mod common;
+
+use salsa::{Database, Setter};
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    identity: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    identifier: u32,
+
+    #[tracked]
+    #[returns(ref)]
+    field: Bomb,
+}
+
+thread_local! {
+    static DROPPED: std::cell::RefCell<Vec<u32>> = const { std::cell::RefCell::new(vec![]) };
+}
+
+fn dropped() -> Vec<u32> {
+    DROPPED.with(|d| d.borrow().clone())
+}
+
+#[derive(Clone, Debug, PartialEq, Eq)]
+struct Bomb {
+    identity: u32,
+}
+
+impl Drop for Bomb {
+    fn drop(&mut self) {
+        DROPPED.with(|d| d.borrow_mut().push(self.identity));
+    }
+}
+
+#[salsa::tracked]
+impl MyInput {
+    #[salsa::tracked]
+    fn create_tracked_struct(self, db: &dyn Database) -> MyTracked<'_> {
+        MyTracked::new(
+            db,
+            self.identity(db),
+            Bomb {
+                identity: self.identity(db),
+            },
+        )
+    }
+}
+
+#[test]
+fn deletion_drops() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::new(&db, 22);
+
+    expect_test::expect![[r#"
+        []
+    "#]]
+    .assert_debug_eq(&dropped());
+
+    let tracked_struct = input.create_tracked_struct(&db);
+    assert_eq!(tracked_struct.field(&db).identity, 22);
+
+    expect_test::expect![[r#"
+        []
+    "#]]
+    .assert_debug_eq(&dropped());
+
+    input.set_identity(&mut db).to(44);
+
+    expect_test::expect![[r#"
+        []
+    "#]]
+    .assert_debug_eq(&dropped());
+
+    // Now that we execute with rev = 44, the old id is put on the free list
+    let tracked_struct = input.create_tracked_struct(&db);
+    assert_eq!(tracked_struct.field(&db).identity, 44);
+
+    expect_test::expect![[r#"
+        []
+    "#]]
+    .assert_debug_eq(&dropped());
+
+    // When we execute again with `input1`, that id is re-used, so the old value is deleted
+    let input1 = MyInput::new(&db, 66);
+    let _tracked_struct1 = input1.create_tracked_struct(&db);
+
+    expect_test::expect![[r#"
+        [
+            22,
+        ]
+    "#]]
+    .assert_debug_eq(&dropped());
+}
diff --git a/crates/salsa/tests/deletion.rs b/crates/salsa/tests/deletion.rs
new file mode 100644
index 000000000..c7c415e2d
--- /dev/null
+++ b/crates/salsa/tests/deletion.rs
@@ -0,0 +1,74 @@
+//! Basic deletion test:
+//!
+//! * entities not created in a revision are deleted, as is any memoized data keyed on them.
+
+mod common;
+use common::LogDatabase;
+use expect_test::expect;
+use salsa::Setter;
+use test_log::test;
+
+#[salsa::input(debug)]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn final_result(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("final_result({input:?})"));
+    let mut sum = 0;
+    for tracked_struct in create_tracked_structs(db, input) {
+        sum += contribution_from_struct(db, tracked_struct);
+    }
+    sum
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn create_tracked_structs(db: &dyn LogDatabase, input: MyInput) -> Vec<MyTracked<'_>> {
+    db.push_log(format!("intermediate_result({input:?})"));
+    (0..input.field(db))
+        .map(|i| MyTracked::new(db, i))
+        .collect()
+}
+
+#[salsa::tracked]
+fn contribution_from_struct<'db>(db: &'db dyn LogDatabase, tracked: MyTracked<'db>) -> u32 {
+    tracked.field(db) * 2
+}
+
+#[test]
+fn basic() {
+    let mut db = common::DiscardLoggerDatabase::default();
+
+    // Creates 3 tracked structs
+    let input = MyInput::new(&db, 3);
+    assert_eq!(final_result(&db, input), 2 * 2 + 2);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result(MyInput { [salsa id]: Id(0), field: 3 })",
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 3 })",
+        ]"#]]);
+
+    // Creates only 2 tracked structs in this revision, should delete 1
+    //
+    // Expect to see 3 DidDiscard events--
+    //
+    // * the struct itself
+    // * the struct's field
+    // * the `contribution_from_struct` result
+    input.set_field(&mut db).to(2);
+    assert_eq!(final_result(&db, input), 2);
+    db.assert_logs(expect![[r#"
+        [
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 2 })",
+            "salsa_event(WillDiscardStaleOutput { execute_key: create_tracked_structs(Id(0)), output_key: MyTracked(Id(402)) })",
+            "salsa_event(DidDiscard { key: MyTracked(Id(402)) })",
+            "salsa_event(DidDiscard { key: contribution_from_struct(Id(402)) })",
+            "final_result(MyInput { [salsa id]: Id(0), field: 2 })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/durability.rs b/crates/salsa/tests/durability.rs
new file mode 100644
index 000000000..3a8e244e0
--- /dev/null
+++ b/crates/salsa/tests/durability.rs
@@ -0,0 +1,47 @@
+//! Tests that code using the builder's durability methods compiles.
+
+use salsa::{Database, Durability, Setter};
+use test_log::test;
+
+#[salsa::input]
+struct N {
+    value: u32,
+}
+
+#[salsa::tracked]
+fn add3(db: &dyn Database, a: N, b: N, c: N) -> u32 {
+    add(db, a, b) + c.value(db)
+}
+
+#[salsa::tracked]
+fn add(db: &dyn Database, a: N, b: N) -> u32 {
+    a.value(db) + b.value(db)
+}
+
+#[test]
+fn durable_to_less_durable() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let a = N::builder(11).value_durability(Durability::HIGH).new(&db);
+    let b = N::builder(22).value_durability(Durability::HIGH).new(&db);
+    let c = N::builder(33).value_durability(Durability::HIGH).new(&db);
+
+    // Here, `add3` invokes `add(a, b)`, which yields 33.
+    assert_eq!(add3(&db, a, b, c), 66);
+
+    a.set_value(&mut db).with_durability(Durability::LOW).to(11);
+
+    // Here, `add3` invokes `add`, which *still* yields 33, but which
+    // is no longer of high durability. Since value didn't change, we might
+    // preserve `add3` unchanged, not noticing that it is no longer
+    // of high durability.
+
+    assert_eq!(add3(&db, a, b, c), 66);
+
+    // In that case, we would not get the correct result here, when
+    // 'a' changes *again*.
+
+    a.set_value(&mut db).to(22);
+
+    assert_eq!(add3(&db, a, b, c), 77);
+}
diff --git a/crates/salsa/tests/elided-lifetime-in-tracked-fn.rs b/crates/salsa/tests/elided-lifetime-in-tracked-fn.rs
new file mode 100644
index 000000000..4979c2ee9
--- /dev/null
+++ b/crates/salsa/tests/elided-lifetime-in-tracked-fn.rs
@@ -0,0 +1,60 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+
+mod common;
+use common::LogDatabase;
+use expect_test::expect;
+use salsa::Setter;
+use test_log::test;
+
+#[salsa::input(debug)]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn final_result(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("final_result({input:?})"));
+    intermediate_result(db, input).field(db) * 2
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn intermediate_result(db: &dyn LogDatabase, input: MyInput) -> MyTracked<'_> {
+    db.push_log(format!("intermediate_result({input:?})"));
+    MyTracked::new(db, input.field(db) / 2)
+}
+
+#[test]
+fn execute() {
+    let mut db = common::LoggerDatabase::default();
+
+    let input = MyInput::new(&db, 22);
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result(MyInput { [salsa id]: Id(0), field: 22 })",
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 22 })",
+        ]"#]]);
+
+    // Intermediate result is the same, so final result does
+    // not need to be recomputed:
+    input.set_field(&mut db).to(23);
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 23 })",
+        ]"#]]);
+
+    input.set_field(&mut db).to(24);
+    assert_eq!(final_result(&db, input), 24);
+    db.assert_logs(expect![[r#"
+        [
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 24 })",
+            "final_result(MyInput { [salsa id]: Id(0), field: 24 })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/expect_reuse_field_x_of_a_tracked_struct_changes_but_fn_depends_on_field_y.rs b/crates/salsa/tests/expect_reuse_field_x_of_a_tracked_struct_changes_but_fn_depends_on_field_y.rs
new file mode 100644
index 000000000..cc0f09808
--- /dev/null
+++ b/crates/salsa/tests/expect_reuse_field_x_of_a_tracked_struct_changes_but_fn_depends_on_field_y.rs
@@ -0,0 +1,80 @@
+//! Test that if field X of a tracked struct changes but not field Y,
+//! functions that depend on X re-execute, but those depending only on Y do not
+//! compiles and executes successfully.
+#![allow(dead_code)]
+
+mod common;
+use common::LogDatabase;
+use expect_test::expect;
+use salsa::Setter;
+
+#[salsa::input(debug)]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn final_result_depends_on_x(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("final_result_depends_on_x({input:?})"));
+    intermediate_result(db, input).x(db) * 2
+}
+
+#[salsa::tracked]
+fn final_result_depends_on_y(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("final_result_depends_on_y({input:?})"));
+    intermediate_result(db, input).y(db) * 2
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    #[tracked]
+    x: u32,
+    #[tracked]
+    y: u32,
+}
+
+#[salsa::tracked]
+fn intermediate_result(db: &dyn LogDatabase, input: MyInput) -> MyTracked<'_> {
+    MyTracked::new(db, input.field(db).div_ceil(2), input.field(db) / 2)
+}
+
+#[test]
+fn execute() {
+    // x = (input.field + 1) / 2
+    // y = input.field / 2
+    // final_result_depends_on_x = x * 2 = (input.field + 1) / 2 * 2
+    // final_result_depends_on_y = y * 2 = input.field / 2 * 2
+    let mut db = common::LoggerDatabase::default();
+
+    // intermediate results:
+    // x = (22 + 1) / 2 = 11
+    // y = 22 / 2 = 11
+    let input = MyInput::new(&db, 22);
+    assert_eq!(final_result_depends_on_x(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result_depends_on_x(MyInput { [salsa id]: Id(0), field: 22 })",
+        ]"#]]);
+
+    assert_eq!(final_result_depends_on_y(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result_depends_on_y(MyInput { [salsa id]: Id(0), field: 22 })",
+        ]"#]]);
+
+    input.set_field(&mut db).to(23);
+    // x = (23 + 1) / 2 = 12
+    // Intermediate result x changes, so final result depends on x
+    // needs to be recomputed;
+    assert_eq!(final_result_depends_on_x(&db, input), 24);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result_depends_on_x(MyInput { [salsa id]: Id(0), field: 23 })",
+        ]"#]]);
+
+    // y = 23 / 2 = 11
+    // Intermediate result y is the same, so final result depends on y
+    // does not need to be recomputed;
+    assert_eq!(final_result_depends_on_y(&db, input), 22);
+    db.assert_logs(expect!["[]"]);
+}
diff --git a/crates/salsa/tests/expect_reuse_field_x_of_an_input_changes_but_fn_depends_on_field_y.rs b/crates/salsa/tests/expect_reuse_field_x_of_an_input_changes_but_fn_depends_on_field_y.rs
new file mode 100644
index 000000000..c4a6ba56e
--- /dev/null
+++ b/crates/salsa/tests/expect_reuse_field_x_of_an_input_changes_but_fn_depends_on_field_y.rs
@@ -0,0 +1,60 @@
+//! Test that if field X of an input changes but not field Y,
+//! functions that depend on X re-execute, but those depending only on Y do not
+//! compiles and executes successfully.
+#![allow(dead_code)]
+
+mod common;
+use common::LogDatabase;
+use expect_test::expect;
+use salsa::Setter;
+
+#[salsa::input(debug)]
+struct MyInput {
+    x: u32,
+    y: u32,
+}
+
+#[salsa::tracked]
+fn result_depends_on_x(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("result_depends_on_x({input:?})"));
+    input.x(db) + 1
+}
+
+#[salsa::tracked]
+fn result_depends_on_y(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("result_depends_on_y({input:?})"));
+    input.y(db) - 1
+}
+
+#[test]
+fn execute() {
+    // result_depends_on_x = x + 1
+    // result_depends_on_y = y - 1
+    let mut db = common::LoggerDatabase::default();
+
+    let input = MyInput::new(&db, 22, 33);
+    assert_eq!(result_depends_on_x(&db, input), 23);
+    db.assert_logs(expect![[r#"
+        [
+            "result_depends_on_x(MyInput { [salsa id]: Id(0), x: 22, y: 33 })",
+        ]"#]]);
+
+    assert_eq!(result_depends_on_y(&db, input), 32);
+    db.assert_logs(expect![[r#"
+        [
+            "result_depends_on_y(MyInput { [salsa id]: Id(0), x: 22, y: 33 })",
+        ]"#]]);
+
+    input.set_x(&mut db).to(23);
+    // input x changes, so result depends on x needs to be recomputed;
+    assert_eq!(result_depends_on_x(&db, input), 24);
+    db.assert_logs(expect![[r#"
+        [
+            "result_depends_on_x(MyInput { [salsa id]: Id(0), x: 23, y: 33 })",
+        ]"#]]);
+
+    // input y is the same, so result depends on y
+    // does not need to be recomputed;
+    assert_eq!(result_depends_on_y(&db, input), 32);
+    db.assert_logs(expect!["[]"]);
+}
diff --git a/crates/salsa/tests/hash_collision.rs b/crates/salsa/tests/hash_collision.rs
new file mode 100644
index 000000000..4efadfa33
--- /dev/null
+++ b/crates/salsa/tests/hash_collision.rs
@@ -0,0 +1,32 @@
+use std::hash::Hash;
+
+#[test]
+fn hello() {
+    use salsa::{Database, DatabaseImpl, Setter};
+
+    #[salsa::input]
+    struct Bool {
+        value: bool,
+    }
+
+    #[salsa::tracked]
+    struct True<'db> {}
+
+    #[salsa::tracked]
+    struct False<'db> {}
+
+    #[salsa::tracked]
+    fn hello(db: &dyn Database, bool: Bool) {
+        if bool.value(db) {
+            True::new(db);
+        } else {
+            False::new(db);
+        }
+    }
+
+    let mut db = DatabaseImpl::new();
+    let input = Bool::new(&db, false);
+    hello(&db, input);
+    input.set_value(&mut db).to(true);
+    hello(&db, input);
+}
diff --git a/crates/salsa/tests/hello_world.rs b/crates/salsa/tests/hello_world.rs
new file mode 100644
index 000000000..4a083648b
--- /dev/null
+++ b/crates/salsa/tests/hello_world.rs
@@ -0,0 +1,85 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+
+mod common;
+use common::LogDatabase;
+use expect_test::expect;
+use salsa::Setter;
+use test_log::test;
+
+#[salsa::input(debug)]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn final_result(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("final_result({input:?})"));
+    intermediate_result(db, input).field(db) * 2
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn intermediate_result(db: &dyn LogDatabase, input: MyInput) -> MyTracked<'_> {
+    db.push_log(format!("intermediate_result({input:?})"));
+    MyTracked::new(db, input.field(db) / 2)
+}
+
+#[test]
+fn execute() {
+    let mut db = common::LoggerDatabase::default();
+
+    let input = MyInput::new(&db, 22);
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result(MyInput { [salsa id]: Id(0), field: 22 })",
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 22 })",
+        ]"#]]);
+
+    // Intermediate result is the same, so final result does
+    // not need to be recomputed:
+    input.set_field(&mut db).to(23);
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 23 })",
+        ]"#]]);
+
+    input.set_field(&mut db).to(24);
+    assert_eq!(final_result(&db, input), 24);
+    db.assert_logs(expect![[r#"
+        [
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 24 })",
+            "final_result(MyInput { [salsa id]: Id(0), field: 24 })",
+        ]"#]]);
+}
+
+/// Create and mutate a distinct input. No re-execution required.
+#[test]
+fn red_herring() {
+    let mut db = common::LoggerDatabase::default();
+
+    let input = MyInput::new(&db, 22);
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result(MyInput { [salsa id]: Id(0), field: 22 })",
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 22 })",
+        ]"#]]);
+
+    // Create a distinct input and mutate it.
+    // This will trigger a new revision in the database
+    // but shouldn't actually invalidate our existing ones.
+    let input2 = MyInput::new(&db, 44);
+    input2.set_field(&mut db).to(66);
+
+    // Re-run the query on the original input. Nothing re-executes!
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        []"#]]);
+}
diff --git a/crates/salsa/tests/input_default.rs b/crates/salsa/tests/input_default.rs
new file mode 100644
index 000000000..5a4d2bd54
--- /dev/null
+++ b/crates/salsa/tests/input_default.rs
@@ -0,0 +1,43 @@
+//! Tests that fields attributed with `#[default]` are initialized with `Default::default()`.
+
+use salsa::Durability;
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    required: bool,
+    #[default]
+    optional: usize,
+}
+
+#[test]
+fn new_constructor() {
+    let db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::new(&db, true);
+
+    assert!(input.required(&db));
+    assert_eq!(input.optional(&db), 0);
+}
+
+#[test]
+fn builder_specify_optional() {
+    let db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::builder(true).optional(20).new(&db);
+
+    assert!(input.required(&db));
+    assert_eq!(input.optional(&db), 20);
+}
+
+#[test]
+fn builder_default_optional_value() {
+    let db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::builder(true)
+        .required_durability(Durability::HIGH)
+        .new(&db);
+
+    assert!(input.required(&db));
+    assert_eq!(input.optional(&db), 0);
+}
diff --git a/crates/salsa/tests/input_field_durability.rs b/crates/salsa/tests/input_field_durability.rs
new file mode 100644
index 000000000..b65a512e0
--- /dev/null
+++ b/crates/salsa/tests/input_field_durability.rs
@@ -0,0 +1,37 @@
+//! Tests that code using the builder's durability methods compiles.
+
+use salsa::Durability;
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    required_field: bool,
+
+    #[default]
+    optional_field: usize,
+}
+
+#[test]
+fn required_field_durability() {
+    let db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::builder(true)
+        .required_field_durability(Durability::HIGH)
+        .new(&db);
+
+    assert!(input.required_field(&db));
+    assert_eq!(input.optional_field(&db), 0);
+}
+
+#[test]
+fn optional_field_durability() {
+    let db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::builder(true)
+        .optional_field(20)
+        .optional_field_durability(Durability::HIGH)
+        .new(&db);
+
+    assert!(input.required_field(&db));
+    assert_eq!(input.optional_field(&db), 20);
+}
diff --git a/crates/salsa/tests/input_setter_preserves_durability.rs b/crates/salsa/tests/input_setter_preserves_durability.rs
new file mode 100644
index 000000000..529418bf3
--- /dev/null
+++ b/crates/salsa/tests/input_setter_preserves_durability.rs
@@ -0,0 +1,33 @@
+use salsa::plumbing::ZalsaDatabase;
+use salsa::{Durability, Setter};
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    required_field: bool,
+
+    #[default]
+    optional_field: usize,
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::builder(true)
+        .required_field_durability(Durability::HIGH)
+        .new(&db);
+
+    // Change the field value. It should preserve high durability.
+    input.set_required_field(&mut db).to(false);
+
+    let last_high_revision = db.zalsa().last_changed_revision(Durability::HIGH);
+
+    // Changing the value again should **again** dump the high durability revision.
+    input.set_required_field(&mut db).to(false);
+
+    assert_ne!(
+        db.zalsa().last_changed_revision(Durability::HIGH),
+        last_high_revision
+    );
+}
diff --git a/crates/salsa/tests/intern_access_in_different_revision.rs b/crates/salsa/tests/intern_access_in_different_revision.rs
new file mode 100644
index 000000000..ff50ae7a5
--- /dev/null
+++ b/crates/salsa/tests/intern_access_in_different_revision.rs
@@ -0,0 +1,28 @@
+use salsa::{Durability, Setter};
+
+#[salsa::interned(no_lifetime)]
+struct Interned {
+    field: u32,
+}
+
+#[salsa::input]
+struct Input {
+    field: i32,
+}
+
+#[test]
+fn the_test() {
+    let mut db = salsa::DatabaseImpl::default();
+    let input = Input::builder(-123456)
+        .field_durability(Durability::HIGH)
+        .new(&db);
+    // Create an intern in an early revision.
+    let interned = Interned::new(&db, 0xDEADBEEF);
+    // Trigger a new revision.
+    input
+        .set_field(&mut db)
+        .with_durability(Durability::HIGH)
+        .to(123456);
+    // Read the interned value
+    let _ = interned.field(&db);
+}
diff --git a/crates/salsa/tests/interned-revisions.rs b/crates/salsa/tests/interned-revisions.rs
new file mode 100644
index 000000000..80dae4e38
--- /dev/null
+++ b/crates/salsa/tests/interned-revisions.rs
@@ -0,0 +1,116 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+
+mod common;
+use common::LogDatabase;
+use expect_test::expect;
+use salsa::{Database, Setter};
+use test_log::test;
+
+#[salsa::input]
+struct Input {
+    field1: usize,
+}
+
+#[salsa::interned]
+struct Interned<'db> {
+    field1: usize,
+}
+
+#[test]
+fn test_intern_new() {
+    #[salsa::tracked]
+    fn function<'db>(db: &'db dyn Database, input: Input) -> Interned<'db> {
+        Interned::new(db, input.field1(db))
+    }
+
+    let mut db = common::EventLoggerDatabase::default();
+    let input = Input::new(&db, 0);
+
+    let result_in_rev_1 = function(&db, input);
+    assert_eq!(result_in_rev_1.field1(&db), 0);
+
+    // Modify the input to force a new value to be created.
+    input.set_field1(&mut db).to(1);
+
+    let result_in_rev_2 = function(&db, input);
+    assert_eq!(result_in_rev_2.field1(&db), 1);
+
+    db.assert_logs(expect![[r#"
+        [
+            "WillCheckCancellation",
+            "WillExecute { database_key: function(Id(0)) }",
+            "DidInternValue { key: Interned(Id(400)), revision: R1 }",
+            "DidSetCancellationFlag",
+            "WillCheckCancellation",
+            "WillExecute { database_key: function(Id(0)) }",
+            "DidInternValue { key: Interned(Id(401)), revision: R2 }",
+        ]"#]]);
+}
+
+#[test]
+fn test_reintern() {
+    #[salsa::tracked]
+    fn function(db: &dyn Database, input: Input) -> Interned<'_> {
+        let _ = input.field1(db);
+        Interned::new(db, 0)
+    }
+
+    let mut db = common::EventLoggerDatabase::default();
+
+    let input = Input::new(&db, 0);
+    let result_in_rev_1 = function(&db, input);
+    db.assert_logs(expect![[r#"
+        [
+            "WillCheckCancellation",
+            "WillExecute { database_key: function(Id(0)) }",
+            "DidInternValue { key: Interned(Id(400)), revision: R1 }",
+        ]"#]]);
+
+    assert_eq!(result_in_rev_1.field1(&db), 0);
+
+    // Modify the input to force the value to be re-interned.
+    input.set_field1(&mut db).to(1);
+
+    let result_in_rev_2 = function(&db, input);
+    db.assert_logs(expect![[r#"
+        [
+            "DidSetCancellationFlag",
+            "WillCheckCancellation",
+            "WillExecute { database_key: function(Id(0)) }",
+            "DidReinternValue { key: Interned(Id(400)), revision: R2 }",
+        ]"#]]);
+
+    assert_eq!(result_in_rev_2.field1(&db), 0);
+}
+
+#[test]
+fn test_durability() {
+    #[salsa::tracked]
+    fn function<'db>(db: &'db dyn Database, _input: Input) -> Interned<'db> {
+        Interned::new(db, 0)
+    }
+
+    let mut db = common::EventLoggerDatabase::default();
+    let input = Input::new(&db, 0);
+
+    let result_in_rev_1 = function(&db, input);
+    assert_eq!(result_in_rev_1.field1(&db), 0);
+
+    // Modify the input to bump the revision without re-interning the value, as there
+    // is no read dependency.
+    input.set_field1(&mut db).to(1);
+
+    let result_in_rev_2 = function(&db, input);
+    assert_eq!(result_in_rev_2.field1(&db), 0);
+
+    db.assert_logs(expect![[r#"
+        [
+            "WillCheckCancellation",
+            "WillExecute { database_key: function(Id(0)) }",
+            "DidInternValue { key: Interned(Id(400)), revision: R1 }",
+            "DidSetCancellationFlag",
+            "WillCheckCancellation",
+            "DidValidateMemoizedValue { database_key: function(Id(0)) }",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/interned-structs.rs b/crates/salsa/tests/interned-structs.rs
new file mode 100644
index 000000000..da9ec6ae5
--- /dev/null
+++ b/crates/salsa/tests/interned-structs.rs
@@ -0,0 +1,217 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+
+use std::path::{Path, PathBuf};
+
+use expect_test::expect;
+use salsa::plumbing::{AsId, FromId};
+use test_log::test;
+
+#[salsa::interned(debug)]
+struct InternedBoxed<'db> {
+    data: Box<str>,
+}
+
+#[salsa::interned(debug)]
+struct InternedString<'db> {
+    data: String,
+}
+
+#[salsa::interned(debug)]
+struct InternedPair<'db> {
+    data: (InternedString<'db>, InternedString<'db>),
+}
+
+#[salsa::interned(debug)]
+struct InternedTwoFields<'db> {
+    data1: String,
+    data2: String,
+}
+
+#[salsa::interned(debug)]
+struct InternedVec<'db> {
+    data1: Vec<String>,
+}
+
+#[salsa::interned(debug)]
+struct InternedPathBuf<'db> {
+    data1: PathBuf,
+}
+
+#[salsa::interned(no_lifetime, debug)]
+struct InternedStringNoLifetime {
+    data: String,
+}
+
+#[derive(Debug, Eq, PartialEq, Hash, Clone)]
+struct Foo;
+
+#[salsa::interned(debug)]
+struct InternedFoo<'db> {
+    data: Foo,
+}
+
+#[derive(Clone, Copy, Hash, Debug, PartialEq, Eq, PartialOrd, Ord)]
+struct SalsaIdWrapper(salsa::Id);
+
+impl AsId for SalsaIdWrapper {
+    fn as_id(&self) -> salsa::Id {
+        self.0
+    }
+}
+
+impl FromId for SalsaIdWrapper {
+    fn from_id(id: salsa::Id) -> Self {
+        SalsaIdWrapper(id)
+    }
+}
+
+#[salsa::interned(id = SalsaIdWrapper, debug)]
+struct InternedStringWithCustomId<'db> {
+    data: String,
+}
+
+#[salsa::interned(id = SalsaIdWrapper, no_lifetime, debug)]
+struct InternedStringWithCustomIdAndNoLifetime<'db> {
+    data: String,
+}
+
+#[salsa::tracked]
+fn intern_stuff(db: &dyn salsa::Database) -> String {
+    let s1 = InternedString::new(db, "Hello, ".to_string());
+    let s2 = InternedString::new(db, "World, ");
+    let s3 = InternedPair::new(db, (s1, s2));
+
+    format!("{s3:?}")
+}
+
+#[test]
+fn execute() {
+    let db = salsa::DatabaseImpl::new();
+    expect![[r#"
+        "InternedPair { data: (InternedString { data: \"Hello, \" }, InternedString { data: \"World, \" }) }"
+    "#]].assert_debug_eq(&intern_stuff(&db));
+}
+
+#[test]
+fn interning_returns_equal_keys_for_equal_data() {
+    let db = salsa::DatabaseImpl::new();
+    let s1 = InternedString::new(&db, "Hello, ".to_string());
+    let s2 = InternedString::new(&db, "World, ".to_string());
+    let s1_2 = InternedString::new(&db, "Hello, ");
+    let s2_2 = InternedString::new(&db, "World, ");
+    assert_eq!(s1, s1_2);
+    assert_eq!(s2, s2_2);
+}
+#[test]
+fn interning_returns_equal_keys_for_equal_data_multi_field() {
+    let db = salsa::DatabaseImpl::new();
+    let s1 = InternedTwoFields::new(&db, "Hello, ".to_string(), "World");
+    let s2 = InternedTwoFields::new(&db, "World, ", "Hello".to_string());
+    let s1_2 = InternedTwoFields::new(&db, "Hello, ", "World");
+    let s2_2 = InternedTwoFields::new(&db, "World, ", "Hello");
+    let new = InternedTwoFields::new(&db, "Hello, World", "");
+
+    assert_eq!(s1, s1_2);
+    assert_eq!(s2, s2_2);
+    assert_ne!(s1, s2_2);
+    assert_ne!(s1, new);
+}
+
+#[test]
+fn interning_boxed() {
+    let db = salsa::DatabaseImpl::new();
+
+    assert_eq!(
+        InternedBoxed::new(&db, "Hello"),
+        InternedBoxed::new(&db, Box::from("Hello"))
+    );
+}
+
+#[test]
+fn interned_structs_have_public_ingredients() {
+    use salsa::plumbing::AsId;
+
+    let db = salsa::DatabaseImpl::new();
+    let s = InternedString::new(&db, String::from("Hello, world!"));
+    let underlying_id = s.0;
+
+    let data = InternedString::ingredient(&db).data(&db, underlying_id.as_id());
+    assert_eq!(data, &(String::from("Hello, world!"),));
+}
+
+#[test]
+fn interning_vec() {
+    let db = salsa::DatabaseImpl::new();
+    let s1 = InternedVec::new(&db, ["Hello, ".to_string(), "World".to_string()].as_slice());
+    let s2 = InternedVec::new(&db, ["Hello, ", "World"].as_slice());
+    let s3 = InternedVec::new(&db, vec!["Hello, ".to_string(), "World".to_string()]);
+    let s4 = InternedVec::new(&db, ["Hello, ", "World"].as_slice());
+    let s5 = InternedVec::new(&db, ["Hello, ", "World", "Test"].as_slice());
+    let s6 = InternedVec::new(&db, ["Hello, ", "World", ""].as_slice());
+    let s7 = InternedVec::new(&db, ["Hello, "].as_slice());
+    assert_eq!(s1, s2);
+    assert_eq!(s1, s3);
+    assert_eq!(s1, s4);
+    assert_ne!(s1, s5);
+    assert_ne!(s1, s6);
+    assert_ne!(s5, s6);
+    assert_ne!(s6, s7);
+}
+
+#[test]
+fn interning_path_buf() {
+    let db = salsa::DatabaseImpl::new();
+    let s1 = InternedPathBuf::new(&db, PathBuf::from("test_path".to_string()));
+    let s2 = InternedPathBuf::new(&db, Path::new("test_path"));
+    let s3 = InternedPathBuf::new(&db, Path::new("test_path/"));
+    let s4 = InternedPathBuf::new(&db, Path::new("test_path/a"));
+    assert_eq!(s1, s2);
+    assert_eq!(s1, s3);
+    assert_ne!(s1, s4);
+}
+
+#[test]
+fn interning_without_lifetimes() {
+    let db = salsa::DatabaseImpl::new();
+
+    let s1 = InternedStringNoLifetime::new(&db, "Hello, ".to_string());
+    let s2 = InternedStringNoLifetime::new(&db, "World, ".to_string());
+    let s1_2 = InternedStringNoLifetime::new(&db, "Hello, ");
+    let s2_2 = InternedStringNoLifetime::new(&db, "World, ");
+    assert_eq!(s1, s1_2);
+    assert_eq!(s2, s2_2);
+}
+
+#[test]
+fn interning_with_custom_ids() {
+    let db = salsa::DatabaseImpl::new();
+
+    let s1 = InternedStringWithCustomId::new(&db, "Hello, ".to_string());
+    let s2 = InternedStringWithCustomId::new(&db, "World, ".to_string());
+    let s1_2 = InternedStringWithCustomId::new(&db, "Hello, ");
+    let s2_2 = InternedStringWithCustomId::new(&db, "World, ");
+    assert_eq!(s1, s1_2);
+    assert_eq!(s2, s2_2);
+}
+
+#[test]
+fn interning_with_custom_ids_and_no_lifetime() {
+    let db = salsa::DatabaseImpl::new();
+
+    let s1 = InternedStringWithCustomIdAndNoLifetime::new(&db, "Hello, ".to_string());
+    let s2 = InternedStringWithCustomIdAndNoLifetime::new(&db, "World, ".to_string());
+    let s1_2 = InternedStringWithCustomIdAndNoLifetime::new(&db, "Hello, ");
+    let s2_2 = InternedStringWithCustomIdAndNoLifetime::new(&db, "World, ");
+    assert_eq!(s1, s1_2);
+    assert_eq!(s2, s2_2);
+}
+
+#[test]
+fn interning_reference() {
+    let db = salsa::DatabaseImpl::new();
+
+    let s1 = InternedFoo::new(&db, Foo);
+    let s2 = InternedFoo::new(&db, &Foo);
+    assert_eq!(s1, s2);
+}
diff --git a/crates/salsa/tests/interned-structs_self_ref.rs b/crates/salsa/tests/interned-structs_self_ref.rs
new file mode 100644
index 000000000..896655b8f
--- /dev/null
+++ b/crates/salsa/tests/interned-structs_self_ref.rs
@@ -0,0 +1,194 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+
+use std::any::TypeId;
+use std::convert::identity;
+
+use salsa::plumbing::Zalsa;
+use test_log::test;
+
+#[test]
+fn interning_returns_equal_keys_for_equal_data() {
+    let db = salsa::DatabaseImpl::new();
+    let s1 = InternedString::new(&db, "Hello, ".to_string(), identity);
+    let s2 = InternedString::new(&db, "World, ".to_string(), |_| s1);
+    let s1_2 = InternedString::new(&db, "Hello, ", identity);
+    let s2_2 = InternedString::new(&db, "World, ", |_| s2);
+    assert_eq!(s1, s1_2);
+    assert_eq!(s2, s2_2);
+}
+// Recursive expansion of interned macro
+// #[salsa::interned]
+// struct InternedString<'db> {
+//     data: String,
+//     other: InternedString<'db>,
+// }
+// ======================================
+
+#[derive(Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
+struct InternedString<'db>(
+    salsa::Id,
+    std::marker::PhantomData<&'db salsa::plumbing::interned::Value<InternedString<'static>>>,
+);
+
+#[allow(warnings)]
+const _: () = {
+    use salsa::plumbing as zalsa_;
+    use zalsa_::interned as zalsa_struct_;
+    type Configuration_ = InternedString<'static>;
+    #[derive(Clone)]
+    struct StructData<'db>(String, InternedString<'db>);
+
+    impl<'db> Eq for StructData<'db> {}
+    impl<'db> PartialEq for StructData<'db> {
+        fn eq(&self, other: &Self) -> bool {
+            self.0 == other.0
+        }
+    }
+
+    impl<'db> std::hash::Hash for StructData<'db> {
+        fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+            self.0.hash(state);
+        }
+    }
+
+    #[doc = r" Key to use during hash lookups. Each field is some type that implements `Lookup<T>`"]
+    #[doc = r" for the owned type. This permits interning with an `&str` when a `String` is required and so forth."]
+    #[derive(Hash)]
+    struct StructKey<'db, T0>(T0, std::marker::PhantomData<&'db ()>);
+
+    impl<'db, T0> zalsa_::interned::HashEqLike<StructKey<'db, T0>> for StructData<'db>
+    where
+        String: zalsa_::interned::HashEqLike<T0>,
+    {
+        fn hash<H: std::hash::Hasher>(&self, h: &mut H) {
+            zalsa_::interned::HashEqLike::<T0>::hash(&self.0, &mut *h);
+        }
+        fn eq(&self, data: &StructKey<'db, T0>) -> bool {
+            (zalsa_::interned::HashEqLike::<T0>::eq(&self.0, &data.0) && true)
+        }
+    }
+    impl zalsa_struct_::Configuration for Configuration_ {
+        const LOCATION: zalsa_::Location = zalsa_::Location {
+            file: file!(),
+            line: line!(),
+        };
+        const DEBUG_NAME: &'static str = "InternedString";
+        type Fields<'a> = StructData<'a>;
+        type Struct<'a> = InternedString<'a>;
+    }
+    impl Configuration_ {
+        pub fn ingredient<Db>(db: &Db) -> &zalsa_struct_::IngredientImpl<Self>
+        where
+            Db: ?Sized + zalsa_::Database,
+        {
+            zalsa_::__maybe_lazy_static! {
+                static CACHE: zalsa_::IngredientCache<zalsa_struct_::IngredientImpl<Configuration_>> =
+                    zalsa_::IngredientCache::new();
+            }
+
+            let zalsa = db.zalsa();
+            CACHE.get_or_create(zalsa, || {
+                zalsa.add_or_lookup_jar_by_type::<zalsa_struct_::JarImpl<Configuration_>>()
+            })
+        }
+    }
+    impl zalsa_::AsId for InternedString<'_> {
+        fn as_id(&self) -> salsa::Id {
+            self.0
+        }
+    }
+    impl zalsa_::FromId for InternedString<'_> {
+        fn from_id(id: salsa::Id) -> Self {
+            Self(id, std::marker::PhantomData)
+        }
+    }
+    unsafe impl Send for InternedString<'_> {}
+
+    unsafe impl Sync for InternedString<'_> {}
+
+    impl std::fmt::Debug for InternedString<'_> {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            Self::default_debug_fmt(*self, f)
+        }
+    }
+    impl zalsa_::SalsaStructInDb for InternedString<'_> {
+        type MemoIngredientMap = zalsa_::MemoIngredientSingletonIndex;
+
+        fn lookup_or_create_ingredient_index(aux: &Zalsa) -> salsa::plumbing::IngredientIndices {
+            aux.add_or_lookup_jar_by_type::<zalsa_struct_::JarImpl<Configuration_>>()
+                .into()
+        }
+
+        #[inline]
+        fn cast(id: zalsa_::Id, type_id: TypeId) -> Option<Self> {
+            if type_id == TypeId::of::<InternedString>() {
+                Some(<InternedString as zalsa_::FromId>::from_id(id))
+            } else {
+                None
+            }
+        }
+    }
+
+    unsafe impl zalsa_::Update for InternedString<'_> {
+        unsafe fn maybe_update(old_pointer: *mut Self, new_value: Self) -> bool {
+            if unsafe { *old_pointer } != new_value {
+                unsafe { *old_pointer = new_value };
+                true
+            } else {
+                false
+            }
+        }
+    }
+    impl<'db> InternedString<'db> {
+        pub fn new<Db_, T0: zalsa_::interned::Lookup<String> + std::hash::Hash>(
+            db: &'db Db_,
+            data: T0,
+            other: impl FnOnce(InternedString<'db>) -> InternedString<'db>,
+        ) -> Self
+        where
+            Db_: ?Sized + salsa::Database,
+            String: zalsa_::interned::HashEqLike<T0>,
+        {
+            Configuration_::ingredient(db).intern(
+                db.as_dyn_database(),
+                StructKey::<'db>(data, std::marker::PhantomData::default()),
+                |id, data| {
+                    StructData(
+                        zalsa_::interned::Lookup::into_owned(data.0),
+                        other(zalsa_::FromId::from_id(id)),
+                    )
+                },
+            )
+        }
+        fn data<Db_>(self, db: &'db Db_) -> String
+        where
+            Db_: ?Sized + zalsa_::Database,
+        {
+            let fields = Configuration_::ingredient(db).fields(db.as_dyn_database(), self);
+            std::clone::Clone::clone((&fields.0))
+        }
+        fn other<Db_>(self, db: &'db Db_) -> InternedString<'db>
+        where
+            Db_: ?Sized + zalsa_::Database,
+        {
+            let fields = Configuration_::ingredient(db).fields(db.as_dyn_database(), self);
+            std::clone::Clone::clone((&fields.1))
+        }
+        #[doc = r" Default debug formatting for this struct (may be useful if you define your own `Debug` impl)"]
+        pub fn default_debug_fmt(this: Self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            zalsa_::with_attached_database(|db| {
+                let fields = Configuration_::ingredient(db).fields(db.as_dyn_database(), this);
+                let mut f = f.debug_struct("InternedString");
+                let f = f.field("data", &fields.0);
+                let f = f.field("other", &fields.1);
+                f.finish()
+            })
+            .unwrap_or_else(|| {
+                f.debug_tuple("InternedString")
+                    .field(&zalsa_::AsId::as_id(&this))
+                    .finish()
+            })
+        }
+    }
+};
diff --git a/crates/salsa/tests/lru.rs b/crates/salsa/tests/lru.rs
new file mode 100644
index 000000000..0db975b32
--- /dev/null
+++ b/crates/salsa/tests/lru.rs
@@ -0,0 +1,143 @@
+//! Test that a `tracked` fn with lru options
+//! compiles and executes successfully.
+
+use std::sync::atomic::{AtomicUsize, Ordering};
+use std::sync::Arc;
+
+mod common;
+use common::LogDatabase;
+use salsa::Database as _;
+use test_log::test;
+
+#[derive(Debug, PartialEq, Eq)]
+struct HotPotato(u32);
+
+thread_local! {
+    static N_POTATOES: AtomicUsize = const { AtomicUsize::new(0) }
+}
+
+impl HotPotato {
+    fn new(id: u32) -> HotPotato {
+        N_POTATOES.with(|n| n.fetch_add(1, Ordering::SeqCst));
+        HotPotato(id)
+    }
+}
+
+impl Drop for HotPotato {
+    fn drop(&mut self) {
+        N_POTATOES.with(|n| n.fetch_sub(1, Ordering::SeqCst));
+    }
+}
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked(lru = 8)]
+fn get_hot_potato(db: &dyn LogDatabase, input: MyInput) -> Arc<HotPotato> {
+    db.push_log(format!("get_hot_potato({:?})", input.field(db)));
+    Arc::new(HotPotato::new(input.field(db)))
+}
+
+#[salsa::tracked]
+fn get_hot_potato2(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("get_hot_potato2({:?})", input.field(db)));
+    get_hot_potato(db, input).0
+}
+
+fn load_n_potatoes() -> usize {
+    N_POTATOES.with(|n| n.load(Ordering::SeqCst))
+}
+
+#[test]
+fn lru_works() {
+    let mut db = common::LoggerDatabase::default();
+    assert_eq!(load_n_potatoes(), 0);
+
+    for i in 0..32u32 {
+        let input = MyInput::new(&db, i);
+        let p = get_hot_potato(&db, input);
+        assert_eq!(p.0, i);
+    }
+
+    assert_eq!(load_n_potatoes(), 32);
+    // trigger the GC
+    db.synthetic_write(salsa::Durability::HIGH);
+    assert_eq!(load_n_potatoes(), 8);
+}
+
+#[test]
+fn lru_can_be_changed_at_runtime() {
+    let mut db = common::LoggerDatabase::default();
+    assert_eq!(load_n_potatoes(), 0);
+
+    let inputs: Vec<(u32, MyInput)> = (0..32).map(|i| (i, MyInput::new(&db, i))).collect();
+
+    for &(i, input) in inputs.iter() {
+        let p = get_hot_potato(&db, input);
+        assert_eq!(p.0, i);
+    }
+
+    assert_eq!(load_n_potatoes(), 32);
+    // trigger the GC
+    db.synthetic_write(salsa::Durability::HIGH);
+    assert_eq!(load_n_potatoes(), 8);
+
+    get_hot_potato::set_lru_capacity(&mut db, 16);
+    assert_eq!(load_n_potatoes(), 8);
+    for &(i, input) in inputs.iter() {
+        let p = get_hot_potato(&db, input);
+        assert_eq!(p.0, i);
+    }
+
+    assert_eq!(load_n_potatoes(), 32);
+    // trigger the GC
+    db.synthetic_write(salsa::Durability::HIGH);
+    assert_eq!(load_n_potatoes(), 16);
+
+    // Special case: setting capacity to zero disables LRU
+    get_hot_potato::set_lru_capacity(&mut db, 0);
+    assert_eq!(load_n_potatoes(), 16);
+    for &(i, input) in inputs.iter() {
+        let p = get_hot_potato(&db, input);
+        assert_eq!(p.0, i);
+    }
+
+    assert_eq!(load_n_potatoes(), 32);
+    // trigger the GC
+    db.synthetic_write(salsa::Durability::HIGH);
+    assert_eq!(load_n_potatoes(), 32);
+
+    drop(db);
+    assert_eq!(load_n_potatoes(), 0);
+}
+
+#[test]
+fn lru_keeps_dependency_info() {
+    let mut db = common::LoggerDatabase::default();
+    let capacity = 8;
+
+    // Invoke `get_hot_potato2` 33 times. This will (in turn) invoke
+    // `get_hot_potato`, which will trigger LRU after 8 executions.
+    let inputs: Vec<MyInput> = (0..(capacity + 1))
+        .map(|i| MyInput::new(&db, i as u32))
+        .collect();
+
+    for (i, input) in inputs.iter().enumerate() {
+        let x = get_hot_potato2(&db, *input);
+        assert_eq!(x as usize, i);
+    }
+
+    db.synthetic_write(salsa::Durability::HIGH);
+
+    // We want to test that calls to `get_hot_potato2` are still considered
+    // clean. Check that no new executions occur as we go here.
+    db.assert_logs_len((capacity + 1) * 2);
+
+    // calling `get_hot_potato2(0)` has to check that `get_hot_potato(0)` is still valid;
+    // even though we've evicted it (LRU), we find that it is still good
+    let p = get_hot_potato2(&db, *inputs.first().unwrap());
+    assert_eq!(p, 0);
+    db.assert_logs_len(0);
+}
diff --git a/crates/salsa/tests/mutate_in_place.rs b/crates/salsa/tests/mutate_in_place.rs
new file mode 100644
index 000000000..047373ee5
--- /dev/null
+++ b/crates/salsa/tests/mutate_in_place.rs
@@ -0,0 +1,29 @@
+//! Test that a setting a field on a `#[salsa::input]`
+//! overwrites and returns the old value.
+
+use salsa::Setter;
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    field: String,
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::new(&db, "Hello".to_string());
+
+    // Overwrite field with an empty String
+    // and store the old value in my_string
+    let mut my_string = input.set_field(&mut db).to(String::new());
+    my_string.push_str(" World!");
+
+    // Set the field back to out initial String,
+    // expecting to get the empty one back
+    assert_eq!(input.set_field(&mut db).to(my_string), "");
+
+    // Check if the stored String is the one we expected
+    assert_eq!(input.field(&db), "Hello World!");
+}
diff --git a/crates/salsa/tests/override_new_get_set.rs b/crates/salsa/tests/override_new_get_set.rs
new file mode 100644
index 000000000..367decf04
--- /dev/null
+++ b/crates/salsa/tests/override_new_get_set.rs
@@ -0,0 +1,70 @@
+//! Test that the `constructor` macro overrides
+//! the `new` method's name and `get` and `set`
+//! change the name of the getter and setter of the fields.
+#![allow(warnings)]
+
+use std::fmt::Display;
+
+use salsa::Setter;
+
+#[salsa::db]
+trait Db: salsa::Database {}
+
+#[salsa::input(constructor = from_string)]
+struct MyInput {
+    #[get(text)]
+    #[set(set_text)]
+    field: String,
+}
+
+impl MyInput {
+    pub fn new(db: &mut dyn Db, s: impl Display) -> MyInput {
+        MyInput::from_string(db, s.to_string())
+    }
+
+    pub fn field(self, db: &dyn Db) -> String {
+        self.text(db)
+    }
+
+    pub fn set_field(self, db: &mut dyn Db, id: String) {
+        self.set_text(db).to(id);
+    }
+}
+
+#[salsa::interned(constructor = from_string)]
+struct MyInterned<'db> {
+    #[get(text)]
+    #[returns(ref)]
+    field: String,
+}
+
+impl<'db> MyInterned<'db> {
+    pub fn new(db: &'db dyn Db, s: impl Display) -> MyInterned<'db> {
+        MyInterned::from_string(db, s.to_string())
+    }
+
+    pub fn field(self, db: &'db dyn Db) -> &str {
+        &self.text(db)
+    }
+}
+
+#[salsa::tracked(constructor = from_string)]
+struct MyTracked<'db> {
+    #[get(text)]
+    field: String,
+}
+
+impl<'db> MyTracked<'db> {
+    pub fn new(db: &'db dyn Db, s: impl Display) -> MyTracked<'db> {
+        MyTracked::from_string(db, s.to_string())
+    }
+
+    pub fn field(self, db: &'db dyn Db) -> String {
+        self.text(db)
+    }
+}
+
+#[test]
+fn execute() {
+    salsa::DatabaseImpl::new();
+}
diff --git a/crates/salsa/tests/panic-when-creating-tracked-struct-outside-of-tracked-fn.rs b/crates/salsa/tests/panic-when-creating-tracked-struct-outside-of-tracked-fn.rs
new file mode 100644
index 000000000..32b444c7f
--- /dev/null
+++ b/crates/salsa/tests/panic-when-creating-tracked-struct-outside-of-tracked-fn.rs
@@ -0,0 +1,16 @@
+//! Test that creating a tracked struct outside of a
+//! tracked function panics with an assert message.
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[test]
+#[should_panic(
+    expected = "cannot create a tracked struct disambiguator outside of a tracked function"
+)]
+fn execute() {
+    let db = salsa::DatabaseImpl::new();
+    MyTracked::new(&db, 0);
+}
diff --git a/crates/salsa/tests/parallel/cycle_a_t1_b_t2.rs b/crates/salsa/tests/parallel/cycle_a_t1_b_t2.rs
new file mode 100644
index 000000000..aa0b84845
--- /dev/null
+++ b/crates/salsa/tests/parallel/cycle_a_t1_b_t2.rs
@@ -0,0 +1,74 @@
+//! Test a specific cycle scenario:
+//!
+//! ```text
+//! Thread T1          Thread T2
+//! ---------          ---------
+//!    |                  |
+//!    v                  |
+//! query_a()             |
+//!  ^  |                 v
+//!  |  +------------> query_b()
+//!  |                    |
+//!  +--------------------+
+//! ```
+
+use salsa::CycleRecoveryAction;
+
+use crate::setup::{Knobs, KnobsDatabase};
+
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy, salsa::Update)]
+struct CycleValue(u32);
+
+const MIN: CycleValue = CycleValue(0);
+const MAX: CycleValue = CycleValue(3);
+
+// Signal 1: T1 has entered `query_a`
+// Signal 2: T2 has entered `query_b`
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=initial)]
+fn query_a(db: &dyn KnobsDatabase) -> CycleValue {
+    db.signal(1);
+
+    // Wait for Thread T2 to enter `query_b` before we continue.
+    db.wait_for(2);
+
+    query_b(db)
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=initial)]
+fn query_b(db: &dyn KnobsDatabase) -> CycleValue {
+    // Wait for Thread T1 to enter `query_a` before we continue.
+    db.wait_for(1);
+
+    db.signal(2);
+
+    let a_value = query_a(db);
+    CycleValue(a_value.0 + 1).min(MAX)
+}
+
+fn cycle_fn(
+    _db: &dyn KnobsDatabase,
+    _value: &CycleValue,
+    _count: u32,
+) -> CycleRecoveryAction<CycleValue> {
+    CycleRecoveryAction::Iterate
+}
+
+fn initial(_db: &dyn KnobsDatabase) -> CycleValue {
+    MIN
+}
+
+#[test_log::test]
+fn the_test() {
+    std::thread::scope(|scope| {
+        let db_t1 = Knobs::default();
+        let db_t2 = db_t1.clone();
+
+        let t1 = scope.spawn(move || query_a(&db_t1));
+        let t2 = scope.spawn(move || query_b(&db_t2));
+
+        let (r_t1, r_t2) = (t1.join().unwrap(), t2.join().unwrap());
+
+        assert_eq!((r_t1, r_t2), (MAX, MAX));
+    });
+}
diff --git a/crates/salsa/tests/parallel/cycle_a_t1_b_t2_fallback.rs b/crates/salsa/tests/parallel/cycle_a_t1_b_t2_fallback.rs
new file mode 100644
index 000000000..faa4c39f4
--- /dev/null
+++ b/crates/salsa/tests/parallel/cycle_a_t1_b_t2_fallback.rs
@@ -0,0 +1,67 @@
+//! Test a specific cycle scenario:
+//!
+//! ```text
+//! Thread T1          Thread T2
+//! ---------          ---------
+//!    |                  |
+//!    v                  |
+//! query_a()             |
+//!  ^  |                 v
+//!  |  +------------> query_b()
+//!  |                    |
+//!  +--------------------+
+//! ```
+use crate::setup::{Knobs, KnobsDatabase};
+
+const FALLBACK_A: u32 = 0b01;
+const FALLBACK_B: u32 = 0b10;
+const OFFSET_A: u32 = 0b0100;
+const OFFSET_B: u32 = 0b1000;
+
+// Signal 1: T1 has entered `query_a`
+// Signal 2: T2 has entered `query_b`
+
+#[salsa::tracked(cycle_result=cycle_result_a)]
+fn query_a(db: &dyn KnobsDatabase) -> u32 {
+    db.signal(1);
+
+    // Wait for Thread T2 to enter `query_b` before we continue.
+    db.wait_for(2);
+
+    query_b(db) | OFFSET_A
+}
+
+#[salsa::tracked(cycle_result=cycle_result_b)]
+fn query_b(db: &dyn KnobsDatabase) -> u32 {
+    // Wait for Thread T1 to enter `query_a` before we continue.
+    db.wait_for(1);
+
+    db.signal(2);
+
+    query_a(db) | OFFSET_B
+}
+
+fn cycle_result_a(_db: &dyn KnobsDatabase) -> u32 {
+    FALLBACK_A
+}
+
+fn cycle_result_b(_db: &dyn KnobsDatabase) -> u32 {
+    FALLBACK_B
+}
+
+#[test_log::test]
+fn the_test() {
+    std::thread::scope(|scope| {
+        let db_t1 = Knobs::default();
+        let db_t2 = db_t1.clone();
+
+        let t1 = scope.spawn(move || query_a(&db_t1));
+        let t2 = scope.spawn(move || query_b(&db_t2));
+
+        let (r_t1, r_t2) = (t1.join(), t2.join());
+
+        assert_eq!((r_t1?, r_t2?), (FALLBACK_A, FALLBACK_B));
+        Ok(())
+    })
+    .unwrap_or_else(|e| std::panic::resume_unwind(e));
+}
diff --git a/crates/salsa/tests/parallel/cycle_ab_peeping_c.rs b/crates/salsa/tests/parallel/cycle_ab_peeping_c.rs
new file mode 100644
index 000000000..cff533e39
--- /dev/null
+++ b/crates/salsa/tests/parallel/cycle_ab_peeping_c.rs
@@ -0,0 +1,78 @@
+//! Test a specific cycle scenario:
+//!
+//! Thread T1 calls A which calls B which calls A.
+//!
+//! Thread T2 calls C which calls B.
+//!
+//! The trick is that the call from Thread T2 comes before B has reached a fixed point.
+//! We want to be sure that C sees the final value (and blocks until it is complete).
+
+use salsa::CycleRecoveryAction;
+
+use crate::setup::{Knobs, KnobsDatabase};
+
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy, salsa::Update)]
+struct CycleValue(u32);
+
+const MIN: CycleValue = CycleValue(0);
+const MID: CycleValue = CycleValue(5);
+const MAX: CycleValue = CycleValue(10);
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=cycle_initial)]
+fn query_a(db: &dyn KnobsDatabase) -> CycleValue {
+    let b_value = query_b(db);
+
+    // When we reach the mid point, signal stage 1 (unblocking T2)
+    // and then wait for T2 to signal stage 2.
+    if b_value == MID {
+        db.signal(1);
+        db.wait_for(2);
+    }
+
+    b_value
+}
+
+fn cycle_fn(
+    _db: &dyn KnobsDatabase,
+    _value: &CycleValue,
+    _count: u32,
+) -> CycleRecoveryAction<CycleValue> {
+    CycleRecoveryAction::Iterate
+}
+
+fn cycle_initial(_db: &dyn KnobsDatabase) -> CycleValue {
+    MIN
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=cycle_initial)]
+fn query_b(db: &dyn KnobsDatabase) -> CycleValue {
+    let a_value = query_a(db);
+
+    CycleValue(a_value.0 + 1).min(MAX)
+}
+
+#[salsa::tracked]
+fn query_c(db: &dyn KnobsDatabase) -> CycleValue {
+    // Wait until T1 has reached MID then execute `query_b`.
+    // This should block and (due to the configuration on our database) signal stage 2.
+    db.wait_for(1);
+
+    query_b(db)
+}
+
+#[test]
+fn the_test() {
+    std::thread::scope(|scope| {
+        let db_t1 = Knobs::default();
+
+        let db_t2 = db_t1.clone();
+        db_t2.signal_on_will_block(2);
+
+        let t1 = scope.spawn(move || query_a(&db_t1));
+        let t2 = scope.spawn(move || query_c(&db_t2));
+
+        let (r_t1, r_t2) = (t1.join().unwrap(), t2.join().unwrap());
+
+        assert_eq!((r_t1, r_t2), (MAX, MAX));
+    });
+}
diff --git a/crates/salsa/tests/parallel/cycle_nested_three_threads.rs b/crates/salsa/tests/parallel/cycle_nested_three_threads.rs
new file mode 100644
index 000000000..f0ff0e128
--- /dev/null
+++ b/crates/salsa/tests/parallel/cycle_nested_three_threads.rs
@@ -0,0 +1,89 @@
+//! Test a nested-cycle scenario across three threads:
+//!
+//! ```text
+//! Thread T1          Thread T2         Thread T3
+//! ---------          ---------         ---------
+//!    |                  |                  |
+//!    v                  |                  |
+//! query_a()             |                  |
+//!  ^  |                 v                  |
+//!  |  +------------> query_b()             |
+//!  |                  ^   |                v
+//!  |                  |   +------------> query_c()
+//!  |                  |                    |
+//!  +------------------+--------------------+
+//!
+//! ```
+
+use salsa::CycleRecoveryAction;
+
+use crate::setup::{Knobs, KnobsDatabase};
+
+#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Clone, Copy, salsa::Update)]
+struct CycleValue(u32);
+
+const MIN: CycleValue = CycleValue(0);
+const MAX: CycleValue = CycleValue(3);
+
+// Signal 1: T1 has entered `query_a`
+// Signal 2: T2 has entered `query_b`
+// Signal 3: T3 has entered `query_c`
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=initial)]
+fn query_a(db: &dyn KnobsDatabase) -> CycleValue {
+    db.signal(1);
+    db.wait_for(3);
+
+    query_b(db)
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=initial)]
+fn query_b(db: &dyn KnobsDatabase) -> CycleValue {
+    db.wait_for(1);
+    db.signal(2);
+    db.wait_for(3);
+
+    let c_value = query_c(db);
+    CycleValue(c_value.0 + 1).min(MAX)
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=initial)]
+fn query_c(db: &dyn KnobsDatabase) -> CycleValue {
+    db.wait_for(2);
+    db.signal(3);
+
+    let a_value = query_a(db);
+    let b_value = query_b(db);
+    CycleValue(a_value.0.max(b_value.0))
+}
+
+fn cycle_fn(
+    _db: &dyn KnobsDatabase,
+    _value: &CycleValue,
+    _count: u32,
+) -> CycleRecoveryAction<CycleValue> {
+    CycleRecoveryAction::Iterate
+}
+
+fn initial(_db: &dyn KnobsDatabase) -> CycleValue {
+    MIN
+}
+
+#[test_log::test]
+fn the_test() {
+    std::thread::scope(|scope| {
+        let db_t1 = Knobs::default();
+        let db_t2 = db_t1.clone();
+        let db_t3 = db_t1.clone();
+
+        let t1 = scope.spawn(move || query_a(&db_t1));
+        let t2 = scope.spawn(move || query_b(&db_t2));
+        let t3 = scope.spawn(move || query_c(&db_t3));
+
+        let r_t1 = t1.join().unwrap();
+        let r_t2 = t2.join().unwrap();
+        let r_t3 = t3.join().unwrap();
+
+        assert_eq!((r_t1, r_t2, r_t3), (MAX, MAX, MAX));
+    });
+}
diff --git a/crates/salsa/tests/parallel/cycle_panic.rs b/crates/salsa/tests/parallel/cycle_panic.rs
new file mode 100644
index 000000000..1c4825549
--- /dev/null
+++ b/crates/salsa/tests/parallel/cycle_panic.rs
@@ -0,0 +1,42 @@
+//! Test for panic in cycle recovery function, in cross-thread cycle.
+use crate::setup::{Knobs, KnobsDatabase};
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=initial)]
+fn query_a(db: &dyn KnobsDatabase) -> u32 {
+    db.signal(1);
+    db.wait_for(2);
+    query_b(db)
+}
+
+#[salsa::tracked(cycle_fn=cycle_fn, cycle_initial=initial)]
+fn query_b(db: &dyn KnobsDatabase) -> u32 {
+    db.wait_for(1);
+    db.signal(2);
+    query_a(db) + 1
+}
+
+fn cycle_fn(_db: &dyn KnobsDatabase, _value: &u32, _count: u32) -> salsa::CycleRecoveryAction<u32> {
+    panic!("cancel!")
+}
+
+fn initial(_db: &dyn KnobsDatabase) -> u32 {
+    0
+}
+
+#[test]
+fn execute() {
+    let db = Knobs::default();
+
+    std::thread::scope(|scope| {
+        let db_t1 = db.clone();
+        let t1 = scope.spawn(move || query_a(&db_t1));
+
+        let db_t2 = db.clone();
+        let t2 = scope.spawn(move || query_b(&db_t2));
+
+        // The main thing here is that we don't deadlock.
+        let (r1, r2) = (t1.join(), t2.join());
+        assert!(r1.is_err());
+        assert!(r2.is_err());
+    });
+}
diff --git a/crates/salsa/tests/parallel/main.rs b/crates/salsa/tests/parallel/main.rs
new file mode 100644
index 000000000..7507a71cf
--- /dev/null
+++ b/crates/salsa/tests/parallel/main.rs
@@ -0,0 +1,11 @@
+mod setup;
+
+mod cycle_a_t1_b_t2;
+mod cycle_a_t1_b_t2_fallback;
+mod cycle_ab_peeping_c;
+mod cycle_nested_three_threads;
+mod cycle_panic;
+mod parallel_cancellation;
+mod parallel_join;
+mod parallel_map;
+mod signal;
diff --git a/crates/salsa/tests/parallel/parallel_cancellation.rs b/crates/salsa/tests/parallel/parallel_cancellation.rs
new file mode 100644
index 000000000..7be92ca2c
--- /dev/null
+++ b/crates/salsa/tests/parallel/parallel_cancellation.rs
@@ -0,0 +1,65 @@
+//! Test for thread cancellation.
+
+use salsa::{Cancelled, Setter};
+
+use crate::setup::{Knobs, KnobsDatabase};
+
+#[salsa::input(debug)]
+struct MyInput {
+    field: i32,
+}
+
+#[salsa::tracked]
+fn a1(db: &dyn KnobsDatabase, input: MyInput) -> MyInput {
+    db.signal(1);
+    db.wait_for(2);
+    dummy(db, input)
+}
+
+#[salsa::tracked]
+fn dummy(_db: &dyn KnobsDatabase, _input: MyInput) -> MyInput {
+    panic!("should never get here!")
+}
+
+// Cancellation signalling test
+//
+// The pattern is as follows.
+//
+// Thread A                   Thread B
+// --------                   --------
+// a1
+// |                          wait for stage 1
+// signal stage 1             set input, triggers cancellation
+// wait for stage 2 (blocks)  triggering cancellation sends stage 2
+// |
+// (unblocked)
+// dummy
+// panics
+
+#[test]
+fn execute() {
+    let mut db = Knobs::default();
+
+    let input = MyInput::new(&db, 1);
+
+    let thread_a = std::thread::spawn({
+        let db = db.clone();
+        move || a1(&db, input)
+    });
+
+    db.signal_on_did_cancel(2);
+    input.set_field(&mut db).to(2);
+
+    // Assert thread A *should* was cancelled
+    let cancelled = thread_a
+        .join()
+        .unwrap_err()
+        .downcast::<Cancelled>()
+        .unwrap();
+
+    // and inspect the output
+    expect_test::expect![[r#"
+        PendingWrite
+    "#]]
+    .assert_debug_eq(&cancelled);
+}
diff --git a/crates/salsa/tests/parallel/parallel_join.rs b/crates/salsa/tests/parallel/parallel_join.rs
new file mode 100644
index 000000000..220e1ab9f
--- /dev/null
+++ b/crates/salsa/tests/parallel/parallel_join.rs
@@ -0,0 +1,103 @@
+#![cfg(feature = "rayon")]
+// test for rayon-like join interactions.
+
+use salsa::{Cancelled, Setter};
+
+use crate::setup::{Knobs, KnobsDatabase};
+
+#[salsa::input]
+struct ParallelInput {
+    a: u32,
+    b: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn salsa::Database, input: ParallelInput) -> (u32, u32) {
+    salsa::join(db, |db| input.a(db) + 1, |db| input.b(db) - 1)
+}
+
+#[salsa::tracked]
+fn a1(db: &dyn KnobsDatabase, input: ParallelInput) -> (u32, u32) {
+    db.signal(1);
+    salsa::join(
+        db,
+        |db| {
+            db.wait_for(2);
+            input.a(db) + dummy(db)
+        },
+        |db| {
+            db.wait_for(2);
+            input.b(db) + dummy(db)
+        },
+    )
+}
+
+#[salsa::tracked]
+fn dummy(_db: &dyn KnobsDatabase) -> u32 {
+    panic!("should never get here!")
+}
+
+#[test]
+#[cfg_attr(miri, ignore)]
+fn execute() {
+    let db = salsa::DatabaseImpl::new();
+
+    let input = ParallelInput::new(&db, 10, 20);
+
+    tracked_fn(&db, input);
+}
+
+// we expect this to panic, as `salsa::par_map` needs to be called from a query.
+#[test]
+#[cfg_attr(miri, ignore)]
+#[should_panic]
+fn direct_calls_panic() {
+    let db = salsa::DatabaseImpl::new();
+
+    let input = ParallelInput::new(&db, 10, 20);
+    let (_, _) = salsa::join(&db, |db| input.a(db) + 1, |db| input.b(db) - 1);
+}
+
+// Cancellation signalling test
+//
+// The pattern is as follows.
+//
+// Thread A                   Thread B
+// --------                   --------
+// a1
+// |                          wait for stage 1
+// signal stage 1             set input, triggers cancellation
+// wait for stage 2 (blocks)  triggering cancellation sends stage 2
+// |
+// (unblocked)
+// dummy
+// panics
+
+#[test]
+#[cfg_attr(miri, ignore)]
+fn execute_cancellation() {
+    let mut db = Knobs::default();
+
+    let input = ParallelInput::new(&db, 10, 20);
+
+    let thread_a = std::thread::spawn({
+        let db = db.clone();
+        move || a1(&db, input)
+    });
+
+    db.signal_on_did_cancel(2);
+    input.set_a(&mut db).to(30);
+
+    // Assert thread A was cancelled
+    let cancelled = thread_a
+        .join()
+        .unwrap_err()
+        .downcast::<Cancelled>()
+        .unwrap();
+
+    // and inspect the output
+    expect_test::expect![[r#"
+        PendingWrite
+    "#]]
+    .assert_debug_eq(&cancelled);
+}
diff --git a/crates/salsa/tests/parallel/parallel_map.rs b/crates/salsa/tests/parallel/parallel_map.rs
new file mode 100644
index 000000000..ef0bc028c
--- /dev/null
+++ b/crates/salsa/tests/parallel/parallel_map.rs
@@ -0,0 +1,100 @@
+#![cfg(feature = "rayon")]
+// test for rayon-like parallel map interactions.
+
+use salsa::{Cancelled, Setter};
+
+use crate::setup::{Knobs, KnobsDatabase};
+
+#[salsa::input]
+struct ParallelInput {
+    field: Vec<u32>,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn salsa::Database, input: ParallelInput) -> Vec<u32> {
+    salsa::par_map(db, input.field(db), |_db, field| field + 1)
+}
+
+#[salsa::tracked]
+fn a1(db: &dyn KnobsDatabase, input: ParallelInput) -> Vec<u32> {
+    db.signal(1);
+    salsa::par_map(db, input.field(db), |db, field| {
+        db.wait_for(2);
+        field + dummy(db)
+    })
+}
+
+#[salsa::tracked]
+fn dummy(_db: &dyn KnobsDatabase) -> u32 {
+    panic!("should never get here!")
+}
+
+#[test]
+#[cfg_attr(miri, ignore)]
+fn execute() {
+    let db = salsa::DatabaseImpl::new();
+
+    let counts = (1..=10).collect::<Vec<u32>>();
+    let input = ParallelInput::new(&db, counts);
+
+    tracked_fn(&db, input);
+}
+
+// we expect this to panic, as `salsa::par_map` needs to be called from a query.
+#[test]
+#[cfg_attr(miri, ignore)]
+#[should_panic]
+fn direct_calls_panic() {
+    let db = salsa::DatabaseImpl::new();
+
+    let counts = (1..=10).collect::<Vec<u32>>();
+    let input = ParallelInput::new(&db, counts);
+    let _: Vec<u32> = salsa::par_map(&db, input.field(&db), |_db, field| field + 1);
+}
+
+// Cancellation signalling test
+//
+// The pattern is as follows.
+//
+// Thread A                   Thread B
+// --------                   --------
+// a1
+// |                          wait for stage 1
+// signal stage 1             set input, triggers cancellation
+// wait for stage 2 (blocks)  triggering cancellation sends stage 2
+// |
+// (unblocked)
+// dummy
+// panics
+
+#[test]
+#[cfg_attr(miri, ignore)]
+fn execute_cancellation() {
+    let mut db = Knobs::default();
+
+    let counts = (1..=10).collect::<Vec<u32>>();
+    let input = ParallelInput::new(&db, counts);
+
+    let thread_a = std::thread::spawn({
+        let db = db.clone();
+        move || a1(&db, input)
+    });
+
+    let counts = (2..=20).collect::<Vec<u32>>();
+
+    db.signal_on_did_cancel(2);
+    input.set_field(&mut db).to(counts);
+
+    // Assert thread A *should* was cancelled
+    let cancelled = thread_a
+        .join()
+        .unwrap_err()
+        .downcast::<Cancelled>()
+        .unwrap();
+
+    // and inspect the output
+    expect_test::expect![[r#"
+        PendingWrite
+    "#]]
+    .assert_debug_eq(&cancelled);
+}
diff --git a/crates/salsa/tests/parallel/setup.rs b/crates/salsa/tests/parallel/setup.rs
new file mode 100644
index 000000000..442467f86
--- /dev/null
+++ b/crates/salsa/tests/parallel/setup.rs
@@ -0,0 +1,102 @@
+use std::sync::atomic::{AtomicUsize, Ordering};
+use std::sync::Arc;
+
+use salsa::{Database, Storage};
+
+use crate::signal::Signal;
+
+/// Various "knobs" and utilities used by tests to force
+/// a certain behavior.
+#[salsa::db]
+pub(crate) trait KnobsDatabase: Database {
+    /// Signal that we are entering stage `stage`.
+    fn signal(&self, stage: usize);
+
+    /// Wait until we reach stage `stage` (no-op if we have already reached that stage).
+    fn wait_for(&self, stage: usize);
+}
+
+/// A database containing various "knobs" that can be used to customize how the queries
+/// behave on one specific thread. Note that this state is
+/// intentionally thread-local (apart from `signal`).
+#[salsa::db]
+pub(crate) struct Knobs {
+    storage: salsa::Storage<Self>,
+
+    /// A kind of flexible barrier used to coordinate execution across
+    /// threads to ensure we reach various weird states.
+    pub(crate) signal: Arc<Signal>,
+
+    /// When this database is about to block, send this signal.
+    signal_on_will_block: Arc<AtomicUsize>,
+
+    /// When this database has set the cancellation flag, send this signal.
+    signal_on_did_cancel: Arc<AtomicUsize>,
+}
+
+impl Knobs {
+    pub fn signal_on_did_cancel(&self, stage: usize) {
+        self.signal_on_did_cancel.store(stage, Ordering::Release);
+    }
+
+    pub fn signal_on_will_block(&self, stage: usize) {
+        self.signal_on_will_block.store(stage, Ordering::Release);
+    }
+}
+
+impl Clone for Knobs {
+    #[track_caller]
+    fn clone(&self) -> Self {
+        // To avoid mistakes, check that when we clone, we haven't customized this behavior yet
+        assert_eq!(self.signal_on_will_block.load(Ordering::Acquire), 0);
+        assert_eq!(self.signal_on_did_cancel.load(Ordering::Acquire), 0);
+        Self {
+            storage: self.storage.clone(),
+            signal: self.signal.clone(),
+            signal_on_will_block: self.signal_on_will_block.clone(),
+            signal_on_did_cancel: self.signal_on_did_cancel.clone(),
+        }
+    }
+}
+
+impl Default for Knobs {
+    fn default() -> Self {
+        let signal = <Arc<Signal>>::default();
+        let signal_on_will_block = Arc::new(AtomicUsize::new(0));
+        let signal_on_did_cancel = Arc::new(AtomicUsize::new(0));
+
+        Self {
+            storage: Storage::new(Some(Box::new({
+                let signal = signal.clone();
+                let signal_on_will_block = signal_on_will_block.clone();
+                let signal_on_did_cancel = signal_on_did_cancel.clone();
+                move |event| match event.kind {
+                    salsa::EventKind::WillBlockOn { .. } => {
+                        signal.signal(signal_on_will_block.load(Ordering::Acquire));
+                    }
+                    salsa::EventKind::DidSetCancellationFlag => {
+                        signal.signal(signal_on_did_cancel.load(Ordering::Acquire));
+                    }
+                    _ => {}
+                }
+            }))),
+            signal,
+            signal_on_will_block,
+            signal_on_did_cancel,
+        }
+    }
+}
+
+#[salsa::db]
+impl salsa::Database for Knobs {}
+
+#[salsa::db]
+impl KnobsDatabase for Knobs {
+    fn signal(&self, stage: usize) {
+        self.signal.signal(stage);
+    }
+
+    fn wait_for(&self, stage: usize) {
+        self.signal.wait_for(stage);
+    }
+}
diff --git a/crates/salsa/tests/parallel/signal.rs b/crates/salsa/tests/parallel/signal.rs
new file mode 100644
index 000000000..e93cb469a
--- /dev/null
+++ b/crates/salsa/tests/parallel/signal.rs
@@ -0,0 +1,36 @@
+use parking_lot::{Condvar, Mutex};
+
+#[derive(Default)]
+pub(crate) struct Signal {
+    value: Mutex<usize>,
+    cond_var: Condvar,
+}
+
+impl Signal {
+    pub(crate) fn signal(&self, stage: usize) {
+        // This check avoids acquiring the lock for things that will
+        // clearly be a no-op. Not *necessary* but helps to ensure we
+        // are more likely to encounter weird race conditions;
+        // otherwise calls to `sum` will tend to be unnecessarily
+        // synchronous.
+        if stage > 0 {
+            let mut v = self.value.lock();
+            if stage > *v {
+                *v = stage;
+                self.cond_var.notify_all();
+            }
+        }
+    }
+
+    /// Waits until the given condition is true; the fn is invoked
+    /// with the current stage.
+    pub(crate) fn wait_for(&self, stage: usize) {
+        // As above, avoid lock if clearly a no-op.
+        if stage > 0 {
+            let mut v = self.value.lock();
+            while *v < stage {
+                self.cond_var.wait(&mut v);
+            }
+        }
+    }
+}
diff --git a/crates/salsa/tests/preverify-struct-with-leaked-data-2.rs b/crates/salsa/tests/preverify-struct-with-leaked-data-2.rs
new file mode 100644
index 000000000..df3bdf941
--- /dev/null
+++ b/crates/salsa/tests/preverify-struct-with-leaked-data-2.rs
@@ -0,0 +1,103 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+
+use std::cell::Cell;
+
+use common::LogDatabase;
+use expect_test::expect;
+mod common;
+use salsa::{Database, Setter};
+use test_log::test;
+
+thread_local! {
+    static COUNTER: Cell<usize> = const { Cell::new(0) };
+}
+
+#[salsa::input]
+struct MyInput {
+    field1: u32,
+    field2: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    #[tracked]
+    counter: usize,
+}
+
+#[salsa::tracked]
+fn function(db: &dyn Database, input: MyInput) -> (usize, usize) {
+    // Read input 1
+    let _field1 = input.field1(db);
+
+    // **BAD:** Leak in the value of the counter non-deterministically
+    let counter = COUNTER.with(|c| c.get());
+
+    // Create the tracked struct, which (from salsa's POV), only depends on field1;
+    // but which actually depends on the leaked value.
+    let tracked = MyTracked::new(db, counter);
+
+    // Read the tracked field
+    let result = counter_field(db, input, tracked);
+
+    // Read input 2. This will cause us to re-execute on revision 2.
+    let _field2 = input.field2(db);
+
+    (result, tracked.counter(db))
+}
+
+#[salsa::tracked]
+fn counter_field<'db>(db: &'db dyn Database, input: MyInput, tracked: MyTracked<'db>) -> usize {
+    // Read input 2. This will cause us to re-execute on revision 2.
+    let _field2 = input.field2(db);
+
+    tracked.counter(db)
+}
+
+#[test]
+fn test_leaked_inputs_ignored() {
+    let mut db = common::EventLoggerDatabase::default();
+
+    let input = MyInput::new(&db, 10, 20);
+    let result_in_rev_1 = function(&db, input);
+    db.assert_logs(expect![[r#"
+        [
+            "WillCheckCancellation",
+            "WillExecute { database_key: function(Id(0)) }",
+            "DidInternValue { key: counter_field::interned_arguments(Id(800)), revision: R1 }",
+            "WillCheckCancellation",
+            "WillExecute { database_key: counter_field(Id(800)) }",
+        ]"#]]);
+
+    assert_eq!(result_in_rev_1, (0, 0));
+
+    // Modify field2 so that `function` is seen to have changed --
+    // but only *after* the tracked struct is created.
+    input.set_field2(&mut db).to(30);
+
+    // Also modify the thread-local counter
+    COUNTER.with(|c| c.set(100));
+
+    let result_in_rev_2 = function(&db, input);
+    db.assert_logs(expect![[r#"
+        [
+            "DidSetCancellationFlag",
+            "WillCheckCancellation",
+            "DidReinternValue { key: counter_field::interned_arguments(Id(800)), revision: R2 }",
+            "WillCheckCancellation",
+            "WillExecute { database_key: counter_field(Id(800)) }",
+            "WillExecute { database_key: function(Id(0)) }",
+            "WillCheckCancellation",
+        ]"#]]);
+
+    // Salsa will re-execute `counter_field` before re-executing
+    // `function` since, from what it can see, no inputs have changed
+    // before `counter_field` is called. This will read the field of
+    // the tracked struct which means it will be *fixed* at `0`.
+    // When we re-execute `counter_field` later, we ignore the new
+    // value of 100 since the struct has already been read during
+    // this revision.
+    //
+    // Contrast with preverify-struct-with-leaked-data.rs.
+    assert_eq!(result_in_rev_2, (0, 0));
+}
diff --git a/crates/salsa/tests/preverify-struct-with-leaked-data.rs b/crates/salsa/tests/preverify-struct-with-leaked-data.rs
new file mode 100644
index 000000000..5c0f84954
--- /dev/null
+++ b/crates/salsa/tests/preverify-struct-with-leaked-data.rs
@@ -0,0 +1,95 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+
+use std::cell::Cell;
+
+use common::LogDatabase;
+use expect_test::expect;
+mod common;
+use salsa::{Database, Setter};
+use test_log::test;
+
+thread_local! {
+    static COUNTER: Cell<usize> = const { Cell::new(0) };
+}
+
+#[salsa::input]
+struct MyInput {
+    field1: u32,
+    field2: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    #[tracked]
+    counter: usize,
+}
+
+#[salsa::tracked]
+fn function(db: &dyn Database, input: MyInput) -> (usize, usize) {
+    // Read input 1
+    let _field1 = input.field1(db);
+
+    // **BAD:** Leak in the value of the counter non-deterministically
+    let counter = COUNTER.with(|c| c.get());
+
+    // Create the tracked struct, which (from salsa's POV), only depends on field1;
+    // but which actually depends on the leaked value.
+    let tracked = MyTracked::new(db, counter);
+
+    // Read the tracked field
+    let result = counter_field(db, tracked);
+
+    // Read input 2. This will cause us to re-execute on revision 2.
+    let _field2 = input.field2(db);
+
+    (result, tracked.counter(db))
+}
+
+#[salsa::tracked]
+fn counter_field<'db>(db: &'db dyn Database, tracked: MyTracked<'db>) -> usize {
+    tracked.counter(db)
+}
+
+#[test]
+fn test_leaked_inputs_ignored() {
+    let mut db = common::EventLoggerDatabase::default();
+
+    let input = MyInput::new(&db, 10, 20);
+    let result_in_rev_1 = function(&db, input);
+    db.assert_logs(expect![[r#"
+        [
+            "WillCheckCancellation",
+            "WillExecute { database_key: function(Id(0)) }",
+            "WillCheckCancellation",
+            "WillExecute { database_key: counter_field(Id(400)) }",
+        ]"#]]);
+
+    assert_eq!(result_in_rev_1, (0, 0));
+
+    // Modify field2 so that `function` is seen to have changed --
+    // but only *after* the tracked struct is created.
+    input.set_field2(&mut db).to(30);
+
+    // Also modify the thread-local counter
+    COUNTER.with(|c| c.set(100));
+
+    let result_in_rev_2 = function(&db, input);
+    db.assert_logs(expect![[r#"
+        [
+            "DidSetCancellationFlag",
+            "WillCheckCancellation",
+            "WillCheckCancellation",
+            "DidValidateMemoizedValue { database_key: counter_field(Id(400)) }",
+            "WillExecute { database_key: function(Id(0)) }",
+            "WillCheckCancellation",
+        ]"#]]);
+
+    // Because salsa does not see any way for the tracked
+    // struct to have changed, it will re-use the cached return value
+    // from `counter_field` (`0`). This in turn "locks" the cached
+    // struct so that the new value of 100 is ignored.
+    //
+    // Contrast with preverify-struct-with-leaked-data-2.rs.
+    assert_eq!(result_in_rev_2, (0, 0));
+}
diff --git a/crates/salsa/tests/return_mode.rs b/crates/salsa/tests/return_mode.rs
new file mode 100644
index 000000000..34f676288
--- /dev/null
+++ b/crates/salsa/tests/return_mode.rs
@@ -0,0 +1,172 @@
+use salsa::Database;
+
+#[salsa::input]
+struct DefaultInput {
+    text: String,
+}
+
+#[salsa::tracked]
+fn default_fn(db: &dyn Database, input: DefaultInput) -> String {
+    let input: String = input.text(db);
+    input
+}
+
+#[test]
+fn default_test() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = DefaultInput::new(db, "Test".into());
+        let x: String = default_fn(db, input);
+        expect_test::expect![[r#"
+            "Test"
+        "#]]
+        .assert_debug_eq(&x);
+    })
+}
+
+#[salsa::input]
+struct CopyInput {
+    #[returns(copy)]
+    text: &'static str,
+}
+
+#[salsa::tracked(returns(copy))]
+fn copy_fn(db: &dyn Database, input: CopyInput) -> &'static str {
+    let input: &'static str = input.text(db);
+    input
+}
+
+#[test]
+fn copy_test() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = CopyInput::new(db, "Test");
+        let x: &str = copy_fn(db, input);
+        expect_test::expect![[r#"
+            "Test"
+        "#]]
+        .assert_debug_eq(&x);
+    })
+}
+
+#[salsa::input]
+struct CloneInput {
+    #[returns(clone)]
+    text: String,
+}
+
+#[salsa::tracked(returns(clone))]
+fn clone_fn(db: &dyn Database, input: CloneInput) -> String {
+    let input: String = input.text(db);
+    input
+}
+
+#[test]
+fn clone_test() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = CloneInput::new(db, "Test".into());
+        let x: String = clone_fn(db, input);
+        expect_test::expect![[r#"
+            "Test"
+        "#]]
+        .assert_debug_eq(&x);
+    })
+}
+
+#[salsa::input]
+struct RefInput {
+    #[returns(ref)]
+    text: String,
+}
+
+#[salsa::tracked(returns(ref))]
+fn ref_fn(db: &dyn Database, input: RefInput) -> String {
+    let input: &String = input.text(db);
+    input.to_owned()
+}
+
+#[test]
+fn ref_test() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = RefInput::new(db, "Test".into());
+        let x: &String = ref_fn(db, input);
+        expect_test::expect![[r#"
+            "Test"
+        "#]]
+        .assert_debug_eq(&x);
+    })
+}
+
+#[salsa::input]
+struct DerefInput {
+    #[returns(deref)]
+    text: String,
+}
+
+#[salsa::tracked(returns(deref))]
+fn deref_fn(db: &dyn Database, input: DerefInput) -> String {
+    let input: &str = input.text(db);
+    input.to_owned()
+}
+
+#[test]
+fn deref_test() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = DerefInput::new(db, "Test".into());
+        let x: &str = deref_fn(db, input);
+        expect_test::expect![[r#"
+            "Test"
+        "#]]
+        .assert_debug_eq(&x);
+    })
+}
+
+#[salsa::input]
+struct AsRefInput {
+    #[returns(as_ref)]
+    text: Option<String>,
+}
+
+#[salsa::tracked(returns(as_ref))]
+fn as_ref_fn(db: &dyn Database, input: AsRefInput) -> Option<String> {
+    let input: Option<&String> = input.text(db);
+    input.cloned()
+}
+
+#[test]
+fn as_ref_test() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = AsRefInput::new(db, Some("Test".into()));
+        let x: Option<&String> = as_ref_fn(db, input);
+        expect_test::expect![[r#"
+            Some(
+                "Test",
+            )
+        "#]]
+        .assert_debug_eq(&x);
+    })
+}
+
+#[salsa::input]
+struct AsDerefInput {
+    #[returns(as_deref)]
+    text: Option<String>,
+}
+
+#[salsa::tracked(returns(as_deref))]
+fn as_deref_fn(db: &dyn Database, input: AsDerefInput) -> Option<String> {
+    let input: Option<&str> = input.text(db);
+    input.map(|s| s.to_owned())
+}
+
+#[test]
+fn as_deref_test() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = AsDerefInput::new(db, Some("Test".into()));
+        let x: Option<&str> = as_deref_fn(db, input);
+        expect_test::expect![[r#"
+            Some(
+                "Test",
+            )
+        "#]]
+        .assert_debug_eq(&x);
+    })
+}
diff --git a/crates/salsa/tests/singleton.rs b/crates/salsa/tests/singleton.rs
new file mode 100644
index 000000000..381db9b74
--- /dev/null
+++ b/crates/salsa/tests/singleton.rs
@@ -0,0 +1,48 @@
+//! Basic Singleton struct test:
+//!
+//! Singleton structs are created only once. Subsequent `get`s and `new`s after creation return the same `Id`.
+
+use expect_test::expect;
+use salsa::Database as _;
+use test_log::test;
+
+#[salsa::input(singleton, debug)]
+struct MyInput {
+    field: u32,
+    id_field: u16,
+}
+
+#[test]
+fn basic() {
+    let db = salsa::DatabaseImpl::new();
+    let input1 = MyInput::new(&db, 3, 4);
+    let input2 = MyInput::get(&db);
+
+    assert_eq!(input1, input2);
+
+    let input3 = MyInput::try_get(&db);
+    assert_eq!(Some(input1), input3);
+}
+
+#[test]
+#[should_panic]
+fn twice() {
+    let db = salsa::DatabaseImpl::new();
+    let input1 = MyInput::new(&db, 3, 4);
+    let input2 = MyInput::get(&db);
+
+    assert_eq!(input1, input2);
+
+    // should panic here
+    _ = MyInput::new(&db, 3, 5);
+}
+
+#[test]
+fn debug() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = MyInput::new(db, 3, 4);
+        let actual = format!("{input:?}");
+        let expected = expect!["MyInput { [salsa id]: Id(0), field: 3, id_field: 4 }"];
+        expected.assert_eq(&actual);
+    });
+}
diff --git a/crates/salsa/tests/specify-only-works-if-the-key-is-created-in-the-current-query.rs b/crates/salsa/tests/specify-only-works-if-the-key-is-created-in-the-current-query.rs
new file mode 100644
index 000000000..a407aee62
--- /dev/null
+++ b/crates/salsa/tests/specify-only-works-if-the-key-is-created-in-the-current-query.rs
@@ -0,0 +1,45 @@
+//! Test that `specify` only works if the key is a tracked struct created in the current query.
+//! compilation succeeds but execution panics
+#![allow(warnings)]
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_struct_created_in_another_query<'db>(
+    db: &'db dyn salsa::Database,
+    input: MyInput,
+) -> MyTracked<'db> {
+    MyTracked::new(db, input.field(db) * 2)
+}
+
+#[salsa::tracked]
+fn tracked_fn<'db>(db: &'db dyn salsa::Database, input: MyInput) -> MyTracked<'db> {
+    let t = tracked_struct_created_in_another_query(db, input);
+    if input.field(db) != 0 {
+        tracked_fn_extra::specify(db, t, 2222);
+    }
+    t
+}
+
+#[salsa::tracked(specify)]
+fn tracked_fn_extra<'db>(_db: &'db dyn salsa::Database, _input: MyTracked<'db>) -> u32 {
+    0
+}
+
+#[test]
+#[should_panic(
+    expected = "can only use `specify` on salsa structs created during the current tracked fn"
+)]
+fn execute_when_specified() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, 22);
+    let tracked = tracked_fn(&db, input);
+}
diff --git a/crates/salsa/tests/synthetic_write.rs b/crates/salsa/tests/synthetic_write.rs
new file mode 100644
index 000000000..9e3c2f305
--- /dev/null
+++ b/crates/salsa/tests/synthetic_write.rs
@@ -0,0 +1,43 @@
+//! Test that a constant `tracked` fn (has no inputs)
+//! compiles and executes successfully.
+#![allow(warnings)]
+
+mod common;
+
+use common::{LogDatabase, Logger};
+use expect_test::expect;
+use salsa::{Database, DatabaseImpl, Durability, Event, EventKind};
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn Database, input: MyInput) -> u32 {
+    input.field(db) * 2
+}
+
+#[test]
+fn execute() {
+    let mut db = common::ExecuteValidateLoggerDatabase::default();
+
+    let input = MyInput::new(&db, 22);
+    assert_eq!(tracked_fn(&db, input), 44);
+
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(WillExecute { database_key: tracked_fn(Id(0)) })",
+        ]"#]]);
+
+    // Bumps the revision
+    db.synthetic_write(Durability::LOW);
+
+    // Query should re-run
+    assert_eq!(tracked_fn(&db, input), 44);
+
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(DidValidateMemoizedValue { database_key: tracked_fn(Id(0)) })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/tracked-struct-id-field-bad-eq.rs b/crates/salsa/tests/tracked-struct-id-field-bad-eq.rs
new file mode 100644
index 000000000..44deec6cb
--- /dev/null
+++ b/crates/salsa/tests/tracked-struct-id-field-bad-eq.rs
@@ -0,0 +1,47 @@
+//! Test an id field whose `PartialEq` impl is always true.
+
+use salsa::{Database, Setter};
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    field: bool,
+}
+
+#[allow(clippy::derived_hash_with_manual_eq)]
+#[derive(Eq, Hash, Debug, Clone)]
+struct BadEq {
+    field: bool,
+}
+
+impl PartialEq for BadEq {
+    fn eq(&self, _other: &Self) -> bool {
+        true
+    }
+}
+
+impl From<bool> for BadEq {
+    fn from(value: bool) -> Self {
+        Self { field: value }
+    }
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: BadEq,
+}
+
+#[salsa::tracked]
+fn the_fn(db: &dyn Database, input: MyInput) {
+    let tracked0 = MyTracked::new(db, BadEq::from(input.field(db)));
+    assert_eq!(tracked0.field(db).field, input.field(db));
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, true);
+    the_fn(&db, input);
+    input.set_field(&mut db).to(false);
+    the_fn(&db, input);
+}
diff --git a/crates/salsa/tests/tracked-struct-id-field-bad-hash.rs b/crates/salsa/tests/tracked-struct-id-field-bad-hash.rs
new file mode 100644
index 000000000..58951d7ae
--- /dev/null
+++ b/crates/salsa/tests/tracked-struct-id-field-bad-hash.rs
@@ -0,0 +1,80 @@
+//! Test for a tracked struct where an untracked field has a
+//! very poorly chosen hash impl (always returns 0).
+//! This demonstrates that the `untracked fields on a struct
+//! can change values and yet the struct can have the same
+//! id (because struct ids are based on the *hash* of the
+//! untracked fields).
+
+use salsa::{Database as Db, Setter};
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    field: bool,
+}
+
+#[derive(PartialEq, Eq, PartialOrd, Ord, Debug, Clone)]
+struct BadHash {
+    field: bool,
+}
+
+impl From<bool> for BadHash {
+    fn from(value: bool) -> Self {
+        Self { field: value }
+    }
+}
+
+impl std::hash::Hash for BadHash {
+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+        state.write_i16(0);
+    }
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: BadHash,
+}
+
+#[salsa::tracked]
+fn the_fn(db: &dyn Db, input: MyInput) {
+    let tracked0 = MyTracked::new(db, BadHash::from(input.field(db)));
+    assert_eq!(tracked0.field(db).field, input.field(db));
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::new(&db, true);
+    the_fn(&db, input);
+    input.set_field(&mut db).to(false);
+    the_fn(&db, input);
+}
+
+#[salsa::tracked]
+fn create_tracked<'db>(db: &'db dyn Db, input: MyInput) -> MyTracked<'db> {
+    MyTracked::new(db, BadHash::from(input.field(db)))
+}
+
+#[salsa::tracked]
+fn with_tracked<'db>(db: &'db dyn Db, tracked: MyTracked<'db>) -> bool {
+    tracked.field(db).field
+}
+
+#[test]
+fn dependent_query() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::new(&db, true);
+    let tracked = create_tracked(&db, input);
+    assert!(with_tracked(&db, tracked));
+
+    input.set_field(&mut db).to(false);
+    // We now re-run the query that creates the tracked struct.
+    // Salsa will re-use the `MyTracked` struct from the previous revision
+    // because it thinks it is unchanged because of `BadHash`'s bad hash function.
+    // That's why Salsa updates the `MyTracked` struct in-place and the struct
+    // should be considered re-created even though it still has the same id.
+    let tracked = create_tracked(&db, input);
+    assert!(!with_tracked(&db, tracked));
+}
diff --git a/crates/salsa/tests/tracked-struct-unchanged-in-new-rev.rs b/crates/salsa/tests/tracked-struct-unchanged-in-new-rev.rs
new file mode 100644
index 000000000..e4633740f
--- /dev/null
+++ b/crates/salsa/tests/tracked-struct-unchanged-in-new-rev.rs
@@ -0,0 +1,34 @@
+use salsa::{Database as Db, Setter};
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn Db, input: MyInput) -> MyTracked<'_> {
+    MyTracked::new(db, input.field(db) / 2)
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let input1 = MyInput::new(&db, 22);
+    let input2 = MyInput::new(&db, 44);
+    let _tracked1 = tracked_fn(&db, input1);
+    let _tracked2 = tracked_fn(&db, input2);
+
+    // modify the input and change the revision
+    input1.set_field(&mut db).to(24);
+    let tracked2 = tracked_fn(&db, input2);
+
+    // this should not panic
+    tracked2.field(&db);
+}
diff --git a/crates/salsa/tests/tracked-struct-value-field-bad-eq.rs b/crates/salsa/tests/tracked-struct-value-field-bad-eq.rs
new file mode 100644
index 000000000..3a02d63c5
--- /dev/null
+++ b/crates/salsa/tests/tracked-struct-value-field-bad-eq.rs
@@ -0,0 +1,86 @@
+//! Test a field whose `PartialEq` impl is always true.
+//! This can result in us getting different results than
+//! if we were to execute from scratch.
+
+use expect_test::expect;
+use salsa::{Database, Setter};
+mod common;
+use common::LogDatabase;
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    field: bool,
+}
+
+#[allow(clippy::derived_hash_with_manual_eq)]
+#[derive(Eq, Hash, Debug, Clone)]
+struct BadEq {
+    field: bool,
+}
+
+impl PartialEq for BadEq {
+    fn eq(&self, _other: &Self) -> bool {
+        true
+    }
+}
+
+impl From<bool> for BadEq {
+    fn from(value: bool) -> Self {
+        Self { field: value }
+    }
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    #[tracked]
+    field: BadEq,
+}
+
+#[salsa::tracked]
+fn the_fn(db: &dyn Database, input: MyInput) -> bool {
+    let tracked = make_tracked_struct(db, input);
+    read_tracked_struct(db, tracked)
+}
+
+#[salsa::tracked]
+fn make_tracked_struct(db: &dyn Database, input: MyInput) -> MyTracked<'_> {
+    MyTracked::new(db, BadEq::from(input.field(db)))
+}
+
+#[salsa::tracked]
+fn read_tracked_struct<'db>(db: &'db dyn Database, tracked: MyTracked<'db>) -> bool {
+    tracked.field(db).field
+}
+
+#[test]
+fn execute() {
+    let mut db = common::ExecuteValidateLoggerDatabase::default();
+
+    let input = MyInput::new(&db, true);
+    let result = the_fn(&db, input);
+    assert!(result);
+
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(WillExecute { database_key: the_fn(Id(0)) })",
+            "salsa_event(WillExecute { database_key: make_tracked_struct(Id(0)) })",
+            "salsa_event(WillExecute { database_key: read_tracked_struct(Id(400)) })",
+        ]"#]]);
+
+    // Update the input to `false` and re-execute.
+    input.set_field(&mut db).to(false);
+    let result = the_fn(&db, input);
+
+    // If the `Eq` impl were working properly, we would
+    // now return `false`. But because the `Eq` is considered
+    // equal we re-use memoized results and so we get true.
+    assert!(result);
+
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(WillExecute { database_key: make_tracked_struct(Id(0)) })",
+            "salsa_event(DidValidateMemoizedValue { database_key: read_tracked_struct(Id(400)) })",
+            "salsa_event(DidValidateMemoizedValue { database_key: the_fn(Id(0)) })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/tracked-struct-value-field-not-eq.rs b/crates/salsa/tests/tracked-struct-value-field-not-eq.rs
new file mode 100644
index 000000000..e37d4af9e
--- /dev/null
+++ b/crates/salsa/tests/tracked-struct-value-field-not-eq.rs
@@ -0,0 +1,45 @@
+//! Test a field whose `PartialEq` impl is always true.
+//! This can our "last changed" data to be wrong
+//! but we *should* always reflect the final values.
+
+use salsa::{Database, Setter};
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    field: bool,
+}
+
+#[derive(Hash, Debug, Clone)]
+struct NotEq {
+    field: bool,
+}
+
+impl From<bool> for NotEq {
+    fn from(value: bool) -> Self {
+        Self { field: value }
+    }
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    #[tracked]
+    #[no_eq]
+    field: NotEq,
+}
+
+#[salsa::tracked]
+fn the_fn(db: &dyn Database, input: MyInput) {
+    let tracked0 = MyTracked::new(db, NotEq::from(input.field(db)));
+    assert_eq!(tracked0.field(db).field, input.field(db));
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+
+    let input = MyInput::new(&db, true);
+    the_fn(&db, input);
+    input.set_field(&mut db).to(false);
+    the_fn(&db, input);
+}
diff --git a/crates/salsa/tests/tracked_fn_constant.rs b/crates/salsa/tests/tracked_fn_constant.rs
new file mode 100644
index 000000000..c6753ebf4
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_constant.rs
@@ -0,0 +1,29 @@
+//! Test that a constant `tracked` fn (has no inputs)
+//! compiles and executes successfully.
+#![allow(warnings)]
+
+use crate::common::LogDatabase;
+
+mod common;
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn salsa::Database) -> u32 {
+    44
+}
+
+#[salsa::tracked]
+fn tracked_custom_db(db: &dyn LogDatabase) -> u32 {
+    44
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+    assert_eq!(tracked_fn(&db), 44);
+}
+
+#[test]
+fn execute_custom() {
+    let mut db = common::LoggerDatabase::default();
+    assert_eq!(tracked_custom_db(&db), 44);
+}
diff --git a/crates/salsa/tests/tracked_fn_high_durability_dependency.rs b/crates/salsa/tests/tracked_fn_high_durability_dependency.rs
new file mode 100644
index 000000000..a05be178f
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_high_durability_dependency.rs
@@ -0,0 +1,36 @@
+#![allow(warnings)]
+
+use salsa::plumbing::HasStorage;
+use salsa::{Database, Durability, Setter};
+
+mod common;
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn salsa::Database, input: MyInput) -> u32 {
+    input.field(db) * 2
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::default();
+
+    let input_high = MyInput::new(&mut db, 0);
+    input_high
+        .set_field(&mut db)
+        .with_durability(Durability::HIGH)
+        .to(2200);
+
+    assert_eq!(tracked_fn(&db, input_high), 4400);
+
+    // Changing the value should re-execute the query
+    input_high
+        .set_field(&mut db)
+        .with_durability(Durability::HIGH)
+        .to(2201);
+
+    assert_eq!(tracked_fn(&db, input_high), 4402);
+}
diff --git a/crates/salsa/tests/tracked_fn_multiple_args.rs b/crates/salsa/tests/tracked_fn_multiple_args.rs
new file mode 100644
index 000000000..7c014356c
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_multiple_args.rs
@@ -0,0 +1,25 @@
+//! Test that a `tracked` fn on multiple salsa struct args
+//! compiles and executes successfully.
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::interned]
+struct MyInterned<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn<'db>(db: &'db dyn salsa::Database, input: MyInput, interned: MyInterned<'db>) -> u32 {
+    input.field(db) + interned.field(db)
+}
+
+#[test]
+fn execute() {
+    let db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, 22);
+    let interned = MyInterned::new(&db, 33);
+    assert_eq!(tracked_fn(&db, input, interned), 55);
+}
diff --git a/crates/salsa/tests/tracked_fn_no_eq.rs b/crates/salsa/tests/tracked_fn_no_eq.rs
new file mode 100644
index 000000000..6f223b791
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_no_eq.rs
@@ -0,0 +1,49 @@
+mod common;
+
+use common::LogDatabase;
+use expect_test::expect;
+use salsa::Setter as _;
+
+#[salsa::input]
+struct Input {
+    number: i16,
+}
+
+#[salsa::tracked(no_eq)]
+fn abs_float(db: &dyn LogDatabase, input: Input) -> f32 {
+    let number = input.number(db);
+
+    db.push_log(format!("abs_float({number})"));
+    number.abs() as f32
+}
+
+#[salsa::tracked]
+fn derived(db: &dyn LogDatabase, input: Input) -> u32 {
+    let x = abs_float(db, input);
+    db.push_log("derived".to_string());
+
+    x as u32
+}
+#[test]
+fn invoke() {
+    let mut db = common::LoggerDatabase::default();
+
+    let input = Input::new(&db, 5);
+    let x = derived(&db, input);
+
+    assert_eq!(x, 5);
+
+    input.set_number(&mut db).to(-5);
+
+    // Derived should re-execute even the result of `abs_float` is the same.
+    let x = derived(&db, input);
+    assert_eq!(x, 5);
+
+    db.assert_logs(expect![[r#"
+        [
+            "abs_float(5)",
+            "derived",
+            "abs_float(-5)",
+            "derived",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/tracked_fn_on_input.rs b/crates/salsa/tests/tracked_fn_on_input.rs
new file mode 100644
index 000000000..e588a40a9
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_on_input.rs
@@ -0,0 +1,20 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+#![allow(warnings)]
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn salsa::Database, input: MyInput) -> u32 {
+    input.field(db) * 2
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, 22);
+    assert_eq!(tracked_fn(&db, input), 44);
+}
diff --git a/crates/salsa/tests/tracked_fn_on_input_with_high_durability.rs b/crates/salsa/tests/tracked_fn_on_input_with_high_durability.rs
new file mode 100644
index 000000000..fbf122dea
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_on_input_with_high_durability.rs
@@ -0,0 +1,54 @@
+#![allow(warnings)]
+
+use common::{EventLoggerDatabase, HasLogger, LogDatabase, Logger};
+use expect_test::expect;
+use salsa::plumbing::HasStorage;
+use salsa::{Database, Durability, Event, EventKind, Setter};
+
+mod common;
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn salsa::Database, input: MyInput) -> u32 {
+    input.field(db) * 2
+}
+
+#[test]
+fn execute() {
+    let mut db = EventLoggerDatabase::default();
+    let input_low = MyInput::new(&db, 22);
+    let input_high = MyInput::builder(2200).durability(Durability::HIGH).new(&db);
+
+    assert_eq!(tracked_fn(&db, input_low), 44);
+    assert_eq!(tracked_fn(&db, input_high), 4400);
+
+    db.assert_logs(expect![[r#"
+        [
+            "WillCheckCancellation",
+            "WillExecute { database_key: tracked_fn(Id(0)) }",
+            "WillCheckCancellation",
+            "WillExecute { database_key: tracked_fn(Id(1)) }",
+        ]"#]]);
+
+    db.synthetic_write(Durability::LOW);
+
+    assert_eq!(tracked_fn(&db, input_low), 44);
+    assert_eq!(tracked_fn(&db, input_high), 4400);
+
+    // FIXME: There's currently no good way to verify whether an input was validated using shallow or deep comparison.
+    // All we can do for now is verify that the values were validated.
+    // Note: It maybe confusing why it validates `input_high` when the write has `Durability::LOW`.
+    // This is because all values must be validated whenever a write occurs. It doesn't mean that it
+    // executed the query.
+    db.assert_logs(expect![[r#"
+        [
+            "DidSetCancellationFlag",
+            "WillCheckCancellation",
+            "DidValidateMemoizedValue { database_key: tracked_fn(Id(0)) }",
+            "WillCheckCancellation",
+            "DidValidateMemoizedValue { database_key: tracked_fn(Id(1)) }",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/tracked_fn_on_interned.rs b/crates/salsa/tests/tracked_fn_on_interned.rs
new file mode 100644
index 000000000..b551b880d
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_on_interned.rs
@@ -0,0 +1,20 @@
+//! Test that a `tracked` fn on a `salsa::interned`
+//! compiles and executes successfully.
+
+#[salsa::interned]
+struct Name<'db> {
+    name: String,
+}
+
+#[salsa::tracked]
+fn tracked_fn<'db>(db: &'db dyn salsa::Database, name: Name<'db>) -> String {
+    name.name(db).clone()
+}
+
+#[test]
+fn execute() {
+    let db = salsa::DatabaseImpl::new();
+    let name = Name::new(&db, "Salsa".to_string());
+
+    assert_eq!(tracked_fn(&db, name), "Salsa");
+}
diff --git a/crates/salsa/tests/tracked_fn_on_interned_enum.rs b/crates/salsa/tests/tracked_fn_on_interned_enum.rs
new file mode 100644
index 000000000..63fa03b67
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_on_interned_enum.rs
@@ -0,0 +1,93 @@
+//! Test that a `tracked` fn on a `salsa::interned`
+//! compiles and executes successfully.
+
+#[salsa::interned(no_lifetime, debug)]
+struct Name {
+    name: String,
+}
+
+#[salsa::interned(debug)]
+struct NameAndAge<'db> {
+    name_and_age: String,
+}
+
+#[salsa::interned(no_lifetime, debug)]
+struct Age {
+    age: u32,
+}
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, salsa::Supertype)]
+enum Enum<'db> {
+    Name(Name),
+    NameAndAge(NameAndAge<'db>),
+    Age(Age),
+}
+
+#[salsa::input(debug)]
+struct Input {
+    value: String,
+}
+
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, salsa::Supertype)]
+enum EnumOfEnum<'db> {
+    Enum(Enum<'db>),
+    Input(Input),
+}
+
+#[salsa::tracked]
+fn tracked_fn<'db>(db: &'db dyn salsa::Database, enum_: Enum<'db>) -> String {
+    match enum_ {
+        Enum::Name(name) => name.name(db),
+        Enum::NameAndAge(name_and_age) => name_and_age.name_and_age(db),
+        Enum::Age(age) => age.age(db).to_string(),
+    }
+}
+
+#[salsa::tracked]
+fn tracked_fn2<'db>(db: &'db dyn salsa::Database, enum_: EnumOfEnum<'db>) -> String {
+    match enum_ {
+        EnumOfEnum::Enum(enum_) => tracked_fn(db, enum_),
+        EnumOfEnum::Input(input) => input.value(db),
+    }
+}
+
+#[test]
+fn execute() {
+    let db = salsa::DatabaseImpl::new();
+    let name = Name::new(&db, "Salsa".to_string());
+    let name_and_age = NameAndAge::new(&db, "Salsa 3".to_string());
+    let age = Age::new(&db, 123);
+
+    assert_eq!(tracked_fn(&db, Enum::Name(name)), "Salsa");
+    assert_eq!(tracked_fn(&db, Enum::NameAndAge(name_and_age)), "Salsa 3");
+    assert_eq!(tracked_fn(&db, Enum::Age(age)), "123");
+    assert_eq!(tracked_fn(&db, Enum::Name(name)), "Salsa");
+    assert_eq!(tracked_fn(&db, Enum::NameAndAge(name_and_age)), "Salsa 3");
+    assert_eq!(tracked_fn(&db, Enum::Age(age)), "123");
+
+    assert_eq!(
+        tracked_fn2(&db, EnumOfEnum::Enum(Enum::Name(name))),
+        "Salsa"
+    );
+    assert_eq!(
+        tracked_fn2(&db, EnumOfEnum::Enum(Enum::NameAndAge(name_and_age))),
+        "Salsa 3"
+    );
+    assert_eq!(tracked_fn2(&db, EnumOfEnum::Enum(Enum::Age(age))), "123");
+    assert_eq!(
+        tracked_fn2(&db, EnumOfEnum::Enum(Enum::Name(name))),
+        "Salsa"
+    );
+    assert_eq!(
+        tracked_fn2(&db, EnumOfEnum::Enum(Enum::NameAndAge(name_and_age))),
+        "Salsa 3"
+    );
+    assert_eq!(tracked_fn2(&db, EnumOfEnum::Enum(Enum::Age(age))), "123");
+    assert_eq!(
+        tracked_fn2(
+            &db,
+            EnumOfEnum::Input(Input::new(&db, "Hello world!".to_string()))
+        ),
+        "Hello world!"
+    );
+}
diff --git a/crates/salsa/tests/tracked_fn_on_tracked.rs b/crates/salsa/tests/tracked_fn_on_tracked.rs
new file mode 100644
index 000000000..967bbd558
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_on_tracked.rs
@@ -0,0 +1,24 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn salsa::Database, input: MyInput) -> MyTracked<'_> {
+    MyTracked::new(db, input.field(db) * 2)
+}
+
+#[test]
+fn execute() {
+    let db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, 22);
+    assert_eq!(tracked_fn(&db, input).field(&db), 44);
+}
diff --git a/crates/salsa/tests/tracked_fn_on_tracked_specify.rs b/crates/salsa/tests/tracked_fn_on_tracked_specify.rs
new file mode 100644
index 000000000..70e4997a2
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_on_tracked_specify.rs
@@ -0,0 +1,45 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+#![allow(warnings)]
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn<'db>(db: &'db dyn salsa::Database, input: MyInput) -> MyTracked<'db> {
+    let t = MyTracked::new(db, input.field(db) * 2);
+    if input.field(db) != 0 {
+        tracked_fn_extra::specify(db, t, 2222);
+    }
+    t
+}
+
+#[salsa::tracked(specify)]
+fn tracked_fn_extra<'db>(_db: &'db dyn salsa::Database, _input: MyTracked<'db>) -> u32 {
+    0
+}
+
+#[test]
+fn execute_when_specified() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, 22);
+    let tracked = tracked_fn(&db, input);
+    assert_eq!(tracked.field(&db), 44);
+    assert_eq!(tracked_fn_extra(&db, tracked), 2222);
+}
+
+#[test]
+fn execute_when_not_specified() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, 0);
+    let tracked = tracked_fn(&db, input);
+    assert_eq!(tracked.field(&db), 0);
+    assert_eq!(tracked_fn_extra(&db, tracked), 0);
+}
diff --git a/crates/salsa/tests/tracked_fn_read_own_entity.rs b/crates/salsa/tests/tracked_fn_read_own_entity.rs
new file mode 100644
index 000000000..11ae72c18
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_read_own_entity.rs
@@ -0,0 +1,87 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+
+use expect_test::expect;
+mod common;
+use common::LogDatabase;
+use salsa::Setter;
+use test_log::test;
+
+#[salsa::input(debug)]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn final_result(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("final_result({input:?})"));
+    intermediate_result(db, input).field(db) * 2
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn intermediate_result(db: &dyn LogDatabase, input: MyInput) -> MyTracked<'_> {
+    db.push_log(format!("intermediate_result({input:?})"));
+    let tracked = MyTracked::new(db, input.field(db) / 2);
+    let _ = tracked.field(db); // read the field of an entity we created
+    tracked
+}
+
+#[test]
+fn one_entity() {
+    let mut db = common::LoggerDatabase::default();
+
+    let input = MyInput::new(&db, 22);
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result(MyInput { [salsa id]: Id(0), field: 22 })",
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 22 })",
+        ]"#]]);
+
+    // Intermediate result is the same, so final result does
+    // not need to be recomputed:
+    input.set_field(&mut db).to(23);
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 23 })",
+        ]"#]]);
+
+    input.set_field(&mut db).to(24);
+    assert_eq!(final_result(&db, input), 24);
+    db.assert_logs(expect![[r#"
+        [
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 24 })",
+            "final_result(MyInput { [salsa id]: Id(0), field: 24 })",
+        ]"#]]);
+}
+
+/// Create and mutate a distinct input. No re-execution required.
+#[test]
+fn red_herring() {
+    let mut db = common::LoggerDatabase::default();
+
+    let input = MyInput::new(&db, 22);
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        [
+            "final_result(MyInput { [salsa id]: Id(0), field: 22 })",
+            "intermediate_result(MyInput { [salsa id]: Id(0), field: 22 })",
+        ]"#]]);
+
+    // Create a distinct input and mutate it.
+    // This will trigger a new revision in the database
+    // but shouldn't actually invalidate our existing ones.
+    let input2 = MyInput::new(&db, 44);
+    input2.set_field(&mut db).to(66);
+
+    // Re-run the query on the original input. Nothing re-executes!
+    assert_eq!(final_result(&db, input), 22);
+    db.assert_logs(expect![[r#"
+        []"#]]);
+}
diff --git a/crates/salsa/tests/tracked_fn_read_own_specify.rs b/crates/salsa/tests/tracked_fn_read_own_specify.rs
new file mode 100644
index 000000000..a96cba356
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_read_own_specify.rs
@@ -0,0 +1,47 @@
+use expect_test::expect;
+mod common;
+use common::LogDatabase;
+use salsa::Database;
+
+#[salsa::input(debug)]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked(debug)]
+struct MyTracked<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn LogDatabase, input: MyInput) -> u32 {
+    db.push_log(format!("tracked_fn({input:?})"));
+    let t = MyTracked::new(db, input.field(db) * 2);
+    tracked_fn_extra::specify(db, t, 2222);
+    tracked_fn_extra(db, t)
+}
+
+#[salsa::tracked(specify)]
+fn tracked_fn_extra<'db>(db: &'db dyn LogDatabase, input: MyTracked<'db>) -> u32 {
+    db.push_log(format!("tracked_fn_extra({input:?})"));
+    0
+}
+
+#[test]
+fn execute() {
+    let mut db = common::LoggerDatabase::default();
+    let input = MyInput::new(&db, 22);
+    assert_eq!(tracked_fn(&db, input), 2222);
+    db.assert_logs(expect![[r#"
+        [
+            "tracked_fn(MyInput { [salsa id]: Id(0), field: 22 })",
+        ]"#]]);
+
+    // A "synthetic write" causes the system to act *as though* some
+    // input of durability `durability` has changed.
+    db.synthetic_write(salsa::Durability::LOW);
+
+    // Re-run the query on the original input. Nothing re-executes!
+    assert_eq!(tracked_fn(&db, input), 2222);
+    db.assert_logs(expect!["[]"]);
+}
diff --git a/crates/salsa/tests/tracked_fn_return_ref.rs b/crates/salsa/tests/tracked_fn_return_ref.rs
new file mode 100644
index 000000000..918f33b37
--- /dev/null
+++ b/crates/salsa/tests/tracked_fn_return_ref.rs
@@ -0,0 +1,27 @@
+use salsa::Database;
+
+#[salsa::input]
+struct Input {
+    number: usize,
+}
+
+#[salsa::tracked(returns(ref))]
+fn test(db: &dyn salsa::Database, input: Input) -> Vec<String> {
+    (0..input.number(db)).map(|i| format!("test {i}")).collect()
+}
+
+#[test]
+fn invoke() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = Input::new(db, 3);
+        let x: &Vec<String> = test(db, input);
+        expect_test::expect![[r#"
+            [
+                "test 0",
+                "test 1",
+                "test 2",
+            ]
+        "#]]
+        .assert_debug_eq(x);
+    })
+}
diff --git a/crates/salsa/tests/tracked_method.rs b/crates/salsa/tests/tracked_method.rs
new file mode 100644
index 000000000..4fc283a64
--- /dev/null
+++ b/crates/salsa/tests/tracked_method.rs
@@ -0,0 +1,59 @@
+//! Test that a `tracked` fn on a `salsa::input`
+//! compiles and executes successfully.
+#![allow(warnings)]
+
+use common::LogDatabase as _;
+use expect_test::expect;
+
+mod common;
+
+trait TrackedTrait {
+    fn tracked_trait_fn(self, db: &dyn salsa::Database) -> u32;
+}
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+impl MyInput {
+    #[salsa::tracked]
+    fn tracked_fn(self, db: &dyn salsa::Database) -> u32 {
+        self.field(db) * 2
+    }
+
+    #[salsa::tracked(returns(ref))]
+    fn tracked_fn_ref(self, db: &dyn salsa::Database) -> u32 {
+        self.field(db) * 3
+    }
+}
+
+#[salsa::tracked]
+impl TrackedTrait for MyInput {
+    #[salsa::tracked]
+    fn tracked_trait_fn(self, db: &dyn salsa::Database) -> u32 {
+        self.field(db) * 4
+    }
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+    let object = MyInput::new(&mut db, 22);
+    // assert_eq!(object.tracked_fn(&db), 44);
+    // assert_eq!(*object.tracked_fn_ref(&db), 66);
+    assert_eq!(object.tracked_trait_fn(&db), 88);
+}
+
+#[test]
+fn debug_name() {
+    let mut db = common::ExecuteValidateLoggerDatabase::default();
+    let object = MyInput::new(&mut db, 22);
+
+    assert_eq!(object.tracked_trait_fn(&db), 88);
+    db.assert_logs(expect![[r#"
+        [
+            "salsa_event(WillExecute { database_key: tracked_trait_fn_(Id(0)) })",
+        ]"#]]);
+}
diff --git a/crates/salsa/tests/tracked_method_inherent_return_deref.rs b/crates/salsa/tests/tracked_method_inherent_return_deref.rs
new file mode 100644
index 000000000..2477b5a1d
--- /dev/null
+++ b/crates/salsa/tests/tracked_method_inherent_return_deref.rs
@@ -0,0 +1,31 @@
+use salsa::Database;
+
+#[salsa::input]
+struct Input {
+    number: usize,
+}
+
+#[salsa::tracked]
+impl Input {
+    #[salsa::tracked(returns(deref))]
+    fn test(self, db: &dyn salsa::Database) -> Vec<String> {
+        (0..self.number(db)).map(|i| format!("test {i}")).collect()
+    }
+}
+
+#[test]
+fn invoke() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = Input::new(db, 3);
+        let x: &[String] = input.test(db);
+
+        assert_eq!(
+            x,
+            &[
+                "test 0".to_string(),
+                "test 1".to_string(),
+                "test 2".to_string()
+            ]
+        );
+    })
+}
diff --git a/crates/salsa/tests/tracked_method_inherent_return_ref.rs b/crates/salsa/tests/tracked_method_inherent_return_ref.rs
new file mode 100644
index 000000000..564bb31ff
--- /dev/null
+++ b/crates/salsa/tests/tracked_method_inherent_return_ref.rs
@@ -0,0 +1,30 @@
+use salsa::Database;
+
+#[salsa::input]
+struct Input {
+    number: usize,
+}
+
+#[salsa::tracked]
+impl Input {
+    #[salsa::tracked(returns(ref))]
+    fn test(self, db: &dyn salsa::Database) -> Vec<String> {
+        (0..self.number(db)).map(|i| format!("test {i}")).collect()
+    }
+}
+
+#[test]
+fn invoke() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = Input::new(db, 3);
+        let x: &Vec<String> = input.test(db);
+        expect_test::expect![[r#"
+            [
+                "test 0",
+                "test 1",
+                "test 2",
+            ]
+        "#]]
+        .assert_debug_eq(x);
+    })
+}
diff --git a/crates/salsa/tests/tracked_method_on_tracked_struct.rs b/crates/salsa/tests/tracked_method_on_tracked_struct.rs
new file mode 100644
index 000000000..f7cb9f6da
--- /dev/null
+++ b/crates/salsa/tests/tracked_method_on_tracked_struct.rs
@@ -0,0 +1,66 @@
+use salsa::Database;
+
+#[derive(Debug, PartialEq, Eq, Hash)]
+pub struct Item {}
+
+#[salsa::input]
+pub struct Input {
+    name: String,
+}
+
+#[salsa::tracked]
+impl Input {
+    #[salsa::tracked]
+    pub fn source_tree(self, db: &dyn Database) -> SourceTree<'_> {
+        SourceTree::new(db, self.name(db).clone())
+    }
+}
+
+#[salsa::tracked]
+pub struct SourceTree<'db> {
+    name: String,
+}
+
+#[salsa::tracked]
+impl<'db1> SourceTree<'db1> {
+    #[salsa::tracked(returns(ref))]
+    pub fn inherent_item_name(self, db: &'db1 dyn Database) -> String {
+        self.name(db)
+    }
+}
+
+trait ItemName<'db1> {
+    fn trait_item_name(self, db: &'db1 dyn Database) -> &'db1 String;
+}
+
+#[salsa::tracked]
+impl<'db1> ItemName<'db1> for SourceTree<'db1> {
+    #[salsa::tracked(returns(ref))]
+    fn trait_item_name(self, db: &'db1 dyn Database) -> String {
+        self.name(db)
+    }
+}
+
+#[test]
+fn test_inherent() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = Input::new(db, "foo".to_string());
+        let source_tree = input.source_tree(db);
+        expect_test::expect![[r#"
+            "foo"
+        "#]]
+        .assert_debug_eq(source_tree.inherent_item_name(db));
+    })
+}
+
+#[test]
+fn test_trait() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = Input::new(db, "foo".to_string());
+        let source_tree = input.source_tree(db);
+        expect_test::expect![[r#"
+            "foo"
+        "#]]
+        .assert_debug_eq(source_tree.trait_item_name(db));
+    })
+}
diff --git a/crates/salsa/tests/tracked_method_trait_return_ref.rs b/crates/salsa/tests/tracked_method_trait_return_ref.rs
new file mode 100644
index 000000000..ec74cf3ae
--- /dev/null
+++ b/crates/salsa/tests/tracked_method_trait_return_ref.rs
@@ -0,0 +1,34 @@
+use salsa::Database;
+
+#[salsa::input]
+struct Input {
+    number: usize,
+}
+
+trait Trait {
+    fn test(self, db: &dyn salsa::Database) -> &Vec<String>;
+}
+
+#[salsa::tracked]
+impl Trait for Input {
+    #[salsa::tracked(returns(ref))]
+    fn test(self, db: &dyn salsa::Database) -> Vec<String> {
+        (0..self.number(db)).map(|i| format!("test {i}")).collect()
+    }
+}
+
+#[test]
+fn invoke() {
+    salsa::DatabaseImpl::new().attach(|db| {
+        let input = Input::new(db, 3);
+        let x: &Vec<String> = input.test(db);
+        expect_test::expect![[r#"
+            [
+                "test 0",
+                "test 1",
+                "test 2",
+            ]
+        "#]]
+        .assert_debug_eq(x);
+    })
+}
diff --git a/crates/salsa/tests/tracked_method_with_self_ty.rs b/crates/salsa/tests/tracked_method_with_self_ty.rs
new file mode 100644
index 000000000..8f8b0678d
--- /dev/null
+++ b/crates/salsa/tests/tracked_method_with_self_ty.rs
@@ -0,0 +1,44 @@
+//! Test that a `tracked` fn with `Self` in its signature or body on a `salsa::input`
+//! compiles and executes successfully.
+#![allow(warnings)]
+
+trait TrackedTrait {
+    type Type;
+
+    fn tracked_trait_fn(self, db: &dyn salsa::Database, ty: Self::Type) -> Self::Type;
+
+    fn untracked_trait_fn();
+}
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+impl MyInput {
+    #[salsa::tracked]
+    fn tracked_fn(self, db: &dyn salsa::Database, other: Self) -> u32 {
+        self.field(db) + other.field(db)
+    }
+}
+
+#[salsa::tracked]
+impl TrackedTrait for MyInput {
+    type Type = u32;
+
+    #[salsa::tracked]
+    fn tracked_trait_fn(self, db: &dyn salsa::Database, ty: Self::Type) -> Self::Type {
+        Self::untracked_trait_fn();
+        Self::tracked_fn(self, db, self) + ty
+    }
+
+    fn untracked_trait_fn() {}
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+    let object = MyInput::new(&mut db, 10);
+    assert_eq!(object.tracked_trait_fn(&db, 1), 21);
+}
diff --git a/crates/salsa/tests/tracked_struct.rs b/crates/salsa/tests/tracked_struct.rs
new file mode 100644
index 000000000..a1bba36c6
--- /dev/null
+++ b/crates/salsa/tests/tracked_struct.rs
@@ -0,0 +1,56 @@
+mod common;
+
+use salsa::{Database, Setter};
+
+#[salsa::tracked]
+struct Tracked<'db> {
+    untracked_1: usize,
+
+    untracked_2: usize,
+}
+
+#[salsa::input]
+struct MyInput {
+    field1: usize,
+    field2: usize,
+}
+
+#[salsa::tracked]
+fn intermediate(db: &dyn salsa::Database, input: MyInput) -> Tracked<'_> {
+    Tracked::new(db, input.field1(db), input.field2(db))
+}
+
+#[salsa::tracked]
+fn accumulate(db: &dyn salsa::Database, input: MyInput) -> (usize, usize) {
+    let tracked = intermediate(db, input);
+    let one = read_tracked_1(db, tracked);
+    let two = read_tracked_2(db, tracked);
+
+    (one, two)
+}
+
+#[salsa::tracked]
+fn read_tracked_1<'db>(db: &'db dyn Database, tracked: Tracked<'db>) -> usize {
+    tracked.untracked_1(db)
+}
+
+#[salsa::tracked]
+fn read_tracked_2<'db>(db: &'db dyn Database, tracked: Tracked<'db>) -> usize {
+    tracked.untracked_2(db)
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::default();
+    let input = MyInput::new(&db, 1, 1);
+
+    assert_eq!(accumulate(&db, input), (1, 1));
+
+    // Should only re-execute `read_tracked_1`.
+    input.set_field1(&mut db).to(2);
+    assert_eq!(accumulate(&db, input), (2, 1));
+
+    // Should only re-execute `read_tracked_2`.
+    input.set_field2(&mut db).to(2);
+    assert_eq!(accumulate(&db, input), (2, 2));
+}
diff --git a/crates/salsa/tests/tracked_struct_db1_lt.rs b/crates/salsa/tests/tracked_struct_db1_lt.rs
new file mode 100644
index 000000000..e5de757ca
--- /dev/null
+++ b/crates/salsa/tests/tracked_struct_db1_lt.rs
@@ -0,0 +1,24 @@
+//! Test that tracked structs with lifetimes not named `'db`
+//! compile successfully.
+
+mod common;
+
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked]
+struct MyTracked1<'db1> {
+    field: MyTracked2<'db1>,
+}
+
+#[salsa::tracked]
+struct MyTracked2<'db2> {
+    field: u32,
+}
+
+#[test]
+fn create_db() {}
diff --git a/crates/salsa/tests/tracked_struct_disambiguates.rs b/crates/salsa/tests/tracked_struct_disambiguates.rs
new file mode 100644
index 000000000..663fedf42
--- /dev/null
+++ b/crates/salsa/tests/tracked_struct_disambiguates.rs
@@ -0,0 +1,104 @@
+//! Test that disambiguation works, that is when we have a revision where we track multiple structs
+//! that have the same hash, we can still differentiate between them.
+#![allow(warnings)]
+
+use std::hash::Hash;
+
+use rayon::iter::Either;
+use salsa::Setter;
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::input]
+struct MyInputs {
+    field: Vec<MyInput>,
+}
+
+#[salsa::tracked]
+struct TrackedStruct<'db> {
+    field: DumbHashable,
+}
+
+#[salsa::tracked]
+struct TrackedStruct2<'db> {
+    field: DumbHashable,
+}
+
+#[derive(Debug, Clone)]
+pub struct DumbHashable {
+    field: u32,
+}
+
+impl Eq for DumbHashable {}
+impl PartialEq for DumbHashable {
+    fn eq(&self, other: &Self) -> bool {
+        self.field == other.field
+    }
+}
+
+// Force collisions, note that this is still a correct implementation wrt. PartialEq / Eq above
+// as keep the property that k1 == k2 -> hash(k1) == hash(k2)
+impl Hash for DumbHashable {
+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
+        (self.field % 3).hash(state);
+    }
+}
+
+fn alternate(
+    db: &dyn salsa::Database,
+    input: MyInput,
+) -> Either<TrackedStruct<'_>, TrackedStruct2<'_>> {
+    if input.field(db) % 2 == 0 {
+        Either::Left(TrackedStruct::new(
+            db,
+            DumbHashable {
+                field: input.field(db),
+            },
+        ))
+    } else {
+        Either::Right(TrackedStruct2::new(
+            db,
+            DumbHashable {
+                field: input.field(db),
+            },
+        ))
+    }
+}
+
+#[salsa::tracked]
+fn batch(
+    db: &dyn salsa::Database,
+    inputs: MyInputs,
+) -> Vec<Either<TrackedStruct<'_>, TrackedStruct2<'_>>> {
+    inputs
+        .field(db)
+        .iter()
+        .map(|input| alternate(db, input.clone()))
+        .collect()
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+    let inputs = MyInputs::new(
+        &db,
+        (0..64).into_iter().map(|i| MyInput::new(&db, i)).collect(),
+    );
+    let trackeds = batch(&db, inputs);
+    for (id, tracked) in trackeds.into_iter().enumerate() {
+        assert_eq!(id % 2 == 0, tracked.is_left());
+        assert_eq!(id % 2 != 0, tracked.is_right());
+    }
+    for input in inputs.field(&db) {
+        let prev = input.field(&db);
+        input.set_field(&mut db).to(prev);
+    }
+    let trackeds = batch(&db, inputs);
+    for (id, tracked) in trackeds.into_iter().enumerate() {
+        assert_eq!(id % 2 == 0, tracked.is_left());
+        assert_eq!(id % 2 != 0, tracked.is_right());
+    }
+}
diff --git a/crates/salsa/tests/tracked_struct_durability.rs b/crates/salsa/tests/tracked_struct_durability.rs
new file mode 100644
index 000000000..7dfd87284
--- /dev/null
+++ b/crates/salsa/tests/tracked_struct_durability.rs
@@ -0,0 +1,133 @@
+/// Test that high durabilities can't cause "access tracked struct from previous revision" panic.
+///
+/// The test models a situation where we have two File inputs (0, 1), where `File(0)` has LOW
+/// durability and `File(1)` has HIGH durability. We can query an `index` for each file, and a
+/// `definitions` from that index (just a sub-part of the index), and we can `infer` each file. The
+/// `index` and `definitions` queries depend only on the `File` they operate on, but the `infer`
+/// query has some other dependencies: `infer(0)` depends on `infer(1)`, and `infer(1)` also
+/// depends directly on `File(0)`.
+///
+/// The panic occurs (in versions of Salsa without a fix) because `definitions(1)` is high
+/// durability, and depends on `index(1)` which is also high durability. `index(1)` creates the
+/// tracked struct `Definition(1)`, and `infer(1)` (which is low durability) depends on
+/// `Definition.file(1)`.
+///
+/// After a change to `File(0)` (low durability), we only shallowly verify `definitions(1)` -- it
+/// passes shallow verification due to durability. We take care to mark-validated the outputs of
+/// `definitions(1)`, but we never verify `index(1)` at all (deeply or shallowly), which means we
+/// never mark `Definition(1)` validated. So when we deep-verify `infer(1)`, we try to access its
+/// dependency `Definition.file(1)`, and hit the panic because we are accessing a tracked struct
+/// that has never been re-validated or re-recreated in R2.
+use salsa::{Durability, Setter};
+
+#[salsa::db]
+trait Db: salsa::Database {
+    fn file(&self, idx: usize) -> File;
+}
+
+#[salsa::input]
+struct File {
+    field: usize,
+}
+
+#[salsa::tracked]
+struct Definition<'db> {
+    #[tracked]
+    file: File,
+}
+
+#[salsa::tracked]
+struct Index<'db> {
+    #[tracked]
+    definitions: Definitions<'db>,
+}
+
+#[salsa::tracked]
+struct Definitions<'db> {
+    #[tracked]
+    definition: Definition<'db>,
+}
+
+#[salsa::tracked]
+struct Inference<'db> {
+    #[tracked]
+    definition: Definition<'db>,
+}
+
+#[salsa::tracked]
+fn index<'db>(db: &'db dyn Db, file: File) -> Index<'db> {
+    let _ = file.field(db);
+    Index::new(db, Definitions::new(db, Definition::new(db, file)))
+}
+
+#[salsa::tracked]
+fn definitions<'db>(db: &'db dyn Db, file: File) -> Definitions<'db> {
+    index(db, file).definitions(db)
+}
+
+#[salsa::tracked]
+fn infer<'db>(db: &'db dyn Db, definition: Definition<'db>) -> Inference<'db> {
+    let file = definition.file(db);
+    if file.field(db) < 1 {
+        let dependent_file = db.file(1);
+        infer(db, definitions(db, dependent_file).definition(db))
+    } else {
+        db.file(0).field(db);
+        index(db, file);
+        Inference::new(db, definition)
+    }
+}
+
+#[salsa::tracked]
+fn check<'db>(db: &'db dyn Db, file: File) -> Inference<'db> {
+    let defs = definitions(db, file);
+    infer(db, defs.definition(db))
+}
+
+#[test]
+fn execute() {
+    #[salsa::db]
+    #[derive(Default, Clone)]
+    struct Database {
+        storage: salsa::Storage<Self>,
+        files: Vec<File>,
+    }
+
+    #[salsa::db]
+    impl salsa::Database for Database {}
+
+    #[salsa::db]
+    impl Db for Database {
+        fn file(&self, idx: usize) -> File {
+            self.files[idx]
+        }
+    }
+
+    let mut db = Database::default();
+    // Create a file 0 with low durability, and a file 1 with high durability.
+
+    let file0 = File::new(&db, 0);
+    db.files.push(file0);
+
+    let file1 = File::new(&db, 1);
+    file1
+        .set_field(&mut db)
+        .with_durability(Durability::HIGH)
+        .to(1);
+    db.files.push(file1);
+
+    // check(0) -> infer(0) -> definitions(0) -> index(0)
+    //                     \-> infer(1) -> definitions(1) -> index(1)
+
+    assert_eq!(check(&db, file0).definition(&db).file(&db).field(&db), 1);
+
+    // update the low durability file 0
+    file0.set_field(&mut db).to(0);
+
+    // Re-query check(0). definitions(1) is high durability so it short-circuits in shallow-verify,
+    // meaning we never verify index(1) at all, but index(1) created the tracked struct
+    // Definition(1), so we never validate Definition(1) in R2, so when we try to verify
+    // Definition.file(1) (as an input of infer(1) ) we hit a panic for trying to use a struct that
+    // isn't validated in R2.
+    check(&db, file0);
+}
diff --git a/crates/salsa/tests/tracked_struct_mixed_tracked_fields.rs b/crates/salsa/tests/tracked_struct_mixed_tracked_fields.rs
new file mode 100644
index 000000000..a5630c631
--- /dev/null
+++ b/crates/salsa/tests/tracked_struct_mixed_tracked_fields.rs
@@ -0,0 +1,68 @@
+mod common;
+
+use salsa::{Database, Setter};
+
+// A tracked struct with mixed tracked and untracked fields to ensure
+// the correct field indices are used when tracking dependencies.
+#[salsa::tracked]
+struct Tracked<'db> {
+    untracked_1: usize,
+
+    #[tracked]
+    tracked_1: usize,
+
+    untracked_2: usize,
+
+    untracked_3: usize,
+
+    #[tracked]
+    tracked_2: usize,
+
+    untracked_4: usize,
+}
+
+#[salsa::input]
+struct MyInput {
+    field1: usize,
+    field2: usize,
+}
+
+#[salsa::tracked]
+fn intermediate(db: &dyn salsa::Database, input: MyInput) -> Tracked<'_> {
+    Tracked::new(db, 0, input.field1(db), 0, 0, input.field2(db), 0)
+}
+
+#[salsa::tracked]
+fn accumulate(db: &dyn salsa::Database, input: MyInput) -> (usize, usize) {
+    let tracked = intermediate(db, input);
+    let one = read_tracked_1(db, tracked);
+    let two = read_tracked_2(db, tracked);
+
+    (one, two)
+}
+
+#[salsa::tracked]
+fn read_tracked_1<'db>(db: &'db dyn Database, tracked: Tracked<'db>) -> usize {
+    tracked.tracked_1(db)
+}
+
+#[salsa::tracked]
+fn read_tracked_2<'db>(db: &'db dyn Database, tracked: Tracked<'db>) -> usize {
+    tracked.tracked_2(db)
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::default();
+    let input = MyInput::new(&db, 1, 1);
+
+    assert_eq!(accumulate(&db, input), (1, 1));
+
+    // Should only re-execute `read_tracked_1`.
+    input.set_field1(&mut db).to(2);
+    assert_eq!(accumulate(&db, input), (2, 1));
+
+    // Should only re-execute `read_tracked_2`.
+    input.set_field2(&mut db).to(2);
+    assert_eq!(accumulate(&db, input), (2, 2));
+}
diff --git a/crates/salsa/tests/tracked_struct_recreate_new_revision.rs b/crates/salsa/tests/tracked_struct_recreate_new_revision.rs
new file mode 100644
index 000000000..c1786a2dd
--- /dev/null
+++ b/crates/salsa/tests/tracked_struct_recreate_new_revision.rs
@@ -0,0 +1,35 @@
+//! Test that re-creating a `tracked` struct after it was deleted in a previous
+//! revision doesn't panic.
+#![allow(warnings)]
+
+use salsa::Setter;
+
+#[salsa::input]
+struct MyInput {
+    field: u32,
+}
+
+#[salsa::tracked(debug)]
+struct TrackedStruct<'db> {
+    field: u32,
+}
+
+#[salsa::tracked]
+fn tracked_fn(db: &dyn salsa::Database, input: MyInput) -> Option<TrackedStruct<'_>> {
+    if input.field(db) == 1 {
+        Some(TrackedStruct::new(db, 1))
+    } else {
+        None
+    }
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::new();
+    let input = MyInput::new(&db, 1);
+    assert!(tracked_fn(&db, input).is_some());
+    input.set_field(&mut db).to(0);
+    assert_eq!(tracked_fn(&db, input), None);
+    input.set_field(&mut db).to(1);
+    assert!(tracked_fn(&db, input).is_some());
+}
diff --git a/crates/salsa/tests/tracked_struct_with_interned_query.rs b/crates/salsa/tests/tracked_struct_with_interned_query.rs
new file mode 100644
index 000000000..4476cceaa
--- /dev/null
+++ b/crates/salsa/tests/tracked_struct_with_interned_query.rs
@@ -0,0 +1,54 @@
+mod common;
+
+use salsa::Setter;
+
+#[salsa::input]
+struct MyInput {
+    value: usize,
+}
+
+#[salsa::tracked]
+struct Tracked<'db> {
+    value: String,
+}
+
+#[salsa::tracked]
+fn query_tracked(db: &dyn salsa::Database, input: MyInput) -> Tracked<'_> {
+    Tracked::new(db, format!("{value}", value = input.value(db)))
+}
+
+#[salsa::tracked]
+fn join<'db>(db: &'db dyn salsa::Database, tracked: Tracked<'db>, with: String) -> String {
+    format!("{}{}", tracked.value(db), with)
+}
+
+#[test]
+fn execute() {
+    let mut db = salsa::DatabaseImpl::default();
+    let input = MyInput::new(&db, 1);
+
+    let tracked = query_tracked(&db, input);
+    let joined = join(&db, tracked, "world".to_string());
+
+    assert_eq!(joined, "1world");
+
+    // Create a new revision: This puts the tracked struct created in revision 0
+    // into the free list.
+    input.set_value(&mut db).to(2);
+
+    let tracked = query_tracked(&db, input);
+    let joined = join(&db, tracked, "world".to_string());
+
+    assert_eq!(joined, "2world");
+
+    // Create a new revision: The tracked struct created in revision 0 is now
+    // reused, including its id. The argument to `join` will hash and compare
+    // equal to the argument used in revision 0 but the return value should be
+    // 3world and not 1world.
+    input.set_value(&mut db).to(3);
+
+    let tracked = query_tracked(&db, input);
+    let joined = join(&db, tracked, "world".to_string());
+
+    assert_eq!(joined, "3world");
+}
diff --git a/crates/salsa/tests/tracked_with_intern.rs b/crates/salsa/tests/tracked_with_intern.rs
new file mode 100644
index 000000000..1b3a381d3
--- /dev/null
+++ b/crates/salsa/tests/tracked_with_intern.rs
@@ -0,0 +1,23 @@
+//! Test that a setting a field on a `#[salsa::input]`
+//! overwrites and returns the old value.
+
+use test_log::test;
+
+#[salsa::input]
+struct MyInput {
+    field: String,
+}
+
+#[salsa::tracked]
+struct MyTracked<'db> {
+    #[tracked]
+    field: MyInterned<'db>,
+}
+
+#[salsa::interned]
+struct MyInterned<'db> {
+    field: String,
+}
+
+#[test]
+fn execute() {}
diff --git a/crates/salsa/tests/tracked_with_struct_db.rs b/crates/salsa/tests/tracked_with_struct_db.rs
new file mode 100644
index 000000000..9af7b5500
--- /dev/null
+++ b/crates/salsa/tests/tracked_with_struct_db.rs
@@ -0,0 +1,61 @@
+//! Test that a setting a field on a `#[salsa::input]`
+//! overwrites and returns the old value.
+
+use salsa::{Database, DatabaseImpl, Update};
+use test_log::test;
+
+#[salsa::input(debug)]
+struct MyInput {
+    field: String,
+}
+
+#[salsa::tracked(debug)]
+struct MyTracked<'db> {
+    #[tracked]
+    data: MyInput,
+    #[tracked]
+    next: MyList<'db>,
+}
+
+#[derive(PartialEq, Eq, Clone, Debug, Update)]
+enum MyList<'db> {
+    None,
+    Next(MyTracked<'db>),
+}
+
+#[salsa::tracked]
+fn create_tracked_list(db: &dyn Database, input: MyInput) -> MyTracked<'_> {
+    let t0 = MyTracked::new(db, input, MyList::None);
+    let t1 = MyTracked::new(db, input, MyList::Next(t0));
+    t1
+}
+
+#[test]
+fn execute() {
+    DatabaseImpl::new().attach(|db| {
+        let input = MyInput::new(db, "foo".to_string());
+        let t0: MyTracked = create_tracked_list(db, input);
+        let t1 = create_tracked_list(db, input);
+        expect_test::expect![[r#"
+            MyTracked {
+                [salsa id]: Id(401),
+                data: MyInput {
+                    [salsa id]: Id(0),
+                    field: "foo",
+                },
+                next: Next(
+                    MyTracked {
+                        [salsa id]: Id(400),
+                        data: MyInput {
+                            [salsa id]: Id(0),
+                            field: "foo",
+                        },
+                        next: None,
+                    },
+                ),
+            }
+        "#]]
+        .assert_debug_eq(&t0);
+        assert_eq!(t0, t1);
+    })
+}
diff --git a/crates/salsa/tests/tracked_with_struct_ord.rs b/crates/salsa/tests/tracked_with_struct_ord.rs
new file mode 100644
index 000000000..51fef9cc6
--- /dev/null
+++ b/crates/salsa/tests/tracked_with_struct_ord.rs
@@ -0,0 +1,37 @@
+//! Test that `PartialOrd` and `Ord` can be derived for tracked structs
+
+use salsa::{Database, DatabaseImpl};
+use test_log::test;
+
+#[salsa::input]
+#[derive(PartialOrd, Ord)]
+struct Input {
+    value: usize,
+}
+
+#[salsa::tracked(debug)]
+#[derive(Ord, PartialOrd)]
+struct MyTracked<'db> {
+    value: usize,
+}
+
+#[salsa::tracked]
+fn create_tracked(db: &dyn Database, input: Input) -> MyTracked<'_> {
+    MyTracked::new(db, input.value(db))
+}
+
+#[test]
+fn execute() {
+    DatabaseImpl::new().attach(|db| {
+        let input1 = Input::new(db, 20);
+        let input2 = Input::new(db, 10);
+
+        // Compares by ID and not by value.
+        assert!(input1 <= input2);
+
+        let t0: MyTracked = create_tracked(db, input1);
+        let t1: MyTracked = create_tracked(db, input2);
+
+        assert!(t0 <= t1);
+    })
+}
diff --git a/crates/salsa/tests/warnings/main.rs b/crates/salsa/tests/warnings/main.rs
new file mode 100644
index 000000000..77438e538
--- /dev/null
+++ b/crates/salsa/tests/warnings/main.rs
@@ -0,0 +1,7 @@
+//! Test that macros don't generate code with warnings
+
+#![deny(warnings)]
+
+mod needless_borrow;
+mod needless_lifetimes;
+mod unused_variable_db;
diff --git a/crates/salsa/tests/warnings/needless_borrow.rs b/crates/salsa/tests/warnings/needless_borrow.rs
new file mode 100644
index 000000000..605f4c778
--- /dev/null
+++ b/crates/salsa/tests/warnings/needless_borrow.rs
@@ -0,0 +1,8 @@
+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
+enum Token {}
+
+#[salsa::tracked]
+struct TokenTree<'db> {
+    #[returns(ref)]
+    tokens: Vec<Token>,
+}
diff --git a/crates/salsa/tests/warnings/needless_lifetimes.rs b/crates/salsa/tests/warnings/needless_lifetimes.rs
new file mode 100644
index 000000000..8976464a1
--- /dev/null
+++ b/crates/salsa/tests/warnings/needless_lifetimes.rs
@@ -0,0 +1,25 @@
+#[salsa::db]
+pub trait Db: salsa::Database {}
+
+#[derive(Debug, PartialEq, Eq, Hash)]
+pub struct Item {}
+
+#[salsa::tracked]
+pub struct SourceTree<'db> {}
+
+#[salsa::tracked]
+impl<'db> SourceTree<'db> {
+    #[salsa::tracked(returns(ref))]
+    pub fn all_items(self, _db: &'db dyn Db) -> Vec<Item> {
+        todo!()
+    }
+}
+
+#[salsa::tracked(returns(ref))]
+fn use_tree<'db>(_db: &'db dyn Db, _tree: SourceTree<'db>) {}
+
+#[allow(unused)]
+fn use_it(db: &dyn Db, tree: SourceTree) {
+    tree.all_items(db);
+    use_tree(db, tree);
+}
diff --git a/crates/salsa/tests/warnings/unused_variable_db.rs b/crates/salsa/tests/warnings/unused_variable_db.rs
new file mode 100644
index 000000000..1df547b3f
--- /dev/null
+++ b/crates/salsa/tests/warnings/unused_variable_db.rs
@@ -0,0 +1,2 @@
+#[salsa::interned]
+struct Keywords<'db> {}
